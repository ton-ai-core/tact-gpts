

## CHANGELOG.md (https://github.com/tact-lang/tact/blob/main/tact-main/CHANGELOG.md)
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added

- `&&=`, `||=`, `>>=` and `<<=` augmented assignment operators: PR [#853](https://github.com/tact-lang/tact/pull/853)
- New CSpell dictionaries: TVM instructions and adjusted list of Fift words: PR [#881](https://github.com/tact-lang/tact/pull/881)
- Ability to specify a compile-time method ID expression for getters: PR [#922](https://github.com/tact-lang/tact/pull/922) and PR [#932](https://github.com/tact-lang/tact/pull/932)
- Destructuring of structs and messages: PR [#856](https://github.com/tact-lang/tact/pull/856), PR [#964](https://github.com/tact-lang/tact/pull/964), PR [#969](https://github.com/tact-lang/tact/pull/969)
- The `SendDefaultMode` send mode constant to the standard library: PR [#1010](https://github.com/tact-lang/tact/pull/1010)
- The `replace` and `replaceGet` methods for the `Map` type: PR [#941](https://github.com/tact-lang/tact/pull/941)
- Utility for logging errors in code that was supposed to be unreachable: PR [#991](https://github.com/tact-lang/tact/pull/991)
- Ability to specify a compile-time message opcode expression: PR [#1188](https://github.com/tact-lang/tact/pull/1188)

### Changed

- The `parseImports` function now returns AST import nodes instead of raw strings: PR [#966](https://github.com/tact-lang/tact/pull/966)
- Optional types for `self` argument in `extends mutates` functions are now allowed: PR [#854](https://github.com/tact-lang/tact/pull/854)
- Error codes in the report are now formatted as a list: PR [#1051](https://github.com/tact-lang/tact/pull/1051)
- Clarify error message for bounced types from which accessed a field that does not fit in 224 bytes: PR [#1111](https://github.com/tact-lang/tact/pull/1111)
- Do not automatically validate all addresses when receiving/sending messages or using address manipulating functions: PR [#1207](https://github.com/tact-lang/tact/pull/1207)
- Remove `enabledMasterchain` compiler config option from `tact.config.json`: PR [#1207](https://github.com/tact-lang/tact/pull/1207)
- Remove `org.ton.chain.any.v0` interface: PR [#1207](https://github.com/tact-lang/tact/pull/1207)

### Fixed

- Collisions in getter method ids are now handled and reported properly: PR [#875](https://github.com/tact-lang/tact/pull/875), PR [#1052](https://github.com/tact-lang/tact/pull/1052)
- Non-null struct fields after null ones are treated correctly in Sandbox tests after updating `@ton/core` to 0.59.0: PR [#933](https://github.com/tact-lang/tact/pull/933)
- Prevent inline code snippets from changing their background color: PR [#935](https://github.com/tact-lang/tact/pull/935)
- `as coins` map value serialization type is now handled correctly: PR [#987](https://github.com/tact-lang/tact/pull/987)
- Type checking for `foreach` loops in trait methods: PR [#1017](https://github.com/tact-lang/tact/pull/1017)
- The `sha256()` function no longer throws on statically known strings of any length: PR [#907](https://github.com/tact-lang/tact/pull/907)
- TypeScript wrappers generation for messages with single quote: PR [#1106](https://github.com/tact-lang/tact/pull/1106)

### Docs

- Added the `description` property to the frontmatter of the each page for better SEO: PR [#916](https://github.com/tact-lang/tact/pull/916)
- Added Google Analytics tags per every page: PR [#921](https://github.com/tact-lang/tact/pull/921)
- Added Ston.fi cookbook: PR [#956](https://github.com/tact-lang/tact/pull/956)
- Added NFTs cookbook: PR [#958](https://github.com/tact-lang/tact/pull/958)
- Added security best practices: PR [#1070](https://github.com/tact-lang/tact/pull/1070)
- Added automatic links to Web IDE from all code blocks: PR [#994](https://github.com/tact-lang/tact/pull/994)
- Added initial semi-automated Chinese translation of the documentation: PR [#942](https://github.com/tact-lang/tact/pull/942)
- Documented `preloadRef` method for the `Slice` type: PR [#1044](https://github.com/tact-lang/tact/pull/1044)
- Added DeDust cookbook: PR [#954](https://github.com/tact-lang/tact/pull/954)
- Described the limit for deeply nested expressions: PR [#1101](https://github.com/tact-lang/tact/pull/1101)
- Completely overhauled the exit codes page: PR [#978](https://github.com/tact-lang/tact/pull/978)
- Enhanced Jettons Cookbook page: PR [#944](https://github.com/tact-lang/tact/pull/944)
- Added a note that `compilables/` can sometimes be used over `wrappers/` in Blueprint projects: PR [#1112](https://github.com/tact-lang/tact/pull/1112)
- Changed the layout of tables, updated syntax highlighting, and added Chinese translations of sidebar separators: PR [#916](https://github.com/tact-lang/tact/pull/916)
- Fixed handling of next and previous page links at the bottom of the pages when there's a separator item in the sidebar: PR [#949](https://github.com/tact-lang/tact/pull/949)
- Enabled compilation of examples in `data-structures.mdx` and across Cookbook: PR [#917](https://github.com/tact-lang/tact/pull/917)
- Removed the Programmatic API page due to frequent changes. To use the API, please refer to the compiler sources: PR [#1184](https://github.com/tact-lang/tact/pull/1184)
- Added a link to the article by CertiK to Security best practices page: PR [#1185](https://github.com/tact-lang/tact/pull/1185)
- Added a note on `dump()` being computationally expensive: PR [#1189](https://github.com/tact-lang/tact/pull/1189)
- Fixed links in Chinese translation: PR [#1206](https://github.com/tact-lang/tact/pull/1206)

### Release contributors

## [1.5.3] - 2024-11-28

### Changed

- Replaced `Set.isSubsetOf()` with `isSubsetOf()` to support Node.js ≥18 and <22: PR [#1009](https://github.com/tact-lang/tact/pull/1009)

### Release contributors

- [Novus Nota](https://github.com/novusnota)

## [1.5.2] - 2024-09-25

### Fixed

- `asm` functions now support full range of Fift-asm syntax: PR [#855](https://github.com/tact-lang/tact/pull/855), PR [#1061](https://github.com/tact-lang/tact/pull/1061)

- Fix `npm` installations of Tact compiler or any of the packages depending on it by hiding unnecessary post-install runs of `husky`: PR [#870](https://github.com/tact-lang/tact/pull/870)

### Release contributors

- [Novus Nota](https://github.com/novusnota)

## [1.5.1] - 2024-09-18

### Added

- The `engines` property in `package.json` and its strict checking to ensure minimal required Node.js version is 22: PR [#847](https://github.com/tact-lang/tact/pull/847)

### Changed

- CI now does matrix tests with [Blueprint](https://github.com/ton-org/blueprint) and `npm`, `yarn`, `pnpm`, and `bun` package managers: PR [#848](https://github.com/tact-lang/tact/pull/848)

### Release contributors

- [Jesús Héctor Domínguez Sánchez](https://github.com/jeshecdom)
- [Novus Nota](https://github.com/novusnota)

## [1.5.0] - 2024-09-15

### Added

- The `exists` method for the `Map` type: PR [#581](https://github.com/tact-lang/tact/pull/581), PR [#938](https://github.com/tact-lang/tact/pull/938)
- The `storeBit` method for `Builder` type and the `loadBit` method for `Slice` type: PR [#699](https://github.com/tact-lang/tact/pull/699), PR [#936](https://github.com/tact-lang/tact/pull/936)
- The `toSlice` method for structs and messages: PR [#630](https://github.com/tact-lang/tact/pull/630), PR [#936](https://github.com/tact-lang/tact/pull/936)
- Wider range of serialization options for integers — `uint1` through `uint256` and `int1` through `int257`: PR [#558](https://github.com/tact-lang/tact/pull/558), PR [#937](https://github.com/tact-lang/tact/pull/937)
- The `deepEquals` method for the `Map` type: PR [#637](https://github.com/tact-lang/tact/pull/637), PR [#939](https://github.com/tact-lang/tact/pull/939)
- `asm` bodies for module-level functions: PR [#769](https://github.com/tact-lang/tact/pull/769), PR [#825](https://github.com/tact-lang/tact/pull/825)
- Corresponding stdlib functions for new TVM instructions from 2023.07 and 2024.04 upgrades: PR [#331](https://github.com/tact-lang/tact/pull/331), PR [#1062](https://github.com/tact-lang/tact/pull/1062). Added the `storeBuilder` extension function and `gasConsumed`, `getComputeFee`, `getStorageFee`, `getForwardFee`, `getSimpleComputeFee`, `getSimpleForwardFee`, `getOriginalFwdFee`, `myStorageDue` functions.
- `slice`, `rawSlice`, `ascii` and `crc32` built-in functions: PR [#787](https://github.com/tact-lang/tact/pull/787), PR [#799](https://github.com/tact-lang/tact/pull/799), PR [#951](https://github.com/tact-lang/tact/pull/951)
- `Builder.storeMaybeRef`, `parseStdAddress` and `parseVarAddress` stdlib functions: PR [#793](https://github.com/tact-lang/tact/pull/793), PR [#950](https://github.com/tact-lang/tact/pull/950)
- The compiler development guide: PR [#833](https://github.com/tact-lang/tact/pull/833)
- Constant evaluator now uses an interpreter: PR [#664](https://github.com/tact-lang/tact/pull/664). This allows calls to user-defined functions and references to declared global constants.

### Changed

- Allow omitting semicolons in contract/trait declarations and definitions: PR [#718](https://github.com/tact-lang/tact/pull/718)
- Compiler Tests are now using `@ton/sandbox` instead of `@tact-lang/emulator`: PR [#651](https://github.com/tact-lang/tact/pull/651)
- The minimal required Node.js version is bumped to 22: PR [#769](https://github.com/tact-lang/tact/pull/769)

### Fixed

- Traits can override inherited abstract functions: PR [#724](https://github.com/tact-lang/tact/pull/724)
- Fix code generation bug for maps from unsigned integers to Boolean values: PR [#725](https://github.com/tact-lang/tact/pull/725)
- Compiler failure when `toString` gets called as a static function and not a method: PR [#745](https://github.com/tact-lang/tact/pull/745)
- Tact AST keeps the original format of integer literals (hex/dec/oct/bin): PR [#771](https://github.com/tact-lang/tact/pull/771)
- Message opcodes are now checked if they fit into 32 bits: PR [#771](https://github.com/tact-lang/tact/pull/771)
- Disallow zero binary message opcodes as those are reserved for text messages: PR [#786](https://github.com/tact-lang/tact/pull/786)
- Return-statements in `init()` function do not cause FunC compilation error anymore: PR [#794](https://github.com/tact-lang/tact/pull/794)
- `emptyMap()` in equality comparison expressions does not cause code generation failures: PR [#814](https://github.com/tact-lang/tact/pull/814)
- Maps with `coins` as value type are now correctly handled in structs: PR [#821](https://github.com/tact-lang/tact/pull/821)
- Contract method calls in return statements: PR [#829](https://github.com/tact-lang/tact/pull/829)
- Disallow initializers for trait storage fields: PR [#831](https://github.com/tact-lang/tact/pull/831)
- Fix `dnsInternalNormalize()` in `@stdlib/dns` to throw on slices with references as expected: PR [#834](https://github.com/tact-lang/tact/pull/834)

### Release contributors

- [Jesús Héctor Domínguez Sánchez](https://github.com/jeshecdom)
- [Novus Nota](https://github.com/novusnota)
- [Daniil Sedov](https://github.com/Gusarich)
- [Anton Trunov](https://github.com/anton-trunov)

### Special thanks

- [Georgiy Komarov](https://github.com/jubnzv)

## [1.4.4] - 2024-08-18

### Added

- Initial version of the API providing AST equivalence check: PR [#689](https://github.com/tact-lang/tact/pull/689)

### Fixed

- Returning `self` from getters is now allowed: PR [#666](https://github.com/tact-lang/tact/pull/666)
- Remainder fields in the middle of a struct are now forbidden: PR [#697](https://github.com/tact-lang/tact/pull/697)
- Defining two native functions from the same FunC function now does not fail compilation: PR [#699](https://github.com/tact-lang/tact/pull/699)
- Map types are checked for well-formedness in all type ascriptions: PR [#704](https://github.com/tact-lang/tact/pull/704)

## [1.4.3] - 2024-08-16

### Fixed

- Parsing of optional nested struct fields does not cause the `Not a tuple` error anymore: PR [#692](https://github.com/tact-lang/tact/pull/692)
- Disallow shadowing of recursive function names: PR [#693](https://github.com/tact-lang/tact/pull/693)
- Better error message for the case when a constant shadows an stdlib identifier: PR [#694](https://github.com/tact-lang/tact/pull/694)

## [1.4.2] - 2024-08-13

### Changed

- Removed unsupported iterators API: PR [#633](https://github.com/tact-lang/tact/pull/633)
- Created a separate API function to enable compiler features: PR [#647](https://github.com/tact-lang/tact/pull/647)
- Use the `ILogger` interface to enable API users implement their own loggers: PR [#668](https://github.com/tact-lang/tact/pull/668)
- Use specific Internal or Compiler errors when throwing exceptions: PR [#669](https://github.com/tact-lang/tact/pull/669)

### Fixed

- FunC function identifiers with characters from hexadecimal set: PR [#636](https://github.com/tact-lang/tact/pull/636)
- Throw syntax error for module-level (top-level) constants with attributes: PR [#644](https://github.com/tact-lang/tact/pull/644)
- Typechecking for optional types when the argument type is not an equality type: PR [#650](https://github.com/tact-lang/tact/pull/650)
- Getters now return flattened types for structs as before: PR [#679](https://github.com/tact-lang/tact/pull/679)
- New bindings cannot shadow global constants: PR [#680](https://github.com/tact-lang/tact/pull/680)
- Disallow using assignment operators on constants: PR [#682](https://github.com/tact-lang/tact/pull/682)
- Fix code generation for some non-Lvalues that weren't turned into Lvalues by wrapping them in a function call: PR [#683](https://github.com/tact-lang/tact/pull/683)

## [1.4.1] - 2024-07-26

### Added

- `-e` / `--eval` CLI flags to evaluate constant Tact expressions: PR [#462](https://github.com/tact-lang/tact/pull/462)
- `-q` / `--quiet` CLI flags to suppress compiler log output: PR [#509](https://github.com/tact-lang/tact/pull/509)
- Markdown report for compiled contracts now includes Mermaid diagrams for trait inheritance and contract dependencies: PR [#560](https://github.com/tact-lang/tact/pull/560)
- Documentation comments to Zod schema of `tact.config.json` for descriptive hover pop-ups in editors: PR [#575](https://github.com/tact-lang/tact/pull/575)

### Changed

- Removed the `LValue` grammatical category and replaced it with `Expression`: PR [#479](https://github.com/tact-lang/tact/pull/479)
- Compilation results are placed into the source file directory when compiling without `tact.config.json` file: PR [#495](https://github.com/tact-lang/tact/pull/495)
- External receivers are enabled for single file compilation: PR [#495](https://github.com/tact-lang/tact/pull/495)
- `[DEBUG]` prefix was removed from debug prints because a similar prefix was already present: PR [#506](https://github.com/tact-lang/tact/pull/506)
- File paths in debug prints always use POSIX file paths (even on Windows): PR [#523](https://github.com/tact-lang/tact/pull/523)
- The IPFS ABI and supported interfaces getters are not generated by default; to generate those, set to `true` the two newly introduced per-project options in `tact.config.json`: `ipfsAbiGetter` and `interfacesGetter`: PR [#534](https://github.com/tact-lang/tact/pull/534)
- Values of `Slice` and `Builder` types are not converted to `Cell` in Typescript bindings anymore: PR [#562](https://github.com/tact-lang/tact/pull/562)
- Debug prints now include line content for better debugging experience: PR [#563](https://github.com/tact-lang/tact/pull/563)
- Error messages now suggest to add the `self` prefix if there is an attempt to access a missing variable when the contract storage has a variable with the same name: PR [#568](https://github.com/tact-lang/tact/pull/568)
- Error messages now suggest to add or remove parentheses if there is an attempt to access a missing field when there is a method with the same name (and vice versa): PR [#622](https://github.com/tact-lang/tact/pull/622)

### Fixed

- Name clashes with FunC keywords in struct constructor function parameters: PR [#467](https://github.com/tact-lang/tact/issues/467)
- Error messages for traversing non-path-expressions in `foreach`-loops : PR [#479](https://github.com/tact-lang/tact/pull/479)
- Shadowing of trait constants by contract storage variables: PR [#480](https://github.com/tact-lang/tact/pull/480)
- Parsing of non-decimal message opcodes: PR [#481](https://github.com/tact-lang/tact/pull/481)
- Detection of multiple receivers of the same message: PR [#491](https://github.com/tact-lang/tact/pull/491)
- Detection of non-unique message opcodes: PR [#493](https://github.com/tact-lang/tact/pull/493)
- Error messages for non-abstract constants in traits: PR [#483](https://github.com/tact-lang/tact/pull/483)
- All immediately inherited traits must be unique: PR [#500](https://github.com/tact-lang/tact/pull/500)
- Do not throw error when overriding abstract and virtual getters: PR [#503](https://github.com/tact-lang/tact/pull/503)
- Error message for non-existent storage variables: PR [#519](https://github.com/tact-lang/tact/issues/519)
- Error message for duplicate receiver definitions inherited from traits: PR [#519](https://github.com/tact-lang/tact/issues/519)
- Usage of `initOf` inside of `init()` does not cause error `135` anymore: PR [#521](https://github.com/tact-lang/tact/issues/521)
- Usage of `newAddress` with hash parts shorter than 64 hexadecimal digits does not cause constant evaluation error `Invalid address hash length` anymore: PR [#525](https://github.com/tact-lang/tact/pull/525)
- Introduced a streamlined error logger for compilation pipeline to support third-party tools: PR [#509](https://github.com/tact-lang/tact/pull/509)
- Collisions of PascalCase getter names in generated wrappers are now checked: PR [#556](https://github.com/tact-lang/tact/pull/556)
- Display a clearer error in case the source code file is missing when using the Tact CLI: PR [#561](https://github.com/tact-lang/tact/pull/561)
- Error messages for unicode code points outside of valid range: PR [#535](https://github.com/tact-lang/tact/pull/535)
- Correct regex for unicode code points and escaping of control codes in generated comments: PR [#535](https://github.com/tact-lang/tact/pull/535)
- Add `impure` specifier to some stdlib functions that are expected to throw errors: PR [#565](https://github.com/tact-lang/tact/pull/565)
- Defining non-existing native FunC functions now throws an understandable compilation error: PR [#585](https://github.com/tact-lang/tact/pull/585)
- Bump used `@tact-lang/opcode` version to `0.0.16` which fixes the issue with `DIV` instructions: PR [#589](https://github.com/tact-lang/tact/pull/589)
- Code generation for `recv_external` now correctly throws exit code `130` when processing an unexpected message: PR [#604](https://github.com/tact-lang/tact/pull/604)
- Allocator bug resulting in cell overflows for some contract data layouts: PR [#615](https://github.com/tact-lang/tact/pull/615)
- Structs with more than 15 fields do not cause a FunC compilation error anymore: PR [#590](https://github.com/tact-lang/tact/pull/590)
- Typechecking for constant and struct field initializers: PR [#621](https://github.com/tact-lang/tact/pull/621)
- Constant evaluation for structures with default and optional fields: PR [#621](https://github.com/tact-lang/tact/pull/621)
- Report error for self-referencing and mutually-recursive types: PR [#624](https://github.com/tact-lang/tact/pull/624)
- Error reporting for bounced receivers with missing parameter types: PR [#626](https://github.com/tact-lang/tact/pull/626)
- Allowed range of FunC function identifiers in `grammar.ohm`: PR [#628](https://github.com/tact-lang/tact/pull/628)

## [1.4.0] - 2024-06-21

### Added

- The bitwise NOT operation (`~`): PR [#337](https://github.com/tact-lang/tact/pull/337)
- Augmented assignment bitwise operators `|=`, `&=`, `^=`: PR [#350](https://github.com/tact-lang/tact/pull/350)
- Traversing maps from contract storage and structs is now allowed: PR [#389](https://github.com/tact-lang/tact/pull/389)
- The `loadBool` method for `Slice` type: PR [#412](https://github.com/tact-lang/tact/pull/412)
- CLI flag `--with-decompilation` to turn on decompilation of BoC files at the end of the compilation pipeline: PR [#417](https://github.com/tact-lang/tact/pull/417)
- Support more Tact expressions in the constant evaluator: conditional expressions, struct instances, struct field accesses, `emptyMap()`: PR [#432](https://github.com/tact-lang/tact/pull/432) and PR [#445](https://github.com/tact-lang/tact/pull/445)
- The `fromCell` and `fromSlice` methods for struct and message parsing: PR [#418](https://github.com/tact-lang/tact/pull/418) and PR [#454](https://github.com/tact-lang/tact/pull/454)
- The `return`-statement reachability analysis now takes into account the `throw` and `nativeThrow` functions: PR [#447](https://github.com/tact-lang/tact/pull/447)

### Changed

- Trailing semicolons in struct and message declarations are optional now: PR [#395](https://github.com/tact-lang/tact/pull/395)
- Tests are refactored and renamed to convey the sense of what is being tested and to reduce the amount of merge conflicts during development: PR [#402](https://github.com/tact-lang/tact/pull/402)
- `let`-statements can now be used without an explicit type declaration and determine the type automatically if it was not specified: PR [#198](https://github.com/tact-lang/tact/pull/198) and PR [#438](https://github.com/tact-lang/tact/pull/438)
- The outdated TextMate-style grammar files for text editors have been removed (the most recent grammar files can be found in the [tact-sublime](https://github.com/tact-lang/tact-sublime) repo): PR [#404](https://github.com/tact-lang/tact/pull/404)
- The JSON schema for `tact.config.json` has been moved to the `schemas` project folder: PR [#404](https://github.com/tact-lang/tact/pull/404)
- Allow underscores as unused variable identifiers: PR [#338](https://github.com/tact-lang/tact/pull/338)
- The default compilation mode does not decompile BoC files anymore, to additionally perform decompilation at the end of the pipeline, set the `fullWithDecompilation` mode in the `mode` project properties of `tact.config.json`: PR [#417](https://github.com/tact-lang/tact/pull/417)
- Trait lists, parameters and arguments in the Tact grammar were assigned their own names in the grammar for better readability and code deduplication: PR [#422](https://github.com/tact-lang/tact/pull/422)
- The semicolon (`;`) terminating a statement is optional if the statement is the last one in the statement block: PR [#434](https://github.com/tact-lang/tact/pull/434)

### Fixed

- Return type of `skipBits` now matches FunC and does not lead to compilation errors: PR [#388](https://github.com/tact-lang/tact/pull/388)
- Typechecking of conditional expressions when one branch's type is a subtype of another, i.e. for optionals and maps/`null`: PR [#394](https://github.com/tact-lang/tact/pull/394)
- Typechecking of conditional expressions when the types of their branches can be generalized, i.e. for non-optionals and `null` can be inferred an optional type: PR [#429](https://github.com/tact-lang/tact/pull/429)
- External fallback receivers now work properly: PR [#408](https://github.com/tact-lang/tact/pull/408)
- `Int as coins` as a value type of a map in persistent storage does not throw compilation error anymore: PR [#413](https://github.com/tact-lang/tact/pull/413)
- The semantics of the Tact arithmetic operations in the constant evaluator to perform rounding towards negative infinity: PR [#432](https://github.com/tact-lang/tact/pull/432)
- Better error messages for the `void` type: PR [#442](https://github.com/tact-lang/tact/pull/442)
- Fixed the native function binding for the stdlib function `nativeThrowWhen` (it needed to be `throw_if` instead of `throw_when`) and also renamed it to `nativeThrowIf` for consistency with FunC: PR [#451](https://github.com/tact-lang/tact/pull/451)

## [1.3.1] - 2024-06-08

### Added

- Tests for recursive functions: PR [#359](https://github.com/tact-lang/tact/pull/359)
- API for AST traversal: PR [#368](https://github.com/tact-lang/tact/pull/368)
- Spell checking for the whole code base: PR [#372](https://github.com/tact-lang/tact/pull/372)

### Changed

- GitHub actions updated to use Node.js 20: PR [#360](https://github.com/tact-lang/tact/pull/360)
- Refactor AST types to simplify access to third-party tools: PR [#325](https://github.com/tact-lang/tact/pull/325)
- Refactor the compiler API used to access AST store: PR [#326](https://github.com/tact-lang/tact/pull/326)
- Update JSON Schema to inform about usage in Blueprint: PR [#330](https://github.com/tact-lang/tact/pull/330)
- All identifiers in error messages are now quoted for consistency: PR [#363](https://github.com/tact-lang/tact/pull/363)
- The Tact grammar has been refactored for better readability: PR [#365](https://github.com/tact-lang/tact/pull/365)
- Error messages now use relative file paths: PR [#456](https://github.com/tact-lang/tact/pull/456)
- Comparison between `null` and non-optionals now throws a compilation error: PR [#571](https://github.com/tact-lang/tact/pull/571)

### Fixed

- The `log2` and `log` math functions were adjusted for consistency in error throwing: PR [#342](https://github.com/tact-lang/tact/pull/342)
- Shadowing built-in static functions is now forbidden: PR [#351](https://github.com/tact-lang/tact/pull/351)
- Augmented assignment now throws compilation error for non-integer types: PR [#356](https://github.com/tact-lang/tact/pull/356)
- Built-in function `address()` now handles parse errors correctly: PR [#357](https://github.com/tact-lang/tact/pull/357)
- The grammar of the unary operators has been fixed, constant and function declarations are prohibited for contracts and at the top level of Tact modules: PR [#365](https://github.com/tact-lang/tact/pull/365)
- Typos in ABI generation: PR [#372](https://github.com/tact-lang/tact/pull/372)
- `__tact_load_address_opt` code generation: PR [#373](https://github.com/tact-lang/tact/pull/373)
- Empty messages are now correctly converted into cells: PR [#380](https://github.com/tact-lang/tact/pull/380)
- All integer and boolean expressions are now being attempted to be evaluated as constants. Additionally, compile-time errors are thrown for errors encountered during the evaluation of actual constants: PR [#352](https://github.com/tact-lang/tact/pull/352)
- Chaining mutable extension functions now does not throw compilation errors: PR [#384](https://github.com/tact-lang/tact/pull/384)
- Removed unused `ton-compiler` dependency: PR [#452](https://github.com/tact-lang/tact/pull/452)

## [1.3.0] - 2024-05-03

### Added

- `log2` and `log` math functions in `@stdlib/math`: PR [#166](https://github.com/tact-lang/tact/pull/166)
- Reserve mode constants in `@stdlib/reserve`, namely `ReserveExact`, `ReserveAllExcept`, `ReserveAtMost`, `ReserveAddOriginalBalance`, `ReserveInvertSign`, `ReserveBounceIfActionFail`: PR [#173](https://github.com/tact-lang/tact/pull/173)
- Support for string escape sequences (`\\`, `\"`, `\n`, `\r`, `\t`, `\v`, `\b`, `\f`, `\u{0}` through `\u{FFFFFF}`, `\u0000` through `\uFFFF`, `\x00` through `\xFF`): PR [#192](https://github.com/tact-lang/tact/pull/192)
- JSON Schema for `tact.config.json`: PR [#194](https://github.com/tact-lang/tact/pull/194)
- Struct fields punning, i.e. `{foo, bar}` is syntactic sugar for `{ foo: foo, bar: bar }`: PR [#272](https://github.com/tact-lang/tact/pull/272)
- The ability to use `dump` function on the values of the `Address` type: PR [#175](https://github.com/tact-lang/tact/pull/175)
- The non-modifying `StringBuilder`'s `concat` extension function for chained string concatenations: PR [#217](https://github.com/tact-lang/tact/pull/217)
- The `toString` extension function for `Address` type: PR [#224](https://github.com/tact-lang/tact/pull/224)
- The bitwise XOR operation (`^`): PR [#238](https://github.com/tact-lang/tact/pull/238)
- The `isEmpty` extension function for the `Map` type: PR [#266](https://github.com/tact-lang/tact/pull/266)
- The `pow2` power function with base 2: PR [#267](https://github.com/tact-lang/tact/pull/267)
- The `try` and `try-catch` statements: PR [#212](https://github.com/tact-lang/tact/pull/212)
- The `del` method for the `Map` type: PR [#95](https://github.com/tact-lang/tact/pull/95)
- The `-h`/`--help`, `-v` (short for `--version`), `-p` (short for `--project`), `--func` (for only outputting FunC code) and `--check` (for only doing the syntax and type checking) command-line flags: PR [#287](https://github.com/tact-lang/tact/pull/287)
- The `mode` enum in project properties of `tact.config.json` for specifying compilation mode: `full` (default), `funcOnly` (only outputs FunC code and exits), or `checkOnly` (only does the syntax and type checking, then exits): PR [#287](https://github.com/tact-lang/tact/pull/287)
- The `foreach` loop for the `Map` type: PR [#106](https://github.com/tact-lang/tact/pull/106)

### Changed

- The implicit empty `init` function is now present by default in the contract if not declared: PR [#167](https://github.com/tact-lang/tact/pull/167)
- Support trailing commas in all comma-separated lists (struct instantiations, `initOf` arguments, `init()` parameters, inherited traits via `with`, function arguments and parameters): PR [#179](https://github.com/tact-lang/tact/pull/179) and PR [#246](https://github.com/tact-lang/tact/pull/246)
- `@stdlib/stoppable` now imports `@stdlib/ownable` so the programmer does not have to do it separately: PR [#193](https://github.com/tact-lang/tact/pull/193)
- The `newAddress` function now evaluates to a constant value if possible: PR [#237](https://github.com/tact-lang/tact/pull/237)
- The `pow` power function could only be used at compile-time, but now it is available in the standard library and can be called both at runtime and compile-time: PR [#267](https://github.com/tact-lang/tact/pull/267)
- The `dump()` and `dumpStack()` functions now print the file path, line number, and column number in addition to the data: PR [#271](https://github.com/tact-lang/tact/pull/271)
- Use `|` instead of `+` for send mode flags because the bitwise OR operation is idempotent and hence safer: PR [#274](https://github.com/tact-lang/tact/pull/274)
- Bumped the versions of `@ton/core` and `ohm-js` to the most recent ones: PR [#276](https://github.com/tact-lang/tact/pull/276)
- Generated `.pkg`-files always use POSIX file paths (even on Windows): PR [# 300](https://github.com/tact-lang/tact/pull/300)
- The `-p`/`--project` flags now allow specifying more than one project name. Additionally, they also require a `--config` flag to be specified: PR [#287](https://github.com/tact-lang/tact/pull/287)
- Command-line interface now allows compiling a single Tact file directly, without specifying a config: PR [#287](https://github.com/tact-lang/tact/pull/287)

### Fixed

- Escape backticks in error messages for generated TypeScript code: PR [#192](https://github.com/tact-lang/tact/pull/192)
- Integer overflows during compile-time constant evaluation are properly propagated as a compilation error: PR [#200](https://github.com/tact-lang/tact/pull/200)
- Incorrect "already exists" errors when using the `toString` and `valueOf` identifiers: PR [#208](https://github.com/tact-lang/tact/pull/208)
- Empty inherited trait lists after `with` keyword are now disallowed: PR [#246](https://github.com/tact-lang/tact/pull/246)
- Allow chaining method calls with `!!`, for instance, `map.asCell()!!.hash()` is grammatically correct now: PR [#257](https://github.com/tact-lang/tact/pull/257)
- Precedence levels for bitwise operators, equality and comparisons now matches common languages, like JavaScript: PR [#265](https://github.com/tact-lang/tact/pull/265)
- Incorrect variable scoping in the `repeat`, `while` and `until` loops: PR [#269](https://github.com/tact-lang/tact/pull/269)
- FunC compilation errors when trying to `dump()` values of the `Cell`, `Slice`, `Builder` and `StringBuilder` types: PR [#271](https://github.com/tact-lang/tact/pull/271)
- Tact's CLI returns a non-zero exit code if compilation fails: PR [#278](https://github.com/tact-lang/tact/pull/278)
- Use the most recent version of the FunC standard library [`stdlib.fc`](https://github.com/ton-blockchain/ton/blob/4cfe1d1a96acf956e28e2bbc696a143489e23631/crypto/smartcont/stdlib.fc): PR [#283](https://github.com/tact-lang/tact/pull/283)
- The WASM version of the FunC compiler has been updated to 0.4.4 and patched to work on larger contracts: PR [#297](https://github.com/tact-lang/tact/pull/297)
- The `return`-statement reachability analysis: PR [#302](https://github.com/tact-lang/tact/pull/302)

## [1.2.0] - 2024-02-29

### Added

- Augmented assignment operators (`+=`, `-=`, `*=`, `/=` and `%=`): PR [#87](https://github.com/tact-lang/tact/pull/87)
- Binary and octal literals with underscores as numerical separators: PR [#99](https://github.com/tact-lang/tact/pull/99)
- Ternary conditional operator (`condition ? then : else`): PR [#97](https://github.com/tact-lang/tact/pull/97)
- The `--version` command-line flag for the Tact executable: PR [#137](https://github.com/tact-lang/tact/pull/137)
- The `SendBounceIfActionFail` send mode constant to the standard library: PR [#122](https://github.com/tact-lang/tact/pull/122)

### Changed

- Decimal and hexadecimal literals now allow underscores as numerical separators: PR [#99](https://github.com/tact-lang/tact/pull/99)
- The equality and non-equality operators (`==` and `!=`) now support slices and strings by comparing the hashes of the left-hand and right-hand sides : PR [#105](https://github.com/tact-lang/tact/pull/105)
- Continuous integration now tests the dev [tact-template](https://github.com/tact-lang/tact-template)'s version with the dev version of Tact: PR [#111](https://github.com/tact-lang/tact/pull/111)
- Continuous integration now tests the latest [Blueprint](https://github.com/ton-org/blueprint)'s version with the dev version of Tact: PR [#152](https://github.com/tact-lang/tact/pull/152)
- Continuous integration now checks there are no ESLint warnings: PR [#157](https://github.com/tact-lang/tact/pull/157)

### Fixed

- Relative imports from parent directories: PR [#125](https://github.com/tact-lang/tact/pull/125)
- The typechecker failed to identify different types when using the `==` and `!=` operators: PR [#127](https://github.com/tact-lang/tact/pull/127)
- ESLint warnings for the whole Tact codebase: PR [#157](https://github.com/tact-lang/tact/pull/157)
- The versions of some vulnerable dependencies were bumped in `package.json` and `yarn.lock`: PR [#158](https://github.com/tact-lang/tact/pull/158) and PR [#160](https://github.com/tact-lang/tact/pull/160)

## [1.1.5] - 2023-12-01

### Added

- Continuous integration to run Tact tests on Linux, macOS and Windows: PR [#96](https://github.com/tact-lang/tact/pull/96)

### Changed

- Migration to `@ton` NPM packages: PR [#89](https://github.com/tact-lang/tact/pull/89)

### Fixed

- Struct and message identifiers need to be capitalized: PRs [#81](https://github.com/tact-lang/tact/pull/81) and [#83](https://github.com/tact-lang/tact/pull/83)
- Fixed the signature of the `checkDataSignature` function in `stdlib/std/crypto.tact`: PR [#50](https://github.com/tact-lang/tact/pull/50)
- Show location info for the internal compiler error 'Invalid types for binary operation': PR [#63](https://github.com/tact-lang/tact/pull/63)

## [1.1.4] - 2023-09-27

### Changed

- Hacked paths to support builds on Windows

## [1.1.3] - 2023-06-27

### Added

- bitwise and and or operations
- statically compile expressions with bitwise operations if possible

## [1.1.2] - 2023-04-27

### Added

- Add full ABI in bindings

## [1.1.1] - 2023-04-20

### Fixed

- Fix typescript bindings generation for custom key and value serialization formats
- Fix missing external messages in bindings

## [1.1.0] - 2023-04-19

### ⚡️ Breaking changes

- `reply` is now a method of `Contract` instead of global context and changed it's behavior if storage reserve is non-zero in contract.
- Logical expressions are now calculated differently: `&&` now does not execute right expression if left is `false` and `||` does not execute right expression if left is `true`. Before it was executed in any case. This change is made in attempt to reduce unexpected behavior.
- `OwnableTransferable` is now sends response to the sender.
- `overwrites` was renamed to `override`
- `Deployable` trait now sends non-bounceable notifications instead of bounceable ones.

### Features

- `Address` to `Address` maps
- Ability to define key and value serializations for maps
- `sha256` hashing
- `forward` and `notify` functions that can be used to send messages to other contracts using remaining value of incoming message
- `virtual` and `abstract` constants that can be shared between traits
- `storageReserve` constant in every contract that can be used to reserve some storage space by any trait
- `abstract` functions that can be implemented in contracts
- `FactoryDeployable` trait for deploying from factory contract
- `@stdlib/dns` for easier DNS resolution
- Opt-in `external` message support
- Typed `bounce` receiver and `bounce<T>` type modifier
- `commit` for committing state changes
- `inline` modifier for functions for inlining them into the caller
- Ability to define empty messages (but not structs)
- Some string-related operations are now computed at compile time if possible

### Fixed

- Signature of `preloadBits` function
- Fixed `readForwardFee` function

## [1.1.0-beta.28] - 2023-04-19

### Fixed

- Fix `func` invocation

## [1.1.0-beta.27] - 2023-04-14

### Fixed

- Remove tact-bindings binary reference

## [1.1.0-beta.26] - 2023-04-14

### Added

- Ability to define empty messages (but not structs)

## [1.1.0-beta.25] - 2023-04-14

### Added

- Support for bounced receivers for message structs

## [1.1.0-beta.24] - 2023-04-13

### Changed

- Bounced messages now skipped first 32 bits before passing it to receivers

### Fixed

- Passing optional structs as arguments

## [1.1.0-beta.23] - 2023-04-13

### Changed

- deploy trait now sends non-bounceable notifications
- changed `forward` and added bounceable and init arguments

### Added

- `Contract.notify()` non-bounceable alternative to reply

## [1.1.0-beta.22] - 2023-04-13

### Added

- `commit` function to commit state changes

## [1.1.0-beta.21] - 2023-04-13

### Fixed

- Work-around func `0.4.3` bug with pragma processing
- Fix external messages with arguments type checking

## [1.1.0-beta.20] - 2023-04-11

### Changed

- Upgrade `func` to `0.4.3`

## [1.1.0-beta.19] - 2023-04-10

### Fixed

- Fix bouncing unknown messages

## [1.1.0-beta.18] - 2023-04-10

### Added

- `FactoryDeployable` trait for deploying from factory contract

## [1.1.0-beta.17] - 2023-04-10

### Added

- Abstract functions
- Abstract and virtual constants in traits

### Changed

- Rename `overrides` to `override`
- Updated ownership transferring methods

### Removed

- Unused `public` modifier

## [1.1.0-beta.16] - 2023-04-09

### Changed

- `reply` now in contract instead of global context

## [1.1.0-beta.15] - 2023-04-09

### Added

- `asCell` to maps

## [1.1.0-beta.14] - 2023-04-09

### Fixed

- Fix `dnsResolveWallet` compilation error

## [1.1.0-beta.13] - 2023-04-09

### Added

- `dns` library
- map key and value serialization formats

## [1.1.0-beta.12] - 2023-04-08

### Fixed

- Upgrade decompiler to a `@tact-lang/opcodes@0.0.13`

## [1.1.0-beta.11] - 2023-04-08

### Fixed

- Signature of `preloadBits` function

## [1.1.0-beta.10] - 2023-04-08

### Added

- `sha256` function to compute sha256 hash of a text or byte string

## [1.1.0-beta.9] - 2023-04-02

### Added

- Opt-in external messages support

## [1.1.0-beta.8] - 2023-04-02

### Fixed

- Missing implementation of `Address` to `Address` maps

## [1.1.0-beta.7] - 2023-03-28

### Added

- `inline` modifier for functions to inline them into the caller

### Fixed

- Fix missing `method_id` in `get_abi_ipfs` and `lazy_deployment_completed`

## [1.1.0-beta.6] - 2023-03-27

### Changed

- Optimization of gas usage of low level primitives

## [1.1.0-beta.5] - 2023-03-25

### Changed

- Optimization of `String.asComment()` that tries to compute it compile time if possible

## [1.1.0-beta.4] - 2023-03-23

### Added

- Ability to compare cells

### Fixed

- Fixed contract crash when equality check involving nullable variables

### Changed

- Change logic of `&&` and `||`. Now second argument is not calculated when first argument is `false` or `true` respectively.

## [1.1.0-beta.3] - 2023-03-22

### Added

- `emit` function to emit events

### Fixed

- Fixed possible inconsistent behavior when calling mutating get methods from inside of the contract
- Fixed regression of order of functions in generated files

## [1.1.0-beta.2] - 2023-03-22

### Changed

- Tact now emits func in multiple files, optimized not only for blockchain, but also for human

## [1.1.0-beta.1] - 2023-03-20

### Fixed

- Some functions for deep structures with optionals not emitted
- Crash in bindings generator on boolean value in dictionary

## [1.1.0-beta.0] - 2023-03-14

### Fixed

- `overwrites` -> `override`
- Invalid `check` function error generation
- Error message for `address(0)`

## [1.0.0] - 2023-03-08

### Added

- `sender()` function to get message sender address

## [1.0.0-rc.13] - 2023-03-08

### Changed

- Upgrade `func` to `0.4.2`

### Fixed

- Windows paths support

## [1.0.0-rc.12] - 2023-03-03

### Fixed

- `pow` is now compile-only function

### Changed

- Use new FunC wasm bundle

## [1.0.0-rc.11] - 2023-03-02

### Added

- exported `check` function for language server support

## [1.0.0-rc.10] - 2023-03-02

### Changed

- Contracts now can be deployed only to the basic workchain unless `masterchain` set `true`
- Checking field initialization in init function

## [1.0.0-rc.9] - 2023-03-01

### Changed

- Contracts now work only with basic workchain. To enable masterchain support set `masterchain: true` in `tact.conf.json`

### Added

- `pow` function for exponentiation
- `address()` compile-time function for creating addresses from strings
- `cell()` compile-time function for creating cells from base64 strings
- `interfaces` field to ABI
- report workchain support in interfaces

## [1.0.0-rc.8] - 2023-02-27

### Added

- `logger` interface to programmatic API

## [1.0.0-rc.7] - 2023-02-27

### Added

- `verify` function to verify compiled package

## [1.0.0-rc.6] - 2023-02-26

### Fixed

- Fixing npm exports

## [1.0.0-rc.5] - 2023-02-26

### Fixed

- Fixing npm exports for typescript

## [1.0.0-rc.4] - 2023-02-26

### Fixed

- Fixing npm exports for typescript

## [1.0.0-rc.3] - 2023-02-26

### Fixed

- Fixed browser/node typings and exports
- Fixed browser environment execution

## [1.0.0-rc.2] - 2023-02-26

### Fixed

- Fixed missing `mkdirp` dependency

## [1.0.0-rc.1] - 2023-02-26

### Fixed

- Fixed cli command

## [1.0.0-rc.0] - 2023-02-26

### Added

- `@ton-lang/compiler/node` to invoke compiler from node similar how cli works
- `@ton-lang/compiler/browser` to invoke compiler from browser

### Removed

- Removed jetton library from stdlib. It would be re-introduced after 1.0 version with more thought put into it.

## [0.10.1] - 2023-02-23

### Added

- Display line and column numbers in error messages to be able to navigate to the error in the editor

### Fixed

- Execution order of struct and message fields
- `initOf` argument type checks

## [0.10.0] - 2023-02-23

### Changed

- Tact contracts are now [Argument-addressable](https://docs.tact-lang.org/evolution/OTP-005) meaning that they depend on init arguments and code hash only. Init function is now called when first valid message is received.
- Refactoring of allocator
- Moving contract's load function to the beginning of the execution
- Moving contract's save function to the end of the execution
- moving `debug` flag from `experimental` to `parameters` in `tact.config.json`
- Unknown fields in config are now considered an error
- Allow contracts without fields
- Typescript bindings are now working in browser and doesn't have `ton-emulator` dependency
- `map` syntax now uses `<>` instead of `[]` for future compatibility with generics

### Added

- Allow `Builder` type as a field type similar to `Cell` and `Slice`
- Allow `String` type as a field type

## [0.9.3] - 2023-02-19

### Added

- Error codes in reports
- Client-friendly typescript bindings

### Changed

- Change repository locations

## [0.9.2] - 2023-02-05

### Added

- `emptyMap()` for creating empty maps
- Allowing assigning `null` value to a map variable (same as calling `emptyMap()`)

## [0.9.1] - 2023-02-03

### Changed

- Update `dump` function to handle booleans and strings, better type checking or arguments
- Report `org.ton.debug.v0` interface if debug mode is enabled
- Update bindings generator to support `ton-emulator >= v2.1.0`

## [0.9.0] - 2023-02-02

### Added

- Importing `func` files

### Changed

- Upgrade `func` to `0.4.1`
- Enforce `func` version in generated files
- Enable critical pragmas by default
- Enable inlining in a lot of places thanks to fixed crashes in `func`

## [0.8.11] - 2023-01-28

### Fixed

- Optional `Address` fields in typescript bindings

### Added

- `Address.asSlice` for manual address parsing
- `@stdlib/content` library with `createOffchainContent` functions

### [0.8.10] - 2023-01-27

## Fixed

- `>>` and `<<` operations
- Type checking of struct constructors

## [0.8.9] - 2023-01-25

### Fixed

- Fix missing func compiler in distributive

## [0.8.8] - 2023-01-25

### Added

- TextMate Grammar for syntax highlighting

### Changed

- Embed `func` compiler to package
- Better builder types
- Moved docs to `ton-docs` repository

## [0.8.7] - 2023-01-13

### Added

- `beginTailString` and `beginStringFromBuilder` for starting a `StringBuilder`
- `Slice.asString` for converting slice to a `String` (without checks of contents)

## [0.8.6] - 2023-01-10

### Fixed

- Fixing passing non-nullable type as second argument to map's `set` operation

### Changed

- New `2022.v12` func compiler

## [0.8.5] - 2023-01-09

### Changed

- Improve gas usage in `storeBool`

## [0.8.4] - 2023-01-09

### Added

-`newAddress` function to create a new address from chain and hash -`getConfigParam` to get system configuration

## [0.8.3] - 2023-01-09

### Fixed

- Deep contract dependencies

## [0.8.2] - 2023-01-08

### Added

- `loadAddress` in `Slice`

## [0.8.1] - 2023-01-07

Fixing missing NPM release

## [0.8.0] - 2023-01-07

### Changed

- Changed message id algorithm to the one based on type signatures instead of tlb

### Added

- Dictionaries in typescript bindings
- Introduced packaging compilation step that packages a contract to a single package that can be deployed in predictable way.
- `tact-bindings` to build bindings to non-tact contracts

## [0.7.1] - 2023-01-04

### Fixed

- Assignability type checks

## [0.7.0] - 2023-01-04

### Added

- `toCell` to all structs and messages
- restored disassembler as part of a compilation flow
- `typescript` bindings parser of structs and messages

### Removed

- `abi.pack_cell` and `abi.pack_slice`

### Changed

- Updated codegen to prefix function names with a `$` to avoid clashing with system functions
- `random` and `randomInt` that are correctly initialized on first use unlike native one
- Changed the way get and init methods expect their arguments and return values to match func-like primitives

### Fixed

- non-nullable value could break the nullable variable memory representation

## [0.6.0] - 2023-01-03

### Changed

- Large bindings generator refactoring to match new `ton-core` and `ton-emulator` packages

### Added

- `Deployable` trait in `@stdlib/deploy`

## [0.5.0] - 2022-12-23

### Added

- Constants in contracts
- Global constants
- Added `SendRemainingBalance`, `SendRemainingValue`, `SendIgnoreErrors`, `SendPayGasSeparately`, `SendDestroyIfZero` constants in stdlib
- Added `emptyCell` and `emptySlice` helpers
- Added jettons example

### Changed

- `require` now accepts two arguments, second one must be a string literal that has error message. This error message then will be exported to ABI
- Optional `Address` fields are not encoded using native representation

## [0.4.0] - 2022-12-22

### Changed

- Renamed Map's `get2` to `get` and removing `get` from keywords list.

### Fixed

- Fixed missing call arguments verification

## [0.3.0] - 2022-12-22

### Added

- `String` literals and variables
- `Int.toString()` and `Int.toFloatString()`
- `StringBuilder` for gas-efficient string building
- Global compile-time `ton` function that converts string to Int during compile time.
- `checkDataSignature` similar to func `check_data_signature`
- `String.asComment` for conversion text to a comment payload
- `Resumable` trait, allows to resume contract operations once it was stopped
- Comment receiver that allows to receive arbitrary comment
- `String.asSlice` cast string to a slice for parsing
- Binary shift operators `>>` and `<<`
- `Slice.fromBase64` that converts text slice that has base64 to binary representation (both classic and url)
- `Slice.asCell`, `Builder.asCell`, `Cell.asSlice`, `Builder.asCell` convenience functions
- `Slice.loadCoins` that reads coins from slice
- `myBalance` that returns current balance of a contract before execution phase

### Changed

- `contractAddress` now accepts single argument of type `StateInit` and always produces address for workchain. Old method is renamed to `contractAddressExt`.
- `hashCell` and `hashSlice` are now extension function `hash` on `Slice` and `Cell`
- Removed some keywords such as `message`, `contract`, `init` to allow use this names as variable names
- Renamed `receiveBounced` to `bounced`

### Fixed

- Fixing importing tact with providing extension, now `import "./lib";` and `import "./lib.tact";` are equivalent.
- Fixing extension function generation
- Fixing clashing of variable names with func primitives and global functions
- Fix fallback and bounce argument type resolving
- Fixed `loadUint`/`preloadUint`
- Fixed invalid generation of `>=` and `>` operators

## [0.2.0]

### Added

- `supported_interfaces` TEP support. TACT now automatically builds a list of supported interfaces of a contract
- `IPFS`-based ABI reporting. TACT now automatically calculates and embeds ABI hash into smart contract and prepares a file to upload to IPFS.


## CONTRIBUTING.md (https://github.com/tact-lang/tact/blob/main/tact-main/CONTRIBUTING.md)
# Hacking on Tact

## General information

The Tact smart contract programming language is a statically-typed smart contract programming language which is currently implemented as a transpiler into [FunC](https://docs.ton.org/develop/func), which in its turn compiles down to the [TVM](https://docs.ton.org/learn/tvm-instructions/tvm-overview) bitcode. This implementation strategy is likely to change in the future.

The Tact compiler parses the input source code into an abstract syntax tree, type-checks it, generates FunC code, runs the FunC compiler, which produces the corresponding [Fift](https://docs.ton.org/develop/fift/overview) code and a TVM binary in the [BoC](https://docs.ton.org/develop/data-formats/cell-boc) format.

Besides TVM binaries, the Tact compiler generates TypeScript "wrappers" to conveniently test Tact contracts locally in a simulated blockchain environment using, for instance, the standard de-facto [Sandbox](https://github.com/ton-org/sandbox) package.

Additionally, it generates summaries for humans and machines in Markdown and JSON formats.
The summaries include information like

- binary code size,
- [TL-B](https://docs.ton.org/develop/data-formats/tl-b-language) schemas for the program types including contract storage and message formats,
- TVM [exit codes](https://docs.ton.org/learn/tvm-instructions/tvm-exit-codes),
- trait inheritance and contract dependency diagrams.

Currently, Tact does not have a (formal) language specification, so one needs to consult the [Tact docs](https://docs.tact-lang.org) and the tests in this repository.

The list of known bugs can be obtained using the following GitHub request: <https://github.com/tact-lang/tact/issues?q=is%3Aopen+is%3Aissue+label%3Abug>.

More detail about different part of the compiler including their corresponding entry points can be found below.

## The Tact dependencies

Tact is implemented in TypeScript. The minimum required version for Node.js is 22.

The rest of the build and development dependencies are specified, as usual, in the [package.json](./package.json) file and the most important ones are described in the present document.

Tact's pipeline uses a patched version of the FunC compiler vendored as a WASM binary with some JS wrappers, see the following files:

- [src/func/funcfiftlib.js](./src/func/funcfiftlib.js)
- [src/func/funcfiftlib.wasm](./src/func/funcfiftlib.wasm)
- [src/func/funcfiftlib.wasm.js](./src/func/funcfiftlib.wasm.js)

The message of the commit [`f777da3213e3b064a7f407b2569cfd546cca277e`](https://github.com/tact-lang/tact/commit/f777da3213e3b064a7f407b2569cfd546cca277e) explains how the patched version was obtained. We had to patch the FunC compiler because the corresponding [FunC compiler issue](https://github.com/ton-blockchain/ton/issues/971) is unresolved at the time of writing.

## Building Tact

The most up-to-date recipe to build Tact is described in [.github/workflows/tact.yml](./.github/workflows/tact.yml) GitHub Actions file.

## Testing Tact implementation

As our testing framework we use [Jest](https://jestjs.io). We use a combination of snapshot and expectation tests supported by Jest.

Some tests are put in the same folder with the implementation and can be located in `*.spec.ts` files,
other tests are grouped into categories in the [src/test](./src/test) folder. The project map section has more information on tests relevant for each compiler component.

### How to update test snapshots

Updating all the test snapshots:

```shell
yarn test -u
```

Updating a subset of the test snapshots can be done like so:

```shell
yarn test -u spec-name-pattern1 spec-name-pattern2
```

## Linting

To pass CI, one needs to have a warning-free build. To run all the lints described below execute the following command in your terminal:

```shell
yarn lint:all
```

### Linting the entire codebase with ESLint

Running [ESLint](https://eslint.org) across the whole Tact codebase:

```shell
yarn lint
```

### Spell-checking

To spell-check the entire codebase with [CSpell](http://cspell.org) run:

```shell
yarn spell
```

### Knip

The [Knip](https://knip.dev) tool is used to check issues with the compiler dependencies and API.
It can be run with

```shell
yarn knip
```

## Project map

### Compiler driver

Tact's command-line interface (CLI) is located in [bin/tact.js](./bin/tact.js).
Tact uses the [meow](https://github.com/sindresorhus/meow) CLI arguments parser.

The main entry point for the Tact CLI is [src/node.ts](./src/node.ts) and [src/pipeline/build.ts](./src/pipeline/build.ts) is the platform-independent compiler driver which contains the high-level compiler pipeline logic described above.

The Tact CLI gets Tact settings from a `tact.config.json` file or creates a default config for a single-file compilation mode. The format of `tact.config.json` files is specified in [schemas/configSchema.json](./schemas/configSchema.json).

The so-called "pre-compilation" steps that include imports resolution, type-checking, building schemas for high-level Tact data structures to be serialized/deserialized as cells (this step is dubbed "allocation") are located in [src/pipeline/precompile.ts](src/pipeline/precompile.ts).

Besides the terminal, the Tact compiler is supposed to work in browser environments as well.

Some CLI tests can be found in [.github/workflows/tact.yml](./.github/workflows/tact.yml) GitHub Action file.

### Parser

The [src/grammar/grammar.ohm](./src/grammar/grammar.ohm) file contains the Tact grammar expressed in the PEG-like language of the [Ohm.js](https://ohmjs.org) parser generator.

The helper file [src/grammar/grammar.ts](./src/grammar/grammar.ts) contains the logic that transforms concrete syntax trees produced with the help of the Ohm.js-generated parser into abstract syntax trees (ASTs) defined in [src/grammar/ast.ts](./src/grammar/ast.ts). The grammar.ts file also does a bit of grammar validation, like checking that function or constant attributes are not duplicated or that user identifiers do not start with certain reserved prefixes.

The [src/grammar/test](./src/grammar/test) folder contains Tact files that are supposed to be parsed without any issues, and the [src/grammar/test-failed](./src/grammar/test-failed) folder contains grammatically incorrect test files which should result in parser errors. The parser error messages and the locations they point to are fixed in the [src/grammar/**snapshots**/grammar.spec.ts.snap](./src/grammar/__snapshots__/grammar.spec.ts.snap) Jest snapshot file.

### Typechecker

The Tact type-checker's implementation can be found mostly in the following files:

- [src/types/resolveDescriptors.ts](./src/types/resolveDescriptors.ts) takes care of checking at the level of module-items, data type definitions, function signatures, etc. and it does not deal with statements (so does not traverse function bodies);
- [src/types/resolveStatements.ts](./src/types/resolveStatements.ts) checks statements and statements blocks;
- [src/types/resolveExpression.ts](./src/types/resolveExpression.ts) type-checks the Tact expressions.

The current implementation of the typechecker is going to be significantly refactored, as per [issue #458](https://github.com/tact-lang/tact/issues/458). The corresponding pull request will have formally specified the Tact typing rules.

Until we have the Tact type system specified, the only source of information about it would be the aforementioned Tact docs and the tests in the following locations:

- [src/types/test](./src/types/test): positive well-formedness tests at the level of data types, contracts, traits and function signatures;
- [src/types/test-failed](./src/types/test-failed): negative well-formedness tests at the level of data types, contracts, traits and function signatures;
- [src/types/stmts](./src/types/stmts): positive type-checking tests at the level of function bodies;
- [src/types/stmts-failed](./src/types/stmts-failed): negative type-checking tests at the level of function bodies;
- [src/test/compilation-failed](./src/test/compilation-failed): negative type-checking tests that require full environment, for instance, the standard library (the other tests in `src/types` don't have access to the full environment).

### Constant evaluator

The constant evaluator is used as an optimizer to prevent some statically known expressions from being evaluated at run-time and increase gas consumption of the contracts. It will be later extended to perform partial evaluation of contracts and use various simplification rules such as applying some algebraic laws to further reduce gas consumption of contracts at run-time.

The constant evaluator supports a large subset of Tact and handles, for instance, constants defined in terms of other constants, built-in and user-defined functions, logical and arithmetic operations.

The main logic of the constant evaluator can be found in the file [src/interpreter.ts](./src/interpreter.ts).

You can find the relevant tests in [src/test/e2e-emulated/contracts/constants.tact](./src/test/e2e-emulated/contracts/constants.tact) and the corresponding spec-file: [](./src/test/e2e-emulated/constants.spec.ts).

The negative tests for constant evaluation are contained in the Tact files prefixed with `const-eval` in the [src/test/compilation-failed/contracts](./src/test/compilation-failed/contracts) folder.

### Code generator

Some general information on how Tact code maps to FunC is described in the Tact docs: <https://docs.tact-lang.org/book/func>.

The code generator lives in the [src/generator](./src/generator) sub-folder with the entry point in [src/generator/writeProgram.ts](./src/generator/writeProgram.ts).

The implementation that we have right now is being refactored to produce FunC ASTs and then pretty-print those ASTs as strings instead of producing source FunC code in one step. Here is the relevant pull request: <https://github.com/tact-lang/tact/pull/559>.

One can find the end-to-end codegen test spec files in the [src/test/e2e-emulated](./src/test/e2e-emulated/) folder. The test contracts are located in [src/test/e2e-emulated/contracts](./src/test/e2e-emulated/contracts) subfolder. Many of those spec files test various language features in relative isolation.
An important spec file that tests argument passing semantics for functions and assignment semantics for variables is here: [src/test/e2e-emulated/semantics.spec.ts](./src/test/e2e-emulated/semantics.spec.ts).

Note: If you add an end-to-end test contract, you also need to include it into [tact.config.json](./tact.config.json) and run `yarn gen` to compile it and create TypeScript wrappers.

`yarn gen` also re-compiles test contracts, so it's important to run it when code generation is changed.

Some other codegen tests are as follows:

- [src/test/exit-codes](./src/test/exit-codes): test that certain actions produce the expected exit codes;
- [src/test/codegen](./src/test/codegen/): test that these contracts compile just fine without running any dynamic tests: bug fixes for FunC code generation often add tests into this folder.

### Pretty-printer and AST comparators

The entry point to the Tact AST pretty-printer is [src/prettyPrinter.ts](./src/prettyPrinter.ts). It is going to be used for the Tact source code formatter once the parser keeps comments and other relevant information.

The AST comparator is defined in [src/grammar/compare.ts](./src/grammar/compare.ts). This is useful, for instance, for static analysis tools which can re-use the Tact TypeScript API.

The corresponding test spec files can be found in [src/test](./src/test/) folder with the test contracts in [src/test/contracts](./src/test/contracts/) folder.


## README.md (https://github.com/tact-lang/tact/blob/main/tact-main/README.md)
# Tact Language Compiler

<img src="https://raw.githubusercontent.com/tact-lang/tact-docs/main/public/banner.jpeg">

A next-gen smart contract language for TON focused on efficiency and simplicity.

- [Changelog](./CHANGELOG.md)
- [How to contribute to Tact development](./CONTRIBUTING.md)
- [Roadmap](./ROADMAP.md)
- [Examples](./examples/)

## Key Resources

- [Tact By Example](https://tact-by-example.org/00-hello-world)
- [Tact Documentation](https://docs.tact-lang.org)
- [Awesome Tact](https://github.com/tact-lang/awesome-tact)

## Community

- [Tact Discussion Group](https://t.me/tactlang)
- [Tact Updates Channel](https://t.me/tact_kitchen)

## Getting started

The easiest way to start is to use our [project template](https://github.com/tact-lang/tact-template) and read [getting started](https://docs.tact-lang.org).

```
git clone https://github.com/tact-lang/tact-template
```

## Installation

TACT is distributed via NPM, to install tact into your project, you need:

```bash
yarn add @tact-lang/compiler
```

TACT doesn't have development environment dependencies and has everything built in. TACT's stdlib also distributed together with a compiler.

For Visual Studio Code syntax support, please download the [Tact extension](https://marketplace.visualstudio.com/items?itemName=KonVik.tact-lang-vscode).

## 10 Commandments of Tact

We have formed a large-scale vision for the philosophy of Tact to make sure that community has something to refer to.

1. ### Familiar syntax

   Tact features modern post-C syntax familiar to developers who know TypeScript, Swift, Kotlin and Rust.

2. ### First-class data structures

   Tact makes it easy to declare, decode and encode data structures according to their TL-B schemas.

3. ### Safe contract interfaces and ABI

   Tact offers strong compile-time checks for contract interfaces, typed addresses and lets you describe messages natively in a subset of TL-B.

4. ### Message dispatch

   Tact offers a convenient yet flexible way to declare, receive and send messages between contracts.

5. ### Plaintext commands

   Tact offers an innovative way for securely sending commands to the contracts by the users using plaintext commands that are parsed on-chain.

6. ### Composition of contracts

   Tact offers traits to extract commonly used behaviors into reusable and verified components.

7. ### Statically bounded iterators

   Tact offers convenient iterators and arrays are bounded and do not hurt scalability of the contracts.

8. ### Batteries-included standard library

   Tact comes with a rich standard library that offers data handling functions and standardized behaviors.

9. ### Interactive

   Tact comes with a live playground, explorer and easy to use deployment tools.

10. ### Verifiable

    Tact produces deterministic builds. Compiler helps analyze gas usage and storage costs.

## License

MIT


## RELEASE.md (https://github.com/tact-lang/tact/blob/main/tact-main/RELEASE.md)
# Tact release checklist template

- [ ] Improve the changelog for `vX.Y.Z`: grammar, wording, polishing
- [ ] Make sure there are no open issues for the [vX.Y.Z milestone](https://github.com/tact-lang/tact/issues?q=is%3Aopen+is%3Aissue+milestone%3AvX.Y.Z) (except for the current one, of course)
- [ ] Bump Tact version in:
  - [ ] [`package.json`](./package.json) file
  - [ ] [CHANGELOG.md](./CHANGELOG.md): `Unreleased` -> `vX.Y.Z`
- [ ] Tag the new `vX.Y.Z` release in Git
  ```shell
  $ git tag vX.Y.Z
  $ git push origin vX.Y.Z
  ```
- [ ] Create the new `vX.Y.Z` release on GitHub: <https://github.com/tact-lang/tact/releases>
- [ ] Publish the new `vX.Y.Z` release on NPM: [@tact-lang/compiler](https://www.npmjs.com/package/@tact-lang/compiler)
  ```shell
  $ git checkout vX.Y.Z
  $ yarn all && npm publish
  ```
- [ ] Update [tact-docs](https://github.com/tact-lang/tact-docs) with the most recent Tact features (tracked in: )
- [ ] Request or perform the plugins/parsers/tools updates and releases:
  - [ ] <https://github.com/tact-lang/tact-template> (tracked in: )
  - [ ] <https://github.com/tact-lang/tree-sitter-tact> (tracked in: )
  - [ ] <https://github.com/tact-lang/tact.vim> (tracked in: )
  - [ ] <https://github.com/tact-lang/tact-sublime> (tracked in: )
  - [ ] <https://github.com/tact-lang/tact-vscode> (tracked in: )
  - [ ] A new release of [tact-vscode](https://marketplace.visualstudio.com/items?itemName=KonVik.tact-lang-vscode) on the Visual Studio Marketplace
  - [ ] <https://github.com/novusnota/prism-ton> (tracked in: )
  - [ ] <https://github.com/nujan-io/nujan-ide> (tracked in: )
  - [ ] <https://github.com/ton-org/blueprint> (tracked in: )
  - [ ] <https://github.com/ton-blockchain/intellij-ton> (tracked in: )
- [ ] Write `vX.Y.Z` release notes explaining the newest changes with code examples
- [ ] [TON Dev News](https://t.me/tondev_news) Telegram channel announcement
- [ ] Accumulate TON dev chats feedback


## ROADMAP.md (https://github.com/tact-lang/tact/blob/main/tact-main/ROADMAP.md)
# TACT Roadmap

> **Note**
> This document is a living document and will be updated as the project evolves.
> The roadmap is not set in stone and is subject to change.
> The roadmap is not a commitment to deliver certain features by certain dates.

## ✍️ Version v1

This version will be the first stable release of TACT. It will be released when the following features are implemented:

- All basic API for Cells, Slices, Builders
- Routing of internal messages
- Random number generation, including a way to seed it
- Ability to deploy contracts
- Ability to send messages to other contracts
- Ability to receive messages from other contracts
- Limited Strings and Maps support
- Importing `func` files
- [Arguments-addressable contracts](https://docs.tact-lang.org/evolution/OTP-005)
- TypeScript bindings for Node, Browser and React Native

## ✍️ Version v2

This version would include the following features:

- Full String support
- Full Maps support, including the ability to iterate over items
- Typed tuples
- `let` type inference when possible
- Limited external messages support
- Contract automatic optimizations
- Auto-unpacking nullable variables to non-null one

## ✍️ Version v3

- Upgradable contracts and contract families


## cspell-fift-words-adjusted.txt (https://github.com/tact-lang/tact/blob/main/tact-main/cspell-fift-words-adjusted.txt)
'exit-interpret
'nop
-roll
-rot
-trailing
-trailing0
0X
0x
2constant
2drop
2dup
2over
2swap
Base
Base
Bcmp
Bhash
BhashB
Bhashu
Blen
Bx
Digit
Fift
Fift-wordlist
Len
Li
Lu
Pos
Split
abort
abs
addop
allot
and
anon
atom
base
base
base64
base64url
bbitrefs
bbits
binary
bl
boc
box
brefs
brembitrefs
brembits
bremrefs
bt
bye
caddr
cadr
call
car
cc
cddr
cdr
char
chr
cmod
cmp
compile
cond
cons
constant
cont
context
count
cr
crc16
crc32
crc32c
create
csr
current
decimal
def
definitions
depth
dict
dictdiff
dictforeach
dictforeachfromx
dictforeachrev
dictmap
dictmapext
dictmerge
dictnew
digit
does
drop
dump
dup
ed25519_chksign
ed25519_sign
ed25519_sign_uint
emit
empty
eq
eqv
exch
exch2
execute
explode
false
file
file-exists
filepart
find
first
fits
forget
gas2runvm
gas2runvmcode
gas2runvmctx
gas2runvmctxact
gas2runvmdict
gasrunvm
gasrunvmcode
gasrunvmctx
gasrunvmctxact
gasrunvmctxactq
gasrunvmdict
getenv
halt
hash
hashB
hashu
hex
hex-number
hmap
hmapempty
hmapforeach
hmapnew
hmapunpack
hold
hole
idict
idictforeach
idictforeachrev
idictmapext
if
ifnot
include
include-depth
integer
interpret-prepare
ldump
len
library
library-version
list
max
min
minmax
mod
namespace
negate
newkeypair
nil
nip
nop
not
now
null
number
octal
or
over
pair
pfxdict
pick
pop
pos
priv
pub
push
quit
recursive
ref
remaining
reverse
rmod
roll
rot
runvm
runvmcode
runvmctx
runvmctxact
runvmctxactq
runvmdict
runvmx
s-fits
s-fits-with
sL
sbitrefs
sbits
scan-until-word
sdict
second
seekeof
sgn
shash
sign
single
skip-ifdef
skip-to-eof
skipspc
sl
smca
space
spec
sr
srefs
string
swap
tab
tc
ten
third
times
totalcsize
totalssize
tpop
triple
true
tuck
tuple
tuple-len
type
udict
ufits
uncons
undef
unpair
unsingle
until
untriple
untuple
variable
vmcont
vmlibs
vmopdump
vmoplen
while
word
word-prefix-find
words
xchg
xor


## cspell-tvm-instructions.txt (https://github.com/tact-lang/tact/blob/main/tact-main/cspell-tvm-instructions.txt)
-ROT
-ROLLX
ABS
ACCEPT
ADD
ADDCONST
ADDDIVMOD
ADDDIVMODC
ADDDIVMODR
ADDRAND
ADDRSHIFTMOD
ADDRSHIFTMODC
ADDRSHIFTMODR
AGAIN
AGAINBRK
AGAINEND
AGAINENDBRK
AND
ATEXIT
ATEXITALT
BALANCE
BBITREFS
BBITS
BCHKBITREFS
BCHKBITREFSQ
BCHKBITS
BCHKBITSQ
BCHKBITSQ_VAR
BCHKBITS_VAR
BCHKREFS
BCHKREFSQ
BDEPTH
BITSIZE
BLESS
BLESSARGS
BLESSNUMARGS
BLESSVARARGS
BLKDROP
BLKDROP2
BLKPUSH
BLKSWAP
BLKSWX
BLOCKLT
BOOLEVAL
BRANCH
BREFS
BREMBITREFS
BREMBITS
BREMREFS
CADDR
CADR
CALLCC
CALLCCARGS
CALLCCVARARGS
CALLDICT
CALLDICT_LONG
CALLREF
CALLXARGS
CALLXARGS_VAR
CALLXVARARGS
CDATASIZE
CDATASIZEQ
CDDDR
CDDR
CDEPTH
CDEPTHIX
CHANGELIB
CHASHIX
CHKBIT
CHKBOOL
CHKDEPTH
CHKNAN
CHKSIGNS
CHKSIGNU
CHKTUPLE
CLEVEL
CLEVELMASK
CMP
COMMIT
COMPOS
COMPOSALT
COMPOSBOTH
CONDSEL
CONDSELCHK
CONFIGDICT
CONFIGOPTPARAM
CONFIGPARAM
CONFIGROOT
CTOS
DEBUG
DEBUGSTR
DEC
DEPTH
DICTADD
DICTADDB
DICTADDGET
DICTADDGETB
DICTADDGETREF
DICTADDREF
DICTDEL
DICTDELGET
DICTDELGETREF
DICTEMPTY
DICTGET
DICTGETNEXT
DICTGETNEXTEQ
DICTGETOPTREF
DICTGETPREV
DICTGETPREVEQ
DICTGETREF
DICTIADD
DICTIADDB
DICTIADDGET
DICTIADDGETB
DICTIADDGETREF
DICTIADDREF
DICTIDEL
DICTIDELGET
DICTIDELGETREF
DICTIGET
DICTIGETEXEC
DICTIGETEXECZ
DICTIGETJMP
DICTIGETJMPZ
DICTIGETNEXT
DICTIGETNEXTEQ
DICTIGETOPTREF
DICTIGETPREV
DICTIGETPREVEQ
DICTIGETREF
DICTIMAX
DICTIMAXREF
DICTIMIN
DICTIMINREF
DICTIREMMAX
DICTIREMMAXREF
DICTIREMMIN
DICTIREMMINREF
DICTIREPLACE
DICTIREPLACEB
DICTIREPLACEGET
DICTIREPLACEGETB
DICTIREPLACEGETREF
DICTIREPLACEREF
DICTISET
DICTISETB
DICTISETGET
DICTISETGETB
DICTISETGETOPTREF
DICTISETGETREF
DICTISETREF
DICTMAX
DICTMAXREF
DICTMIN
DICTMINREF
DICTPUSHCONST
DICTREMMAX
DICTREMMAXREF
DICTREMMIN
DICTREMMINREF
DICTREPLACE
DICTREPLACEB
DICTREPLACEGET
DICTREPLACEGETB
DICTREPLACEGETREF
DICTREPLACEREF
DICTSET
DICTSETB
DICTSETGET
DICTSETGETB
DICTSETGETOPTREF
DICTSETGETREF
DICTSETREF
DICTUADD
DICTUADDB
DICTUADDGET
DICTUADDGETB
DICTUADDGETREF
DICTUADDREF
DICTUDEL
DICTUDELGET
DICTUDELGETREF
DICTUGET
DICTUGETEXEC
DICTUGETEXECZ
DICTUGETJMP
DICTUGETJMPZ
DICTUGETNEXT
DICTUGETNEXTEQ
DICTUGETOPTREF
DICTUGETPREV
DICTUGETPREVEQ
DICTUGETREF
DICTUMAX
DICTUMAXREF
DICTUMIN
DICTUMINREF
DICTUREMMAX
DICTUREMMAXREF
DICTUREMMIN
DICTUREMMINREF
DICTUREPLACE
DICTUREPLACEB
DICTUREPLACEGET
DICTUREPLACEGETB
DICTUREPLACEGETREF
DICTUREPLACEREF
DICTUSET
DICTUSETB
DICTUSETGET
DICTUSETGETB
DICTUSETGETOPTREF
DICTUSETGETREF
DICTUSETREF
DIV
DIVC
DIVMOD
DIVMODC
DIVMODR
DIVR
DIV_BASE
DROP
DROP2
DROPX
DUEPAYMENT
DUMP
DUMPSTK
DUP
DUP2
ECRECOVER
ENDC
ENDS
ENDXC
EQINT
EQUAL
EXECUTE
EXPLODE
EXPLODEVAR
FIRST
FIRSTQ
FITS
FITSX
GASCONSUMED
GEQ
GETFORWARDFEE
GETFORWARDFEESIMPLE
GETGASFEE
GETGASFEESIMPLE
GETGLOB
GETGLOBVAR
GETORIGINALFWDFEE
GETPARAM
GETPRECOMPILEDGAS
GETSTORAGEFEE
GLOBALID
GLOBALID
GREATER
GTINT
HASHCU
HASHEXT
HASHEXTAR_BLAKE
HASHEXTAR_BLAKE2B
HASHEXTAR_KECCAK
HASHEXTAR_KECCAK256
HASHEXTAR_KECCAK512
HASHEXTAR_SHA
HASHEXTAR_SHA256
HASHEXTAR_SHA512
HASHEXTA_BLAKE
HASHEXTA_BLAKE2B
HASHEXTA_KECCAK
HASHEXTA_KECCAK256
HASHEXTA_KECCAK512
HASHEXTA_SHA256
HASHEXTA_SHA512
HASHEXTR_BLAKE2B
HASHEXTR_KECCAK256
HASHEXTR_KECCAK512
HASHEXTR_SHA256
HASHEXTR_SHA512
HASHEXT_BLAKE2B
HASHEXT_KECCAK256
HASHEXT_KECCAK512
HASHEXT_SHA256
HASHEXT_SHA512
HASHSU
IF
IFBITJMP
IFBITJMPREF
IFELSE
IFELSEREF
IFJMP
IFJMPREF
IFNBITJMP
IFNBITJMPREF
IFNOT
IFNOTJMP
IFNOTJMPREF
IFNOTREF
IFNOTRET
IFNOTRETALT
IFREF
IFREFELSE
IFREFELSEREF
IFRET
IFRETALT
INC
INCOMINGVALUE
INDEX
INDEX2
INDEX3
INDEXQ
INDEXVAR
INDEXVARQ
INVERT
ISNAN
ISNEG
ISNNEG
ISNPOS
ISNULL
ISPOS
ISTUPLE
ISZERO
JMPDICT
JMPREF
JMPREFDATA
JMPX
JMPXARGS
JMPXDATA
JMPXVARARGS
KECCAK
LAST
LDDICT
LDDICTQ
LDDICTS
LDGRAMS
LDI
LDILE4
LDILE4Q
LDILE8
LDILE8Q
LDIQ
LDIX
LDIXQ
LDI_ALT
LDMSGADDR
LDMSGADDRQ
LDONES
LDREF
LDREFRTOS
LDSAME
LDSLICE
LDSLICEQ
LDSLICEX
LDSLICEXQ
LDSLICE_ALT
LDU
LDULE4
LDULE4Q
LDULE8
LDULE8Q
LDUQ
LDUX
LDUXQ
LDU_ALT
LDVARINT
LDVARINT16
LDVARUINT
LDZEROES
LEQ
LESS
LESSINT
LSHIFT
LSHIFTADDDIVMOD
LSHIFTADDDIVMODC
LSHIFTADDDIVMODR
LSHIFTDIV
LSHIFTDIVC
LSHIFTDIVC_VAR
LSHIFTDIVR
LSHIFTDIVR_VAR
LSHIFTDIV_VAR
LSHIFT_VAR
LTIME
MAX
MIN
MINMAX
MOD
MODPOW2
MUL
MULADDDIVMOD
MULADDDIVMODC
MULADDDIVMODR
MULADDRSHIFTCMOD
MULADDRSHIFTMOD
MULADDRSHIFTRMOD
MULCONST
MULDIV
MULDIVMOD
MULDIVR
MULRSHIFT
MULRSHIFTC
MULRSHIFTC_VAR
MULRSHIFTR
MULRSHIFTR_VAR
MULRSHIFT_VAR
MYADDR
MYCODE
NEGATE
NEQ
NEQINT
NEWC
NEWDICT
NIL
NIP
NOP
NOT
NOW
NULL
NULLROTRIF
NULLROTRIF2
NULLROTRIFNOT
NULLROTRIFNOT2
NULLSWAPIF
NULLSWAPIF2
NULLSWAPIFNOT
NULLSWAPIFNOT2
ONE
ONLYTOPX
ONLYX
OR
OVER
OVER2
P256_CHKSIGNS
P256_CHKSIGNU
PAIR
PARSEMSGADDR
PARSEMSGADDRQ
PFXDICTADD
PFXDICTCONSTGETJMP
PFXDICTDEL
PFXDICTGET
PFXDICTGETEXEC
PFXDICTGETJMP
PFXDICTGETQ
PFXDICTREPLACE
PFXDICTSET
PICK
PLDDICT
PLDDICTQ
PLDDICTS
PLDI
PLDILE4
PLDILE4Q
PLDILE8
PLDILE8Q
PLDIQ
PLDIX
PLDIXQ
PLDREF
PLDREFIDX
PLDREFVAR
PLDSLICE
PLDSLICEQ
PLDSLICEX
PLDSLICEXQ
PLDU
PLDULE
PLDULE4
PLDULE4Q
PLDULE8
PLDULE8Q
PLDUQ
PLDUX
PLDUXQ
PLDUZ
POP
POPCTR
POPCTRX
POPROOT
POPSAVE
POP_LONG
POW2
PREPAREDICT
PREVBLOCKSINFOTUPLE
PREVKEYBLOCK
PREVMCBLOCKS
PU2XC
PUSH
PUSH2
PUSH3
PUSHCONT
PUSHCONT_SHORT
PUSHCTR
PUSHCTRX
PUSHINT
PUSHINT_16
PUSHINT_4
PUSHINT_8
PUSHINT_LONG
PUSHNAN
PUSHNEGPOW2
PUSHPOW2
PUSHPOW2DEC
PUSHREF
PUSHREFCONT
PUSHREFSLICE
PUSHROOT
PUSHSLICE
PUSHSLICE_LONG
PUSHSLICE_REFS
PUSH_LONG
PUXC
PUXC2
PUXCPU
QADD
QAND
QDEC
QDIV
QDIVC
QDIVMOD
QDIVMODC
QDIVMODR
QDIVR
QFITS
QFITSX
QINC
QLSHIFT
QMOD
QMUL
QMULDIVMOD
QMULDIVR
QNEGATE
QNOT
QOR
QPOW2
QRSHIFT
QSUB
QSUBR
QTLEN
QUFITS
QUFITSX
QXOR
RAND
RANDSEED
RANDU
RANDU256
RAWRESERVE
RAWRESERVEX
REPEAT
REPEATBRK
REPEATEND
REPEATENDBRK
RET
RETALT
RETARGS
RETDATA
RETURNARGS
RETURNVARARGS
RETVARARGS
REVERSE
REVX
REWRITESTDADDR
REWRITESTDADDRQ
REWRITEVARADDR
REWRITEVARADDRQ
RIST255_ADD
RIST255_FROMHASH
RIST255_MUL
RIST255_MULBASE
RIST255_PUSHL
RIST255_QADD
RIST255_QMUL
RIST255_QMULBASE
RIST255_QSUB
RIST255_QVALIDATE
RIST255_SUB
RIST255_VALIDATE
ROLL
ROLLREV
ROLLX
ROT
ROT2
ROTREV
RSHIFT
RSHIFTC
RSHIFTC_VAR
RSHIFTR
RSHIFTR_VAR
RSHIFT_VAR
RUNVM
RUNVMX
SAMEALT
SAMEALTSAVE
SAVE
SAVEALT
SAVEBOTH
SBITREFS
SBITS
SCHKBITREFS
SCHKBITREFSQ
SCHKBITS
SCHKBITSQ
SCHKREFS
SCHKREFSQ
SCUTFIRST
SCUTLAST
SDATASIZE
SDATASIZEQ
SDBEGINS
SDBEGINSQ
SDBEGINSX
SDBEGINSXQ
SDCNTLEAD0
SDCNTLEAD1
SDCNTTRAIL0
SDCNTTRAIL1
SDCUTFIRST
SDCUTLAST
SDEMPTY
SDEPTH
SDEQ
SDFIRST
SDLEXCMP
SDPFX
SDPFXREV
SDPPFX
SDPPFXREV
SDPSFX
SDPSFXREV
SDSFX
SDSFXREV
SDSKIPFIRST
SDSKIPLAST
SDSUBSTR
SECOND
SECONDQ
SEMPTY
SENDMSG
SENDRAWMSG
SETALTCTR
SETCODE
SETCONTARGS
SETCONTARGS_N
SETCONTCTR
SETCONTCTRX
SETCONTVARARGS
SETCP
SETCP0
SETCPX
SETCP_SPECIAL
SETEXITALT
SETFIRST
SETFIRSTQ
SETGASLIMIT
SETGLOB
SETGLOBVAR
SETINDEX
SETINDEXQ
SETINDEXVAR
SETINDEXVARQ
SETLIBCODE
SETNUMARGS
SETNUMVARARGS
SETRAND
SETRETCTR
SETSECOND
SETSECONDQ
SETTHIRD
SETTHIRDQ
SGN
SHA256U
SINGLE
SKIPDICT
SPLIT
SPLITQ
SREFS
SREMPTY
SSKIPFIRST
SSKIPLAST
STB
STBQ
STBR
STBREF
STBREFQ
STBREFR
STBREFRQ
STBREFR_ALT
STBRQ
STDICT
STDICTS
STGRAMS
STI
STILE4
STILE8
STIQ
STIR
STIRQ
STIX
STIXQ
STIXR
STIXRQ
STI_ALT
STONE
STONES
STOPTREF
STORAGEFEES
STREF
STREF2CONST
STREFCONST
STREFQ
STREFR
STREFRQ
STREF_ALT
STSAME
STSLICE
STSLICECONST
STSLICEQ
STSLICER
STSLICERQ
STSLICE_ALT
STU
STULE
STULE4
STULE8
STUQ
STUR
STURQ
STUX
STUXQ
STUXR
STUXRQ
STU_ALT
STVARINT16
STVARINT
STVARUINT
STZERO
STZEROES
SUB
SUBDICTGET
SUBDICTIGET
SUBDICTIRPGET
SUBDICTRPGET
SUBDICTUGET
SUBDICTURPGET
SUBR
SUBSLICE
SWAP
SWAP2
TEN
THENRET
THENRETALT
THIRD
THIRDQ
THROW
THROWANY
THROWANYIF
THROWANYIFNOT
THROWARG
THROWARGANY
THROWARGANYIF
THROWARGANYIFNOT
THROWARGIF
THROWARGIFNOT
THROWIF
THROWIFNOT
THROWIFNOT_SHORT
THROWIF_SHORT
THROW_SHORT
TLEN
TPOP
TPUSH
TRIPLE
TRUE
TRY
TRYARGS
TUCK
TUPLE
TUPLEVAR
TWO
UBITSIZE
UFITS
UFITSX
UNPACKEDCONFIGTUPLE
UNPACKFIRST
UNPACKFIRSTVAR
UNPAIR
UNSINGLE
UNTIL
UNTILBRK
UNTILEND
UNTILENDBRK
UNTRIPLE
UNTUPLE
UNTUPLEVAR
WHILE
WHILEBRK
WHILEEND
WHILEENDBRK
XC2PU
XCHG
XCHG2
XCHG3
XCHG3_ALT
XCHGX
XCHG_0I
XCHG_0I_LONG
XCHG_1I
XCHG_IJ
XCPU
XCPU2
XCPUXC
XCTOS
XLOAD
XLOADQ
XOR
ZERO


## cspell.json (https://github.com/tact-lang/tact/blob/main/tact-main/cspell.json)
{
  "$schema": "https://raw.githubusercontent.com/streetsidesoftware/cspell/main/cspell.schema.json",
  "version": "0.2",
  "language": "en",
  "dictionaryDefinitions": [
    {
      "name": "fift-words",
      "path": "./cspell-fift-words-adjusted.txt"
    },
    {
      "name": "tvm-instructions",
      "path": "./cspell-tvm-instructions.txt"
    }
  ],
  "dictionaries": ["fift-words", "tvm-instructions"],
  "words": [
    "alnum",
    "assgn",
    "augmentedassign",
    "basechain",
    "bitcode",
    "bitstring",
    "blockstore",
    "bounceable",
    "Brujin",
    "cleanall",
    "codegen",
    "comptime",
    "Compilables",
    "compilables",
    "Daniil",
    "decompilation",
    "decompile",
    "Decompiled",
    "decompiler",
    "decompiles",
    "decompiling",
    "dentry",
    "Descr",
    "disasm",
    "divmod",
    "dnsresolve",
    "Domínguez",
    "elseifnot",
    "forall",
    "formedness",
    "funcfiftlib",
    "funcid",
    "funs",
    "frontmatter",
    "Georgiy",
    "getsimpleforwardfee",
    "gettest",
    "Héctor",
    "infixl",
    "infixr",
    "initof",
    "ipfs",
    "ipld",
    "Jesús",
    "jettons",
    "jsxdev",
    "keccak",
    "knip",
    "Komarov",
    "Korshakov",
    "Laika",
    "langle",
    "lparen",
    "lvalue",
    "lvalues",
    "masterchain",
    "maxint",
    "Merkle",
    "minmax",
    "mintable",
    "mktemp",
    "multiformats",
    "nanotons",
    "Neovim",
    "nocheck",
    "noexcept",
    "nonterminal",
    "Nonterminal",
    "Novus",
    "Offchain",
    "Parens",
    "pinst",
    "POSIX",
    "postpack",
    "prando",
    "rangle",
    "rawslice",
    "renamer",
    "replaceget",
    "rparen",
    "rugpull",
    "rugpulled",
    "Sánchez",
    "sctx",
    "Sedov",
    "seqno",
    "shiki",
    "Stateinit",
    "stdlib",
    "stmts",
    "Ston",
    "struct",
    "structs",
    "subtyping",
    "Tarjan",
    "testdata",
    "Topup",
    "Toncoin",
    "Toncoins",
    "Trunov",
    "typechecker",
    "uintptr",
    "uninit",
    "unixfs",
    "varuint",
    "workchain",
    "xffff",
    "привет"
  ],
  "ignoreRegExpList": [
    "\\b[xB]\\{[a-fA-F0-9]*_?\\}", // binary literals in Fift-asm
    "\\b0[xX][a-fA-F0-9_]*\\b", // hexadecimal numbers
    "\\b(?:address|crc32|cell|slice|rawSlice)\\(\".+\"\\)" // some comptime functions
  ],
  "flagWords": [],
  "ignorePaths": [
    "*.boc",
    "*.fif",
    "**/*/output",
    "*.spec.ts.snap",
    "node_modules",
    "dist",
    "func",
    "grammar/sample.json",
    "src/generator/writers/writeStdlib.ts",
    "src/grammar/grammar.ohm-bundle.d.ts",
    "src/grammar/test/items-native-fun-funcid.tact",
    "src/grammar/test/items-asm-funs.tact",
    "src/grammar/test-asm/*.tact",
    "src/grammar/test-failed/funcid-*.tact",
    "src/imports/stdlib.ts",
    "/src/test/compilation-failed/const-eval-failed.spec.ts",
    "src/test/e2e-emulated/address.spec.ts",
    "src/test/e2e-emulated/intrinsics.spec.ts",
    "src/test/e2e-emulated/optionals.spec.ts",
    "src/test/e2e-emulated/strings.spec.ts",
    "src/test/e2e-emulated/contracts/intrinsics.tact",
    "src/test/e2e-emulated/contracts/strings.tact",
    "src/test/e2e-emulated/contracts/dns.tact",
    "src/test/compilation-fail/fail-const-eval.spec.ts",
    "src/test/e2e-emulated/getter-names-conflict.spec.ts",
    "src/test/exit-codes/contracts/compute-phase-errors.tact",
    "stdlib/stdlib.fc",
    "/docs"
  ]
}


## jest.config.js (https://github.com/tact-lang/tact/blob/main/tact-main/jest.config.js)
module.exports = {
    preset: "ts-jest",
    testEnvironment: "node",
    testPathIgnorePatterns: ["/node_modules/", "/dist/"],
    maxWorkers: "50%",
    globalSetup: "./jest.setup.js",
    globalTeardown: "./jest.teardown.js",
    snapshotSerializers: ["@tact-lang/ton-jest/serializers"],
};


## jest.setup.js (https://github.com/tact-lang/tact/blob/main/tact-main/jest.setup.js)
// eslint-disable-next-line @typescript-eslint/no-var-requires
const coverage = require("@tact-lang/coverage");

module.exports = async () => {
    if (process.env.COVERAGE === "true") {
        coverage.beginCoverage();
    }
};


## jest.teardown.js (https://github.com/tact-lang/tact/blob/main/tact-main/jest.teardown.js)
const coverage = require("@tact-lang/coverage");
const path = require("path");

module.exports = async () => {
    if (process.env.COVERAGE === "true") {
        coverage.completeCoverage([
            path.resolve(__dirname, "examples", "output", "*.boc"),
            path.resolve(
                __dirname,
                "src",
                "test",
                "codegen",
                "output",
                "*.boc",
            ),
            path.resolve(
                __dirname,
                "src",
                "test",
                "e2e-emulated",
                "output",
                "*.boc",
            ),
            path.resolve(
                __dirname,
                "src",
                "benchmarks",
                "contracts",
                "output",
                "*.boc",
            ),
        ]);
    }
};


## knip.json (https://github.com/tact-lang/tact/blob/main/tact-main/knip.json)
{
  "$schema": "https://unpkg.com/knip@5/schema.json",
  "entry": ["src/index.ts", "src/main.ts", "src/node.ts", "bin/tact.js"],
  "project": ["src/**/*.ts", "bin/tact.js"],
  "ignore": [
    "src/grammar/ast.ts",
    "src/prettyPrinter.ts",
    "src/error/display-to-json.ts",
    "src/grammar/src-info.ts",
    ".github/workflows/tact*.yml"
  ],
  "ignoreDependencies": ["@tact-lang/ton-abi"]
}


## package.json (https://github.com/tact-lang/tact/blob/main/tact-main/package.json)
{
  "name": "@tact-lang/compiler",
  "version": "1.5.2",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tact-lang/tact.git"
  },
  "homepage": "https://tact-lang.org",
  "description": "Tact is a next-gen smart contract language for TON",
  "author": "Steve Korshakov <steve@korshakov.com>",
  "license": "MIT",
  "scripts": {
    "gen:grammar": "ohm generateBundles --withTypes src/grammar/*.ohm",
    "gen:pack": "ts-node ./scripts/pack.ts",
    "gen:compiler": "ts-node ./scripts/prepare.ts",
    "gen": "yarn gen:grammar && yarn gen:pack && yarn gen:compiler",
    "clean": "rm -fr dist",
    "cleanall": "rm -fr dist node_modules",
    "build": "tsc && node --no-warnings=ExperimentalWarning -r ts-node/register ./scripts/copy-files",
    "test": "jest",
    "coverage": "cross-env COVERAGE=true jest",
    "release": "yarn clean && yarn build && yarn coverage && yarn release-it --npm.yarn1",
    "type": "tsc --noEmit",
    "lint": "yarn eslint .",
    "lint:schema": "ajv validate -s schemas/configSchema.json -d tact.config.json",
    "fmt": "yarn prettier -l -w .",
    "fmt:check": "yarn prettier --check .",
    "spell": "yarn cspell --no-progress \"**\"",
    "knip": "knip",
    "lint:all": "yarn lint && yarn fmt:check && yarn lint:schema && yarn spell && yarn knip",
    "all": "yarn clean && yarn gen && yarn build && yarn coverage && yarn lint:all",
    "postinstall": "node .husky/install.mjs || true",
    "prepack": "pinst --disable",
    "postpack": "pinst --enable"
  },
  "files": [
    "dist/**/*",
    "src/**/*",
    "bin/**/*",
    "stdlib/**/*",
    "!**/test",
    "!/docs"
  ],
  "main": "./dist/main.js",
  "bin": {
    "tact": "bin/tact.js"
  },
  "dependencies": {
    "@tact-lang/opcode": "^0.0.16",
    "@ton/core": "0.59.0",
    "@ton/crypto": "^3.2.0",
    "blockstore-core": "1.0.5",
    "change-case": "^4.1.2",
    "crc-32": "1.2.2",
    "ipfs-unixfs-importer": "9.0.10",
    "json-bigint": "^1.0.0",
    "meow": "^13.2.0",
    "mkdirp": "^2.1.3",
    "ohm-js": "^17.1.0",
    "path-normalize": "^6.0.13",
    "prando": "^6.0.1",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@ohm-js/cli": "^2.0.0",
    "@release-it/keep-a-changelog": "^5.0.0",
    "@tact-lang/coverage": "^0.0.8",
    "@tact-lang/ton-abi": "^0.0.3",
    "@tact-lang/ton-jest": "^0.0.4",
    "@ton/sandbox": "^0.22.0",
    "@ton/test-utils": "^0.4.2",
    "@types/glob": "^8.1.0",
    "@types/jest": "^29.5.12",
    "@types/json-bigint": "^1.0.4",
    "@types/node": "^22.5.0",
    "@typescript-eslint/eslint-plugin": "^7.0.2",
    "@typescript-eslint/parser": "^7.0.2",
    "ajv-cli": "^5.0.0",
    "cross-env": "^7.0.3",
    "cspell": "^8.8.3",
    "eslint": "^8.56.0",
    "glob": "^8.1.0",
    "husky": "^9.1.5",
    "jest": "^29.3.1",
    "knip": "^5.24.1",
    "pinst": "^3.0.0",
    "prettier": "^3.2.5",
    "release-it": "^17.6.0",
    "rimraf": "^4.1.2",
    "ts-jest": "^29.0.3",
    "ts-node": "^10.9.1",
    "typescript": "~5.6.2"
  },
  "publishConfig": {
    "access": "public",
    "registry": "https://registry.npmjs.org/"
  },
  "release-it": {
    "github": {
      "release": true
    },
    "plugins": {
      "@release-it/keep-a-changelog": {
        "filename": "CHANGELOG.md"
      }
    }
  },
  "packageManager": "yarn@1.22.22",
  "engines": {
    "node": ">=22.0.0"
  }
}


## tact.config.json (https://github.com/tact-lang/tact/blob/main/tact-main/tact.config.json)
{
  "$schema": "http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json",
  "projects": [
    {
      "name": "echo",
      "path": "./examples/echo.tact",
      "output": "./examples/output"
    },
    {
      "name": "inheritance",
      "path": "./examples/inheritance.tact",
      "output": "./examples/output"
    },
    {
      "name": "large",
      "path": "./examples/large.tact",
      "output": "./examples/output"
    },
    {
      "name": "native",
      "path": "./examples/native.tact",
      "output": "./examples/output"
    },
    {
      "name": "maps",
      "path": "./examples/maps.tact",
      "output": "./examples/output"
    },
    {
      "name": "payouts",
      "path": "./examples/payouts.tact",
      "output": "./examples/output"
    },
    {
      "name": "external",
      "path": "./examples/external.tact",
      "output": "./examples/output",
      "options": {
        "external": true
      }
    },
    {
      "name": "wallet",
      "path": "./examples/wallet.tact",
      "output": "./examples/output"
    },
    {
      "name": "wallet-opt",
      "path": "./examples/wallet-opt.tact",
      "output": "./examples/output",
      "options": {
        "experimental": {
          "inline": true
        }
      }
    },
    {
      "name": "treasure",
      "path": "./examples/treasure.tact",
      "output": "./examples/output"
    },
    {
      "name": "multisig",
      "path": "./examples/multisig.tact",
      "output": "./examples/output"
    },
    {
      "name": "multisig-3",
      "path": "./examples/multisig-3.tact",
      "output": "./examples/output"
    },
    {
      "name": "increment",
      "path": "./examples/increment.tact",
      "output": "./examples/output"
    },
    {
      "name": "rugpull",
      "path": "./examples/rugpull.tact",
      "output": "./examples/output"
    },
    {
      "name": "maps",
      "path": "./src/test/e2e-emulated/contracts/maps.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "map-traverse",
      "path": "./src/test/e2e-emulated/contracts/map-traverse.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "map-comparison",
      "path": "./src/test/e2e-emulated/contracts/map-comparison.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "mutating-methods",
      "path": "./src/test/e2e-emulated/contracts/mutating-methods.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "underscore-variable",
      "path": "./src/test/e2e-emulated/contracts/underscore-variable.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "optionals",
      "path": "./src/test/e2e-emulated/contracts/optionals.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "sample-jetton",
      "path": "./src/test/e2e-emulated/contracts/sample-jetton.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "serialization",
      "path": "./src/test/e2e-emulated/contracts/serialization.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "serialization-2",
      "path": "./src/test/e2e-emulated/contracts/serialization-2.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "serialization-3",
      "path": "./src/test/e2e-emulated/contracts/serialization-3.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "strings",
      "path": "./src/test/e2e-emulated/contracts/strings.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "constants",
      "path": "./src/test/e2e-emulated/contracts/constants.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "math",
      "path": "./src/test/e2e-emulated/contracts/math.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "dns",
      "path": "./src/test/e2e-emulated/contracts/dns.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "integer-literals",
      "path": "./src/test/e2e-emulated/contracts/integer-literals.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "random",
      "path": "./src/test/e2e-emulated/contracts/random.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "ordering",
      "path": "./src/test/e2e-emulated/contracts/ordering.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "deep",
      "path": "./src/test/e2e-emulated/contracts/deep-sequence.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "bounced-routing",
      "path": "./src/test/e2e-emulated/contracts/bounced-routing.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "external-fallbacks",
      "path": "./src/test/e2e-emulated/contracts/external-fallbacks.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "external": true
      }
    },
    {
      "name": "debug",
      "path": "./src/test/e2e-emulated/contracts/debug.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "send",
      "path": "./src/test/e2e-emulated/contracts/send.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "intrinsics",
      "path": "./src/test/e2e-emulated/contracts/intrinsics.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "masterchain",
      "path": "./src/test/e2e-emulated/contracts/masterchain.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "try-catch",
      "path": "./src/test/e2e-emulated/contracts/try-catch.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "address",
      "path": "./src/test/e2e-emulated/contracts/address.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "ternary",
      "path": "./src/test/e2e-emulated/contracts/ternary.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "implicit-init",
      "path": "./src/test/e2e-emulated/contracts/implicit-init.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "recursion",
      "path": "./src/test/e2e-emulated/contracts/recursion.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "local-type-inference",
      "path": "./src/test/e2e-emulated/contracts/local-type-inference.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "benchmark_functions",
      "path": "./src/benchmarks/contracts/functions.tact",
      "output": "./src/benchmarks/contracts/output"
    },
    {
      "name": "benchmark_functions_inline",
      "path": "./src/benchmarks/contracts/functions.tact",
      "output": "./src/benchmarks/contracts/output",
      "options": {
        "experimental": {
          "inline": true
        }
      }
    },
    {
      "name": "codegen",
      "path": "./src/test/codegen/all-contracts.tact",
      "output": "./src/test/codegen/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "stdlib",
      "path": "./src/test/e2e-emulated/contracts/stdlib.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "structs",
      "path": "./src/test/e2e-emulated/contracts/structs.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "initof",
      "path": "./src/test/e2e-emulated/contracts/initof.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "initof-2",
      "path": "./src/test/e2e-emulated/contracts/initof-2.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "initof-3",
      "path": "./src/test/e2e-emulated/contracts/initof-3.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "getters",
      "path": "./src/test/e2e-emulated/contracts/getters.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "allocation",
      "path": "./src/test/e2e-emulated/contracts/allocation.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "traits",
      "path": "./src/test/e2e-emulated/contracts/traits.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "receiver-empty",
      "path": "./src/test/e2e-emulated/contracts/receiver-empty.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "init-of-message",
      "path": "./src/test/e2e-emulated/contracts/init-of-message.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "init-return",
      "path": "./src/test/e2e-emulated/contracts/init-return.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "repeat-range",
      "path": "./src/test/exit-codes/contracts/repeat-range.tact",
      "output": "./src/test/exit-codes/contracts/output"
    },
    {
      "name": "semantics",
      "path": "./src/test/e2e-emulated/contracts/semantics.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "contract-methods",
      "path": "./src/test/e2e-emulated/contracts/contract-methods.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "asm-functions",
      "path": "./src/test/e2e-emulated/contracts/asm-functions.tact",
      "output": "./src/test/e2e-emulated/contracts/output"
    },
    {
      "name": "text-message-receivers",
      "path": "./src/test/e2e-emulated/contracts/text-message-receivers.tact",
      "output": "./src/test/e2e-emulated/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "tact-reserved-contract-errors",
      "path": "./src/test/exit-codes/contracts/tact-reserved-contract-errors.tact",
      "output": "./src/test/exit-codes/contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "compute-phase-errors",
      "path": "./src/test/exit-codes/contracts/compute-phase-errors.tact",
      "output": "./src/test/exit-codes/contracts/output"
    }
  ]
}


## tsconfig.base.json (https://github.com/tact-lang/tact/blob/main/tact-main/tsconfig.base.json)
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */
    /* Basic Options */
    // "incremental": true,                         /* Enable incremental compilation */
    "target": "esnext" /* Specify ECMAScript target version: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', 'ES2021', or 'ESNEXT'. */,
    "module": "commonjs" /* Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'. */,
    "lib": ["ESNext"],
    // "allowJs": true,                             /* Allow javascript files to be compiled. */
    // "checkJs": true,                             /* Report errors in .js files. */
    // "jsx": "preserve",                           /* Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'. */
    "declaration": true /* Generates corresponding '.d.ts' file. */,
    // "declarationMap": true,                      /* Generates a sourcemap for each corresponding '.d.ts' file. */
    // "sourceMap": true,                           /* Generates corresponding '.map' file. */
    // "outFile": "./",                             /* Concatenate and emit output to single file. */
    // "rootDir": "./",                             /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // "composite": true,                           /* Enable project compilation */
    // "tsBuildInfoFile": "./",                     /* Specify file to store incremental compilation information */
    // "removeComments": true,                      /* Do not emit comments to output. */
    // "noEmit": false,                              /* Do not emit outputs. */
    // "importHelpers": true,                       /* Import emit helpers from 'tslib'. */
    "downlevelIteration": true /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */,
    // "isolatedModules": true,                     /* Transpile each file as a separate module (similar to 'ts.transpileModule'). */
    /* Strict Type-Checking Options */
    "strict": true /* Enable all strict type-checking options. */,
    // "noImplicitAny": true,                       /* Raise error on expressions and declarations with an implied 'any' type. */
    // "strictNullChecks": true,                    /* Enable strict null checks. */
    // "strictFunctionTypes": true,                 /* Enable strict checking of function types. */
    // "strictBindCallApply": true,                 /* Enable strict 'bind', 'call', and 'apply' methods on functions. */
    // "strictPropertyInitialization": true,        /* Enable strict checking of property initialization in classes. */
    // "noImplicitThis": true,                      /* Raise error on 'this' expressions with an implied 'any' type. */
    // "alwaysStrict": true,                        /* Parse in strict mode and emit "use strict" for each source file. */
    /* Additional Checks */
    // "noUnusedLocals": true,                      /* Report errors on unused locals. */
    // "noUnusedParameters": true,                  /* Report errors on unused parameters. */
    "noImplicitReturns": true /* Report error when not all code paths in function return a value. */,
    // "noFallthroughCasesInSwitch": true,          /* Report errors for fallthrough cases in switch statement. */
    "noUncheckedIndexedAccess": true /* Include 'undefined' in index signature results */,
    // "noImplicitOverride": true,                  /* Ensure overriding members in derived classes are marked with an 'override' modifier. */
    // "noPropertyAccessFromIndexSignature": true,  /* Require undeclared properties from index signatures to use element accesses. */
    /* Module Resolution Options */
    // "moduleResolution": "node",                  /* Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6). */
    // "baseUrl": "./",                             /* Base directory to resolve non-absolute module names. */
    // "paths": {},                                 /* A series of entries which re-map imports to lookup locations relative to the 'baseUrl'. */
    // "rootDirs": [],                              /* List of root folders whose combined content represents the structure of the project at runtime. */
    // "typeRoots": [],                             /* List of folders to include type definitions from. */
    // "types": [],                                 /* Type declaration files to be included in compilation. */
    "allowSyntheticDefaultImports": true /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */,
    "esModuleInterop": true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */,
    // "preserveSymlinks": true,                    /* Do not resolve the real path of symlinks. */
    // "allowUmdGlobalAccess": true,                /* Allow accessing UMD globals from modules. */
    /* Source Map Options */
    // "sourceRoot": "",                            /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // "mapRoot": "",                               /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                     /* Emit a single file with source maps instead of having a separate file. */
    // "inlineSources": true,                       /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */
    /* Experimental Options */
    // "experimentalDecorators": true,              /* Enables experimental support for ES7 decorators. */
    // "emitDecoratorMetadata": true,               /* Enables experimental support for emitting type metadata for decorators. */
    /* Advanced Options */
    "skipLibCheck": true /* Skip type checking of declaration files. */,
    "forceConsistentCasingInFileNames": true /* Disallow inconsistently-cased references to the same file. */,
    "resolveJsonModule": true
  }
}


## tsconfig.eslint.json (https://github.com/tact-lang/tact/blob/main/tact-main/tsconfig.eslint.json)
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "noImplicitReturns": false /* Report error when not all code paths in function return a value. */,
    "noUncheckedIndexedAccess": false /* Include 'undefined' in index signature results */
  },
  "include": [
    "src/",
    "examples/",
    "scripts/",
    "./jest.config.js",
    "bin/tact.js"
  ],
  "exclude": ["**/*.bind.ts", "src/test/**/output/**/*"]
}


## tsconfig.json (https://github.com/tact-lang/tact/blob/main/tact-main/tsconfig.json)
{
  "extends": "./tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*"],
  "exclude": ["**/**.spec.ts", "**/**.bind.ts", "src/test/features/output/**/*"]
}


## pull_request_template.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/pull_request_template.md)
Click the `Preview` tab and select a PR template:

- [New language feature](?expand=1&template=language-feature.md)
- [Bugfix](?expand=1&template=bugfix.md)
- [Optimization of generated code](?expand=1&template=codegen.md)
- [API for third-party tools](?expand=1&template=api.md)
- [Project dependencies: updating, porting to another library, etc.](?expand=1&template=dependencies.md)
- [CI](?expand=1&template=CI.md)
- [Linters: adding more lints or changing the existing ones](?expand=1&template=linters.md)
- [Compiler documentation](?expand=1&template=compiler-documentation.md)
- [Improve compiler tests by adding new ones or modifying the existing tests](?expand=1&template=tests.md)
- [Tact release](?expand=1&template=release.md)
- [Project policies](?expand=1&template=policies.md)
- [Code quality improvement](?expand=1&code-quality.md)


## 01-generic.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/ISSUE_TEMPLATE/01-generic.md)
---
name: Generic issue
about: Feature requests, refactor proposal, CI, lints, docs, etc.
title: ""
labels: []
assignees: ""
---


## CI.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/CI.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## api.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/api.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] This part of API is exported from the corresponding `index.ts`
- [ ] I have run all the tests locally and no test failure was reported
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## bugfix.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/bugfix.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] I have added tests to demonstrate the contribution is correctly implemented: this usually includes both positive and negative tests, showing the happy path(s) and featuring intentionally broken cases
- [ ] I have run all the tests locally and no test failure was reported
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## code-quality.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/code-quality.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!

IMPORTANT:
In general, the Tact team does not accept refactorings from external contributors unless those were previously discussed and you've got the green light to change things without adding new functionality or to fix something broken. Language features, bugfixes, doc improvements are more than welcome!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] I have run all the tests locally and no test failure was reported
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## codegen.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/codegen.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] I have added tests to demonstrate the contribution is correctly implemented: it reduces gas consumption for the common cases, makes storage improvements, etc. and does not have too much negative impact for the rest of the use-cases
- [ ] I have run all the tests locally and no test failure was reported
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## compiler-documentation.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/compiler-documentation.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## dependencies.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/dependencies.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] I have run all the tests locally and no test failure was reported
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## language-feature.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/language-feature.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] I have documented my contribution in `docs/` and made the build locally
- [ ] I have added tests to demonstrate the contribution is correctly implemented: this usually includes both positive and negative tests, showing the happy path(s) and featuring intentionally broken cases
- [ ] I have run all the tests locally and no test failure was reported
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## linters.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/linters.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## policies.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/policies.md)
## Issue

Closes #number.

## Checklist

- [ ] I have run the linter, formatter and spellchecker


## release.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/release.md)
## Issue

Towards issue #number.

## Checklist

- [ ] I have improved and updated CHANGELOG.md
- [ ] I have updated `package.json` with the new version
- [ ] I have run the linter, formatter and spellchecker


## tests.md (https://github.com/tact-lang/tact/blob/main/tact-main/.github/PULL_REQUEST_TEMPLATE/tests.md)
<!--
IMPORTANT:
If your PR doesn't close a particular issue, please, create the issue first and describe the whole context: what you're adding/changing and why you're doing so. And only then open the Pull Request, which would close that issue!
-->

## Issue

Closes #number.

## Checklist

- [ ] I have updated CHANGELOG.md
- [ ] I have run all the tests locally and no test failure was reported
- [ ] I have run the linter, formatter and spellchecker
- [ ] I did not do unrelated and/or undiscussed refactorings


## tact.js (https://github.com/tact-lang/tact/blob/main/tact-main/bin/tact.js)
#!/usr/bin/env node

const pkg = require("../package.json");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const main = require("../dist/node.js");
const meowModule = import("meow");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const { execFileSync } = require("child_process");

void meowModule.then(
    /** @param meow {import('meow/build/index')} */
    (meow) => {
        const cli = meow.default(
            `
    Usage
      $ tact [...flags] (--config CONFIG | FILE)

    Flags
      -c, --config CONFIG         Specify path to config file (tact.config.json)
      -p, --project ...names      Build only the specified project name(s) from the config file
      -q, --quiet                 Suppress compiler log output
      --with-decompilation        Full compilation followed by decompilation of produced binary code
      --func                      Output intermediate FunC code and exit
      --check                     Perform syntax and type checking, then exit
      -e, --eval EXPRESSION       Evaluate a Tact expression and exit
      -v, --version               Print Tact compiler version and exit
      -h, --help                  Display this text and exit

    Examples
      $ tact --version
      ${pkg.version}

    Learn more about Tact:        https://docs.tact-lang.org
    Join Telegram group:          https://t.me/tactlang
    Follow X/Twitter account:     https://twitter.com/tact_language`,
            {
                importMeta: {
                    url: new URL("file://" + __dirname + __filename).toString(),
                },
                description: `Command-line utility for the Tact compiler:\n${pkg.description}`,
                autoVersion: false,
                flags: {
                    config: {
                        shortFlag: "c",
                        type: "string",
                        isRequired: (flags, _) => {
                            // Require a config when the projects are specified
                            // AND version/help are not specified
                            // AND eval is not specified
                            return (
                                flags.projects.length !== 0 &&
                                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                                !flags.version &&
                                // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
                                !flags.help &&
                                !flags.eval
                            );
                        },
                    },
                    projects: {
                        shortFlag: "p",
                        type: "string",
                        isMultiple: true,
                    },
                    quiet: { shortFlag: "q", type: "boolean", default: false },
                    withDecompilation: { type: "boolean", default: false },
                    func: { type: "boolean", default: false },
                    check: { type: "boolean", default: false },
                    eval: { shortFlag: "e", type: "string" },
                    version: { shortFlag: "v", type: "boolean" },
                    help: { shortFlag: "h", type: "boolean" },
                },
                allowUnknownFlags: false,
            },
        );

        // Helper function to write less in following checks
        const isEmptyConfigAndInput = () => {
            return cli.flags.config === undefined && cli.input.length === 0;
        };

        // Show help regardless of other flags
        if (cli.flags.help) {
            cli.showHelp(0);
        }

        // Show version regardless of other flags
        if (cli.flags.version) {
            console.log(pkg.version);
            // if working inside a git repository
            // also print the current git commit hash
            try {
                const gitCommit = execFileSync("git", ["rev-parse", "HEAD"], {
                    encoding: "utf8",
                    stdio: ["ignore", "pipe", "ignore"],
                }).trim();
                console.log(`git commit: ${gitCommit}`);
            } finally {
                process.exit(0);
            }
        }

        // Evaluate expression regardless of other flags
        if (cli.flags.eval) {
            const result = main.parseAndEvalExpression(cli.flags.eval);
            switch (result.kind) {
                case "ok":
                    {
                        console.log(result.value);
                        process.exit(0);
                    }
                    break;
                case "error": {
                    console.log(result.message);
                    process.exit(30);
                }
            }
        }

        // Disallow specifying both config or Tact source file at the same time
        if (cli.flags.config !== undefined && cli.input.length > 0) {
            console.log(
                "Error: Both config and Tact file can't be simultaneously specified, pick one!",
            );
            cli.showHelp();
        }

        // Disallow specifying several exclusive compilation mode flags
        const compilationModeFlags = [
            cli.flags.check,
            cli.flags.func,
            cli.flags.withDecompilation,
        ];
        const numOfCompilationModeFlagsSet = compilationModeFlags.filter(
            (flag) => flag,
        ).length;
        if (numOfCompilationModeFlagsSet > 1) {
            console.log(
                "Error: Flags --with-decompilation, --func and --check are mutually exclusive!",
            );
            cli.showHelp();
        }

        // Disallow using compilation mode flags without a config or a file specified
        if (isEmptyConfigAndInput() && numOfCompilationModeFlagsSet > 0) {
            console.log(
                "Error: Either config or Tact file have to be specified!",
            );
            cli.showHelp();
        }

        // Disallow specifying more than one Tact file
        if (cli.input.length > 1) {
            console.log(
                "Error: Only one Tact file can be specified at a time. If you want more, provide a config!",
            );
            cli.showHelp();
        }

        // Show help when all flags and inputs are empty
        // Note, that version/help flags are already processed above and don't need to be mentioned here
        if (
            isEmptyConfigAndInput() &&
            numOfCompilationModeFlagsSet === 0 &&
            cli.flags.projects.length === 0
        ) {
            cli.showHelp(0);
        }

        // Compilation mode
        const mode = cli.flags.check
            ? "checkOnly"
            : cli.flags.func
              ? "funcOnly"
              : cli.flags.withDecompilation
                ? "fullWithDecompilation"
                : undefined;

        // TODO: all flags on the cli should take precedence over flags in the config
        // Make a nice model for it in the src/node.ts instead of the current mess
        // Consider making overwrites right here or something.

        // Main command
        void main
            .run({
                fileName: cli.input.at(0),
                configPath: cli.flags.config,
                projectNames: cli.flags.projects ?? [],
                additionalCliOptions: { mode },
                suppressLog: cli.flags.quiet,
            })
            .then((response) => {
                // https://nodejs.org/docs/v20.12.1/api/process.html#exit-codes
                process.exit(response.ok ? 0 : 30);
            });
    },
);


## fail.config.json (https://github.com/tact-lang/tact/blob/main/tact-main/bin/test/fail.config.json)
{
  "$schema": "../../schemas/configSchema.json",
  "projects": [
    {
      "name": "fail",
      "path": "./fail.tact",
      "output": "./fail_output",
      "mode": "checkOnly"
    }
  ]
}


## fail.tact (https://github.com/tact-lang/tact/blob/main/tact-main/bin/test/fail.tact)
contract Fail {
    syntax_error
}


## success.config.json (https://github.com/tact-lang/tact/blob/main/tact-main/bin/test/success.config.json)
{
  "$schema": "../../schemas/configSchema.json",
  "projects": [
    {
      "name": "success",
      "path": "./success.tact",
      "output": "./success_output",
      "options": { "external": true },
      "mode": "full"
    }
  ]
}


## success.config.with.decompilation.json (https://github.com/tact-lang/tact/blob/main/tact-main/bin/test/success.config.with.decompilation.json)
{
  "$schema": "../../schemas/configSchema.json",
  "projects": [
    {
      "name": "success",
      "path": "./success.tact",
      "output": "./success_output",
      "options": { "external": true },
      "mode": "fullWithDecompilation"
    }
  ]
}


## success.tact (https://github.com/tact-lang/tact/blob/main/tact-main/bin/test/success.tact)
contract HelloWorld {

    get fun greeting(): String {
        return "hello world";
    }
    external("foobar") {}
}


## README.md (https://github.com/tact-lang/tact/blob/main/tact-main/docs/README.md)

<img src="public/banner.jpg">

# Welcome to ⚡ Tact Documentation

[![Built with Starlight](https://astro.badg.es/v2/built-with-starlight/tiny.svg)](https://starlight.astro.build)

Hello there! This is the source for the Tact language documentation.

Latest docs are always available at: [docs.tact-lang.org](https://docs.tact-lang.org).

Our goal here is to create a welcoming and rich resource that benefits all Tact developers, from beginners to experts.

## 🌟 Join the Tact community

Tact is not just a technology; it's a growing community of developers like you! Whether you are just starting out or have tons of experience, your contributions are valuable.

Here's how you can contribute:

- Organize or clarify information 📝
- Make Pull Requests to improve the code or docs 🚀
- Share tutorials, guides, and articles 📚

Join our community chat to stay updated and collaborate: [Tact Telegram community](https://t.me/tactlang)

## 🤔 How can you contribute?

Contributing is not just encouraged, it's easy!

If you've solved a challenging problem or found a better way to explain a complex topic, share it:

— Got an idea? [Open an issue](https://github.com/tact-lang/tact/issues/new).
— Ready to contribute? [Setup the dev environment](#setup-your-development-environment).

### ⚙️ Setup your development environment

Before you submit your amazing contributions, ensure they work seamlessly.

#### 🌩️ Quick cloud setup

Use Gitpod for a hassle-free cloud-based IDE experience:

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/tact-lang/tact-docs)

#### 🏠 Local setup

1. Clone this GitHub repository.
2. Make sure to have the latest version of [Node.js LTS](https://nodejs.org/en/download/) installed.
3. Open your terminal in the project directory.
4. Install dependencies without modifying the `yarn.lock`:

   ```
   yarn deps
   ```

5. Start your local development server:

   ```
   yarn dev
   ```

This will open a new browser window displaying your local version of the documentation. Most updates are automatically reflected.

### 🚀 Project Structure

Inside of this Astro + Starlight project, you'll see the following folders and files (besides others):

```
.
├── public/
├── src/
│   ├── assets/
│   ├── content/
│   │   ├── docs/     ← HERE ARE ALL THE TACT DOCUMENTATION PAGES
│   │   └── config.ts
│   └── env.d.ts
├── astro.config.mjs
├── package.json
└── tsconfig.json
└── cspell.json
```

Starlight looks for `.md` or `.mdx` files in the `src/content/docs/` directory. Each file is exposed as a route based on its file name. The Tact docs use `.mdx` files only.

Images can be added to `src/assets/` and embedded in MDX files with a relative link. Static assets, like favicons, can be placed in the `public/` directory.

It's recommended that local images are kept in `src/` whenever possible, so that Astro can transform, optimize and bundle them. Files in the `public/` directory are always served or copied into the build folder as-is, with no processing, and are publicly available by a direct link.

The local images stored in `src/` can be used by all files in the project: `.astro`, `.md`, `.mdx`, `.mdoc`, and other UI frameworks (if any). Images can be stored in any folder, including alongside your content.

### 🧞 Commands

All commands are run from the root of the project, from a terminal:

| Command                   | Action
| :------------------------ | :-----
| `yarn deps`               | Installs dependencies.
| `yarn dev`                | Starts local dev server at `localhost:4321`.
| `yarn build`              | Build your production site to `./dist/`. Runs CSpell and also validates all the internal links.
| `yarn preview`            | Preview your build locally, before deploying.
| `yarn astro ...`          | Run CLI commands like `astro add`, `astro check`, etc.
| `yarn astro -- --help`    | Get help using the Astro CLI.

### ⚠️ Gotchas

- When updating TextMate grammars in `grammars/` (for example, `grammar-tact.json`), make sure that the value for the `"name"` property is written all lowercase, otherwise highlighting will break.

### 👀 Want to learn more about the framework behind Tact docs?

Check out [Starlight’s docs](https://starlight.astro.build/), read [the Astro documentation](https://docs.astro.build), or jump into the [Astro Discord server](https://astro.build/chat).

## License 📄

[CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)


## cspell.json (https://github.com/tact-lang/tact/blob/main/tact-main/docs/cspell.json)
{
  "$schema": "https://raw.githubusercontent.com/streetsidesoftware/cspell/main/cspell.schema.json",
  "version": "0.2",
  "language": "en",
  "dictionaryDefinitions": [
    {
      "name": "fift-words",
      "path": "../cspell-fift-words-adjusted.txt"
    },
    {
      "name": "tvm-instructions",
      "path": "../cspell-tvm-instructions.txt"
    }
  ],
  "dictionaries": ["fift-words", "tvm-instructions"],
  "words": [
    "Brujin",
    "bocchi",
    "Cheatsheet",
    "Cheatsheets",
    "Comptime",
    "Compilables",
    "Daniil",
    "Decompilation",
    "Decompiled",
    "Descr",
    "Domínguez",
    "Epva",
    "Georgiy",
    "Héctor",
    "IPFS",
    "Jesús",
    "Jetton",
    "Jettons",
    "Komarov",
    "Korshakov",
    "Laika",
    "Masterchain",
    "Merkle",
    "Neovim",
    "Nonterminal",
    "Novus",
    "Offchain",
    "Offchain",
    "Parens",
    "RANDU",
    "STON.fi",
    "Satoshi",
    "Seamus",
    "Sedov",
    "Stateinit",
    "Ston",
    "Stonfi",
    "Sánchez",
    "TIMELOCK",
    "Tactina",
    "Tarjan",
    "Timeouted",
    "Toncoin",
    "Toncoins",
    "Topup",
    "Trunov",
    "Uninit",
    "alnum",
    "assgn",
    "astrojs",
    "augmentedassign",
    "babecafe",
    "basechain",
    "basechain",
    "bitcode",
    "bitstring",
    "bitstrings",
    "blockstore",
    "bounceable",
    "bounceable",
    "cheatsheet",
    "cheatsheets",
    "cleanall",
    "codegen",
    "comptime",
    "compilables",
    "decompilation",
    "decompilation",
    "decompile",
    "decompiler",
    "decompiles",
    "decompiles",
    "decompiling",
    "decompiling",
    "dentry",
    "disasm",
    "divmod",
    "dnsresolve",
    "dnsresolve",
    "elseifnot",
    "forall",
    "formedness",
    "funcfiftlib",
    "funcid",
    "funs",
    "gettest",
    "idict",
    "infixl",
    "infixr",
    "initof",
    "ipfs",
    "ipfs",
    "ipld",
    "jetton",
    "jettons",
    "jettons",
    "jojo",
    "jsxdev",
    "keccak",
    "knip",
    "langle",
    "logomark",
    "lparen",
    "lvalue",
    "lvalues",
    "masterchain",
    "mathrm",
    "maxint",
    "minmax",
    "mintable",
    "mktemp",
    "multiformats",
    "nanotons",
    "nanotons",
    "nextra",
    "nocheck",
    "noexcept",
    "nonterminal",
    "omelander",
    "pinst",
    "postpack",
    "prando",
    "quadtree",
    "quadtrees",
    "rangle",
    "rawslice",
    "renamer",
    "respecifying",
    "rparen",
    "rugpull",
    "rugpulled",
    "sctx",
    "seamus",
    "seqno",
    "seqno",
    "seti",
    "shardchains",
    "shiki",
    "stdlib",
    "stdlibs",
    "stmts",
    "struct",
    "structs",
    "subtyping",
    "testdata",
    "timeouted",
    "typechecker",
    "udict",
    "uintptr",
    "uncons",
    "uninit",
    "unixfs",
    "vogons",
    "workchain",
    "workchain",
    "workchains",
    "xffff",
    "xtwitter",
    "привет",
  ],
  "ignoreRegExpList": [
    "\\(#.*\\)",
    "^\\[.+\\]: .+",       // link declarations like [foo]: /ref/stdlib-ownable#bar
    "\\[.+\\]\\[.+\\]",    // links like [`Resumable{:tact}`][res]
    "\\[.+\\]\\(.+\\)",    // links like [`self.toCell().asSlice(){:tact}`](/ref/core-cells#cellasslice)
    "\\b(?:address|crc32|cell|slice|rawSlice)\\(\".+\"\\)", // Comptime functions
    "mathrm\\{.+\\}",      // LaTeX subset
    "\\[#.+\\]",           // [#nativereserve-combining-modes-with-flags]
    "\\{#.+\\}",           // {#some-other-custom-heading-link}
    "href=\".+\"",         // href="/cookbook/dexes/stonfi"
    "\".+\": \".+\"",      // "from": "kQBrSAP2y7QIUw4_1q0qciHfqdFmOYR9CC1oinn7kyWWRuoV"
    "Urls"
  ],
  "flagWords": [],
  "ignorePaths": [
    "*.boc",
    "*.fif",
    "*.func",
    "node_modules",
    "dist",
    "out",
    "src/content/docs/ref/spec.mdx",
    "src/content/docs/zh-cn"
  ]
}


## inline-code-highlighting.js (https://github.com/tact-lang/tact/blob/main/tact-main/docs/inline-code-highlighting.js)
// TODO: move this to a standalone new rehype plugin

/**
 * @import {Root} from 'hast'
 */

import { visit } from 'unist-util-visit';
import { toString } from 'hast-util-to-string';
import {
  bundledLanguages,
  createHighlighter,
  createWasmOnigEngine,
} from 'shiki';
import fs from 'node:fs';

// Import custom grammars
const grammar_tact = JSON.parse(fs.readFileSync(new URL('grammars/grammar-tact.json', import.meta.url), 'utf-8'));
const grammar_func = JSON.parse(fs.readFileSync(new URL('grammars/grammar-func.json', import.meta.url), 'utf-8'));
const grammar_ohm = JSON.parse(fs.readFileSync(new URL('grammars/grammar-ohm.json', import.meta.url), 'utf-8'));

/**
 * Highlight inline code tags with Shiki
 *
 * @returns Transform.
 */
export default function rehypeInlineCodeHighlighting() {
  /**
   * @param {Root} tree
   * @return {undefined}
   */
  return async function(tree) {
    /** @type {{node: import('hast').Element, lang: string, code: string}[]} */
    const nodesToProcess = [];

    visit(tree, 'element', function(node, _num, parent) {
      if (node.tagName === 'code'
        && node.children.length === 1
        && node.children[0].type === "text"
        && node.children[0].value.match(/\{:\s*[a-zA-Z0-9_\-]+\s*\}\s*$/) !== null
        && parent !== undefined
        && parent.tagName !== 'pre') {
        // Obtain the string value
        const value = toString(node);

        // Match-out the inner language string
        const lang = value.match(/\{:\s*([a-zA-Z0-9_\-]+)\s*\}\s*$/)[1];
        const code = value.match(/(.*?)\s*\{:\s*[a-zA-Z0-9_\-]+\s*\}\s*$/)[1];

        // Save them for future processing
        nodesToProcess.push({ node, lang, code });
      }
    });

    // Prepare Shiki
    const hl = await createHighlighter({
      themes: ['one-dark-pro', 'one-light'], // TODO: abstract away
      langs: [
        // ...Object.keys(bundledLanguages),
        bundledLanguages.javascript,
        bundledLanguages.typescript,
        bundledLanguages.json,
        bundledLanguages.markdown,
        bundledLanguages.bash,
        bundledLanguages.shell,
        bundledLanguages.bat,
        bundledLanguages.batch,
        bundledLanguages.powershell,
        grammar_tact,
        grammar_func,
        grammar_ohm,
      ],
      // TODO: Made the 'name' lowercase in the TextMate grammars
      langAlias: { fc: 'func' },
      engine: await createWasmOnigEngine(import('shiki/wasm')),
    });

    // Apply highlighting to each target node
    for (let i = 0; i < nodesToProcess.length; i += 1) {
      const res = hl.codeToHast(nodesToProcess[i].code.trim(), {
        lang: nodesToProcess[i].lang,
        theme: 'one-dark-pro', // TODO: move out
        // theme: 'one-light',
        structure: 'inline',
      });
      nodesToProcess[i].node.children = res.children;
      // console.log(nodesToProcess[i].node);
    }

    // TODO: hoist preparation elsewhere?
    hl.dispose();
  }
}


## links-to-web-ide.js (https://github.com/tact-lang/tact/blob/main/tact-main/docs/links-to-web-ide.js)
/**
 * @import {Root} from 'mdast'
 * @import {VFile} from 'vfile'
 */
import { visit } from 'unist-util-visit';

/**
 * Maximum allowed characters in a Chrome
 * Firefox has more limit but we are using less for compatibility
 */
const maxAllowedCharacters = 32779;

/**
 * Adds links to every code block, allowing to open its contents in the Web IDE
 *
 * @returns Transform.
 */
export default function remarkLinksToWebIDE() {
  /**
   * @param tree {Root}
   * @param file {VFile}
   * @return {undefined}
   */
  return function(tree, file) {
    // Specifying 'code' items guarantees non-inline code blocks
    visit(tree, 'code', function(node, index, parent) {
      // Only allow Tact code blocks
      if (node.lang !== 'tact') { return undefined; }

      // Only allow certain amount of characters
      let src = node.value.trim();
      if (src.length > maxAllowedCharacters) { return undefined; }

      // Disallow single-line code blocks as they pose very little value and they're often represent function signatures in the Reference section
      const lines = src.split('\n');
      if (lines.length <= 1) { return undefined; }

      // Only allow pages in the Cookbook
      // NOTE: This limitation can be lifted in the future if there's popular demand
      if (file.path.indexOf('docs/cookbook') === -1) { return undefined; }

      // Detect module-level items
      let hasModuleItems = false;
      for (let i = 0; i < lines.length; i += 1) {
        // Same regex as in scripts/check-cookbook-examples.js
        const matchRes = lines[i].match(/^\s*(?:import|primitive|const|asm|fun|extends|mutates|virtual|override|inline|abstract|@name|@interface|contract|trait|struct|message)\b/);
        // TODO: Unite the regexes when Tact 2.0 arrives (or if some new module-level item arrives, or via try/catch and re-using compiler's parser)

        if (matchRes !== null) {
          hasModuleItems = true;
          break;
        }
      }

      // Adjust the source code if the module-level items are NOT present
      if (!hasModuleItems) {
        src = [
          'fun fromTactDocs() {',
          lines.map(line => `    ${line}`).join('\n'),
          '}',
        ].join('\n');
      }

      // Encode to URL-friendly Base64
      const encoded = Buffer.from(src).toString('base64url');

      // Double-check the number of characters in the link
      const link = `https://ide.ton.org?lang=tact&code=${encoded}`;
      if (link.length > maxAllowedCharacters) { return undefined; }

      /** @type import('mdast').Html */
      const button = {
        type: 'html',
        value: [
          // Constructing opening <a> tag
          [
            // Open the tag
            '<a data-pagefind-ignore="all"',
            // Make links opened in new tab
            'target="_blank"',
            // Set styles
            'class="web-ide-link"',
            // Add hyperref with > to close the tag
            `href="${link}">`,
          ].join(' '),
          // The text to click on
          '<span class="web-ide-link-span">▶️ Open in Web IDE</span>',
          // Closing </a> tag
          '</a>',
        ].join(''),
      };

      // Place the button after the code block
      parent.children.splice(index + 1, 0, button);
    });
  }
}


## package.json (https://github.com/tact-lang/tact/blob/main/tact-main/docs/package.json)
{
  "name": "tact-docs",
  "license": "CC-BY-4.0",
  "private": "true",
  "type": "module",
  "scripts": {
    "clean": "rm -rf dist/ out/ .astro/",
    "deps": "yarn install --frozen-lockfile",
    "dev": "astro dev",
    "build": "yarn clean && yarn lint:all && astro check && astro build",
    "preview": "astro preview",
    "astro": "astro",
    "spell": "yarn cspell --no-progress src/content/docs",
    "lint:all": "yarn spell"
  },
  "dependencies": {
    "@astrojs/check": "0.9.4",
    "@astrojs/markdown-remark": "5.3.0",
    "@astrojs/starlight": "0.29.3",
    "astro": "4.16.18",
    "cspell": "^8.14.4",
    "hast-util-to-string": "^3.0.0",
    "rehype-autolink-headings": "7.1.0",
    "rehype-katex": "7.0.1",
    "remark": "^15.0.1",
    "remark-custom-heading-id": "2.0.0",
    "remark-math": "6.0.0",
    "sharp": "^0.32.5",
    "starlight-links-validator": "^0.12.1",
    "typescript": "^5.6.2",
    "unist-util-visit": "^5.0.0"
  },
  "packageManager": "yarn@1.22.22",
  "version": ""
}


## tsconfig.json (https://github.com/tact-lang/tact/blob/main/tact-main/docs/tsconfig.json)
{
  "extends": "astro/tsconfigs/strict"
}

## grammar-func.json (https://github.com/tact-lang/tact/blob/main/tact-main/docs/grammars/grammar-func.json)
{
	"$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
	"name": "func",
	"foldingStartMarker": "\\{\\s*$",
	"foldingStopMarker": "^\\s*\\}",
	"patterns": [
		{
			"include": "#keywords"
		},
		{
			"include": "#strings"
		},
		{
			"include": "#directives"
		},
		{
			"include": "#numeric"
		},
		{
			"include": "#comments"
		},
		{
			"include": "#storage"
		},
		{
			"include": "#functions"
		},
		{
			"include": "#variables"
		}
	],
	"repository": {
		"keywords": {
			"patterns": [
				{
					"name": "keyword.control.",
					"match": "\\b(if|ifnot|else|elseif|elseifnot|while|do|until|repeat|return|impure|method_id|forall|asm|inline|inline_ref)\\b"
				},
				{
					"name": "keyword.operator",
					"match": "(?<=\\s)(<=>|>=|<=|!=|==|\\^>>|\\~>>|>>|<<|\\/%|\\^%|\\~%|\\^\\/|\\~\\/|\\+=|-=|\\*=|\\/=|~\\/=|\\^\\/=|%=|\\^%=|<<=|>>=|~>>=|\\^>>=|&=|\\|=|\\^=|\\^|=|~|\\/|%|-|\\*|\\+|>|<|&|\\||:|\\?)(?=\\s)"
				},
				{
					"name": "keyword.other",
					"match": "\\b(false|true)\\b"
				}
			]
		},
		"directives": {
			"name": "storage.modifier.import",
			"begin": "#include|#pragma",
			"end": ";",
			"patterns": [
				{
					"begin": "\"",
					"end": "\"",
					"name": "string.quoted.double"
				},
				{
					"match": "(>=|<=|=|>|<|\\^)?([0-9]+)(.[0-9]+)?(.[0-9]+)?",
					"name": "constant.numeric"
				}
			]
		},
		"strings": {
			"name": "string.quoted.double.",
			"begin": "\"",
			"end": "\"(H|h|c|u|s|a)?"
		},
		"numeric": {
			"name": "constant.numeric",
			"match": "(-?([\\d]+|0x[\\da-fA-F]+))\\b"
		},
		"comments": {
			"patterns": [
				{
					"name": "comment.line",
					"match": ";;(.*)"
				},
				{
					"name": "comment.block",
					"begin": "{-",
					"end": "-}"
				}
			]
		},
		"storage": {
			"patterns": [
				{
					"name": "storage.type",
					"match": "\\b(var|int|slice|tuple|cell|builder|cont|_)(?=[\\s\\),\\[\\]])"
				},
				{
					"name": "storage.modifier",
					"match": "\\b(global|const)\\s"
				}
			]
		},
		"variables": {
			"patterns": [
				{
					"match": "(?!\")(`([^`]+)`|((?=_)_|(?={){|(?=})}|(?![_`{}]))([^;,\\[\\]\\(\\)\\s~.]+))",
					"name": "variable.name"
				}
			]
		},
		"functions": {
			"patterns": [
				{
					"match": "(?!\")(`([^`]+)`|(\\.|~)?((?=_)_|(?={){|(?=})}|(?![_`{}]))([^;,\\[\\]\\(\\)\\s~.]+))(?=[\\(])",
					"name": "entity.name.function"
				}
			]
		}
	},
	"scopeName": "source.func"
}


## grammar-ohm.json (https://github.com/tact-lang/tact/blob/main/tact-main/docs/grammars/grammar-ohm.json)
{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "ohm",
  "scopeName": "source.ohm",
  "fileTypes": [
    "ohm"
  ],
  "patterns": [
    {
      "include": "#comment"
    },
    {
      "include": "#grammar"
    }
  ],
  "repository": {
    "grammar": {
      "patterns": [
        {
          "include": "#baseGrammar"
        },
        {
          "include": "#derivedGrammar"
        }
      ]
    },
    "baseGrammar": {
      "begin": "^\\s*([a-zA-Z_]\\w*)\\s*({)",
      "beginCaptures": {
        "1": {
          "name": "entity.name.class"
        },
        "2": {
          "name": "punctuation.bracket"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#ruleName"
        },
        {
          "include": "#ruleBody"
        }
      ],
      "end": "}",
      "endCaptures": {
        "0": {
          "name": "punctuation.bracket"
        }
      }
    },
    "derivedGrammar": {
      "begin": "^\\s*([a-zA-Z_]\\w*)\\s+(<:)\\s+([a-zA-Z_]\\w*)\\s*({)",
      "beginCaptures": {
        "1": {
          "name": "entity.name.class"
        },
        "2": {
          "name": "keyword.operator"
        },
        "3": {
          "name": "entity.other.inherited-class"
        },
        "4": {
          "name": "punctuation.bracket"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#ruleName"
        },
        {
          "include": "#ruleBody"
        }
      ],
      "end": "}",
      "endCaptures": {
        "0": {
          "name": "punctuation.bracket"
        }
      }
    },
    "ruleName": {
      "begin": "^\\s*([a-zA-Z_]\\w*)",
      "beginCaptures": {
        "1": {
          "name": "entity.name.function"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#formals"
        },
        {
          "include": "#ruleDescr"
        }
      ],
      "end": "([:+]?=)",
      "endCaptures": {
        "1": {
          "name": "keyword.operator"
        }
      }
    },
    "formals": {
      "begin": "(<)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.bracket"
        }
      },
      "patterns": [
        {
          "name": "variable.parameter",
          "match": "[a-zA-Z_]\\w*"
        },
        {
          "name": "punctuation.delimiter",
          "match": ","
        }
      ],
      "end": "(>)",
      "endCaptures": {
        "1": {
          "name": "punctuation.bracket"
        }
      }
    },
    "ruleDescr": {
      "name": "comment.block.documentation",
      "begin": "(\\()",
      "beginCaptures": {
        "1": {
          "name": "punctuation.bracket"
        }
      },
      "end": "(\\))",
      "endCaptures": {
        "1": {
          "name": "punctuation.bracket"
        }
      }
    },
    "ruleBody": {
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#builtInRulesLexical"
        },
        {
          "include": "#builtInRulesSyntactic"
        },
        {
          "include": "#terminal"
        },
        {
          "include": "#operator"
        },
        {
          "include": "#punctuation"
        },
        {
          "include": "#caseName"
        }
      ]
    },
    "builtInRulesLexical": {
      "name": "support.function",
      "match": "\\b(?:any|alnum|end|digit|hexDigit|letter|space|lower|upper|caseInsensitive|listOf|nonemptyListOf|emptyListOf|applySyntactic)\\b"
    },
    "builtInRulesSyntactic": {
      "name": "support.function",
      "match": "\\b(?:ListOf|NonemptyListOf|EmptyListOf)\\b"
    },
    "terminal": {
      "name": "string.quoted.double",
      "begin": "\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin"
        }
      },
      "patterns": [
        {
          "name": "constant.character.escape",
          "match": "\\\\(?:x\\h{2}|u\\h{4}|u\\{\\h{1,6}\\}|t|r|n|b|'|\"|\\\\)"
        }
      ],
      "end": "(?:(?<!\\\\)|(?<=\\\\\\\\))\"",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end"
        }
      }
    },
    "operator": {
      "name": "keyword.operator",
      "match": "<:|=|:=|\\+=|\\*|\\+|\\?|~|&|#|\\.\\.|\\.\\.\\.|\\|"
    },
    "punctuation": {
      "patterns": [
        {
          "name": "punctuation.delimiter",
          "match": "<|>|,"
        },
        {
          "name": "punctuation.bracket",
          "match": "(|)"
        }
      ]
    },
    "caseName": {
      "match": "(--)\\s*([a-zA-Z_]\\w*)",
      "captures": {
        "1": {
          "name": "punctuation.delimiter"
        },
        "2": {
          "name": "entity.name.tag"
        }
      }
    },
    "comment": {
      "patterns": [
        {
          "include": "#lineComment"
        },
        {
          "include": "#blockComment"
        }
      ]
    },
    "lineComment": {
      "name": "comment.line",
      "begin": "//",
      "beginCaptures": {
        "0": {
          "name": "comment.line.double-slash"
        }
      },
      "patterns": [
        {
          "include": "#todoComment"
        }
      ],
      "end": "$"
    },
    "blockComment": {
      "name": "comment.block",
      "begin": "\\s*/\\*",
      "beginCaptures": {
        "0": {
          "name": "comment.block.begin"
        }
      },
      "patterns": [
        {
          "include": "#todoComment"
        }
      ],
      "end": "\\*/",
      "endCaptures": {
        "0": {
          "name": "comment.block.end"
        }
      }
    },
    "todoComment": {
      "name": "keyword.comment.todo",
      "match": "(?i)\\b(FIXME|TODO|CHANGED|XXX|IDEA|HACK|NOTE|REVIEW|NB|BUG)\\b"
    }
  }
}


## grammar-tact.json (https://github.com/tact-lang/tact/blob/main/tact-main/docs/grammars/grammar-tact.json)
{
  "name": "tact",
  "displayName": "Tact",
  "scopeName": "source.tact",
  "fileTypes": [
    "tact"
  ],
  "foldingStartMarker": "\\{\\s*$",
  "foldingStopMarker": "^\\s*\\}",
  "patterns": [
    {
      "include": "#comment"
    },
    {
      "include": "#annotation"
    },
    {
      "include": "#literal"
    },
    {
      "include": "#invalid"
    },
    {
      "include": "#constant"
    },
    {
      "include": "#type"
    },
    {
      "include": "#expression"
    },
    {
      "include": "#punctuation"
    },
    {
      "include": "#keyword"
    },
    {
      "include": "#function"
    },
    {
      "include": "#variable"
    }
  ],
  "repository": {
    "comment": {
      "patterns": [
        {
          "name": "comment.line.double-slash.tact",
          "begin": "//",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.comment.line.double-slash.tact"
            }
          },
          "patterns": [
            {
              "include": "#todo"
            }
          ],
          "end": "$"
        },
        {
          "name": "comment.block.tact",
          "begin": "\\s*/\\*",
          "beginCaptures": {
            "0": {
              "name": "comment.block.begin.tact punctuation.definition.comment.begin.tact"
            }
          },
          "patterns": [
            {
              "include": "#todo"
            }
          ],
          "end": "\\*/",
          "endCaptures": {
            "0": {
              "name": "comment.block.end.tact punctuation.definition.comment.end.tact"
            }
          }
        }
      ]
    },

    "todo": {
      "match": "(?i)\\b(FIXME|TODO|CHANGED|XXX|IDEA|HACK|NOTE|REVIEW|NB|BUG)\\b(?-i)",
      "name": "keyword.comment.todo.tact"
    },

    "annotation": {
      "patterns": [
        {
          "comment": "@name() in native functions",
          "begin": "^\\s*(@name)\\s*(\\()",
          "beginCaptures": {
            "1": {
              "name": "entity.other.attribute-name.tact"
            },
            "2": {
              "name": "punctuation.brackets.round.tact"
            }
          },
          "patterns": [
            {
              "comment": "FunC identifier",
              "match": "(.*?)",
              "name": "entity.name.function.func.tact"
            }
          ],
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.brackets.round.tact"
            }
          }
        },
        {
          "comment": "One or more @inteface() before traits and contracts",
          "begin": "(?<!\\.)(@interface)\\s*(\\()",
          "beginCaptures": {
            "1": {
              "name": "entity.other.attribute-name.tact"
            },
            "2": {
              "name": "punctuation.brackets.round.tact"
            }
          },
          "patterns": [
            {
              "include": "#string"
            }
          ],
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.brackets.round.tact"
            }
          }
        },
        {
          "comment": "Asm arrangements",
          "begin": "(?<!\\.)(asm)\\s*(\\()",
          "beginCaptures": {
            "1": {
              "name": "entity.other.attribute-name.tact"
            },
            "2": {
              "name": "punctuation.brackets.round.tact"
            }
          },
          "patterns": [
            {
              "include": "#variable"
            },
            {
              "match": "->",
              "name": "keyword.operator.mapsto.tact"
            },
            {
              "comment": "Decimal integer WITH leading zero",
              "match": "\\b(0[0-9]*)\\b",
              "name": "constant.numeric.decimal.tact"
            },
            {
              "comment": "Decimal integer WITHOUT leading zero",
              "match": "\\b([1-9](?:_?[0-9])*)\\b",
              "name": "constant.numeric.decimal.tact"
            }
          ],
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.brackets.round.tact"
            }
          }
        },
        {
          "comment": "Fallback match",
          "match": "(?<!\\.)\\b(@name|@interface|asm)\\b",
          "name": "entity.other.attribute-name.tact"
        }
      ]
    },

    "literal": {
      "patterns": [
        {
          "comment": "Hexadecimal integer",
          "match": "\\b(0[xX][a-fA-F0-9](?:_?[a-fA-F0-9])*)\\b",
          "name": "constant.numeric.hex.tact"
        },
        {
          "comment": "Octal integer",
          "match": "\\b(0[oO][0-7](?:_?[0-7])*)\\b",
          "name": "constant.numeric.oct.tact"
        },
        {
          "comment": "Binary integer",
          "match": "\\b(0[bB][01](?:_?[01])*)\\b",
          "name": "constant.numeric.bin.tact"
        },
        {
          "comment": "Decimal integer WITH leading zero",
          "match": "\\b(0[0-9]*)\\b",
          "name": "constant.numeric.decimal.tact"
        },
        {
          "comment": "Decimal integer WITHOUT leading zero",
          "match": "\\b([1-9](?:_?[0-9])*)\\b",
          "name": "constant.numeric.decimal.tact"
        },
        {
          "comment": "Boolean literal",
          "match": "(?<!\\.)\\b(true|false)\\b",
          "name": "constant.language.bool.tact"
        },
        {
          "include": "#string"
        },
        {
          "comment": "self",
          "match": "(?<!\\.)\\b(self)\\b",
          "name": "variable.language.this.tact"
        }
      ]
    },

    "string": {
      "comment": "String literal",
      "begin": "\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.tact"
        }
      },
      "name": "string.quoted.double.tact",
      "patterns": [
        {
          "include": "#escape-sequence"
        }
      ],
      "end": "\"",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.tact"
        }
      }
    },

    "escape-sequence": {
      "comment": "Allowed escape sequences in strings",
      "match": "(?:\\\\)(?:(\\\\)|(\")|([nrtvbf])|(x[a-fA-F0-9]{2})|(u[a-fA-F0-9]{4})|(u\\{[a-fA-F0-9]{1,6}\\}))",
        "name": "constant.character.escape.tact",
        "captures": {
          "1": {
            "name": "constant.character.escape.backslash.tact"
          },
          "2": {
            "name": "constant.character.escape.double-quote.tact"
          },
          "3": {
            "name": "constant.character.escape.special.tact"
          },
          "4": {
            "name": "constant.character.escape.hex.tact"
          },
          "5": {
            "name": "constant.character.escape.unicode.tact"
          },
          "6": {
            "name": "constant.character.escape.unicodepoint.tact"
          }
        }
      },

      "invalid": {
        "patterns": [
          {
            "comment": "Anything starting with __gen or __tact",
            "match": "\\b__(?:gen|tact)[a-zA-Z0-9_]*\\b",
            "name": "invalid.illegal.identifier.tact"
          }
        ]
      },

      "constant": {
        "patterns": [
          {
            "comment": "self.storageReserve",
            "match": "(?<=self\\.)(storageReserve)\\b",
            "name": "constant.other.builtin.tact"
          },
          {
            "comment": "Other constants from the core library",
            "match": "(?<!\\.)\\b(SendDefaultMode|SendRemainingValue|SendRemainingBalance|SendPayGasSeparately|SendIgnoreErrors|SendBounceIfActionFail|SendDestroyIfZero|SendOnlyEstimateFee|ReserveExact|ReserveAllExcept|ReserveAtMost|ReserveAddOriginalBalance|ReserveInvertSign|ReserveBounceIfActionFail)\\b",
            "name": "constant.other.builtin.tact"
          },
          {
            "comment": "ALL CAPS constants",
            "match": "\\b([A-Z]{2}[A-Z0-9_]*)\\b",
            "name": "constant.other.caps.tact"
          },
          {
            "comment": "Constant declaration or definition",
            "match": "(?<!\\.)\\b(const)\\s+([a-zA-Z_][A-Za-z0-9_]*)\\b",
            "captures": {
              "1": {
                "name": "keyword.other.tact"
              },
              "2": {
                "name": "constant.other.declaration.tact"
              }
            }
          },
          {
            "comment": "null",
            "match": "(?<!\\.)\\b(null)\\b",
            "name": "constant.language.null.tact"
          }
        ]
      },

      "type": {
        "patterns": [
          {
            "include": "#simple-type"
          },
          {
            "comment": "bounced<T>",
            "begin": "(?<!\\.)\\b(bounced)\\s*(<)",
            "beginCaptures": {
              "1": {
                "name": "entity.name.type.tact"
              },
              "2": {
                "name": "punctuation.brackets.angle.tact"
              }
            },
            "patterns": [
              {
                "include": "#simple-type"
              }
            ],
            "end": ">",
            "endCaptures": {
              "0": {
                "name": "punctuation.brackets.angle.tact"
              }
            }
          },
          {
            "comment": "map<K, V>",
            "begin": "(?<!\\.)\\b(map)\\s*(<)",
            "beginCaptures": {
              "1": {
                "name": "entity.name.type.tact"
              },
              "2": {
                "name": "punctuation.brackets.angle.tact"
              }
            },
            "patterns": [
              {
                "include": "#simple-type"
              },
              {
                "match": ",",
                "name": "punctuation.comma.tact"
              },
              {
                "include": "#as-tlb"
              }
            ],
            "end": ">",
            "endCaptures": {
              "0": {
                "name": "punctuation.brackets.angle.tact"
              }
            }
          },
          {
            "include": "#as-tlb"
          }
        ]
      },

      "simple-type": {
        "comment": "Simple types",
        "match": "(?<!\\.)\\b([A-Z][a-zA-Z0-9_]*)(\\??)",
        "captures": {
          "1": {
            "name": "entity.name.type.tact"
          },
          "2": {
            "name": "keyword.operator.optional.tact"
          }
        }
      },

      "as-tlb": {
        "comment": "Serialization",
        "patterns": [
          {
            "match": "(?<!\\.)\\b(as)\\s+(coins|remaining|bytes32|bytes64|int257|u?int(?:2[0-5][0-6]|1[0-9][0-9]|[1-9][0-9]?))\\b",
            "captures": {
              "1": {
                "name": "keyword.other.as.tact storage.modifier.tact"
              },
              "2": {
                "name": "entity.name.type.tact"
              }
            }
          }
        ]
      },

      "expression": {
        "patterns": [
          {
            "comment": "Logical operators",
            "match": "(\\|\\||&&|!!?)(?!=)",
            "name": "keyword.operator.logical.tact"
          },
          {
            "comment": "Bitwise operators",
            "match": "(\\^|&|\\||~|<<|>>)(?!=)",
            "name": "keyword.operator.bitwise.tact"
          },
          {
            "comment": "Augmented assignment operators",
            "match": "(\\+=|-=|\\*=|/=|%=|\\^=|&=|\\|=|<<=|>>=)",
            "name": "keyword.operator.assignment.tact"
          },
          {
            "comment": "Assignment operator",
            "match": "(?<![<>])=(?!=)",
            "name": "keyword.operator.assignment.equal.tact"
          },
          {
            "comment": "Comparison operators",
            "match": "([!=]=|<=?|>=?)",
            "name": "keyword.operator.comparison.tact"
          },
          {
            "comment": "Arithmetic operators",
            "match": "([+%*\\-])|(/(?!/))",
            "name": "keyword.operator.arithmetic.tact"
          },
          {
            "comment": "initOf expression",
            "match": "\\b(initOf)\\b",
            "name": "keyword.operator.new.tact"
          },
          {
            "comment": "Ternary expression",
            "begin": "(?!\\?\\.\\s*[^[:digit:]])(\\?)(?!\\?)",
            "beginCaptures": {
              "1": {
                "name": "keyword.operator.ternary.tact"
              }
            },
            "patterns": [
              {
                "include": "$self"
              }
            ],
            "end": "\\s*(:)",
            "endCaptures": {
              "1": {
                "name": "keyword.operator.ternary.tact"
              }
            }
          }
        ]
      },

      "punctuation": {
        "patterns": [
          {
            "match": ",",
            "name": "punctuation.comma.tact"
          },
          {
            "match": "[{}]",
            "name": "punctuation.brackets.curly.tact"
          },
          {
            "match": "[()]",
            "name": "punctuation.brackets.round.tact"
          },
          {
            "match": ";",
            "name": "punctuation.semi.tact"
          },
          {
            "match": ":",
            "name": "punctuation.colon.tact"
          },
          {
            "match": "\\.",
            "name": "punctuation.dot.tact"
          }
        ]
      },

      "keyword": {
        "patterns": [
          {
            "match": "(?<!\\.)\\b(import)\\b",
            "name": "keyword.control.import.tact"
          },
          {
            "comment": "Control flow keywords, prefixed by more than one dot",
            "match": "(?<=\\.\\.)\\b(else|catch|until|in(?!\\s*\\())\\b",
            "name": "keyword.control.tact"
          },
          {
            "comment": "Control flow keywords",
            "match": "(?<!\\.)\\b(if|else|try|catch|repeat|do|until|while|foreach|in(?!\\s*\\()|return)\\b",
            "name": "keyword.control.tact"
          },
          {
            "comment": "let and const",
            "match": "(?<!\\.)\\b(let|const)\\b",
            "name": "keyword.other.tact"
          },
          {
            "comment": "Serialization",
            "match": "(?<!\\.)\\b(as)\\b",
            "name": "keyword.other.as.tact storage.modifier.tact"
          },
          {
            "match": "(?<!\\.)\\b(struct)\\b",
            "name": "keyword.other.struct.tact"
          },
          {
            "match": "(?<!\\.)\\b(message)\\b",
            "name": "keyword.other.message.tact"
          },
          {
            "match": "(?<!\\.)\\b(trait)\\b",
            "name": "keyword.other.trait.tact"
          },
          {
            "match": "(?<!\\.)\\b(contract)\\b",
            "name": "keyword.other.contract.tact"
          },
          {
            "comment": "Constant and function attributes",
            "match": "(?<!\\.)\\b(abstract|virtual|override)\\b",
            "name": "keyword.other.attribute.tact storage.modifier.tact"
          },
          {
            "comment": "Function attributes",
            "match": "(?<!\\.)\\b(extends|get|inline|mutates)\\b",
            "name": "keyword.other.attribute.tact"
          },
          {
            "comment": "Function declaration/definition keywords",
            "match": "(?<!\\.)\\b(fun|native)\\b",
            "name": "keyword.other.function.tact"
          },
          {
            "comment": "Special functions",
            "match": "(?<!\\.)\\b(init|receive|bounced|external)(?=\\s*\\()",
            "name": "keyword.other.function.tact"
          },
          {
            "comment": "Reserved keywords",
            "match": "(?<!\\.)\\b(extend|public)\\b",
            "name": "keyword.other.reserved.tact"
          },
          {
            "comment": "Other keywords",
            "match": "(?<!\\.)\\b(primitive|with)\\b",
            "name": "keyword.other.tact"
          }
        ]
      },

      "function": {
        "comment": "Function declaration, definition or call",
        "match": "\\b((?:[a-zA-Z_][a-zA-Z0-9_]*))\\s*(\\()",
        "captures": {
          "1": {
            "name": "entity.name.function.tact"
          },
          "2": {
            "name": "punctuation.brackets.round.tact"
          }
        }
      },

      "variable": {
        "patterns": [
          {
            "comment": "Any valid Tact identifier",
            "match": "(?<!\\.)\\b(_)\\b",
            "name": "comment.unused-identifier.tact"
          },
          {
            "comment": "Any valid Tact identifier",
            "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)\\b",
            "name": "variable.other.tact"
          }
        ]
      }
    }
  }


## check-cookbook-examples.js (https://github.com/tact-lang/tact/blob/main/tact-main/docs/scripts/check-cookbook-examples.js)
/*─────────────────────────────────────────────────────────────────────────────╗
│                                IMPORTANT:                                    │
│  Run this script from the root of the docs, not from the scripts directory!  │
╞══════════════════════════════════════════════════════════════════════════════╡
│  The script:                                                                 │
│  1. Goes over every file in Cookbook                                         │
│  2. Extracts the Tact code blocks from them                                  │
│  3. For every code block, it runs the latest publicly available version      │
│     of the Tact compiler, performing the syntax and type checking (--check)  │
│  4. If there are any errors, outputs them and exits                          │
│                                                                              │
│  Checks take ~0.5 seconds per code block, so lets use it for Cookbook only   │
╚─────────────────────────────────────────────────────────────────────────────*/

import { spawnSync } from 'node:child_process';
import { tmpdir } from 'node:os';
import {
  mkdtempSync,
  readFileSync,
  readdirSync,
  statSync,
  writeFileSync,
  existsSync,
} from 'node:fs';
import { chdir, cwd } from 'node:process';
// TODO(?): check the proper dir (from git) and automatically change the working dir

/*******************/
/* Utility helpers */
/*******************/

/** Default directory for temporary files with / separator (because even PowerShell can use direct slash) */
const globalTmpDir = tmpdir() + '/';

/**
 * Obtains the list of files with target extension in the target directory and its
 * sub-directories as a flat array of names.
 *
 * @param dir {string | undefined} defaults to "." (current directory)
 * @param extension {string | undefined} defaults to any file
 * @returns {string[]}
 */
const getFileNames = (dir, extension) => {
  /**
   * @param dir {string | undefined}
   * @param extension {string | undefined}
   * @returns {string[]}
   */
  const recGetFileNames = (dir, extension, _files) => {
    _files = _files || [];
    let files = readdirSync(dir);
    for (let i in files) {
      let name = dir + '/' + files[i];
      if (statSync(name).isDirectory()) {
        recGetFileNames(name, extension, _files);
        continue;
      }
      if (extension === undefined || name.endsWith(extension)) {
        _files.push(name.trim());
      }
    }
    return _files;
  };

  return recGetFileNames(dir ?? ".", extension);
};

/**
 * @param src {string} source of the .md or .mdx file to extract code blocks from
 * @returns {string[]} all Tact code blocks on the page ready to be processed
 */
const extractTactCodeBlocks = (src) => {
  /** @type RegExpExecArray[] */
  const regexMatches = [...src.matchAll(/```(\w*).*?\n([\s\S]*?)```/gm)];
  /** @type string[] */
  let res = [];

  for (let i = 0; i < regexMatches.length; i += 1) {
    // Skip non-Tact matches
    if (regexMatches[i].at(1)?.trim() !== "tact") {
      continue;
    }

    // Guard the contents
    let code = regexMatches[i].at(2)?.trim();
    if (code === undefined || code.length === 0) {
      console.log(`Error: regex failed when processing code blocks of:\n\n${src}`);
      process.exit(1);
    }

    // See if the `code` needs additional wrapping in a global function or not
    // i.e. if it doesn't contain any module-level items (implicit convention in Tact docs):
    const moduleItems = code.split('\n').filter((line) => {
      const matchRes = line.match(/^\s*(?:import|primitive|const|asm|fun|extends|mutates|virtual|override|inline|abstract|@name|@interface|contract|trait|struct|message)\b/);

      if (matchRes === null) { return false; }
      else { return true; }
    });

    if (moduleItems.length === 0) {
      code = `fun _() {\n${code}\n}`;
    }

    // Save the code
    res.push(code);
  }

  return res;
};

/**
 * @requires Node.js 22+ with npm installed
 * @param filepath {string} a path to Tact file
 * @returns {{ ok: true } | { ok: false, error: string }}
 */
const checkTactFile = (filepath) => {
  // Using the latest publicly available compiler to ensure that current users
  // can compile and run the code, not just the compiler developers
  const res = spawnSync('npx',
    ['-y', '@tact-lang/compiler@latest', '--check', filepath],
    { encoding: 'utf8' }
  );

  if (res.status !== 0) {
    return {
      ok: false,
      error: res.stdout + res.stderr,
    }
  }

  return { ok: true };
};

/**********/
/* Script */
/**********/

/** @type string */
const cookbookPath = "src/content/docs/cookbook";

if (!existsSync(cookbookPath)) {
  console.log(`Error: path ${cookbookPath} doesn't exist, ensure that you're in the right directory!`);
  process.exit(1);
}

/** @type string[] */
const mdxFileNames = getFileNames(cookbookPath, ".mdx");

for (let i = 0; i < mdxFileNames.length; i += 1) {
  const file = readFileSync(mdxFileNames[i], { encoding: 'utf8' });
  const codeBlocks = extractTactCodeBlocks(file);
  const tmpDirForCurrentPage = mkdtempSync(globalTmpDir);
  const pageName = mdxFileNames[i].slice(
    mdxFileNames[i].lastIndexOf('/') + 1,
    mdxFileNames[i].lastIndexOf('.mdx'),
  );

  for (let j = 0; j < codeBlocks.length; j += 1) {
    const tactFile = `${tmpDirForCurrentPage}/${pageName}-block-${(j + 1).toString()}.tact`;
    writeFileSync(tactFile, codeBlocks[j], { encoding: 'utf8', mode: '644' });
    console.log(`Checking ${tactFile}`);

    // TODO(?): Alternative solution would be to prepare a tact.config.json on the fly
    const savedCwd = cwd();
    chdir(tmpDirForCurrentPage);

    // Perform individual checks (see TODO above)
    const checkRes = checkTactFile(tactFile);
    chdir(savedCwd);
    
    if (checkRes.ok === false) {
      console.log(`Error: check of ${tactFile} has failed:\n\n${checkRes.error}`);
      process.exit(1);
    }
  }
}


## env.d.ts (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/env.d.ts)
/// <reference path="../.astro/types.d.ts" />
/// <reference types="astro/client" />


## config.ts (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/config.ts)
import { defineCollection } from 'astro:content';
import { docsSchema } from '@astrojs/starlight/schema';

export const collections = {
	docs: defineCollection({ schema: docsSchema() }),
	// 'dev-docs': defineCollection({ schema: docsSchema() }),
};


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/index.mdx)
---
title: Learn all about programming in ⚡ Tact
description: Tact is a new programming language for TON Blockchain that is focused on efficiency and simplicity. It is designed to be easy to learn and use, and to be a good fit for smart contracts.
template: splash
hero:
  tagline: Tact is a new programming language for TON Blockchain that is focused on efficiency and simplicity. It is designed to be easy to learn and use, and to be a good fit for smart contracts. Tact is a statically typed language with a simple syntax and a powerful type system.
  image:
    dark: /public/logomark-dark.svg
    light: /public/logomark-light.svg
    alt: Tact logo
  actions:
    - text: 📚 Book
      link: /book
      variant: minimal
      icon: right-arrow

    - text: 🍲 Cookbook
      link: /cookbook
      variant: minimal
      icon: right-arrow

    - text: 🔬 Reference
      link: /ref
      variant: minimal
      icon: right-arrow

    - text: 🗺️ Ecosystem
      link: /ecosystem
      variant: minimal
      icon: right-arrow
---

import { LinkCard, CardGrid, Tabs, TabItem, Steps } from '@astrojs/starlight/components';

## 🚀 Let's start! {#start}

<p>ㅤ</p>

<Steps>

1. #### Ensure that the supported version of Node.js is installed and available {#start-1}

	 To check it, run `node --version{:shell}` — it should show you the version 22.0.0 or later.

2. #### Run the following command {#start-2}

   It will create a new project with the simple counter contract:

   <Tabs>
     <TabItem label="yarn" icon="seti:yarn">
       ```shell
       # recommended
       yarn create ton simple-counter --type tact-counter --contractName SimpleCounter
       ```
     </TabItem>
     <TabItem label="npm" icon="seti:npm">
       ```shell
       npm create ton@latest -- simple-counter --type tact-counter --contractName SimpleCounter
       ```
     </TabItem>
     <TabItem label="pnpm" icon="pnpm">
       ```shell
       pnpm create ton@latest simple-counter --type tact-counter --contractName SimpleCounter
       ```
     </TabItem>
     <TabItem label="bun" icon="bun">
       ```shell
       bun create ton@latest simple-counter --type tact-counter --contractName SimpleCounter
       ```
     </TabItem>
   </Tabs>

3. #### That's it! {#start-3}

   Your first contract project is written and compiled already!

   Go check it out by moving into the relevant directory — `cd simple-counter/contracts{:shell}`. Here's how it would look like:

	 ```tact
	 import "@stdlib/deploy";

	 message Add {
	     queryId: Int as uint64;
	     amount: Int as uint32;
	 }

	 contract SimpleCounter with Deployable {
	     id: Int as uint32;
	     counter: Int as uint32;

	     init(id: Int) {
	         self.id = id;
	         self.counter = 0;
	     }

	     receive(msg: Add) {
	         self.counter += msg.amount;

	         // Notify the caller that the receiver was executed and forward remaining value back
	         self.notify("Cashback".asComment());
	     }

	     get fun counter(): Int {
	         return self.counter;
	     }

	     get fun id(): Int {
	         return self.id;
	     }
	 }
	 ```

   To re-compile or deploy, refer to the commands in the scripts section of `package.json` in the root of this newly created project and to the documentation of [Blueprint](https://github.com/ton-org/blueprint) — this is the tool we've used to create and compile your first simple counter contract in Tact. In fact, Blueprint can do much more than that: including tests, customizations and more.

</Steps>

## 🤔 Where to go next? {#next}

<p>ㅤ</p>

<Steps>

1. #### Have some blockchain knowledge already? {#next-1}

   See the [Tact Cookbook](/cookbook), which is a handy collection of everyday tasks (and solutions) every Tact developer faces during smart contract development. Use it to avoid re-inventing the wheel.

   Alternatively, check the following cheat sheets to quickly get started:

   <CardGrid>
     <LinkCard
       title="💎 Coming from FunC (TON)"
       href="/book/cs/from-func"
     />
     <LinkCard
       title="🔷 Coming from Solidity (Ethereum)"
       href="/book/cs/from-solidity"
     />
   </CardGrid>

2. #### Want to know more? {#next-2}

   For further guidance on compilation, testing and deployment see the respective pages:

   * [Testing and debugging](/book/debug) page tells you everything about debugging Tact contracts
   * [Deployment](/book/deploy) page shows what deployment looks like and helps you harness the powers of [Blueprint](https://github.com/ton-org/blueprint) for it.

   For custom plugins for your favorite editor and other tooling see the [Ecosystem](/ecosystem) section.

   Alternatively, take a look at the following broader sections:

   * [Book](/book) helps you learn the language step-by-step
   * [Cookbook](/cookbook) gives you ready-made recipes of Tact code
   * [Reference](/ref) provides a complete glossary of the standard library, grammar and evolution process
   * Finally, [Ecosystem](/ecosystem) describes "what's out there" in the Tact's and TON's ecosystems

   <CardGrid>
     <LinkCard
       title="📚 Read the Book of Tact"
       href="/book"
     />
     <LinkCard
       title="🍲 Grind the Cookbook"
       href="/cookbook"
     />
     <LinkCard
       title="🔬 Skim the Reference"
       href="/ref"
     />
     <LinkCard
       title="🗺️ Embrace the Ecosystem"
       href="/ecosystem"
     />
   </CardGrid>

3. #### Feeling a bit uncomfortable? {#next-3}

   If you ever get stuck, try searching — the search box is right at the top of the documentation. There is also a handy <kbd>Ctrl</kbd> + <kbd>K</kbd> shortcut to quickly focus and start the search as you type.

   If you can't find the answer in the docs, or you've tried to do some local testing and it still didn't help — don't hesitate to reach out to Tact's flourishing community:

   <CardGrid>
     <LinkCard
       title="✈️ Telegram Group"
       href="https://t.me/tactlang"
     />
     <LinkCard
       title="🐦 X/Twitter"
       href="https://twitter.com/tact_language"
     />
   </CardGrid>

   Good luck on your coding adventure with ⚡ Tact!

</Steps>


## assembly-functions.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/assembly-functions.mdx)
---
title: Assembly functions
description: "Advanced module-level functions that allow writing TVM instructions directly in the Tact assembly"
---

import { Badge } from '@astrojs/starlight/components';

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

:::caution

  These are very advanced functions that require experience and vigilance in both definitions and usage. The logical errors in them are extremely hard to spot, the error messages are abysmal, and type checking isn't currently provided by Tact.

  That said, if you know what you're doing, they can offer you the smallest possible gas usage, the best performance and the most control over [TVM][tvm] execution. Remember — with great power comes great responsibility.

:::

Assembly functions (or asm functions for short) are module-level functions that allow you to write Tact assembly. Unlike all other functions, their bodies consist only of [TVM instructions](#tvm) and some other primitives, and don't use any Tact [statements](/book/statements) or [expressions](/book/expressions).

```tact
// all assembly functions must start with "asm" keyword
// ↓
   asm fun answer(): Int { 42 INT }
//                         ------
//                         Notice, that the body contains only of
//                         TVM instructions and some primitives,
//                         like numbers or bitstrings, which serve
//                         as arguments to the instructions
```

## TVM instructions {#tvm}

In Tact, the term _TVM instruction_ refers to the command that is executed by the [TVM][tvm] during its run-time — the [compute phase](https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase). Where possible, Tact will try to optimize their use for you, but it won't define new ones or introduce extraneous syntax for their [pre-processing](https://docs.ton.org/v3/documentation/smart-contracts/fift/fift-and-tvm-assembly). Instead, it is recommended to combine the best of Tact and TVM instructions, as shown in the [`onchainSha256(){:tact}` example](#onchainsha256) near the end of this page.

Each [TVM instruction][tvm-instructions], when converted to its binary representation, is an opcode (operation code) to be executed by the [TVM][tvm] plus some optional arguments to it written immediately after. However, when writing instructions in `asm{:tact}` functions, the arguments, if any, are written before the instruction and are separated by spaces. This [reverse Polish notation (RPN)](https://en.wikipedia.org/wiki/Reverse_Polish_notation) syntax is intended to show the stack-based nature of [TVM][tvm].

For example, the [`DROP2`](https://docs.ton.org/v3/documentation/tvm/instructions#5B) or its alias [`2DROP`](https://docs.ton.org/v3/documentation/tvm/instructions#5B), which drop (discard) two top values from the stack, have the same opcode prefix — `0x5B`, or `1011011` in binary.

```tact
/// Pushes `a` and `b` onto the stack, then immediately drops them from it
asm fun discardTwo(a: Int, b: Int) { DROP2 }
```

The arguments to [TVM instructions][tvm-instructions] in Tact are called primitives — they don't manipulate the stack themselves and aren't pushed on it by themselves. Attempting to specify a primitive without the instruction that immediately consumes it will result in compilation errors.

```tact
/// COMPILATION ERROR!
/// The 43 were meant to be an argument to some subsequent TVM instruction
/// but there weren't found any
asm fun bad(): Int { 43 }
```

For some instructions, the resulting opcode depends on the specified primitive. For example, the [`PUSHINT`](https://docs.ton.org/v3/documentation/tvm/instructions#7i), or its shorter alias [`INT`](https://docs.ton.org/v3/documentation/tvm/instructions#7i), have the same opcode `0x7` if the specified number argument is in the inclusive range from $-5$ to $10$. However, if the number is greater than that, the opcode changes accordingly: [`0x80`](https://docs.ton.org/v3/documentation/tvm/instructions#80xx) for arguments in the inclusive range from $-128$ to $127$, [`0x81`](https://docs.ton.org/v3/documentation/tvm/instructions#81xxxx) for arguments in the inclusive range from $-2^{15}$ to $2^{15}$, and so on. For your convenience, all these variations of opcodes are described using the same instruction name, in this case `PUSHINT`.

```tact
asm fun push42(): Int {
    // The following will be converted to 0x80 followed by 0x2A
    // in their binary representation for execution by the TVM
    42 PUSHINT
}
```

:::note[Useful links:]

  [List of TVM instructions in TON Docs][tvm-instructions]

:::

## Stack calling conventions {#conventions}

The syntax for parameters and returns is the same as for other function kinds, but there is one caveat — argument values are pushed to the stack before the function body is executed, and return type is what's captured from the stack afterward.

### Parameters {#conventions-parameters}

The first parameter is pushed to the stack first, the second one second, and so on, so that the first parameter is at the bottom of the stack and the last one at the top.

```tact
asm extends fun storeCoins(self: Builder, value: Int): Builder {
    //                     ↑              ↑
    //                     |              Pushed last, sits on top of the stack
    //                     Pushed first, sits on the bottom of the stack

    // Stores the value of type `Int as coins` into the Builder,
    // taking the Builder from the bottom of the stack
    // and Int from the top of the stack,
    // producing a new Builder back
    STVARUINT16
}
```

Since the bodies of `asm{:tact}` functions do not contain Tact statements, any direct references to parameters in function bodies will be recognized as [TVM][tvm] instructions, which can easily lead to very obscure error messages.

```tact
/// Simply returns back the value of `x`
asm fun identity(x: Int): Int { }

/// COMPILATION ERROR!
/// The `BOC` is not recognized as a parameter,
/// but instead is interpreted as a non-existent TVM instruction
asm fun bocchiThe(BOC: Cell): Cell { BOC }
```

The parameters of arbitrary [Struct][struct] types are distributed over their fields, recursively flattened as the arguments are pushed onto the stack. In particular, the value of the first field of the [Struct][struct] is pushed first, the second is pushed second, and so on, so that the value of the first field is at the bottom of the stack and the value of the last is at the top. If there are nested structures inside those [Structs][struct], they're flattened in the same manner.

:::note

  This behavior of [Structs][struct] is experimental and may change in future releases of Tact. When in doubt, prefer specifying multiple parameters over a single [Struct][struct] with many fields.

:::

```tact
// Struct with two fields of type Int
struct AB { a: Int; b: Int }

// This will produce the sum of two fields in the `AB` Struct
asm fun sum(two: AB): Int { ADD }

// Struct with two nested `AB` structs as its fields
struct Nested { ab1: AB; ab2: AB }

// This will multiply the sums of fields of nested `AB` Structs
asm fun mulOfSums(n: Nested): Int { ADD -ROT ADD MUL }

// Action!
fun showcase() {
    sum(AB{ a: 27, b: 50 }); // 77
    //      ↑      ↑
    //      |      Pushed last, sits on top of the stack
    //      Pushed first, sits on the bottom of the stack

    mulOfSums(Nested{ ab1: AB{ a: 1, b: 2 }, ab2: AB{ a: 3, b: 4 } }); // 21
    //                         ↑     ↑                ↑     ↑
    //                         |     |                |     Pushed last,
    //                         |     |                |     sits on top of the stack
    //                         |     |                Pushed second-to-last,
    //                         |     |                sits below the top of the stack
    //                         |     Pushed second,
    //                         |     sits right above the bottom of the stack
    //                         Pushed first, sits on the bottom of the stack
}
```

### Returns {#conventions-returns}

When present, return type of an assembly function attempts to capture relevant values from the resulting stack after the function execution and possible stack [arrangements](#arrangements). When not present, however, assembly function does not take any values from the stack.

When present, an assembly function's return type attempts to grab relevant values from the resulting stack after the function execution and any [result arrangements](#arrangements). If the return type is not present, however, the assembly function does not take any values from the stack.

```tact
// Pushes `x` onto the stack, increments it there,
// but does not capture the result, leaving it on the stack
asm fun push(x: Int) { INC }
```

Specifying a [primitive type][p], such as an [`Int{:tact}`][int] or a [`Cell{:tact}`][cell], will make the assembly function capture the top value from the stack. If the run-time type of the taken value doesn't match the specified return type, an exception with [exit code 7](/book/exit-codes#7) will be thrown: `Type check error`.

```tact
// CAUSES RUN-TIME ERROR WHEN CALLED!
// Pushes `x` onto the stack, does nothing else with it,
// then tries to capture it as a Cell, causing an exit code 7: Type check error
asm fun push(x: Int): Cell { }
```

Just like in [parameters](#conventions-parameters), arbitrary [Struct][struct] return types are distributed across their fields and recursively flattened in exactly the same order. The only differences are that they now capture values from the stack and do so in a right-to-left fashion — the last field of the [Struct][struct] grabs the topmost value from the stack, the second-to-last grabs the second to the top, and so on, so that the last field contains the value from the top of the stack and the first field contains the value from the bottom.

```tact
// Struct with two fields of type Int
struct MinMax { minVal: Int; maxVal: Int }

// Pushes `a` and `b` onto the stack,
// then captures two values back via the `MinMax` Struct
asm fun minmax(a: Int, b: Int): MinMax { MINMAX }
```

If the run-time type of some captured value doesn't match some specified field type of the [Struct][struct] or the nested [Structs][struct], if any, an exception with [exit code 7](/book/exit-codes#7) will be thrown: `Type check error`. Moreover, attempts to capture more values than there were on the stack throw an exception with [exit code 2](/book/exit-codes#2): `Stack underflow`.

```tact
// Struct with way too many fields for initial stack to handle
struct Handler { f1: Int; f2: Int; f3: Int; f4: Int; f5: Int; f6: Int; f7: Int }

// CAUSES RUN-TIME ERROR WHEN CALLED!
// Tries to capture 7 values from the stack and map them onto the fields of `Handler`,
// but there's just isn't that many values on the initial stack after TVM initialization,
// which causes an exit code 2 to be thrown: Stack underflow
asm fun overHandler(): Handler { }
```

As parameters and return values of assembly functions, [Structs][struct] can only have up to $16$ fields. Each of these fields can in turn be declared as another [Struct][struct], where each of these nested structures can also only have up to $16$ fields. This process can be repeated until there would be a total of $256$ fields of [primitive types][p] due to the [assembly function limitations](#limitations). This restriction also applies to the parameter list of assembly functions — you can only declare up to $16$ parameters.

```tact
// Seventeen fields
struct S17 { f1:Int; f2:Int; f3:Int; f4:Int; f5:Int; f6:Int; f7:Int; f8:Int; f9:Int; f10:Int; f11:Int; f12:Int; f13:Int; f14:Int; f15:Int; f16:Int; f17:Int }

// COMPILATION ERROR!
asm fun chuckles(imInDanger: S17) { }
```

## Stack registers {#stack-registers}

The so-called _stack registers_ are a way of referring to the values at the top of the stack. In total, there are $256$ stack registers, i.e. values held on the stack at any given time. You can specify any of them using any of `s0`, `s1`, ..., `s255`, but only if the certain [TVM][tvm] instruction expects it as an argument. Otherwise, their concept is meant for succinct descriptions of the effects of a particular [TVM][tvm] instruction in text or comments to the code, not in the code itself.

Register `s0` is the value at the top of the stack, register `s1` is the value immediately after it, and so on, until we reach the bottom of the stack, represented by `s255`, i.e. the $256$th stack register. When a value `x` is pushed onto a stack, it becomes the new `s0`. At the same time, old `s0` becomes new `s1`, old `s1` — new `s2`, and so on.

```tact
asm fun takeSecond(a: Int, b: Int): Int {
    //             ↑       ↑
    //             |       Pushed last, sits on top of the stack
    //             Pushed first, sits second from the top of the stack

    // Now, let's swap the s0 (top of the stack) with s1 (second-to-top)

    // Before │ After
    // ───────┼───────
    // s0 = b │ s0 = a
    // s1 = a │ s1 = b
    SWAP

    // Then, let's drop the value from the top of the stack

    // Before │ After
    // ───────┼───────
    // s0 = a │ s0 = b
    // s1 = b │ s1 is now either some value deeper or just blank
    DROP

    // At the end, we have only one value on the stack, which is b
    // Thus, it is captured by our return type `Int`
}

fun showcase() {
    takeSecond(5, 10); // 10, i.e. b
}
```

:::caution

  Attempts to access an empty stack register, i.e. one with no value at the time of access, throw an exception with [exit code 2](/book/exit-codes#2): `Stack underflow`.

  More about stack limits: [Limitations](#limitations).

:::

## Arrangements {#arrangements}

Often times it's useful to change the order of arguments pushed to the stack or the order of return values without referring to stack registers in the body. You can do this with `asm{:tact}` arrangements — with them, the evaluation flow of the assembly function can be thought of in these $5$ steps:

1. Function takes arguments in the order specified by the parameters.
2. If an argument arrangement is present, arguments are reordered before being pushed to the stack.
3. Function body, consisting of [TVM instructions][tvm-instructions] and primitives, is executed.
4. If a result arrangement is present, resulting values are reordered on the stack.
5. The resulting values are captured (partially or fully) by the return type of the function.

The argument arrangement has the syntax `asm(arg2 arg1)`, where `arg1` and `arg2` are some arguments of the function in the order we want to push them onto the stack: `arg1` will be pushed first and get on the bottom of the stack, while `arg2` will be pushed last and get on top of the stack. Arrangements are not limited by two arguments and operate on all parameters of the function. If there are any parameters of arbitrary [Struct][struct] types, their arrangement is done prior to their flattening.

```tact
// Changing the order of arguments to match the STDICT signature:
// `c` will be pushed first and get on the bottom of the stack,
// while `self` will be pushed last and get on top of the stack
asm(c self) extends fun asmStoreDict(self: Builder, c: Cell?): Builder { STDICT }
```

The return arrangement has the syntax `asm(-> 1 0)`, where $1$ and $0$ are a left-to-right reordering of [stack registers](#stack-registers) `s1` and `s0` correspondingly: the contents of `s1` will be at the top of the stack, followed by the contents of `s0`. Arrangements are not limited by two return values and operate on captured values. If an arbitrary [Struct][struct] is specified as the return type, the arrangement is done with respect to their fields, mapping values on the stack to the recursively flattened [Struct][struct].

```tact
// Changing the order of return values of LDVARUINT16 instruction,
// since originally it would place the modified Slice on top of the stack
asm(-> 1 0) extends fun asmLoadCoins(self: Slice): SliceInt { LDVARUINT16 }
//     ↑ ↑
//     | Value of the stack register 0,
//     | which is the topmost value in the stack
//     Value of the stack register 1,
//     which is second-to-top value in the stack
// And the return type `SliceInt`,
// which is the following Struct:
struct SliceInt { s: Slice; val: Int }
```

Both argument and return arrangement can be combined together and written as follows: `asm(arg2 arg1 -> 1 0)`.

```tact
// Changing the order of return values compared to the stack
// and switching the order of arguments as well
asm(s len -> 1 0) fun asmLoadInt(len: Int, s: Slice): SliceInt { LDIX }
//           ↑ ↑
//           | Value of the stack register 0,
//           | which is the topmost value in the stack
//           Value of the stack register 1,
//           which is second-to-top value in the stack
// And the return type `SliceInt`,
// which is the following Struct:
struct SliceInt { s: Slice; val: Int }
```

Using all those re-arranged functions together we get:

```tact
asm(c self) extends fun asmStoreDict(self: Builder, c: Cell?): Builder { STDICT }
asm(-> 1 0) extends fun asmLoadCoins(self: Slice): SliceInt { LDVARUINT16 }
asm(s len -> 1 0) fun asmLoadInt(len: Int, s: Slice): SliceInt { LDIX }
struct SliceInt { s: Slice; val: Int }

fun showcase() {
    let b = beginCell()
        .storeCoins(42)
        .storeInt(27, 10)
        .asmStoreDict(emptyMap());

    let s = b.asSlice();
    let si: SliceInt = s.asmLoadCoins(); // Slice remainder and 42
    s = si.s; // assigning the modified Slice
    let coins = si.val; // 42
    let si2: SliceInt = asmLoadInt(10, s); // Slice remainder and 27
}
```

Note, that arrangements do not drop or discard any values — they only manipulate the order of arguments and return values as those are declared. This means, for example, that arrangement cannot access values from the stack that are not captured by the return type of the assembly function.

That said, there's a [caveat to `mutates{:tact}` attribute and `asm` arrangements](#caveats-mutates).

## Limitations {#limitations}

Attempts to drop the number of stack values below $0$ throw an exception with [exit code 2](/book/exit-codes#2): `Stack underflow`.

```tact
asm fun drop() { DROP }

fun exitCode2() {
    // Drops way more elements from the stack
    // than there were before, causing an underflow
    repeat (100) { drop() }
}
```

The [TVM][tvm] stack itself has **no** limit on the total number of values, so you can theoretically push new values there until you run out of gas. However, various [continuations](https://docs.ton.org/v3/documentation/tvm/tvm-overview#tvm-is-a-stack-machine) may have a maximum number of values defined for their inner stacks, going over which will throw an exception with [exit code 3](/book/exit-codes#3): `stack overflow`.

```tact
asm fun stackOverflow() {
    x{} SLICE        // s
    BLESS            // c
    0 SETNUMARGS     // c'
    2 PUSHINT        // c' 2
    SWAP             // 2 c'
    1 -1 SETCONTARGS // ← this blows up
}

fun exitCode3() {
    // Overflows the inner stack of a continuation
    stackOverflow();
}
```

Although there are only $256$ [stack registers](#stack-registers), the stack itself can have more than $256$ values on it in total. The deeper values won't be immediately accessible by any [TVM instructions][tvm-instructions], but they would be on the stack nonetheless.

## Caveats {#caveats}

### Case sensitivity {#caveats-case}

[TVM instructions][tvm-instructions] are case-sensitive and are always written in upper case (capital letters).

```tact
/// ERROR!
asm fun bad1(): Cell { mycode }

/// ERROR!
asm fun bad2(): Cell { MyCoDe }

/// 👍
asm fun good(): Cell { MYCODE }
```

### No double quotes needed {#caveats-quotes}

It is not necessary to enclose [TVM instructions][tvm-instructions] in double quotes. On the contrary, they are then interpreted as strings, which is probably _not_ what you want:

```tact
// Pushes the string "MYCODE" onto the compile-time stack,
// where it gets discarded even before the compute phase starts
asm fun wrongMyCode() { "MYCODE" }

// Invokes the TVM instruction MYCODE during the compute phase,
// which returns the contract code as a Cell
asm fun myCode(): Cell { MYCODE }
```

### `mutates` consumes an extra value {#caveats-mutates}

Specifying a [`mutates{:tact}`](/book/functions#mutation-functions) attribute, i.e. defining a mutation function, makes the assembly function consume one more value deeper into the stack than the declared return values. Consider the following example:

```tact
asm(-> 1 0) extends mutates fun loadRef(self: Slice): Cell { LDREF }
```

There, `LDREF` instruction produces two stack entries: a [`Cell{:tact}`][cell] and a modified [`Slice{:tact}`][slice] in that order, with the [`Slice{:tact}`][slice] pushed on top of the stack. Then, the arrangement `-> 1 0{:tact}` inverses those values, making the [`Cell{:tact}`][cell] sit on top of the stack.

Finally, the [`mutates{:tact}`](/book/functions#mutation-functions) attribute makes the function consume the deepest value on the stack, i.e. [`Slice{:tact}`][slice], and assign it to `self{:tact}`, while returning the [`Cell{:tact}`][cell] value to the caller.

Overall, [`mutates{:tact}`](/book/functions#mutation-functions) attribute can be useful in some cases, but you must stay vigilant when using it with assembly functions.

:::caution

  If the type of the deepest value on the stack won't match the type of `self{:tact}`, then an exception with [exit code 7](/book/exit-codes#7) will be thrown: `Type check error`.

:::

### Don't rely on initial stack values {#caveats-initial}

The [TVM][tvm] places a couple of values onto its stack upon initialization, and those values are based on the [event that caused the transaction][tvm-init]. In other languages you might've had to rely on their order and types, while in Tact the parsing is done for you. Thus, in Tact these initial stack values are different from [what's described in TON Docs][tvm-init].

:::caution

  The initial elements placed on the stack during the [TVM initialization][tvm-init] and altered by Tact **must** remain on the stack until the end of the function body and be the only values present there. If they don't, an exception with [exit code 7](/book/exit-codes#7) is thrown: `Type check error`.

:::

Therefore, to access details such as the amount of [nanoToncoins](/book/integers#nanotoncoin) in a message or the [`Address{:tact}`][p] of the sender it's strongly recommended to call the [`context(){:tact}`](/ref/core-common#context) or [`sender(){:tact}`](/ref/core-common#sender) functions instead of attempting to look for those values on the stack.

## Debugging {#debugging}

The number of values the stack has at any given time is called the _depth_, and it's accessible via the [`DEPTH`](https://docs.ton.org/v3/documentation/tvm/instructions#68) instruction. It's quite handy for seeing the number of values before and after calling the assembly functions you're debugging, and can be used within asm logic.

```tact
asm fun depth(): Int { DEPTH }
```

To see both the stack depth and the values on it, there's a function in the Core library of Tact: [`dumpStack(){:tact}`](/ref/core-debug#dumpstack). It's great for keeping track of the stack while debugging, although it's computationally expensive and only prints values, not returns them, so use it sparingly and only when testing.

Read more about debugging Tact contracts on the dedicated page: [Debugging](/book/debug).

## Attributes {#attributes}

The following attributes can be specified:

* `inline{:tact}` — does nothing, since assembly functions are always inlined.
* [`extends{:tact}`](/book/functions#extension-function) — makes it an [extension function](/book/functions#extension-function).
* [`mutates{:tact}`](/book/functions#mutation-functions) (along with [`extends{:tact}`](/book/functions#extension-function)) — makes it an [extension mutation function](/book/functions#mutation-functions).

Those attributes _cannot_ be specified:

* `abstract{:tact}` — assembly functions must have a body defined.
* `virtual{:tact}` and `override{:tact}` — assembly functions cannot be defined within a contract or a trait.
* [`get{:tact}`](/book/functions#getter-functions) — assembly functions cannot be [getters](/book/functions#getter-functions).

```tact
/// `Builder.storeCoins()` extension function
asm extends fun storeCoins(self: Builder, value: Int): Builder {
    STVARUINT16
}

/// `Slice.skipBits()` extension mutation function
asm extends mutates fun skipBits(self: Slice, l: Int) {
    SDSKIPFIRST
}
```

## Interesting examples {#examples}

On the [TVM instructions][tvm-instructions] page, you may have noticed that the "signatures" of instructions are written in a special form called _stack notation_, which describes the state of the stack before and after the given instruction is executed.

For example, `x y - z` describes an instruction that grabs two values `x` and `y` from the stack, with `y` at the top of the stack and `x` second to the top, and then pushes the result `z` onto the stack. Notice that other values deeper down the stack are not accessed.

That notation omits the type info and only implicitly describes the state of stack registers, so for the following examples we'll use a different one, combining the notions of parameters and return values with the stack notation like this:

```tact
//   The types of parameters
//   |      |       and types of return values are shown
//   ↓      ↓       ↓
// x:Int, y:Int → z:Int — all comma-separated
// ————————————————————
// s1     s0    → s0
// ↑      ↑       ↑
// And the stack registers are shown too,
// which helps visually map them onto parameters and return values
```

When there are literals involved, they'll be shown as is. Additionally, when values on the stack do not represent the parameters or [Struct][struct] fields of the return type, only their type is given.

### keccak256

```tact
// Computes and returns the Keccak-256 hash as an 256-bit unsigned `Int`
// from a passed `Slice` `s`. Uses the Ethereum-compatible implementation.
asm fun keccak256(s: Slice): Int {
    // s:Slice → s:Slice, 1
    // —————————————————————
    // s0      → s1       s0
    ONE

    // s:Slice, 1  → h:Int
    // ———————————————————
    // s1       s0 → s0
    HASHEXT_KECCAK256
}
```

The [`HASHEXT_SHA256`](https://docs.ton.org/v3/documentation/tvm/instructions#F90400) and [`HASHEXT_BLAKE2B`](https://docs.ton.org/v3/documentation/tvm/instructions#F90402) instructions can be used in the similar manner, with respect to different number of return values. In addition, all of those can also work with values of type [`Builder{:tact}`][builder].

The [`HASHEXT_KECCAK512`](https://docs.ton.org/v3/documentation/tvm/instructions#F90404) and [`HASHEXT_SHA512`](https://docs.ton.org/v3/documentation/tvm/instructions#F90401), however, put a tuple of two integers on the stack instead of putting two separate integers there. Because of that, you'd need to also add the `UNPAIR` instruction right after them.

```tact
// Computes and returns the Keccak-512 hash in two 256-bit unsigned `Int`
// values from a passed `Slice` `s`. Uses the Ethereum-compatible implementation.
asm fun keccak256(s: Slice): Hash512 {
    // s:Slice → s:Slice, 1
    // —————————————————————
    // s0      → s1       s0
    ONE

    // s:Slice, 1  → Tuple(h1:Int, h2:Int)
    // ———————————————————————————————————
    // s1       s0 → s0
    HASHEXT_KECCAK512

    // Tuple(h1:Int, h2:Int) → h1:Int, h2:Int
    // —————————————————————————————————————
    // s0                    → s1      s2
    UNPAIR // could've used UNTUPLE in a more general case too
}

// Helper Struct
struct Hash512 { h1: Int; h2: Int }
```

:::note[Useful links:]

  [`HASHEXT_KECCAK256`](https://docs.ton.org/v3/documentation/tvm/instructions#F90403)\
  [`HASHEXT_KECCAK512`](https://docs.ton.org/v3/documentation/tvm/instructions#F90404)\
  [Reference Keccak-256 implementation](https://keccak.team/index.html)

:::

### isUint8

Mapping onto a single instruction by itself is inefficient if the values they place onto the stack can vary depending on some conditions. That's because one cannot map them to Tact types directly and often needs to some additional stack manipulations prior or post to their execution.

Since this is often the case for the "quiet" versions of instructions, the recommendation is to prefer their non-quiet alternatives. Usually, non-quiet versions throw exceptions and are consistent in their return values, while quiet ones push $-1$ or other values onto the stack, thus varying the number or the type of their result values.

For the simpler cases such as this example, it's convenient to do all the stack manipulations within the same function.

```tact
// Checks if the given `Int` `val` is in
// the inclusive range from 0 to 255
asm fun isUint8(val: Int): Bool {
    // val:Int → val:Int or NaN
    // ————————————————————————
    // s0      → s0
    8 QUFITS

    // val:Int or NaN → Bool
    // —————————————————————
    // s0             → s0
    ISNAN

    // Since ISNAN gives true when the `val` NaN,
    // i.e. when the `val` did not fit into the uint8 range,
    // we need to flip it

    // Bool → Bool
    // ———————————
    // s0   → s0
    NOT // could've used 0 EQINT too
}

fun showcase() {
    isUint8(55);            // true
    isUint8(-55);           // false
    isUint8(pow(2, 8));     // false
    isUint8(pow(2, 8) - 1); // true
}
```

### ecrecover

This example shows one possible way to work with partially captured results from the stack, getting the omitted ones later.

```tact
// Recovers a public key from the signature like its done on Bitcoin or Ethereum
//
// Takes the 256-bit unsigned integer `hash` and the 65-byte signature of:
// * 8-bit unsigned integer `v`
// * and 256-bit unsigned integers `r` and `s`
//
// Returns `null` on failure, or `EcrecoverKey` structure on success
fun ecrecover(hash: Int, v: Int, r: Int, s: Int): EcrecoverKey? {
    let successful = _ecrecoverExecute(hash, v, r, s);
    if (successful) {
        return _ecrecoverSuccess();
    } else {
        return null;
    }
}

// The 65-byte public key returned by `ecrecover()` in case of success,
// which consists of the 8-bit unsigned integer `h`
// and 256-bit unsigned integers `x1` and `x2`
struct EcrecoverKey {
    h: Int as uint8;
    x1: Int as uint256;
    x2: Int as uint256;
}

// Underlying assembly function that does the work
// and only captures the topmost value from the stack
//
// Since the `ECRECOVER` instruction places the 0 on top of the stack
// in case of failure and -1 in case of success,
// this maps nicely onto the Bool type
asm fun _ecrecoverExecute(hash: Int, v: Int, r: Int, s: Int): Bool { ECRECOVER }

// Simply captures the values from the stack
// if the call to `ecrecoverExecute()` was successful
asm fun _ecrecoverSuccess(): EcrecoverKey { }
```

### onchainSha256

This example extends the [`ecrecover(){:tact}`](#ecrecover) one and adds more complex stack management and interaction with Tact statements such as loops.

```tact
// Calculates and returns the SHA-256 hash
// as a 256-bit unsigned `Int` of the given `data`.
// Unlike the `sha256()` function from the Core library,
// this one works purely on-chain (at runtime), hashing the strings completely,
// whereas the `sha256()` reliably works only with their first 1023 bits of data
fun onchainSha256(data: String): Int {
    _onchainShaPush(data);
    while (_onchainShaShouldProceed()) {
        _onchainShaOperate();
    }
    return _onchainShaHashExt();
}

// Helper assembly functions,
// each manipulating the stack in their own ways
// in different parts of the `onchainSha256()` function
asm fun _onchainShaPush(data: String) { ONE }
asm fun _onchainShaShouldProceed(): Bool { OVER SREFS 0 NEQINT }
asm fun _onchainShaOperate() { OVER LDREF s0 POP CTOS s0 s1 XCHG INC }
asm fun _onchainShaHashExt(): Int { HASHEXT_SHA256 }
```

:::note[Useful links:]

  [TVM overview in TON Docs][tvm]\
  [List of TVM instructions in TON Docs][tvm-instructions]

:::

[p]: /book/types#primitive-types
[struct]: /book/structs-and-messages#structs
[int]: /book/integers
[cell]: /book/cells#cells
[builder]: /book/cells#builders
[slice]: /book/cells#slices

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[tvm-instructions]: https://docs.ton.org/v3/documentation/tvm/instructions
[tvm-init]: https://docs.ton.org/v3/documentation/tvm/tvm-initialization#stack


## bounced.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/bounced.mdx)
---
title: Bounced messages
description: "When a contract sends a message with a flag bounce set to true, then if the message wasn't processed properly, it would bounce back to the sender"
---

When a contract sends a message with a flag `bounce` set to `true{:tact}`, then if the message wasn't processed properly, it would bounce back to the sender. This is useful when you want to make sure that the message was processed properly and if not — revert the changes.

## Caveats

Currently, bounced messages in TON have only 224 usable data bits in the message body and don't have any references. This means that you can't recover much of the data from the bounced message. This is a limitation of the TON blockchain and will be fixed in the future. Tact helps you to check if your message fits the limit and in case it doesn't — suggests using a special type constructor `bounced<T>{:tact}` for the bounced message receiver, that would construct a partial representation of the message that fits into the required limits.

## Bounced message receiver

:::caution

  Bounced text messages are not supported yet.

:::

To receive a bounced message, define a `bounced(){:tact}` [receiver function](/book/contracts#receiver-functions) in your [contract](/book/contracts) or a [trait](/book/types#traits):

```tact {2-4}
contract MyContract {
    bounced(msg: bounced<MyMessage>) {
        // ...
    }
}
```

To process bounced messages manually, you can use a fallback definition that handles a raw [`Slice{:tact}`](/book/cells#slices) directly. Note, that such receiver will get **all** the bounced messages produced by your contract:

```tact /rawMsg: Slice/
contract MyContract {
    bounced(rawMsg: Slice) {
        // ...
    }
}
```


## cells.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/cells.mdx)
---
title: Cells, Builders and Slices
description: "Cells, Builders and Slices are low-level primitives of TON Blockchain"
---

[Cells](#cells), [Builders](#builders) and [Slices](#slices) are low-level [primitives][p] of TON Blockchain. The virtual machine of TON Blockchain, [TVM][tvm], uses cells to represent all data structures in persistent storage, and most in memory.

## Cells

`Cell{:tact}` is a [primitive][p] and a data structure, which [ordinarly](#cells-kinds) consists of up to $1023$ continuously laid out bits and up to $4$ references (refs) to other cells. Circular references are forbidden and cannot be created by the means of [TVM][tvm], which means cells can be viewed as [quadtrees][quadtree] or [directed acyclic graphs (DAGs)](https://en.wikipedia.org/wiki/Directed_acyclic_graph) of themselves. Contract code itself is represented by a tree of cells.

Cells and [cell primitives](#cells-immutability) are bit-oriented, not byte-oriented: [TVM][tvm] regards data kept in cells as sequences (strings or streams) of up to $1023$ bits, not bytes. If necessary, contracts are free to use, say, $21$-bit integer fields serialized into [TVM][tvm] cells, thus using fewer persistent storage bytes to represent the same data.

### Kinds {#cells-kinds}

While the [TVM][tvm] type [`Cell{:tact}`](#cells) refers to all cells, there are different cell kinds with various memory layouts. The one described [earlier](#cells) is commonly referred to as an _ordinary_ (or simple) cell — that's the most simple and most commonly used flavor of cells, which can only contain data. The grand majority of descriptions, guides and [references](/ref/core-cells) to cells and their usage assumes ordinary ones.

Other kinds of cells are collectively called _exotic_ (or special) cells. They sometimes appear in actual representations of blocks and other data structures on TON Blockchain. Their memory layouts and purposes significantly differ from ordinary cells.

Kinds (or subtypes) of all cells are encoded by an integer between $-1$ and $255$. Ordinary cells are encoded by $-1$, while exotic ones can be encoded by any other integer in that range. The subtype of an exotic cell is stored in the first $8$ bits of its data, which means valid exotic cells always have at least $8$ data bits.

[TVM][tvm] currently supports the following exotic cell subtypes:
* [Pruned branch cell][c-pruned], with subtype encoded as $1$ — they represent deleted subtrees of cells.
* [Library reference cell][c-library], with subtype encoded as $2$ — they are used for storing libraries, and usually, in [masterchain][masterchain] contexts.
* [Merkle proof cell][c-mproof], with subtype encoded as $3$ — they are used for verifying that certain portions of other cell's tree data belong to the full tree.
* [Merkle update cell][c-mupdate], with subtype encoded as $4$ — they always have two references and behave like a [Merkle proof][mproof] for both of them.

:::note[Useful links:]

  [Pruned branch cells in TON Docs][c-pruned]\
  [Library reference cells in TON Docs][c-library]\
  [Merkle proof cells in TON Docs][c-mproof]\
  [Merkle update cells in TON Docs][c-mupdate]\
  [Simple proof-verifying example in TON Docs][mproof]

:::

[c-pruned]: https://docs.ton.org/develop/data-formats/exotic-cells#pruned-branch
[c-library]: https://docs.ton.org/develop/data-formats/library-cells
[c-mproof]: https://docs.ton.org/develop/data-formats/exotic-cells#merkle-proof
[c-mupdate]: https://docs.ton.org/develop/data-formats/exotic-cells#merkle-update
[mproof]: https://docs.ton.org/develop/data-formats/exotic-cells#simple-proof-verifying-example
[masterchain]: https://docs.ton.org/v3/documentation/smart-contracts/shards/shards-intro#masterchain

### Levels {#cells-levels}

Every cell, being a [quadtree][quadtree], has an attribute called _level_, which is represented by an integer between $0$ and $3$. The level of an [ordinary](#cells-kinds) cell is always equal to the maximum of the levels of all its references. That is, level of an ordinary cell without references is equal to $0$.

[Exotic](#cells-kinds) cells have different rules for determining their level, which are described [on this page in TON Docs](https://docs.ton.org/develop/data-formats/exotic-cells).

### Serialization {#cells-serialization}

Before a cell can be transferred over the network or stored on disk, it must be serialized. There are several common formats, such as [standard `Cell{:tact}` representation](#cells-representation) and [BoC](#cells-boc).

#### Standard representation {#cells-representation}

Standard [`Cell{:tact}`](#cells) representation is a common serialization format for cells first described in the [tvm.pdf](https://docs.ton.org/tvm.pdf). Its algorithm representing cells in octet (byte) sequences begins with serializing the first $2$ bytes called descriptors:

* _Refs descriptor_ is calculated according to this formula: $r + 8 * k + 32 * l$, where $r$ is the number of references contained in the cell (between $0$ and $4$), $k$ is a flag for the cell kind ($0$ for [ordinary](#cells-kinds) and $1$ for [exotic](#cells-kinds)), and $l$ is the [level](#cells-levels) of the cell (between $0$ and $3$).
* _Bits descriptor_ is calculated according to this formula $\lfloor\frac{b}{8}\rfloor + \lceil\frac{b}{8}\rceil$, where $b$ is the number of bits in the cell (between $0$ and $1023$).

Then, the data bits of the cell themselves are serialized as $\lceil\frac{b}{8}\rceil$ $8$-bit octets (bytes). If $b$ is not a multiple of eight, a binary $1$ and up to six binary $0$s are appended to the data bits.

Next, the $2$ bytes store the depth of the refs, i.e. the number of cells between the root of the cell tree (the current cell) and the deepest of the references, including it. For example, a cell containing only one reference and no further references would have a depth of $1$, while the referenced cell would have a depth of $0$.

Finally, for every reference cell the [SHA-256][sha-2] hash of its standard representation is stored, occupying $32$ bytes per each such cell and recursively repeating the said algorithm. Notice, that cyclic cell references are not allowed, so this recursion always ends in a well-defined manner.

If we were to compute the hash of the standard representation of this cell, all the bytes from steps above would be concatenated together and then hashed using [SHA-256][sha-2] hash. This is the algorithm behind [`HASHCU` and `HASHSU` instructions](https://docs.ton.org/learn/tvm-instructions/instructions) of [TVM][tvm] and respective [`Cell.hash(){:tact}`](/ref/core-cells#cellhash) and [`Slice.hash(){:tact}`](/ref/core-cells#slicehash) functions of Tact.

#### Bag of Cells {#cells-boc}

Bag of Cells, or _BoC_ for short, is a format for serializing and de-serializing cells into byte arrays as described in [boc.tlb](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25) [TL-B schema][tlb].

Read more about BoC in TON Docs: [Bag of Cells](https://docs.ton.org/develop/data-formats/cell-boc#bag-of-cells).

:::note

  Advanced information on [`Cell{:tact}`](#cells) serialization: [Canonical `Cell{:tact}` Serialization](https://docs.ton.org/develop/research-and-development/boc).

:::

### Immutability {#cells-immutability}

Cells are read-only and immutable, but there are two major sets of [ordinary](#cells-kinds) cell manipulation instructions in [TVM][tvm]:

* Cell creation (or serialization) instructions, which are used to construct new cells from previously kept values and cells;
* And cell parsing (or deserialization) instructions, which are used to extract or load data previously stored into cells via serialization instructions.

On top of that, there are instructions specific to [exotic](#cells-kinds) cells to create them and expect their values. However, [ordinary](#cells-kinds) cell parsing instructions can still be used on [exotic](#cells-kinds) ones, in which case they are automatically replaced by [ordinary](#cells-kinds) cells during such deserialization attempts.

All cell manipulation instructions require transforming values of [`Cell{:tact}`](#cells) type to either [`Builder{:tact}`](#builders) or [`Slice{:tact}`](#slices) types before such cells can be modified or inspected.

## Builders

`Builder{:tact}` is a cell manipulation [primitive][p] for using cell creation instructions. They're immutable just like cells are, and allow constructing new cells from previously kept values and cells. Unlike cells, values of type `Builder{:tact}` appear only on [TVM][tvm] stack and cannot be stored in persistent storage. That means, for example, that persistent storage fields with type `Builder{:tact}` would actually be stored as cells under the hood.

`Builder{:tact}` type represents partially composed cells, for which fast operations for appending integers, other cells, references to other cells and many others are defined:

* [`Builder.storeUint(){:tact}` in Core library][b-2]
* [`Builder.storeInt(){:tact}` in Core library][b-3]
* [`Builder.storeBool(){:tact}` in Core library][b-4]
* [`Builder.storeSlice(){:tact}` in Core library][b-5]
* [`Builder.storeCoins(){:tact}` in Core library][b-6]
* [`Builder.storeAddress(){:tact}` in Core library][b-7]
* [`Builder.storeRef(){:tact}` in Core library][b-8]

While you may use them for [manual construction](#cnp-manually) of the cells, it's strongly recommended to use [Structs][struct] instead: [Construction of cells with Structs](#cnp-structs).

## Slices

`Slice{:tact}` is a cell manipulation [primitive][p] for using cell parsing instructions. Unlike cells, they're mutable and allow extracting or loading data previously stored into cells via serialization instructions. Also unlike cells, values of type `Slice{:tact}` appear only on [TVM][tvm] stack and cannot be stored in persistent storage. That means, for example, that persistent storage fields with type `Slice{:tact}` would actually be stored as cells under the hood.

`Slice{:tact}` type represents either the remainder of a partially parsed cell, or a value (subcell) residing inside such a cell and extracted from it by a parsing instruction:

* [`Slice.loadUint(){:tact}` in Core library][s-2]
* [`Slice.loadInt(){:tact}` in Core library][s-3]
* [`Slice.loadBool(){:tact}` in Core library][s-4]
* [`Slice.loadBits(){:tact}` in Core library][s-5]
* [`Slice.loadCoins(){:tact}` in Core library][s-6]
* [`Slice.loadAddress(){:tact}` in Core library][s-7]
* [`Slice.loadRef(){:tact}` in Core library][s-8]

While you may use them for [manual parsing](#cnp-manually) of the cells, it's strongly recommended to use [Structs][struct] instead: [Parsing of cells with Structs](#cnp-structs).

## Serialization types

Similar to serialization options of [`Int{:tact}`](/book/integers) type, `Cell{:tact}`, `Builder{:tact}` and `Slice{:tact}` also have various representations for encoding their values in the following cases:

* as [storage variables](/book/contracts#variables) of [contracts](/book/contracts) and [traits](/book/types#traits),
* and as fields of [Structs](/book/structs-and-messages#structs) and [Messages](/book/structs-and-messages#messages).

```tact {2-3}
contract SerializationExample {
    someCell: Cell as remaining;
    someSlice: Slice as bytes32;

    // Constructor function,
    // necessary for this example contract to compile
    init() {
        self.someCell = emptyCell();
        self.someSlice = beginCell().storeUint(42, 256).asSlice();
    }
}
```

### `remaining` {#serialization-remaining}

The `remaining{:tact}` serialization option can be applied to values of [`Cell{:tact}`](#cells), [`Builder{:tact}`](#builders) and [`Slice{:tact}`](#slices) types.

It affects the process of constructing and parsing cell values by causing them to be stored and loaded directly rather than as a reference. To draw parallels with [cell manipulation instructions](#cells-immutability), specifying `remaining{:tact}` is like using [`Builder.storeSlice(){:tact}`][b-5] and [`Slice.loadBits(){:tact}`][s-5] instead of [`Builder.storeRef(){:tact}`][b-8] and [`Slice.loadRef(){:tact}`][s-8], which are to be used by default.

In addition, the [TL-B][tlb] representation produced by Tact changes too:

```tact {3-5, 8-10}
contract SerializationExample {
    // By default
    cRef: Cell;    // ^cell in TL-B
    bRef: Builder; // ^builder in TL-B
    sRef: Slice;   // ^slice in TL-B

    // With `remaining`
    cRem: Cell as remaining;    // remainder<cell> in TL-B
    bRem: Builder as remaining; // remainder<builder> in TL-B
    sRem: Slice as remaining;   // remainder<slice> in TL-B

    // Constructor function,
    // necessary for this example contract to compile
    init() {
        self.cRef = emptyCell();
        self.bRef = beginCell();
        self.sRef = emptySlice();
        self.cRem = emptyCell();
        self.bRem = beginCell();
        self.sRem = emptySlice();
    }
}
```

There, `^cell`, `^builder` and `^slice` in [TL-B][tlb] syntax mean the reference to [`Cell{:tact}`](#cells), [`Builder{:tact}`](#builders) and [`Slice{:tact}`](#slices) values respectively, while the `remainder<…>` of `cell`, `builder` or `slice` tells that the given value would be stored as a `Slice{:tact}` directly and not as a reference.

Now, to give a real-world example, imagine that you need to notice and react to inbound [jetton][jetton] transfers in your smart contract. The appropriate [Message][message] structure for doing so would look something like this:

```tact /remaining/
message(0x7362d09c) JettonTransferNotification {
    queryId: Int as uint64;             // arbitrary request number to prevent replay attacks
    amount: Int as coins;               // amount of jettons transferred
    sender: Address;                    // address of the sender of the jettons
    forwardPayload: Slice as remaining; // optional custom payload
}
```

And the [receiver][recv] in the contract would look like this:

```tact
receive(msg: JettonTransferNotification) {
    // ... you do you ...
}
```

Upon receiving a [jetton][jetton] transfer notification message, its cell body is converted into a [`Slice{:tact}`](#slices) and then parsed as a `JettonTransferNotification{:tact}` [Message][message]. At the end of this process, the `forwardPayload` will have all the remaining data of the original message cell.

Here, it's not possible to violate the [jetton][jetton] standard by placing the `forwardPayload: Slice as remaining` field in any other position in the `JettonTransferNotification{:tact}` [Message][message]. That's because Tact prohibits usage of `as remaining{:tact}` for any but the last field of the [Structs][struct] and [Messages][message] to prevent misuse of the contract storage and reduce gas consumption.

:::note

  Note, that the cell serialized via `as remaining{:tact}` cannot be [optional](/book/optionals). That is, specifying something like `Cell? as remaining{:tact}`, `Builder? as remaining{:tact}` or `Slice? as remaining{:tact}` would cause a compilation error.

  Also note, that specifying `remaining{:tact}` for the `Cell{:tact}` as the [map](/book/maps) value type is considered an error and it won't compile.

:::

### `bytes32` {#serialization-bytes64}

:::note

  To be resolved by [#94](https://github.com/tact-lang/tact-docs/issues/94).

:::

### `bytes64` {#serialization-bytes64}

:::note

  To be resolved by [#94](https://github.com/tact-lang/tact-docs/issues/94).

:::

## Operations

### Construct and parse {#operations-cnp}

In Tact, there are at least two ways to construct and parse cells:

* [Manually](#cnp-manually), which involves active use of [`Builder{:tact}`](#builders), [`Slice{:tact}`](#slices) and [relevant methods](/ref/core-cells).
* [Using Structs](#cnp-structs), which is a recommended and much more convenient approach.

#### Manually {#cnp-manually}

Construction via `Builder{:tact}`      | Parsing via `Slice{:tact}`
:------------------------------------- | :-------------------------
[`beginCell(){:tact}`][b-1]            | [`Cell.beginParse(){:tact}`][s-1]
[`.storeUint(42, 7){:tact}`][b-2]      | [`Slice.loadUint(7){:tact}`][s-2]
[`.storeInt(42, 7){:tact}`][b-3]       | [`Slice.loadInt(7){:tact}`][s-3]
[`.storeBool(true){:tact}`][b-4]       | [`Slice.loadBool(true){:tact}`][s-4]
[`.storeSlice(slice){:tact}`][b-5]     | [`Slice.loadBits(slice){:tact}`][s-5]
[`.storeCoins(42){:tact}`][b-6]        | [`Slice.loadCoins(42){:tact}`][s-6]
[`.storeAddress(address){:tact}`][b-7] | [`Slice.loadAddress(){:tact}`][s-7]
[`.storeRef(cell){:tact}`][b-8]        | [`Slice.loadRef(){:tact}`][s-8]
[`.endCell(){:tact}`][b-9]             | [`Slice.endParse(){:tact}`][s-9]

[b-1]: /ref/core-cells#begincell
[b-2]: /ref/core-cells#builderstoreuint
[b-3]: /ref/core-cells#builderstoreint
[b-4]: /ref/core-cells#builderstorebool
[b-5]: /ref/core-cells#builderstoreslice
[b-6]: /ref/core-cells#builderstorecoins
[b-7]: /ref/core-cells#builderstoreaddress
[b-8]: /ref/core-cells#builderstoreref
[b-9]: /ref/core-cells#builderendcell
[s-1]: /ref/core-cells#cellbeginparse
[s-2]: /ref/core-cells#sliceloaduint
[s-3]: /ref/core-cells#sliceloadint
[s-4]: /ref/core-cells#sliceloadbool
[s-5]: /ref/core-cells#sliceloadbits
[s-6]: /ref/core-cells#sliceloadcoins
[s-7]: /ref/core-cells#sliceloadaddress
[s-8]: /ref/core-cells#sliceloadref
[s-9]: /ref/core-cells#sliceendparse

#### Using Structs (recommended) {#cnp-structs}

[Structs][struct] and [Messages][message] are almost like living [TL-B schemas][tlb]. Which means that they're, essentially, [TL-B schemas][tlb] expressed in maintainable, verifiable and user-friendly Tact code.

It is strongly recommended to use them and their [methods](/book/functions#extension-function) like [`Struct.toCell(){:tact}`][st-tc] and [`Struct.fromCell(){:tact}`][st-fc] instead of manually constructing and parsing cells, as this allows for much more declarative and self-explanatory contracts.

The examples of manual parsing [above](#cnp-manually) could be re-written using [Structs][struct], with descriptive names of fields if one so desires:

```tact /fromCell/ /toCell/
// First Struct
struct Showcase {
    id: Int as uint8;
    someImportantNumber: Int as int8;
    isThatCool: Bool;
    payload: Slice;
    nanoToncoins: Int as coins;
    wackyTacky: Address;
    jojoRef: Adventure; // another Struct
}

// Here it is
struct Adventure {
    bizarre: Bool = true;
    time: Bool = false;
}

fun example() {
    // Basics
    let s = Showcase.fromCell(
        Showcase{
            id: 7,
            someImportantNumber: 42,
            isThatCool: true,
            payload: emptySlice(),
            nanoToncoins: 1330 + 7,
            wackyTacky: myAddress(),
            jojoRef: Adventure{ bizarre: true, time: false },
        }.toCell());
    s.isThatCool; // true
}
```

Note, that Tact's auto-layout algorithm is greedy. For example, `struct Adventure{:tact}` occupies very little space, and it won't be stored as a reference [`Cell{:tact}`](#cells), but will be provided directly as a [`Slice{:tact}`](#slices).

By using [Structs][struct] and [Messages][message] over manual [`Cell{:tact}`](#cells) composition and parsing, those details would be simplified away and won't cause any hassle when the optimized layout changes.

:::note[Useful links:]

  [Convert serialization](/book/func#convert-serialization)\
  [`Struct.toCell(){:tact}` in Core library][st-tc]\
  [`Struct.fromCell(){:tact}` in Core library][st-fc]\
  [`Struct.fromSlice(){:tact}` in Core library][st-fs]\
  [`Message.toCell(){:tact}` in Core library][msg-tc]\
  [`Message.fromCell(){:tact}` in Core library][msg-fc]\
  [`Message.fromSlice(){:tact}` in Core library][msg-fs]

:::

[st-tc]: /ref/core-cells#structtocell
[st-fc]: /ref/core-cells#structfromcell
[st-fs]: /ref/core-cells#structfromslice
[msg-tc]: /ref/core-cells#messagetocell
[msg-fc]: /ref/core-cells#messagefromcell
[msg-fs]: /ref/core-cells#messagefromslice

### Check if empty {#operations-empty}

Neither [`Cell{:tact}`](#cells) nor [`Builder{:tact}`](#builders) can be checked for emptiness directly — one needs to convert them to [`Slice{:tact}`](#slices) first.

To check if there are any bits, use [`Slice.dataEmpty(){:tact}`][s-de]. To check if there are any references, use [`Slice.refsEmpty(){:tact}`][s-re]. And to check both at the same time, use [`Slice.empty(){:tact}`][s-e].

To also throw an [exit code 9](/book/exit-codes#9) whenever the [`Slice{:tact}`](#slices) isn't completely empty, use [`Slice.endParse(){:tact}`][s-ep].

```tact
// Preparations
let someCell = beginCell().storeUint(42, 7).endCell();
let someBuilder = beginCell().storeRef(someCell);

// Obtaining our Slices
let slice1 = someCell.asSlice();
let slice2 = someBuilder.asSlice();

// .dataEmpty()
slice1.dataEmpty(); // false
slice2.dataEmpty(); // true

// .refsEmpty()
slice1.refsEmpty(); // true
slice2.refsEmpty(); // false

// .empty()
slice1.empty(); // false
slice2.empty(); // false

// .endParse()
try {
    slice1.endParse();
    slice2.endParse();
} catch (e) {
    e; // 9
}
```

:::note[Useful links:]

  [`Cell.asSlice(){:tact}` in Core library](/ref/core-cells#cellasslice)\
  [`Builder.asSlice(){:tact}` in Core library](/ref/core-cells#builderasslice)\
  [`Slice.dataEmpty(){:tact}` in Core library][s-de]\
  [`Slice.refsEmpty(){:tact}` in Core library][s-re]\
  [`Slice.empty(){:tact}` in Core library][s-e]\
  [`Slice.endParse(){:tact}` in Core library][s-ep]

:::

[s-de]: /ref/core-cells#slicedataempty
[s-re]: /ref/core-cells#slicerefsempty
[s-e]: /ref/core-cells#sliceempty
[s-ep]: /ref/core-cells#sliceendparse

### Check if equal {#operations-equal}

Values of type [`Builder{:tact}`](#builders) cannot be compared directly using binary equality [`=={:tact}`][bin-eq] or inequality [`!={:tact}`][bin-eq] operators. However, values of type [`Cell{:tact}`](#cells) and [`Slice{:tact}`](#slices) can.

Direct comparisons:

```tact
let a = beginCell().storeUint(123, 8).endCell();
let aSlice = a.asSlice();

let b = beginCell().storeUint(123, 8).endCell();
let bSlice = b.asSlice();

let areCellsEqual = a == b; // true
let areCellsNotEqual = a != b; // false

let areSlicesEqual = aSlice == bSlice; // true
let areSlicesNotEqual = aSlice != bSlice; // false
```

Note, that direct comparison via `=={:tact}` or `!={:tact}` operators implicitly uses [SHA-256](https://en.wikipedia.org/wiki/SHA-2#Hash_standard) hashes of [standard `Cell{:tact}` representation](#cells-representation) under the hood.

Explicit comparisons using `.hash(){:tact}` are also available:

```tact
let a = beginCell().storeUint(123, 8).endCell();
let aSlice = a.asSlice();

let b = beginCell().storeUint(123, 8).endCell();
let bSlice = b.asSlice();

let areCellsEqual = a.hash() == b.hash(); // true
let areCellsNotEqual = a.hash() != b.hash(); // false

let areSlicesEqual = aSlice.hash() == bSlice.hash(); // true
let areSlicesNotEqual = aSlice.hash() != bSlice.hash(); // false
```

:::note[Useful links:]

  [`Cell.hash(){:tact}` in Core library](/ref/core-cells#cellhash)\
  [`Slice.hash(){:tact}` in Core library](/ref/core-cells#slicehash)\
  [`=={:tact}` and `!={:tact}`][bin-eq]

:::

[p]: /book/types#primitive-types
[struct]: /book/structs-and-messages#structs
[message]: /book/structs-and-messages#messages
[recv]: /book/contracts#receiver-functions

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[jetton]: https://docs.ton.org/develop/dapps/asset-processing/jettons
[sha-2]: https://en.wikipedia.org/wiki/SHA-2#Hash_standard

[quadtree]: https://en.wikipedia.org/wiki/Quadtree
[bin-eq]: /book/operators#binary-equality



## config.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/config.mdx)
---
title: Configuration
description: "The behavior of Tact compiler can be customized using its configuration file"
---

The behavior of Tact compiler can be customized using its configuration file, `tact.config.json` — a JSON file that contains the list of settings according to the specific [schema](#schema).

This page lists all the configuration options as they're structured in the [schema](#schema). Look for table of contents on the right to easily navigate them.

:::note

  The only requirement for that file is to be a valid JSON with [proper fields](#schema), so it can be named arbitrarily. However, naming your config file as `tact.config.json` is a common convention encouraged and supported by all tools working with Tact.

:::

## `$schema` {#schema}

A [JSON schema](https://json-schema.org/) file is available for editors to provide autocompletion and hover hints: [configSchema.json](http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json).

Simply add the `$schema` field on top your configuration file:

```json filename="tact.config.json" {2}
{
  "$schema": "http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json",
  "projects": []
}
```

## `projects` {#projects}

List of Tact projects with respective compilation options. Each `.tact` file represents its own Tact project.

```json filename="tact.config.json" {3,4}
{
  "projects": [
    { },
    { }
  ]
}
```

### `name` {#projects-name}

Name of the project. All generated files are prefixed with it.

In [Blueprint][bp], `name` refers to the name of the contract itself.

```json filename="tact.config.json" {4,7}
{
  "projects": [
    {
      "name": "some_prefix"
    },
    {
      "name": "ContractUnderBlueprint"
    }
  ]
}
```

### `path` {#projects-path}

Path to the project's Tact file. You can only specify one Tact file per project.

In [Blueprint][bp], `path` is superseded by the `target` field in `wrappers/ContractName.compile.ts` by default, or in `compilables/ContractName.compile.ts` if you have `separateCompilables` the option set in the [`blueprint.config.ts`][bp-config].

```json filename="tact.config.json" {5}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact"
    }
  ]
}
```

### `output` {#projects-output}

Path to the directory where all generated files will be placed.

In [Blueprint][bp], `output` is not used and all generated files are always placed in `build/ProjectName/`.

```json filename="tact.config.json" {6}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output"
    }
  ]
}
```

### `options` {#projects-options}

Compilation options for the project.

In [Blueprint][bp], they act as default unless modified in `wrappers/ContractName.compile.ts` by default, or in `compilables/ContractName.compile.ts` if you have `separateCompilables` the option set in the [`blueprint.config.ts`][bp-config].

```json filename="tact.config.json" {7,11}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {}
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {}
    }
  ]
}
```

#### `debug` {#options-debug}

`false{:json}` by default.

If set to `true{:json}`, enables debug output of a contract and allows usage of [`dump(){:tact}`](/ref/core-debug#dump) function, which is useful for [debugging purposes](/book/debug). With this option enabled, the contract will report that it was compiled in debug mode using the `supported_interfaces` method.

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "debug": true
      }
    }
  ]
}
```

:::note

  Read more on the dedicated page: [Debugging](/book/debug).

:::

#### `external` {#options-external}

`false{:json}` by default.

If set to `true{:json}`, enables support of [external](/book/external) message receivers.

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "external": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "external": true
      }
    }
  ]
}
```

:::note

  Read more on the dedicated page: [External messages](/book/external).

:::

#### `ipfsAbiGetter` {#options-ipfsabigetter}

`false{:json}` by default.

If set to `true{:json}`, enables generation of a [getter](/book/contracts#getter-functions) with IPFS links describing the contract's ABI.

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "ipfsAbiGetter": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "ipfsAbiGetter": true
      }
    }
  ]
}
```

:::note

  Read more on the dedicated page: [OTP-003: Self-ABI reporting](/ref/evolution/otp-003).

:::

#### `interfacesGetter` {#options-interfacesgetter}

`false{:json}` by default.

If set to `true{:json}`, enables generation of a [getter](/book/contracts#getter-functions) with a list of interfaces provided by the contract.

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "interfacesGetter": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "interfacesGetter": true
      }
    }
  ]
}
```

:::note

  Read more: [Supported interfaces](/book/contracts#interfaces).

:::

#### `experimental` {#options-experimental}

Experimental options that might be removed in the future. Use with caution!

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "experimental": {}
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "experimental": {}
      }
    }
  ]
}
```

##### `inline` {#experimental-inline}

`false{:json}` by default.

If set to `true{:json}`, enables inlining of all functions in contracts. This can reduce gas usage at the cost of bigger contracts.

```json filename="tact.config.json" {9,17}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "experimental": {
          "inline": true
        }
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "experimental": {
          "inline": true
        }
      }
    }
  ]
}
```

### `mode` {#projects-mode}

Compilation mode of the project. Valid values are:

Value                            | Description
:------------------------------- | :----------
`"full"{:json}`                  | (default) Runs the whole compilation pipeline and emits FunC code, BoC, and various utility files, including wrappers for TypeScript.
`"fullWithDecompilation"{:json}` | Runs the whole compilation pipeline like `"full"{:json}`, and also decompiles produced binary code in the BoC format.
`"funcOnly"{:json}`              | Only outputs intermediate FunC code, preventing further compilation.
`"checkOnly"{:json}`             | Only performs syntax and type checking, preventing further compilation.

In [Blueprint][bp], `mode` is always set to `"full"{:json}` and cannot be overwritten.

```json filename="tact.config.json" {7,13}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "mode": "full"
    },
    {
      "name": "func_only",
      "path": "./contract.tact",
      "output": "./contract_output",
      "mode": "funcOnly"
    }
  ]
}
```

## Full example

```json filename="tact.config.json" copy=false
{
  "$schema": "http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json",
  "projects": [
    {
      "name": "basic",
      "path": "./basic.tact",
      "output": "./basic_output",
      "mode": "full"
    },
    {
      "name": "func_only",
      "path": "./basic.tact",
      "output": "./basic_output",
      "mode": "funcOnly"
    },
    {
      "name": "debugPrefix",
      "path": "./contracts/contract.tact",
      "output": "./contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "debug": false,
        "external": false,
        "ipfsAbiGetter": true,
        "interfacesGetter": true,
        "experimental": {
          "inline": false
        }
      }
    }
  ]
}
```

[bp]: https://github.com/ton-org/blueprint
[bp-config]: https://github.com/ton-org/blueprint/tree/main?tab=readme-ov-file#configuration


## constants.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/constants.mdx)
---
title: Constants
description: "Immutable values that cannot be changed through reassignment"
---

Constants in Tact could be a little bit more advanced than in popular languages: they could be virtual and abstract. Smart contracts often need to implement multiple traits and sometimes you need to configure some of them in compile time. Constructors in traits are prohibited due to their unpredictable behavior. So, we have to use constants and fields instead to pass values to them. It is the job of a main contract to implement values and constants for all traits.

## Simple constant

Let's start with a simple constant. It is a value that is defined in compile time and cannot be changed. You can define a constant on the top level or inside a contract/trait. Let's define a constant on top level:

```tact
const MY_CONSTANT: Int = 42;
```

Similar for traits and contracts:

```tact
trait MyTrait {
    const MY_CONSTANT: Int = 42;
}

contract MyContract {
    const MY_CONSTANT: Int = 42;
}
```

## Virtual and abstract constants

Virtual constants are the constants that could be defined in a trait but changed in a contract. It is useful when you need to configure some of the traits in compile time. Let's define a virtual constant and an abstract one:

```tact
trait MyTrait {
    virtual const MY_FEE: Int = ton("1.0");
}

trait MyAbstractTrait {
    abstract const MY_DEV_FEE: Int;
}
```

Now you can overwrite defaults in the contract:

```tact
contract MyContract with
    MyTrait,
    MyAbstractTrait, // trailing comma is allowed
{
    override const MY_FEE: Int = ton("0.5");
    override const MY_DEV_FEE: Int = ton("1000");
}
```

This could be very useful to help a compiler to have some values in compile time, for example, you can enable and disable features without needing to change the code and not wasting gas.

```tact
trait Treasure {
    virtual const ENABLE_TIMELOCK: Bool = true;

    receive("Execute") {
        if (self.ENABLE_TIMELOCK) {
            //
            // This branch would be removed in compile time if ENABLE_TIMELOCK is false
            //
        }
    }
}

contract MyContract with Treasure {
    override const ENABLE_TIMELOCK: Bool = false;
}
```


## contracts.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/contracts.mdx)
---
title: Contracts
description: "Contracts in Tact are similar to classes in popular object-oriented languages, except that their instances are deployed on the blockchain and they can't be passed around like Structs and Messages"
---

Contracts in Tact are similar to classes in popular object-oriented languages, except that their instances are deployed on the blockchain and they can't be passed around like [Structs and Messages](/book/structs-and-messages).

## Self-references {#self}

Contracts and [traits][trait] have a built-in [identifier](/book/expressions#identifiers) `self{:tact}`, which is used for referring to their fields (persistent state [variables](#variables) and [constants](#variables)) and methods ([internal functions](#internal-functions)):

```tact
contract Example {
    // persistent state variables
    foo: Int;

    init() {
        self.foo = 42; // <- referencing variable foo through self.
    }
}
```

## Structure

Each contract can contain:

* [Inherited traits](#traits)
* [Supported interfaces](#interfaces)
* [Persistent state variables](#variables)
* [Constructor function `init(){:tact}`](#init-function)
* [Contract constants](#constants)
* [Getter functions](#getter-functions)
* [Receiver functions](#receiver-functions)
* [Internal functions](#internal-functions)

### Inherited traits, `with{:tact}` {#traits}

Contracts can inherit all the declarations and definitions from [traits][trait] and override some of their default behaviours. In addition to that, every contract and trait implicitly inherits the special [`BaseTrait{:tact}` trait](/ref/core-base).

To inherit a [trait][trait], specify its name after the keyword `with{:tact}` in contract's declaration. To inherit multiple traits at once, specify their names in a comma-separated list with an optional trailing comma.

```tact /with/
trait InheritMe {}
trait InheritMeToo {}

// A contract inheriting a single trait
contract Single with InheritMe {}

// A contract inheriting multiple traits
contract Plural with
    InheritMe,
    InheritMeToo, // trailing comma is allowed
{}
```

As [traits][trait] are not allowed to have [`init(){:tact}` function](#init-function), a contract inheriting a trait with any [persistent state variables](#variables) declared must initialize them by providing its own [`init(){:tact}` function](#init-function).

```tact
trait Supe { omelander: Bool }

contract Vot with Supe {
    init() {
        self.omelander = true;
    }
}
```

If declared or defined in a trait, internal functions and constants can be marked as [virtual or abstract](/book/functions#virtual-and-abstract-functions) and overridden in contracts inheriting from the trait.

### Supported interfaces, `@interface(…)` {#interfaces}

It's hard to figure out what a contract does and what [receivers](#receiver-functions) and [getters](#getter-functions) it has without looking at its source code. Sometimes the source is unavailable or inaccessible, and all that's left is to try to disassemble the contract and introspect it that way, which is a very messy and error-prone approach with diminishing returns and no real reproducibility.

In order to resolve this issue, an [OTP-001: Supported Interfaces](/ref/evolution/otp-001) was created. In accordance to it, Tact contracts [can report](/book/config#options-interfacesgetter) the list of supported interfaces as a return value of a special `supported_interfaces` [getter](#getter-functions). That getter is accessible off-chain using any TON Blockchain explorer — one just needs to specify `supported_interfaces` as a method to execute and get a list of hexadecimal values in return.

These hexadecimal values are truncated to the first 128 bit of [SHA-256](https://en.wikipedia.org/wiki/SHA-2#Hash_standard) hashes of the original [`String{:tact}`][p] values of the supported interfaces. The first value in this list **must** be equal to $\mathrm{0x5cec3d5d2cae7b1e84ec39d64a851b66}$ in [hexadecimal notation](/book/integers#hexadecimal), which is the first half of the SHA-256 hash for `"org.ton.introspection.v0"{:tact}`. If the first value is wrong, you must stop trying to introspect the contract, as it doesn't conform to the [Supported Interfaces](/ref/evolution/otp-001) proposal.

To declare support of a certain interface, add one or more `@interface("…"){:tact}` attributes right before contract and [trait][trait] declarations:

```tact
@interface("His name is")
@interface("John")
contract SeeNah with Misc {
    // ...
}

@interface("name_of_your_org - miscellaneous")
trait Misc {
    // ...
}
```

Tact has a small set of interfaces provided under specific conditions:

* `"org.ton.abi.ipfs.v0"{:tact}`, in accordance to [OTP-003: Self-ABI Reporting](/ref/evolution/otp-003) — opt-in via [`ipfsAbiGetter`](/book/config#options-ipfsabigetter) config property
* `"org.ton.deploy.lazy.v0"{:tact}`, in accordance to [OTP-005: Argument-addressable contracts](/ref/evolution/otp-005)
* `"org.ton.debug.v0"{:tact}`, but only if [debug mode](/book/debug#debug-mode) is enabled

Some [traits][trait] in [standard libraries](/ref/standard-libraries) define their interfaces too:

* [`Ownable{:tact}`](/ref/stdlib-ownable#ownable) trait specifies `"org.ton.ownable"{:tact}`
* [`OwnableTransferable{:tact}`](/ref/stdlib-ownable#ownabletransferable) trait specifies `"org.ton.ownable.transferable.v2"{:tact}`
* [`Stoppable{:tact}`](/ref/stdlib-stoppable#stoppable) trait specifies `"org.ton.stoppable"{:tact}`
* [`Resumable{:tact}`](/ref/stdlib-stoppable#resumable) trait specifies `"org.ton.resumable"{:tact}`

To enable `supported_interfaces` [getter](#getter-functions) generation and use `@interface(){:tact}` attribute in your Tact contracts, modify a [`tact.config.json`](/book/config) file in the root of your project (or create it if it didn't exist yet), and [set the `interfacesGetter` property to `true{:json}`](/book/config#options-interfacesgetter).

If you're working on a [Blueprint][bp]-based project, you can enable `supported_interfaces` in the compilation configs of your contracts, which are located in a directory named `wrappers/`:

```typescript title="wrappers/YourContractName.compile.ts" {7}
import { CompilerConfig } from '@ton/blueprint';

export const compile: CompilerConfig = {
  lang: 'tact',
  target: 'contracts/your_contract_name.tact',
  options: {
    interfacesGetter: true, // ← that's the stuff!
  }
};
```

In addition to that, [`tact.config.json`](/book/config) may still be used in [Blueprint][bp] projects. In such cases values specified in [`tact.config.json`](/book/config) act as default unless modified in the `wrappers/`.

:::note

  If you have the `separateCompilables` option set to `true{:typescript}` in the [`blueprint.config.ts`][bp-config], then the `.compile.ts` files will be located in the `compilables/` directory and **not** in `wrappers/`.

:::

:::caution

  Be aware that adding an interface does not guarantee that the contract actually implements any particular functionality, or that it implements it in any particular way. It's just an off-chain, verifiable promise that a contract _might_ have some specific code in it. It's up to you to trust, but verify, such claims.

  In addition, there is no guarantee that there won't be name clashes between different interfaces, although they are unlikely because even the first 128 bits of SHA-256 provide sufficient [collision resistance](https://en.wikipedia.org/wiki/Collision_resistance).

:::

### Persistent state variables {#variables}

Contracts can define state variables that persist between contract calls. Contracts in TON [pay rent](https://docs.ton.org/develop/smart-contracts/fees#storage-fee) in proportion to the amount of persistent space they consume, so [compact representations via serialization](/book/integers#serialization) are encouraged.

```tact
contract Example {
    // persistent state variables
    val: Int;              // Int
    val32: Int as uint32;  // Int serialized to an 32-bit unsigned
    mapVal: map<Int, Int>; // Int keys to Int values
    optVal: Int?;          // Int or null
}
```

State variables must have a default value or initialized in [`init(){:tact}`](#init-function) function, that runs on deployment of the contract. The only exception is persistent state variables of type [`map<K, V>{:tact}`](/book/maps) since they are initialized empty by default.

:::note

  Note, that Tact supports local, non-persistent-state variables too, see: [Variable declaration](/book/statements#let).

:::

### Contract constants {#constants}

Unlike [variables](#variables), constants cannot change. Their values are calculated in _compile-time_ and cannot change during execution.

There isn't much difference between constants defined outside of a contract (global constants) and inside the contract (contract constants). Those defined outside can be used by other contracts in your project.

Constant initializations must be relatively simple and only rely on values known during compilation. If you add two numbers for example, the compiler will calculate the result during build and put the result in your compiled code.

You can read constants both in [receivers](#receiver-functions) and in [getters](#getter-functions).

Unlike [contract variables](#variables), **contract constants don't consume space in persistent state**. Their values are stored directly in the code [`Cell{:tact}`](/book/cells#cells) of the contract.

```tact
// global constants are calculated in compile-time and cannot change
const GlobalConst1: Int = 1000 + ton("42") + pow(10, 9);

contract Example {
    // contract constants are also calculated in compile-time and cannot change
    const ContractConst1: Int = 2000 + ton("43") + pow(10, 9);

    // contract constants can be an easy alternative to enums
    const StateUnpaid: Int = 0;
    const StatePaid: Int = 1;
    const StateDelivered: Int = 2;
    const StateDisputed: Int = 3;

    get fun sum(): Int {
        // access constants from anywhere
        return GlobalConst1 + self.ContractConst1 + self.StatePaid;
    }
}
```

Read more about constants on their dedicated page: [Constants](/book/constants).

### Constructor function `init()` {#init-function}

On deployment of the contract, the constructor function `init(){:tact}` is run.

If a contract has any [persistent state variables](#variables) without default values specified, it must initialize them in this function.

```tact
contract Example {
    // persistent state variables
    var1: Int = 0; // initialized with default value 0
    var2: Int;     // must be initialized in the init() function

    // constructor function
    init() {
        self.var2 = 42;
    }
}
```

If a contract doesn't have any persistent state variables, or they all have their default value specified, it may omit the `init(){:tact}` function declaration altogether. That's because unless explicitly declared, the empty `init(){:tact}` function is present by default in all contracts.

The following is an example of a valid empty contract:

```tact
contract IamEmptyAndIKnowIt {}
```

For your convenience, parameter list of `init(){:tact}` can have a trailing comma:

```tact
contract TheySeeMeTrailing {
    init(
        param1: Int,
        param2: Int, // trailing comma is allowed
    ) {
        // ...
    }
}
```

:::note

  To obtain initial state of the target contract in [internal functions](#internal-functions), [receivers](#receiver-functions) or [getters](#getter-functions) use [`initOf{:tact}`](/book/expressions#initof) expression.

:::

### Getter functions

[Getter functions](/book/functions#getter-functions) are **not accessible from other contracts and exported only to off-chain world**.

Additionally, **getters cannot modify the contract's state variables**, only read their values and use them in expressions.

```tact
contract HelloWorld {
    foo: Int;

    init() {
        self.foo = 0;
    }

    // getter function with return type Int
    get fun foo(): Int {
        return self.foo; // can't change self.foo here
    }
}
```

Read more about them in their dedicated section: [Getter functions](/book/functions#getter-functions)

### Receiver functions

[Receiver functions](/book/functions#receiver-functions) in Tact can be one of the following three kinds:

* [`receive(){:tact}`](/book/receive), which receive internal messages (from other contracts).
* [`bounced(){:tact}`](/book/bounced), which are called when outgoing message from this contract has bounced back.
* [`external(){:tact}`](/book/external), which don't have a sender and can be sent by anyone in the world.

```tact
message CanBounce {
    counter: Int;
}

contract HelloWorld {
    counter: Int;

    init() {
        self.counter = 0;
    }

    get fun counter(): Int {
        return self.counter;
    }

    // internal message receiver, which responds to a string message "increment"
    receive("increment") {
        self.counter += 1;

        // sending the message back to the sender
        send(SendParameters{
            to: sender(),
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
            body: CanBounce{counter: self.counter}.toCell(),
        });
    }

    // bounced message receiver, which is called when the message bounces back to this contract
    bounced(src: bounced<MsBounced>) {
        self.counter = 0; // reset the counter in case message bounced
    }

    // external message receiver, which responds to off-chain message "hello, it's me"
    external("hello, it's me") {
        // can't be replied to as there's no sender!
        self.counter = 0;
    }
}
```

Naming a parameter of the receiver function with an underscore `_{:tact}` makes its value considered unused and discarded. This is useful when you don't need to inspect the message received and you only want it to convey a specific opcode:

```tact
message(42) UniverseCalls {}

contract Example {
    receive(_: UniverseCalls) {
        // Got a Message with opcode 42
    }
}
```

### Internal functions

These functions behave similarly to private methods in popular object-oriented languages — they're internal to contracts and can be called by prefixing them with a special [identifier `self{:tact}`](#self). That's why internal functions can sometimes be referred to as "contract methods".

Internal functions can access the contract's [persistent state variables](#variables) and [constants](#constants).

They can only be called from [receivers](#receiver-functions), [getters](#getter-functions) and other internal functions, but not from other contracts or [`init(){:tact}`](#init-function).

```tact
contract Functions {
    val: Int = 0;

    // this contract method can only be called from within this contract and access its variables
    fun onlyZeros() {
        require(self.val == 0, "Only zeros are permitted!");
    }

    // receiver function, which calls the internal function onlyZeros
    receive("only zeros") {
        self.onlyZeros();
    }
}
```

:::note

  Note, that Tact supports other kinds of functions too, see: [Functions](/book/functions).

:::

[p]: /book/types#primitive-types
[trait]: /book/types#traits

[bp]: https://github.com/ton-org/blueprint
[bp-config]: https://github.com/ton-org/blueprint/tree/main?tab=readme-ov-file#configuration


## debug.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/debug.mdx)
---
title: Debugging Tact contracts
description: "Various ways to reveal problems or bugs in Tact code"
---

import { LinkCard, CardGrid, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

Without fail, the code we write as smart contract developers doesn’t always do what we expected it to do. Sometimes it does something completely different! When the unexpected happens, the next task is to figure out why. To do so, there are various ways to reveal problems or "bugs" in the code. Let's get to *debugging*!

<CardGrid>
  <LinkCard
    title="General approach"
    href="#approach"
  />
  <LinkCard
    title="Debug mode"
    href="#debug-mode"
  />
  <LinkCard
    title="Structure of tests"
    href="#tests-structure"
  />
  <LinkCard
    title="Dump values"
    href="#tests-dump"
  />
  <LinkCard
    title="Expect certain states"
    href="#tests-errors"
  />
  <LinkCard
    title="Send messages"
    href="#tests-send"
  />
  <LinkCard
    title="Observe fees"
    href="#tests-fees"
  />
  <LinkCard
    title="Expect exit codes"
    href="#tests-errors"
  />
  <LinkCard
    title="Simulate time"
    href="#tests-time"
  />
  <LinkCard
    title="Emit and log messages"
    href="#logging"
  />
  <LinkCard
    title="Handle bounced messages"
    href="#bounced"
  />
  <LinkCard
    title="Experimental lab setup"
    href="#lab"
  />
</CardGrid>

## General approach {#approach}

At the moment, Tact doesn't have a step-through debugger. Despite that, it's still possible to use the ["printf debugging"](https://en.wikipedia.org/wiki/Debugging#printf_debugging) approach.

It involves actively placing [`dump(){:tact}`][dump] and [`dumpStack(){:tact}`](/ref/core-debug#dumpstack) function calls throughout your code and observing states of variables at a given point of time. Note, that those functions work only in a [debug mode](#debug-mode) and won't be executed otherwise.

:::note

  See how to use [`dump(){:tact}`][dump] for debugging: [Debug with `dump(){:tact}`](#tests-dump).

:::

In addition to dumping values, it's often helpful to use assertive functions like [`require(){:tact}`](/ref/core-debug#require), [`nativeThrowIf(){:tact}`](/ref/core-debug#nativethrowif) and [`nativeThrowUnless(){:tact}`](/ref/core-debug#nativethrowunless). They help stating your assumptions clear, and are handy for setting up "trip wires" for catching issues in the future.

And if you didn't find or cannot resolve the cause of your issues, try asking the community in Tact's [Telegram chat][tg] or, if your issue or question is generally related to TON more than it's related to Tact, hop into [TON Dev Telegram chat](https://t.me/tondev_eng).

## Common debugging functions {#debug-functions}

Tact provides a handful amount of various functions useful for debugging: [Core library → Debug](/ref/core-debug).

## Enabling debug mode in compilation options {#debug-mode}

In order to make certain functions like [`dump(){:tact}`][dump] or [`dumpStack(){:tact}`](/ref/core-debug#dumpstack) work, one needs to enable debug mode.

The simplest and recommended approach is to modify a [`tact.config.json`](/book/config) file in the root of your project (or create it if it didn't exist yet), and [set the `debug` property to `true{:json}`](/book/config#options-debug).

If you're working on a [Blueprint][bp]-based project, you can enable debug mode in the compilation configs of your contracts, which are located in a directory named `wrappers/`:

```typescript title="wrappers/YourContractName.compile.ts" {7}
import { CompilerConfig } from '@ton/blueprint';

export const compile: CompilerConfig = {
  lang: 'tact',
  target: 'contracts/your_contract_name.tact',
  options: {
    debug: true, // ← that's the stuff!
  }
};
```

Note, that versions of [Blueprint][bp] starting with 0.20.0 automatically enable debug mode in `wrappers/` for new contracts.

In addition to that, [`tact.config.json`](/book/config) may still be used in [Blueprint][bp] projects. In such cases values specified in [`tact.config.json`](/book/config) act as default unless modified in the `wrappers/`.

:::note

  If you have the `separateCompilables` option set to `true{:typescript}` in the [`blueprint.config.ts`][bp-config], then the `.compile.ts` files will be located in the `compilables/` directory and **not** in `wrappers/`.

:::

:::note

  Read more about configuration and [`tact.config.json`](/book/config) file: [Configuration](/book/config).\
  See how to use [`dump(){:tact}`][dump] for debugging: [Debug with `dump(){:tact}`](#tests-dump).

:::

## Writing tests in Blueprint, with Sandbox and Jest {#tests}

The [Blueprint][bp] is a popular development framework for writing, testing and deploying smart contracts on TON Blockchain.

For testing smart contracts it uses the [Sandbox][sb], a local TON Blockchain emulator and [Jest][jest], a JavaScript testing framework.

Whenever you create a new [Blueprint][bp] project or use `blueprint create` command inside the existing project, it creates a new contract alongside with a test suite file for it.

Those files are placed in `tests/` folder and executed with [Jest][jest]. By default, all tests run, unless you specify specific group or test closure. For other options, refer to the brief documentation in the Jest CLI: `jest --help`.

### Structure of test files {#tests-structure}

Let's say that we have a contract named `Playground`, written in `contracts/playground.tact` file. If we've created that contract through [Blueprint][bp], then it also created a `tests/Playground.spec.ts` test suite file for us.

The test file contains a single `describe(){:typescript}` [Jest][jest] function call, which denotes a test group.

Inside that group, you'll have three variables, available in all tests within:

* `blockchain` — local blockchain instance provided by [Sandbox][sb]
* `deployer` — a TypeScript wrapper used for deploying our `Playground` contract or any other we'd like to be deployed
* `playground` — a TypeScript wrapper for our `Playground` contract

:::note

  It's a common mistake to update `.tact` code and run tests without making a build first. That's because tests in [Blueprint][bp] rely on TypeScript wrappers generated by a Tact compiler and work with the latest build made.

  That's why every time you make a change to your Tact code, make sure to also build it with `npx blueprint build` before you execute the test suite. For your convenience, you may unite builds and tests into a single command, as shown in the [experimental lab setup](#lab-4).

:::

Then, a `beforeEach(){:tact}` [Jest][jest] function is called — it specifies all the code to be executed before each of the subsequent test closures.

:::note

  It is strongly advised not to modify the contents of `beforeEach(){:tact}`, unless you really need some specific behavior for each test closure or parameters of your [`init(){:tact}`](/book/contracts#init-function) function have changed.

:::

Finally, each test closure is described with a call to `it(){:tact}` [Jest][jest] function — that's where tests are actually written.

A simplest example of the test closure can look like that:

```typescript
it('should deploy', async () => {
  // The check is done inside beforeEach, so this can be empty
});
```

### Debug with `dump()` {#tests-dump}

:::note

  Calling [`dump(){:tact}`][dump] is computationally expensive and consumes a lot of gas. Be sure to always supply enough Toncoins in your tests to avoid [exit code -14](/book/exit-codes#-14).

:::

To see results of [`dump(){:tact}`][dump] function calls and use ["printf debugging"](#approach) approach, one has to:

1. Put calls to [`dump(){:tact}`][dump] and other [common debugging functions](#debug-functions) in relevant places of the code.
2. Run [Jest][jest] tests, which would call target functions and send messages to target receivers.

Assuming you've created a [new counter contract project](/#start), let's see how it works in practice.

First, let's place a call to [`dump(){:tact}`][dump] in `contracts/simple_counter.tact`, which would output the `amount` passed in `msg{:tact}` [Struct][struct] to contract's debug console:

```tact title="contracts/simple_counter.tact" {3}
// ...
receive(msg: Add) {
    dump(msg.amount);
    // ...
}
// ...
```

Next, let's comment out all existing `it(){:typescript}` test closures in `tests/SimpleCounter.spec.ts` file. And then add the following one:

```typescript title="tests/SimpleCounter.spec.ts"
it('should dump', async () => {
  await playground.send(
    deployer.getSender(),
    { value: toNano('0.5') },
    { $$type: 'Add', queryId: 1n, amount: 1n },
  );
});
```

It sends a message to our contract's `receive(msg: Add){:tact}` [receiver](/book/receive) without storing the [results of such send](#tests-send).

Now, if we build our contract with `yarn build{:shell}` and run our test suite with `yarn test{:shell}`, we'll see the following in the test logs:

```txt
console.log
  #DEBUG#: [DEBUG] File contracts/simple_counter.tact:17:9
  #DEBUG#: 1

    at SmartContract.runCommon (node_modules/@ton/sandbox/dist/blockchain/SmartContract.js:221:21)
```

Which is produced by of our [`dump(){:tact}`][dump] call above.

:::note

  Read more about sending messages to contracts in tests: [Send messages to contracts](#tests-send).

:::

### State expectations with `expect()` {#tests-expect}

The integral parts of writing tests is ensuring that your expectations match the observed reality. For that, [Jest][jest] provides a function `expect(){:tact}`, which is used as follows:

1. First, an observed variable is provided.
2. Then, a specific method is called to check a certain property of that variable.

Here's a more involved example, which uses `expect(){:tact}` function to check that counter contract actually properly increases the counter:

```typescript
it('should increase counter', async () => {
  const increaseTimes = 3;
  for (let i = 0; i < increaseTimes; i++) {
    console.log(`increase ${i + 1}/${increaseTimes}`);

    const increaser = await blockchain.treasury('increaser' + i);

    const counterBefore = await simpleCounter.getCounter();
    console.log('counter before increasing', counterBefore);

    const increaseBy = BigInt(Math.floor(Math.random() * 100));
    console.log('increasing by', increaseBy);

    const increaseResult = await simpleCounter.send(
      increaser.getSender(),
      { value: toNano('0.05') },
      { $$type: 'Add', queryId: 0n, amount: increaseBy }
    );

    expect(increaseResult.transactions).toHaveTransaction({
      from: increaser.address,
      to: simpleCounter.address,
      success: true,
    });

    const counterAfter = await simpleCounter.getCounter();
    console.log('counter after increasing', counterAfter);

    expect(counterAfter).toBe(counterBefore + increaseBy);
  }
});
```

:::note

  See more test examples in the [Sandbox][sb] documentation:\
  [Testing flow (FunC)](https://github.com/ton-org/sandbox/blob/main/docs/testing-key-points.md)\
  [Writing tests for Tact](https://github.com/ton-org/sandbox/blob/main/docs/tact-testing-examples.md)

:::

### Utility methods {#tests-jest-utils}

Test files generated by [Blueprint][bp] import `@ton/test-utils` library, which provides access to a number of additional helper methods for the result type of `expect(){:typescript}` [Jest][jest] function. Note, that regular methods like `toEqual(){:typescript}` are still there and ready to be used.

#### toHaveTransaction

The method `expect(…).toHaveTransaction(){:typescript}` checks that the list of transactions has a transaction matching certain properties you specify:

```typescript {2}
const res = await yourContractName.send(…);
expect(res.transactions).toHaveTransaction({
  // For example, let's check that a transaction to your contract was successful:
  to: yourContractName.address,
  success: true,
});
```

To know the full list of such properties, look at auto-completion options provided by your editor or IDE.

#### toEqualCell

The method `expect(…).toEqualCell(){:typescript}` checks equality of two [cells](/book/cells#cells):

```typescript {3}
expect(oneCell).toEqualCell(anotherCell);
```

#### toEqualSlice

The method `expect(…).toEqualSlice(){:typescript}` checks equality of two [slices](/book/cells#slices):

```typescript {3}
expect(oneSlice).toEqualSlice(anotherSlice);
```

#### toEqualAddress

The method `expect(…).toEqualAddress(){:typescript}` checks equality of two [addresses](/book/types#primitive-types):

```typescript {3}
expect(oneAddress).toEqualAddress(anotherAddress);
```

### Send messages to contracts {#tests-send}

To send messages to contracts, use `.send(){:typescript}` method on their TypeScript wrappers like so:

```typescript
// It accepts 3 arguments:
await yourContractName.send(
  // 1. sender of the message
  deployer.getSender(), // this is a default treasury, can be replaced

  // 2. value and (optional) bounce, which is true by default
  { value: toNano('0.5'), bounce: false },

  // 3. a message body, if any
  'Look at me!',
);
```

Message body can be a simple string, or an object specifying fields of the [Message](/book/structs-and-messages#messages) type:

```typescript {4-8}
await yourContractName.send(
  deployer.getSender(),
  { value: toNano('0.5') },
  {
    $$type: 'NameOfYourMessageType',
    field1: 0n, // bigint zero
    field2: 'yay',
  },
);
```

More often than not, it's important to store results of such sends, because they contain events occurred, transactions made and external messages sent:

```typescript
const res = await yourContractName.send(…);
// res.events — array of events occurred
// res.externals — array of external-out messages
// res.transactions — array of transactions made
```

With that, we can easily filter or check certain transactions:

```typescript
expect(res.transactions).toHaveTransaction(…);
```

### Observe the fees and values {#tests-fees}

[Sandbox][sb] provides a helper function `printTransactionFees(){:typescript}`, which pretty-prints all the values and fees that went into transactions provided. It is quite handy for observing the flow of [nanoToncoins](/book/integers#nanotoncoin).

To use it, modify imports from `@ton/sandbox` on top of the test file:

```typescript
import { Blockchain, SandboxContract, TreasuryContract, printTransactionFees } from '@ton/sandbox';
//                                                      ^^^^^^^^^^^^^^^^^^^^
```

Then, provide an array of transactions as an argument, like so:

```typescript
printTransactionFees(res.transactions);
```

To work with individual values of total fees or fees from compute and action [phases](https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases), inspect each transaction individually:

```typescript {11,17,21}
// Storing the transaction handled by the receiver in a separate constant
const receiverHandledTx = res.transactions[1];
expect(receiverHandledTx.description.type).toEqual('generic');

// Needed to please TypeScript
if (receiverHandledTx.description.type !== 'generic') {
  throw new Error('Generic transaction expected');
}

// Total fees
console.log('Total fees: ', receiverHandledTx.totalFees);

// Compute fee
const computeFee = receiverHandledTx.description.computePhase.type === 'vm'
  ? receiverHandledTx.description.computePhase.gasFees
  : undefined;
console.log('Compute fee: ', computeFee);

// Action fee
const actionFee = receiverHandledTx.description.actionPhase?.totalActionFees;
console.log('Action fee: ', actionFee);

// Now we can do some involved checks, like limiting the fees to 1 Toncoin
expect(
  (computeFee ?? 0n)
  + (actionFee ?? 0n)
).toBeLessThanOrEqual(toNano('1'));
```

:::note

  [Sandbox][sb] has many more utility functions, which are often handy. For example, it provides `prettyLogTransaction(){:typescript}` and `prettyLogTransactions(){:typescript}`, which operate on a single or multiple transactions respectively and pretty-print flow of values between the addresses.

:::

### Transactions with intentional errors {#tests-errors}

Sometimes it's useful to make negative tests, featuring intentional errors and throwing specific [exit codes](/book/exit-codes).

Example of such [Jest][jest] test closure in [Blueprint][bp]:

```typescript title="tests/YourTestFileHere.spec.ts" {9,15}
it('throws specific exit code', async () => {
  // Send a specific message to our contract and store the results
  const res = await your_contract_name.send(
    deployer.getSender(),
    {
      value: toNano('0.5'), // value in nanoToncoins sent
      bounce: true,         // (default) bounceable message
    },
    'the message your receiver expects', // ← change it to yours
  );

  // Expect the transaction to our contract fail with a certain exit code
  expect(res.transactions).toHaveTransaction({
    to: your_contract_name.address,
    exitCode: 5, // ← change it to yours
  });
});
```

Note, that to track down transactions with a certain exit code, you only need to specify `exitCode` field in object argument to the `toHaveTransaction(){:typescript}` method of `expect(){:typescript}`.

However, it's useful to narrow the scope by specifying the recipient address `to`, such that Jest would look only at the transaction caused by our message to the contract.

### Simulate passage of time {#tests-time}

The Unix time in local blockchain instances provided by [Sandbox][bp] starts at the moment of the creation of those in `beforeEach(){:typescript}` block.

```typescript {2}
beforeEach(async () => {
  blockchain = await Blockchain.create(); // ← here
  // ...
});
```

Previously, we've been warned not to modify the `beforeEach(){:typescript}` block unless we really need to. And now, to override the time and time travel a little, we do.

Let's add the following line by the end of it, setting `blockchain.now` explicitly to the time when deployment message was handled:
```typescript {3}
beforeEach(async () => {
  // ...
  blockchain.now = deployResult.transactions[1].now;
});
```

Now, we can manipulate time in out test clauses. For example, let's make a transaction one minute after the deployment and another one after two:

```typescript {2,4}
it('your test clause title', async () => {
  blockchain.now += 60; // 60 seconds late
  const res1 = await yourContractName.send(…);
  blockchain.now += 60; // another 60 seconds late
  const res2 = await yourContractName.send(…);
});
```

## Logging via `emit` {#logging}

A [global static function](/book/functions#global-static-functions) [`emit(){:tact}`](/ref/core-common#emit) sends a message to the outer world — it doesn't have a specific recipient.

This function is very handy for logging and analyzing data off-chain — one just has to look at [external messages](/book/external) produced by the contract.

### Logs in local Sandbox tests {#logging-local}

When deploying in the [Sandbox][sb], you may call [`emit(){:tact}`](/ref/core-common#emit) from a [receiver function](/book/contracts#receiver-functions) and then observe the list of sent [external messages](/book/external):

```typescript {9-10}
it('emits', async () => {
  const res = await simpleCounter.send(
    deployer.getSender(),
    { value: toNano('0.05') },
    'emit_receiver', // ← change to the message your receiver handles
  );

  console.log("Address of our contract: " + simpleCounter.address);
  console.log(res.externals); // ← here one would see results of emit() calls,
                              //   and all external messages in general
});
```

### Logs of a deployed contract {#logging-deployed}

Every transaction on TON Blockchain [contains `out_msgs`](https://docs.ton.org/develop/data-formats/transaction-layout#transaction) — a dictionary that holds the list of outgoing messages that were created while executing the transaction.

To see logs from [`emit(){:tact}`](/ref/core-common#emit) in that dictionary, look for external messages without a recipient. In various TON Blockchain explorers, such transactions will be marked as `external-out` with destination specified as `-` or `empty`.

Note, that some explorers deserialize the message body sent for you, while others don't. However, you can always [parse it yourself](#logging-parsing) locally.

### Parsing body of the emitted message {#logging-parsing}

Consider the following example:

```tact
// We have a Struct
struct Ballroom {
    meme: Bool;
    in: Int;
    theory: String;
}

// And a simple contract,
contract Bonanza {
    // which can receive a String message,
    receive("time to emit") {
        // emit a String
        emit("But to the Supes? Absolutely diabolical.".asComment());

        // and a Struct
        emit(Ballroom{meme: true, in: 42, theory: "Duh"}.toCell());
    }
}
```

Now, let's make a simple [test clause](#tests-structure) for the `Bonanza` contract:

```typescript /bonanza/
it('emits', async () => {
  const res = await bonanza.send(
    deployer.getSender(),
    { value: toNano('0.05') },
    'time to emit',
  );
});
```

There, the `res` object would contain the list of sent [external messages](/book/external) as its `externals` field. Let's access it to parse the first message sent via a call to [`emit(){:tact}`](/ref/core-common#emit) in Tact code (or _emitted_ for short):

```typescript /body/
it('emits', async () => {
  // ... prior code ...

  // We'll need only the body of the observed message:
  const firstMsgBody = res.externals[0].body;

  // Now, let's parse it, knowing that it's a text message.
  // NOTE: In a real-world scenario,
  //       you'd want to check that first or wrap this in a try...catch
  const firstMsgText = firstMsgBody.asSlice().loadStringTail();

  // "But to the Supes? Absolutely diabolical."
  console.log(firstMsgText);
});
```

To parse the second emitted message, we could manually use a bunch of `.loadSomething(){:typescript}` functions, but that's way too brittle — if the fields of the `Ballroom{:tact}` [Struct][struct] even change, you'd need to start all over. That could really backfire when you have a lot of tests written in that manner.

Fortunately, Tact compiler auto-generates TypeScript bindings (or wrappers) for the contracts, and it's really easy to re-use them in your test suite. Not only they have a wrapper of the contract you're testing, but they also export a bunch of helper functions to store or load [Structs][struct] and [Messages][message] defined in the contract. The latter will be named just like the [Structs][struct] and [Messages][message] are, but with the `load` prefix in front.

For example, in our case we'll need a function called `loadBallroom(){:typescript}`, for parsing a [`Slice{:tact}`][slice] into the `Ballroom{:tact}` [Struct][struct] in TypeScript. To import it, either type the name and let your IDE suggest auto-importing it for you, or take a look at the top of your test suite file — there should be a similar line:

```typescript
import { Bonanza } from '../wrappers/Bonanza';
//              ^ here you could import loadBallroom
```

With that, let's parse the second emitted message:

```typescript
it('emits', async () => {
  // ... prior code ...

  // We'll need only the body of the observed message:
  const secondMsgBody = res.externals[1].body;

  // Now, let's parse it, knowing that it's the Ballroom Struct.
  // NOTE: In a real-world scenario,
  //       you'd want to check that first or wrap this in a try...catch
  const secondMsgStruct = loadBallroom(secondMsgBody.asSlice());

  // { '$$type': 'Ballroom', meme: true, in: 42n, theory: 'Duh' }
  console.log(secondMsgStruct);
});
```

Mind you, that it's also possible to parse emitted messages of deployed contracts even outside of our test suite. You would just need to obtain the emitted message bodies and then use the auto-generated TypeScript bindings of Tact alongside the `@ton/core` library just like we did in those examples above.

## Handling bounced messages {#bounced}

When [sent](/book/send) with `bounce: true{:tact}`, messages can bounce back in case of errors. Make sure to write relevant [`bounced(){:tact}`](/book/bounced) message [receivers](/book/contracts#receiver-functions) and handle bounced messages gracefully:

```tact
bounced(msg: YourMessage) {
    // ...alright squad, let's bounce!...
}
```

Keep in mind that bounced messages in TON have only $224$ usable data bits in their message body and don't have any references, so one cannot recover much data from it. However, you still get to see whether the message has bounced or not, allowing you to create more robust contracts.

Read more about bounced messages and receivers: [Bounced messages](/book/bounced).

## Experimental lab setup {#lab}

If you're overwhelmed by the testing setup of [Blueprint][bp] or just want to test some things quickly, worry not — there is a way to set up a simple playground as an experimental lab to test your ideas and hypotheses.

<Steps>

1. #### Create a new Blueprint project {#lab-1}

   That will prevent pollution of your existing one with arbitrary code and tests.

   The new project can be named anything, but I'll name it `Playground` to convey the right intent.

   To create it, run the following command:

   <Tabs>
     <TabItem label="yarn" icon="seti:yarn">
       ```shell
       # recommended
       yarn create ton tact-playground --type tact-empty --contractName Playground
       ```
     </TabItem>
     <TabItem label="npm" icon="seti:npm">
       ```shell
       npm create ton@latest -- tact-playground --type tact-empty --contractName Playground
       ```
     </TabItem>
     <TabItem label="pnpm" icon="pnpm">
       ```shell
       pnpm create ton@latest tact-playground --type tact-empty --contractName Playground
       ```
     </TabItem>
     <TabItem label="bun" icon="bun">
       ```shell
       bun create ton@latest tact-playground --type tact-empty --contractName Playground
       ```
     </TabItem>
   </Tabs>

   Versions of [Blueprint][bp] starting with 0.20.0 automatically enable debug mode in `wrappers/` for new contracts, so we only have to adjust the testing suite and prepare our `Playground` contract for testing.

2. #### Update the test suite {#lab-2}

   Move into the newly created `tact-playground/` project and in the `tests/Playground.spec.ts`, change the `"should deploy"{:tact}` test closure to the following:

   ```typescript title="tests/Playground.spec.ts"
   it('plays', async () => {
     const res = await playground.send(
       deployer.getSender(),
       { value: toNano('0.5') }, // ← here you may increase the value in nanoToncoins sent
       'plays',
     );

     console.log("Address of our contract: " + playground.address);
     console.log(res.externals); // ← here one would see results of emit() calls
   });
   ```

3. #### Modify the contract {#lab-3}

   Replace the code in `contracts/playground.tact` with the following:

   ```tact title="contracts/playground.tact" {4-6}
   import "@stdlib/deploy";

   contract Playground with Deployable {
       receive("plays") {
           // NOTE: write your test logic here!
       }
   }
   ```

   The basic idea of this setup is to place the code you want to test into the [receiver function](/book/contracts#receiver-functions) responding to the [string](/book/types#primitive-types) message `"plays"{:tact}`.

   Note, that you can still write any valid Tact code outside of that [receiver](/book/contracts#receiver-functions). But in order to test it you'll need to write related test logic inside of it.

4. #### Let's test! {#lab-4}

   With that, our experimental lab setup is complete. To execute that single test we've prepared for our `Playground` contract, run the following:

   ```shell
   yarn test -t plays
   ```

   From now on, to test something you only need to modify the contents of the tested [receiver function](/book/contracts#receiver-functions) of your Tact contract file and re-run the command above. Rinse and repeat that process until you've tested what you wanted to test.

   For simplicity and cleaner output's sake, you may add a new field to `scripts` in your `package.json`, such that you'll only need to run `yarn lab{:shell}` to build and test in one.

   On Linux or macOS, it would look like:

   ```json filename="package.json" {3}
   {
     "scripts": {
       "lab": "blueprint build --all 1>/dev/null && yarn test -t plays"
     }
   }
   ```

   And here's how it may look on Windows:

   ```json filename="package.json" {3-4}
   {
     "scripts": {
       "build": "blueprint build --all | out-null",
       "lab": "yarn build && yarn test -t plays"
     }
   }
   ```

   To run:

   ```shell
   yarn lab
   ```

</Steps>

[dump]: /ref/core-debug#dump
[struct]: /book/structs-and-messages#structs
[message]: /book/structs-and-messages#messages
[cell]: /book/cells#cells
[slice]: /book/cells#slices

[tg]: https://t.me/tactlang
[bp]: https://github.com/ton-org/blueprint
[bp-config]: https://github.com/ton-org/blueprint/tree/main?tab=readme-ov-file#configuration
[sb]: https://github.com/ton-org/sandbox
[jest]: https://jestjs.io


## deploy.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/deploy.mdx)
---
title: Deployment
description: "Common ways to deploy Tact contracts to testnet or mainnet of TON Blockchain"
prev:
  link: /book/message-mode
  label: Message mode
---

Tact Deployer is a small library that integrates with [TON Verifier](https://verifier.ton.org) that allows you to deploy your contracts safely using your favorite wallet without needing to manage keys or deploy contracts manually. Tact Deployer also automatically verifies your contract's source code and you can be sure that your compiler is not compromised.

## Requirements

Your contract MUST have the `Deployer` trait from the `@stdlib/deploy` package to be able to use Tact Deployer.

## Installation

To add Tact Deployer to your project, just use `yarn`:

```bash
yarn add @tact-lang/deployer
```

## How to use

When you build your smart contracts using Tact, it produces a package (*.pkg) file that has all the required information about the built smart contract. To deploy your smart contract, you need to create a deployer instance, pass your package file to it and provide initial data for your contract.

```typescript
import * as fs from 'fs';
import * as path from 'path';
import { Address, contractAddress } from "ton";
import { SampleTactContract } from "./output/sample_SampleTactContract";
import { prepareTactDeployment } from "@tact-lang/deployer";

// Parameters
let testnet = true;                                 // Flag for testnet or mainnet
let packageName = 'sample_SampleTactContract.pkg';  // Name of your package to deploy
let outputPath = path.resolve(__dirname, 'output'); // Path to output directory
let owner = Address.parse('<put_address_here>');    // Our sample contract has an owner
let init = await SampleTactContract.init(owner);    // Create initial data for our contract

// Calculations
let address = contractAddress(0, init);     // Calculate contract address. MUST match with the address in the verifier
let data = init.data.toBoc();               // Create init data
let pkg = fs.readFileSync(                  // Read package file
    path.resolve(outputPath, packageName)
);

// Prepare deploy
let link = await prepareTactDeployment({ pkg, data, testnet });

// Present a deployment link and contract address
console.log('Address: ' + address.toString({ testOnly: testnet }));
console.log('Deploy link: ' + link);
```

After following this link you will be able to deploy and verify your smart contract.


## exit-codes.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/exit-codes.mdx)
---
title: Exit codes
description: "An exit code is a 32-bit signed integer, which indicates whether the compute or action phase of the transaction was successful, and if not — holds the code of the exception occurred"
---

import { Badge } from '@astrojs/starlight/components';

Each transaction on TON Blockchain consists of [multiple phases](https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases). An _exit code_ is a $32$-bit signed integer, which indicates whether the [compute](#compute) or [action](#action) phase of the transaction was successful, and if not — holds the code of the exception occurred. Each exit code represents its own exception or resulting state of the transaction.

Exit codes $0$ and $1$ indicate normal (successful) execution of the [compute phase](#compute). Exit (or [result](#action)) code $0$ indicates normal (successful) execution of the [action phase](#action). Any other exit code indicates that a certain exception has occurred and that the transaction wasn't successful in one way or another, i.e. transaction was reverted or the inbound message has bounced back.

TON Blockchain reserves exit code values from $0$ to $127$, while Tact utilizes exit codes from $128$ to $255$. Note, that exit codes used by Tact indicate contract errors which can occur when using Tact-generated FunC code, and are therefore thrown in the transaction's [compute phase](#compute) and not during the compilation.

The range from $256$ to $65535$ is free for developer-defined exit codes.

:::note

  While an exit (or [result](#action)) code is a $32$-bit signed integer on TON Blockchain, an attempt to [throw](/ref/core-debug) an exit code out of bounds of the $16$-bit unsigned integer ($0 - 65535$) will cause an error with [exit code 5](#5). That's done intentionally to prevent some exit codes from being produced artificially, such as the [exit code -14](#-14).

:::

## Table of exit codes {#table}

The following table lists exit codes with an origin (where it can occur) and a short description for each. The table doesn't list the exit code of the [`require()`](/ref/core-debug#require), as it generates it depending on the concrete `error` message [String][p].

Exit code     | Origin                              | Brief description
:------------ | :---------------------------------- | :----------------
[$0$](#0)     | [Compute][c] and [action][a] phases | Standard successful execution exit code.
[$1$](#1)     | [Compute phase][c]                  | Alternative successful execution exit code. Reserved, but doesn't occur.
[$2$](#2)     | [Compute phase][c]                  | Stack underflow.
[$3$](#3)     | [Compute phase][c]                  | Stack overflow.
[$4$](#4)     | [Compute phase][c]                  | Integer overflow.
[$5$](#5)     | [Compute phase][c]                  | Range check error — some integer is out of its expected range.
[$6$](#6)     | [Compute phase][c]                  | Invalid [TVM][tvm] opcode.
[$7$](#7)     | [Compute phase][c]                  | Type check error.
[$8$](#8)     | [Compute phase][c]                  | Cell overflow.
[$9$](#9)     | [Compute phase][c]                  | Cell underflow.
[$10$](#10)   | [Compute phase][c]                  | Dictionary error.
[$11$](#11)   | [Compute phase][c]                  | Described in [TVM][tvm] docs as "Unknown error, may be thrown by user programs".
[$12$](#12)   | [Compute phase][c]                  | Fatal error. Thrown by [TVM][tvm] in situations deemed impossible.
[$13$](#13)   | [Compute phase][c]                  | Out of gas error.
[$-14$](#-14) | [Compute phase][c]                  | Same as $13$. Negative, so that it [cannot be faked](#13).
[$14$](#14)   | [Compute phase][c]                  | VM virtualization error. Reserved, but never thrown.
[$32$](#32)   | [Action phase][a]                   | Action list is invalid.
[$33$](#33)   | [Action phase][a]                   | Action list is too long.
[$34$](#34)   | [Action phase][a]                   | Action is invalid or not supported.
[$35$](#35)   | [Action phase][a]                   | Invalid source address in outbound message.
[$36$](#36)   | [Action phase][a]                   | Invalid destination address in outbound message.
[$37$](#37)   | [Action phase][a]                   | Not enough Toncoin.
[$38$](#38)   | [Action phase][a]                   | Not enough extra currencies.
[$39$](#39)   | [Action phase][a]                   | Outbound message does not fit into a cell after rewriting.
[$40$](#40)   | [Action phase][a]                   | Cannot process a message — not enough funds, the message is too large or its Merkle depth is too big.
[$41$](#41)   | [Action phase][a]                   | Library reference is null during library change action.
[$42$](#42)   | [Action phase][a]                   | Library change action error.
[$43$](#43)   | [Action phase][a]                   | Exceeded maximum number of cells in the library or the maximum depth of the Merkle tree.
[$50$](#50)   | [Action phase][a]                   | Account state size exceeded limits.
[$128$](#128) | Tact compiler ([Compute phase][c])  | Null reference exception.
[$129$](#129) | Tact compiler ([Compute phase][c])  | Invalid serialization prefix.
[$130$](#130) | Tact compiler ([Compute phase][c])  | Invalid incoming message — there's no receiver for the opcode of the received message.
[$131$](#131) | Tact compiler ([Compute phase][c])  | Constraints error. Reserved, but never thrown.
[$132$](#132) | Tact compiler ([Compute phase][c])  | Access denied — someone other than the owner sent a message to the contract.
[$133$](#133) | Tact compiler ([Compute phase][c])  | Contract stopped. Reserved, but never thrown.
[$134$](#134) | Tact compiler ([Compute phase][c])  | Invalid argument.
[$135$](#135) | Tact compiler ([Compute phase][c])  | Code of a contract was not found.
~~[$136$](#136)~~ | ~~Tact compiler ([Compute phase][c])~~  | ~~Invalid address.~~ Removed since Tact 1.6
~~[$137$](#137)~~ | ~~Tact compiler ([Compute phase][c])~~  | ~~Masterchain support is not enabled for this contract.~~ Removed since Tact 1.6

:::note

  Often enough you might encounter the exit code $65535$ (or `0xffff`), which usually means the same as the [exit code 130](#130) — the received opcode is unknown to the contract as there were no receivers expecting it. When writing contracts, the exit code $65535$ is set by the developers and not by [TVM][tvm]or the Tact compiler.

:::

[c]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase
[a]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases

## Exit codes in Blueprint projects {#blueprint}

In [Blueprint][bp] tests, exit codes from the [compute phase](#compute) are specified in the `exitCode` field of the object argument for `toHaveTransaction(){:typescript}` method of `expect(){:typescript}` matcher. The field for the [result](#action) codes (exit codes from the [action phase](#action)) in the same `toHaveTransaction(){:typescript}` method is called `actionResultCode`.

:::note

  Read more about expecting specific exit codes: [Transactions with intentional errors](/book/debug#tests-errors).

:::

Additionally, one can take a look at the result of [sending a message to a contract](/book/debug#tests-send) and discover the phases of each transaction and their values, including exit (or result) codes for [compute phase](#compute) (or [action phase](#action)).

Note, that in order to do so, you'll have to do a couple of type checks before that:

```typescript
it('tests something, you name it', async () => {
  // Send a specific message to our contract and store the results
  const res = await your_contract_name.send(…);

  // Now, we have an access to array of executed transactions,
  // with the second one (index 1) being the one that we look for
  const tx = res.transactions[1]!;

  // To do something useful with it, let's ensure that it's type is 'generic'
  // and that the compute phase in it wasn't skipped
  if (tx.description.type === "generic"
      && tx.description.computePhase.type === "vm") {
    // Finally, we're able to freely peek into the transaction for general details,
    // such as printing out the exit code of the compute phase if we so desire
    console.log(tx.description.computePhase.exitCode);
  }

  // ...
});
```

## Compute and action phases

### 0: Normal termination {#0}

This exit (or [result](#action)) code indicates a successful completion of the [compute](#compute) (or [action](#action)) phase of the transaction.

## Compute phase {#compute}

[TVM][tvm] initialization and all computations occur in the [compute phase][c].

If the compute phase fails (the resulting exit code isn't [$0$](#0) or [$1$](#1)), the transaction skips the [action phase](#action) and goes to the bounce phase. In it, the bounce message is formed for the transactions initiated by the inbound message.

### 1: Alternative termination {#1}

This is an alternative exit code for the successful execution of the [compute phase](#compute). Reserved, but never occurs.

### 2: Stack underflow {#2}

If some operation consumed more elements than there were on the stack, the error with exit code $2$ is thrown: `Stack underflow`.

```tact
asm fun drop() { DROP }

contract Loot {
    receive("I solemnly swear that I'm up to no good") {
        try {
            // Removes 100 elements from the stack, causing an underflow
            repeat (100) { drop() }
        } catch (exitCode) {
            // exitCode is 2
        }
    }
}
```

:::note[Useful links:]

  [TVM is a stack machine](https://docs.ton.org/learn/tvm-instructions/tvm-overview#tvm-is-a-stack-machine) in TON Docs.

:::

### 3: Stack overflow {#3}

If there are too many elements copied into a closure continuation, an error with exit code $3$ is thrown: `Stack overflow`. Occurs rarely, unless you're deep in [Fift and TVM assembly](https://docs.ton.org/develop/fift/fift-and-tvm-assembly) trenches:

```tact
// Remember kids, don't try to overflow the stack at home!
asm fun stackOverflow() {
    x{} SLICE        // s
    BLESS            // c
    0 SETNUMARGS     // c'
    2 PUSHINT        // c' 2
    SWAP             // 2 c'
    1 -1 SETCONTARGS // ← this blows up
}

contract ItsSoOver {
    receive("I solemnly swear that I'm up to no good") {
        try {
            stackOverflow();
        } catch (exitCode) {
            // exitCode is 3
        }
    }
}
```

:::note[Useful links:]

  [TVM is a stack machine](https://docs.ton.org/learn/tvm-instructions/tvm-overview#tvm-is-a-stack-machine) in TON Docs.

:::

### 4: Integer overflow {#4}

If the value in calculation goes beyond the range from $-2^{256}$ to $2^{256} - 1$ inclusive, or there's an attempt to [divide](/book/operators#binary-divide) or [modulo](/book/operators#binary-modulo) by zero, an error with exit code $4$ is thrown: `Integer overflow`.

```tact
let x = -pow(2, 255) - pow(2, 255); // -2^{256}

try {
    -x; // integer overflow by negation
        // since the max positive value is 2^{256} - 1
} catch (exitCode) {
    // exitCode is 4
}

try {
    x / 0; // division by zero!
} catch (exitCode) {
    // exitCode is 4
}

try {
    x * x * x; // integer overflow!
} catch (exitCode) {
    // exitCode is 4
}

// There can also be an integer overflow when doing:
// addition (+),
// subtraction (-),
// division (/) by a negative number or modulo (%) by zero
```

### 5: Integer out of range {#5}

Range check error — some integer is out of its expected range. I.e. any attempt to store an unexpected amount of data or specify an out-of-bounds value throws an error with exit code $5$: `Integer out of range`.

Examples of specifying an out-of-bounds value:

```tact
try {
    // Repeat only operates on inclusive range from 1 to 2^{31} - 1
    // and any valid integer value greater than that causes an error with exit code 5
    repeat (pow(2, 55)) {
        dump("smash. logs. I. must.");
    }
} catch (exitCode) {
    // exitCode is 5
}

try {
    // Builder.storeUint() function can only use up to 256 bits, so 512 is too much:
    let s: Slice = beginCell().storeUint(-1, 512).asSlice();
} catch (exitCode) {
    // exitCode is 5
}
```

### 6: Invalid opcode {#6}

If you specify an instruction that is not defined in the current [TVM][tvm] version or try to set an unsupported [code page](https://docs.ton.org/v3/documentation/tvm/tvm-overview#tvm-state), an error with exit code $6$ is thrown: `Invalid opcode`.

```tact
// There's no such codepage, and attempt to set it fails
asm fun invalidOpcode() { 42 SETCP }

contract OpOp {
    receive("I solemnly swear that I'm up to no good") {
        try {
            invalidOpcode();
        } catch (exitCode) {
            // exitCode is 6
        }
    }
}
```

### 7: Type check error {#7}

If an argument to a primitive is of an incorrect value type or there's any other mismatch in types during the [compute phase](#compute), an error with exit code $7$ is thrown: `Type check error`.

```tact
// The actual returned value type doesn't match the declared one
asm fun typeCheckError(): map<Int, Int> { 42 PUSHINT }

contract VibeCheck {
    receive("I solemnly swear that I'm up to no good") {
        try {
            // The 0th index doesn't exist
            typeCheckError().get(0)!!;
        } catch (exitCode) {
            // exitCode is 7
        }
    }
}
```

### 8: Cell overflow {#8}

From [Cells, Builders and Slices page](/book/cells#cells) of the Book:

> [`Cell{:tact}`][cell] is a [primitive][p] and a data structure, which [ordinarly](/book/cells#cells-kinds) consists of up to $1023$ continuously laid out bits and up to $4$ references (refs) to other cells.

To construct a [`Cell{:tact}`][cell], a [`Builder{:tact}`][builder] is used. If you try to store more than $1023$ bits of data or more than $4$ references to other cells, an error with exit code $8$ is thrown: `Cell overflow`.

This error can be triggered by [manual construction](/book/cells#cnp-manually) of the cells via [relevant `.loadSomething()` methods](/ref/core-cells) or when [using Structs and Messages and their convenience methods](/book/cells#cnp-structs).

```tact
// Too much bits
try {
    let data = beginCell()
        .storeInt(0, 250)
        .storeInt(0, 250)
        .storeInt(0, 250)
        .storeInt(0, 250)
        .storeInt(0, 24) // 1024 bits!
        .endCell();
} catch (exitCode) {
    // exitCode is 8
}

// Too much refs
try {
    let data = beginCell()
        .storeRef(emptyCell())
        .storeRef(emptyCell())
        .storeRef(emptyCell())
        .storeRef(emptyCell())
        .storeRef(emptyCell()) // 5 refs!
        .endCell();
} catch (exitCode) {
    // exitCode is 8
}
```

### 9: Cell underflow {#9}

From [Cells, Builders and Slices page](/book/cells#cells) of the Book:

> `Cell{:tact}` is a [primitive][p] and a data structure, which [ordinarly](/book/cells#cells-kinds) consists of up to $1023$ continuously laid out bits and up to $4$ references (refs) to other cells.

To parse a [`Cell{:tact}`][cell], a [`Slice{:tact}`][slice] is used. If you try to load more data or references than `Slice{:tact}` contains, an error with exit code $9$ is thrown: `Cell underflow`.

The most common cause of this error is a mismatch between the expected and actual memory layouts of the cells, so it's recommended to [use Structs and Messages for parsing](/book/cells#cnp-structs) of the cells instead of [manual parsing](/book/cells#cnp-manually) via [relevant `.loadSomething()` methods](/ref/core-cells).

```tact
// Too few bits
try {
    emptySlice().loadInt(1); // 0 bits!
} catch (exitCode) {
    // exitCode is 9
}

// Too few refs
try {
    emptySlice().loadRef(); // 0 refs!
} catch (exitCode) {
    // exitCode is 9
}
```

### 10: Dictionary error {#10}

In Tact, the [`map<K, V>{:tact}`](/book/maps) type is an abstraction over the ["hash" map dictionaries of FunC](https://docs.ton.org/develop/func/dictionaries#hashmap) and underlying [`HashmapE` type](https://docs.ton.org/develop/data-formats/tl-b-types#hashmap) of [TL-B][tlb] and [TVM][tvm].

If there is an incorrect manipulation of dictionaries, such as improper assumptions about their memory layout, an error with exit code $10$ is thrown: `Dictionary error`. Note, that Tact prevents you from getting this error unless you do [Fift and TVM assembly](https://docs.ton.org/develop/fift/fift-and-tvm-assembly) work yourself:

```tact
/// Pre-computed Int to Int dictionary with two entries — 0: 0 and 1: 1
const cellWithDictIntInt: Cell = cell("te6cckEBBAEAUAABAcABAgPQCAIDAEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMLMbT1U=");

/// Tries to preload a dictionary from a Slice as a map<Int, Cell>
asm fun toMapIntCell(x: Slice): map<Int, Cell> { PLDDICT }

contract DictPic {
    receive("I solemnly swear that I'm up to no good") {
        try {
            // The Int to Int dictionary is being misinterpreted as a map<Int, Cell>
            let m: map<Int, Cell> = toMapIntCell(cellWithDictIntInt.beginParse());

            // And the error happens only when we touch it
            m.get(0)!!;
        } catch (exitCode) {
            // exitCode is 10
        }
    }
}
```

### 11: "Unknown" error {#11}

Described in [TVM][tvm] docs as "Unknown error, may be thrown by user programs", although most commonly used for problems with queueing a message send or problems with [get-methods](https://docs.ton.org/develop/smart-contracts/guidelines/get-methods).

```tact
try {
    // Unlike nativeSendMessage which uses SENDRAWMSG, this one uses SENDMSG,
    // and therefore fails in Compute phase when the message is ill-formed
    nativeSendMessageReturnForwardFee(emptyCell(), 0);
} catch (exitCode) {
    // exitCode is 11
}
```

### 12: Fatal error {#12}

Fatal error. Thrown by TVM in situations deemed impossible.

### 13: Out of gas error {#13}

If there isn't enough gas to end computations in the [compute phase](#compute), the error with exit code $13$ is thrown: `Out of gas error`.

But this code isn't immediately shown as is — instead, the bitwise NOT operation is applied, which changes the value from $13$ to $-14$. And only then the code is shown.

That's done in order to prevent the resulting code ($-14$) from being produced artificially in user contracts, since all functions that can [throw an exit code](/ref/core-debug) can only specify integers in the range from $0$ to $65535$ inclusive.

```tact
try {
    repeat (pow(2, 31) - 1) {}
} catch (exitCode) {
    // exitCode is -14
}
```

### -14: Out of gas error {#-14}

See [exit code 13](#13).

### 14: Virtualization error {#14}

Virtualization error, related to [prunned branch cells](/book/cells#cells-kinds). Reserved, but never thrown.

## Action phase {#action}

The [action phase][a] is processed after the successful execution of the [compute phase](#compute). It attempts to perform the actions stored into the action list by [TVM][tvm] during the compute phase.

Some actions may fail during processing, in which case those actions may be skipped or the whole transaction may revert depending on the mode of actions. The code indicating the resulting state of the [action phase][a] is called a _result code_. Since it's also a $32$-bit signed integer that essentially serves the same purpose as _exit code_ of [compute phase](#compute), it's common to call the result code an exit code too.

### 32: Action list is invalid {#32}

If the list of actions contains [exotic cells](/book/cells#cells-kinds), an action entry cell does not have references or some action entry cell couldn't be parsed, an error with exit code $32$ is thrown: `Action list is invalid`.

:::note

  Aside from this exit code there's a boolean flag `valid`, which you can find under `description.actionPhase.valid` in the transaction results when working with [Sandbox and Blueprint](#blueprint). Transaction can set this flag to `false` even when there is some other exit code thrown from the action phase.

:::

### 33: Action list is too long {#33}

If there are more than $255$ actions queued for execution, the [action phase](#action) will throw an error with an exit code $33$: `Action list is too long`.

```tact
// For example, let's attempt to queue reservation of specific amount of nanoToncoins
// This won't fail in compute phase, but will result in exit code 33 in Action phase
repeat (256) {
    nativeReserve(ton("0.001"), ReserveAtMost);
}
```

### 34: Invalid or unsupported action {#34}

There are only four supported actions at the moment: changing the contract code, sending a message, reserving a specific amount of [nanoToncoins](/book/integers#nanotoncoin) and changing the library cell. If there's any issue with the specified action (invalid message, unsupported action, etc.), an error with exit code $34$ is thrown: `Invalid or unsupported action`.

```tact
// For example, let's try to send an ill-formed message:
nativeSendMessage(emptyCell(), 0); // won't fail in compute phase,
                                   // but will result in exit code 34 in Action phase
```

### 35: Invalid source address in outbound message {#35}

If the source address in the outbound message isn't equal to [`addr_none`](https://docs.ton.org/develop/data-formats/msg-tlb#addr_none00) or to the address of the contract that initiated this message, an error with exit code $35$ is thrown: `Invalid source address in outbound message`.

### 36: Invalid destination address in outbound message {#36}

If the destination address in the outbound message is invalid, e.g. it doesn't conform to the relevant [TL-B][tlb] schemas, contains unknown workchain ID or it has invalid length for the given workchain, an error with exit code $36$ is thrown: `Invalid destination address in outbound message`.

:::note

  If the [optional flag +2](/book/message-mode#optional-flags) is set, this error won't be thrown and the given message won't be sent.

:::

### 37: Not enough Toncoin {#37}

If all funds of the inbound message with [base mode 64](/book/message-mode#base-modes) set had been already consumed and there's not enough funds to pay for the failed action, or the [TL-B][tlb] layout of the provided value ([`CurrencyCollection`](https://docs.ton.org/develop/data-formats/msg-tlb#currencycollection)) is invalid, or there's not enough funds to pay [forward fees](https://docs.ton.org/develop/smart-contracts/guidelines/processing) or not enough funds after deducting fees, an error with exit code $37$ is thrown: `Not enough Toncoin`.

:::note

  If the [optional flag +2](/book/message-mode#optional-flags) is set, this error won't be thrown and the given message won't be sent.

:::

### 38: Not enough extra currencies {#38}

Besides the native currency, Toncoin, TON Blockchain supports up to $2^{32}$ extra currencies. They differ from making new [Jettons](/cookbook/jettons) because extra currencies are natively supported — one can potentially just specify an extra [`HashmapE`](https://docs.ton.org/develop/data-formats/tl-b-types#hashmap) of extra currency amounts in addition to the Toncoin amount in the internal message to another contract. Unlike Jettons, extra currencies can only be stored and transferred and do not have any other functionality.

At the moment, **there are no extra currencies** on TON Blockchain, but the exit code $38$ in cases when there is not enough extra currency to send the specified amount of it is already reserved: `Not enough extra currencies`.

:::note[Useful links:]

  [Extra currencies](https://docs.ton.org/develop/dapps/defi/coins) in TON Docs.\
  [Extra currency mining](https://docs.ton.org/develop/research-and-development/minter-flow) in TON Docs.

:::

### 39: Outbound message doesn't fit into a cell {#39}

When processing the message, TON Blockchain tries to pack it according to the [relevant TL-B schemas](https://docs.ton.org/develop/data-formats/msg-tlb), and if it cannot an error with exit code $39$ is thrown: `Outbound message doesn't fit into a cell`.

:::note

  If attempts at sending the message fail multiple times and the [optional flag +2](/book/message-mode#optional-flags) is set, this error won't be thrown and the given message won't be sent.

:::

### 40: Cannot process a message {#40}

If there would not be enough funds to process all the cells in a message, the message is too large or its Merkle depth is too big, an error with exit code $40$ is thrown: `Cannot process a message`.

### 41: Library reference is null {#41}

If the library reference was required during library change action, but it was null, an error with exit code $41$ is thrown: `Library reference is null`.

### 42: Library change action error {#42}

If there's an error during an attempt at library change action, an error with exit code $42$ is thrown: `Library change action error`.

### 43: Library limits exceeded {#43}

If the maximum number of cells in the library is exceeded or the maximum depth of the Merkle tree is exceeded, an error with exit code $43$ is thrown: `Library limits exceeded`.

### 50: Account state size exceeded limits {#50}

If the account state (contract storage, essentially) exceeds any of the limits specified in [config param 43 of TON Blockchain](https://docs.ton.org/develop/howto/blockchain-configs#param-43) by the end of the [action phase](#action), an error with exit code $50$ is thrown: `Account state size exceeded limits`.

If the configuration is absent, default values are:

* `max_msg_bits` is equal to $2^{21}$ — maximum message size in bits.
* `max_msg_cells` is equal to $2^{13}$ — maximum number of [cells][cell] a message can occupy.
* `max_library_cells` is equal to $1000$ — maximum number of [cells][cell] that can be used as [library reference cells](/book/cells#cells-kinds).
* `max_vm_data_depth` is equal to $2^{9}$ — maximum [cells][cell] depth in messages and account state.
* `ext_msg_limits.max_size` is equal to $65535$ — maximum external message size in bits.
* `ext_msg_limits.max_depth` is equal to $2^{9}$ — maximum external message [depth](/book/cells#cells-representation).
* `max_acc_state_cells` is equal to $2^{16}$ — maximum number of [cells][cell] that an account state can occupy.
* `max_acc_state_bits` is equal to $2^{16} * 1023$ — maximum account state size in bits.
* `max_acc_public_libraries` is equal to $2^{8}$ — maximum number of [library reference cells](/book/cells#cells-kinds) that an account state can use on the masterchain.
* `defer_out_queue_size_limit` is equal to $2^{8}$ — maximum number of outbound messages to be queued (regards validators and collators).

## Tact compiler

Tact utilizes exit codes from $128$ to $255$. Note, that exit codes used by Tact indicate contract errors which can occur when using Tact-generated FunC code, and are therefore thrown in the transaction's [compute phase](#compute) and not during the compilation.

### 128: Null reference exception {#128}

If there's a non-null assertion, such as the [`!!{:tact}`](/book/operators#unary-non-null-assert) operator, and the checked value is [`null{:tact}`](/book/optionals), an error with exit code $128$ is thrown: `Null reference exception`.

```tact
let gotcha: String? = null;

try {
    // Asserting that the value isn't null, which isn't the case!
    dump(gotcha!!);
} catch (exitCode) {
    // exitCode is 128
}
```

### 129: Invalid serialization prefix {#129}

Reserved, but due to a number of prior checks it cannot be thrown unless one hijacks the contract code before deployment and changes the opcodes of the [Messages][message] expected to be received in the contract.

### 130: Invalid incoming message {#130}

If the received internal or external message isn't handled by the contract, an error with exit code $130$ is thrown: `Invalid incoming message`. It usually happens when the contract doesn't have a receiver for the particular message and its opcode prefix (32-bit integer header).

Consider the following contract:

```tact
import "@stdlib/deploy";

contract Dummy with Deployable {}
```

If you try to send any message, except for [`Deploy{:tact}`](/ref/stdlib-deploy#deploy) provided by [`@stdlib/deploy`](/ref/stdlib-deploy), the contract won't have a receiver for it and thus would throw an error with exit code $130$.

### 131: Constraints error {#131}

Constraints error. Reserved, but never thrown.

### 132: Access denied {#132}

If you use the [`Ownable{:tact}`](/ref/stdlib-ownable#ownable) [trait][ct] from the [`@stdlib/ownable`](/ref/stdlib-ownable) library, the helper function `requireOwner(){:tact}` provided by it will throw an error with exit code $132$ if the sender of the inbound message won't match the specified owner: `Access denied`.

```tact
import "@stdlib/ownable";

contract Hal9k with Ownable {
    owner: Address;

    init(owner: Address) {
        self.owner = owner; // set the owner address upon deployment
    }

    receive("I'm sorry Dave, I'm afraid I can't do that.") {
        // Checks that the message sender's address equals to the owner address,
        // and if not — throws an error with exit code 132.
        self.requireOwner();

        // ... you do you ...
    }
}
```

### 133: Contract stopped {#133}

A message has been sent to a stopped contract. Reserved, but never thrown.

### 134: Invalid argument {#134}

If there is an invalid or unexpected argument value, an error with exit code $134$ is thrown: `Invalid argument`.

Here are some of the functions in Tact which can throw an error with this exit code:

1. [`Int.toFloatString(digits){:tact}`](/ref/core-strings#inttofloatstring): if the `digits` is not in the interval: $0 <$ `digits` $< 78$.

2. [`String.fromBase64(){:tact}`](/ref/core-strings#stringfrombase64) and [`Slice.fromBase64(){:tact}`](/ref/core-strings#slicefrombase64): if the given [`String{:tact}`][p] or [`Slice{:tact}`][slice] contains non-Base64 characters.

```tact
try {
    // 0 is code of NUL in ASCII and it is not valid Base64
    let code: Slice = beginCell().storeUint(0, 8).asSlice().fromBase64();
} catch (exitCode) {
    // exitCode is 134
}
```

### 135: Code of a contract was not found {#135}

If the code of the contract doesn't match the one saved in TypeScript wrappers, the error with exit code $135$ will be thrown: `Code of a contract was not found`.

### 136: Invalid address {#136}

<Badge text="Removed since Tact 1.6" variant="tip" size="medium"/><p/>

A value of type [`Address{:tact}`][p] is valid in Tact when:

* It occupies $267$ bits: $11$ bits for the chain ID prefix and $256$ bits for the [address itself](https://docs.ton.org/learn/overviews/addresses#address-of-smart-contract).
* It belongs to either basechain (ID $0$) or masterchain (ID $-1$).

If the [`Address{:tact}`][p] isn't valid, the error with exit code $136$ will be thrown: `Invalid address`.

```tact
// Only basechain (ID 0) or masterchain (ID -1) are supported by Tact
let unsupportedChainID = 1;

try {
    // Zero address in unsupported workchain
    dump(newAddress(unsupportedChainID, 0));
} catch (exitCode) {
    // exitCode is 136
}
```

### 137: Masterchain support is not enabled for this contract {#137}

<Badge text="Removed since Tact 1.6" variant="tip" size="medium"/><p/>

Prior to removal, any attempts to point to masterchain (ID $-1$) or otherwise interact with it without enabling masterchain support were throwing an exception with exit code $137$: `Masterchain support is not enabled for this contract`.

```tact
let masterchainID = -1;

try {
    // Zero address in masterchain without the config option set
    dump(newAddress(masterchainID, 0));
} catch (exitCode) {
    // exitCode is 137
}
```

[p]: /book/types#primitive-types
[ct]: /book/types#composite-types
[cell]: /book/cells
[builder]: /book/cells#builders
[slice]: /book/cells#slices
[message]: /book/structs-and-messages#messages

[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[bp]: https://github.com/ton-org/blueprint
[sb]: https://github.com/ton-org/sandbox
[jest]: https://jestjs.io


## expressions.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/expressions.mdx)
---
title: Expressions
description: "This page lists all the expressions in Tact"
---

Every operator in Tact forms an expression, but there's much more to uncover as Tact offers a wide range of expressive options to choose from.

:::note

  The current maximum allowed nesting level of expressions is $83$. An attempt to write a deeper expression will result in a compilation error:

  ```tact
  fun elegantWeaponsForCivilizedAge(): Int {
      return
      ((((((((((((((((((((((((((((((((
          ((((((((((((((((((((((((((((((((
              (((((((((((((((((((( // 84 parens, compilation error!
                  42
              ))))))))))))))))))))
          ))))))))))))))))))))))))))))))))
      ))))))))))))))))))))))))))))))));
  }
  ```

:::

## Literals

Literals represent values in Tact. These are fixed values—not variables—that you _literally_ provide in your code. All literals in Tact are expressions themselves.

You can also call [extension functions](/book/functions#extension-function) defined on certain [primitive types][p] corresponding to literals right on the literal values:

```tact
// Calling toString() defined for Int on a integer literal:
42.toString();

// Calling asComment() defined for String on a string literal:
"Tact is awesome!".asComment();
```

### Integer literals

Integer literals can be written in [decimal](/book/integers#decimal) (base $10$), [hexadecimal](/book/integers#hexadecimal) (base $16$), [octal](/book/integers#octal) (base $8$) and [binary](/book/integers#binary) (base $2$) notations:

* A [_decimal_ integer](/book/integers#decimal) literal is a sequence of digits ($\mathrm{0 - 9}$).

* A leading $\mathrm{0x}$ (or $\mathrm{0X}$) indicates a [hexadecimal integer](/book/integers#hexadecimal) literal. They can include digits ($\mathrm{0 - 9}$) and the letters $\mathrm{a - f}$ and $\mathrm{A - F}$. Note, that the case of a character does not change its value. Therefore: $\mathrm{0xa}$ = $\mathrm{0xA}$ = $10$ and $\mathrm{0xf}$ = $\mathrm{0xF}$ = $15$.

* A leading $\mathrm{0o}$ (or $\mathrm{0O}$) indicates a [octal integer](/book/integers#octal) literals. They can include only the digits $\mathrm{0 - 7}$.

* A leading $\mathrm{0b}$ (or $\mathrm{0B}$) indicates a [binary integer](/book/integers#binary) literal. THey can only include the digits $0$ and $1$.

:::caution
  Be wary that in Tact integer literals with a leading $0$ are still considered decimals, unlike in JavaScript/TypeScript where leading $0$ indicates an octal!
:::

Some examples of integer literals:

```tact
// decimal, base 10:
0, 42, 1_000, 020

// hexadecimal, base 16:
0xABC, 0xF, 0x0011

// octal, base 8:
0o777, 0o001

// binary, base 2:
0b01111001_01101111_01110101_00100000_01100001_01110010_01100101_00100000_01100001_01110111_01100101_01110011_01101111_01101101_01100101
```

Read more about integers and [`Int{:tact}`](/book/integers) type on the dedicated page: [Integers](/book/integers).

### Boolean literals

The [`Bool{:tact}`](/book/types#booleans) type has only two literal values: `true{:tact}` and `false{:tact}`.

```tact
true == true;
true != false;
```

Read more about booleans and [`Bool{:tact}`](/book/types#booleans) type in the dedicated chapter: [Booleans](/book/types#booleans).

### String literals

A string literal is zero or more characters enclosed in double (`"`) quotation marks. All string literals are objects of [`String{:tact}`][p] type.

```tact
"foo";
"1234";
```

Tact strings support a range of [escape sequences](https://en.wikipedia.org/wiki/Escape_sequence) starting with a backslash `\\` character:

* `\\{:tact}` — literal backslash
* `\"{:tact}` — double quote
* `\n{:tact}` — newline
* `\r{:tact}` — carriage return
* `\t{:tact}` — tab
* `\v{:tact}` — vertical tab
* `\b{:tact}` — backspace
* `\f{:tact}` — form feed
* `\x00{:tact}` through `\xFF{:tact}` — [code point](https://en.wikipedia.org/wiki/Code_point), must be exactly two hex digits long
* `\u0000{:tact}` through `\uFFFF{:tact}` — [Unicode code point][unicode], must be exactly four hex digits long
* `\u{0}{:tact}` through `\u{FFFFFF}{:tact}` — [Unicode code point][unicode], can be from $1$ to $6$ hex digits long

[unicode]: https://en.wikipedia.org/wiki/Unicode#Codespace_and_code_points

```tact
// \\
"escape \\ if \\ you \\ can \\";

// \"
"this \"literally\" works";

// \n
"line \n another line";

// \r
"Shutters \r Like \r This \r One";

// \t
"spacing \t granted!";

// \v
"those \v words \v are \v aligned";

// \b
"rm\b\bcreate!";

// \f
"form \f feed";

// \x00 - \xFF
"this \x22literally\x22 works"; // \x22 represents a double quote

// \u0000 - \uFFFF
"danger, \u26A1 high voltage \u26A1"; // \u26A1 represents the ⚡ emoji

// \u{0} - \u{FFFFFF}
"\u{1F602} LOL \u{1F602}"; // \u{1F602} represents the 😂 emoji
```

:::note

  Read more about strings and [`String{:tact}`][p] type:\
  [Primitive types in the Book][p]\
  [Strings and StringBuilders in the Reference](/ref/core-strings)

:::

### `null` literal

The `null{:tact}` value is written with a `null{:tact}` literal. It's **not** an [identifier](#identifiers) and doesn't refer to any object. It's also **not** an instance of a [primitive type][p]. Instead, `null{:tact}` represents a lack of identification and the intentional absence of any value.

```tact
let var: Int? = null; // variable, which can hold null value
var = 42;
if (var != null) {
    var!! + var!!;
}
```

Read more about working with `null{:tact}` on the dedicated page: [Optionals](/book/optionals).

## Identifiers

An identifier is a sequence of characters in the code that _identifies_ a [variable](/book/statements#let), [constant](/book/constants), [map](/book/maps) and a [function](/book/functions), as well as a [Struct][s], [Message][m], [contract](/book/contracts), [trait](/book/types#traits), or their fields and methods. Identifiers are case-sensitive and not quoted.

In Tact, identifiers can contain latin lowercase letters (`a-z`), latin uppercase letters (`A-Z`), underscores (`_`) and digits ($\mathrm{0 - 9}$), but may not start with a digit. An identifier differs from a [string](#string-literals) in that a string is data, while an identifier is part of the code.

Note, that when identifiers for [primitive types][p] start with an uppercase letter. Used-defined [composite types](/book/types#composite-types), such as [Structs][s] and [Messages][m] also must be capitalized.

## Instantiation

You can create instances of the following types:

* [Structs][s]
* [Messages][m]

```tact
struct StExample {
    fieldInit: Int = 1;
    fieldUninit: Int;
}

fun example() {
    // Instance with default value of fieldInit
    StExample{ fieldUninit: 2 };

    // Instance with both fields set
    StExample{
        fieldInit: 0,
        fieldUninit: 2, // trailing comma is allowed
    };
}
```

## Field access

You can directly access fields of the following types:

* [Structs][s]
* [Messages][m]

```tact
struct StExample {
    fieldInit: Int = 1;
    fieldUninit: Int;
}

fun example(): Int {
    let struct: StExample = StExample{ fieldUninit: 2 }; // instantiation

    struct.fieldInit;          // access a field
    return struct.fieldUninit; // return field value from the function
}
```

## Extension function call

[Extension functions](/book/functions#extension-function) are defined only on specific types. They can be called similar to method calls in many other languages:

```tact
42.toString(); // toString() is a stdlib function that is defined on Int type
```

## Static function call

Anywhere in the function body, a global [static function](/book/functions#global-static-functions) or an internal function of a [contract](/book/contracts) can be called:

```tact
contract ExampleContract {
    receive() {
        now(); // now() is a static function of stdlib
        let expiration: Int = now() + 1000; // operation and variable declaration
        expiration = self.answerQuestion(); // internal function
    }
    fun answerQuestion(): Int {
        return 42;
    }
}
```

## `initOf`

Expression `initOf{:tact}` computes initial state (`StateInit{:tact}`) of a [contract](/book/contracts):

```tact
//                     argument values for the init() function of the contract
//                     ↓   ↓
initOf ExampleContract(42, 100); // returns a Struct StateInit{}
//     ---------------
//     ↑
//     name of the contract
//     ↓
//     ---------------
initOf ExampleContract(
    42,  // first argument
    100, // second argument, trailing comma is allowed
);
```

Where `StateInit{:tact}` is a built-in [Struct][s], that consists of:

Field  | Type               | Description
:----- | :----------------- | :----------
`code` | [`Cell{:tact}`][cell] | initial code of the [contract](/book/contracts) (the compiled bytecode)
`data` | [`Cell{:tact}`][cell] | initial data of the [contract](/book/contracts) (arguments of `init(){:tact}` function of the contract)

[p]: /book/types#primitive-types
[cell]: /book/cells#cells
[s]: /book/structs-and-messages#structs
[m]: /book/structs-and-messages#messages


## external.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/external.mdx)
---
title: External Messages
description: "External messages don't have a sender and can be sent by anyone from the offchain"
---

:::caution
  This page is under re-construction as per [#384](https://github.com/tact-lang/tact-docs/issues/384). All anchor links (`#`) may change in the future!
:::

:::caution
  External message support must be enabled explicitly in the project configuration.
  Without enabling it compilation would fail.
:::

External messages are those that don't have a sender and can be sent by anyone in the world. External messages are good tools for integrating with off-chain systems or for the general maintenance of contracts. Handling external messages is different from handling internal messages. In this section, we will cover how to handle external messages.

## How External Messages are Different

External messages are different from internal messages in the following ways:

### Contracts Pay for Gas Usage Themselves

When processing internal messages, the sender usually pays for gas usage. When processing external messages, the contract pays for gas usage. This means that you need to be careful with gas usage in external messages. You should always test the gas usage of your contracts and verify that everything is working as intended.

### Messages Have to Be Accepted Manually

External messages are not accepted automatically. You need to accept them manually. This is done by calling the `acceptMessage` function. If you don't call the `acceptMessage` function, the message will be rejected. This is done to prevent the spamming of external messages.

### 10k Gas Limit Before Message Acceptance

10k gas is a very small limit, and Tact itself can consume a sizable amount of gas before it even reaches your code. You should always test the gas usage of your contracts and verify that everything is working as intended.

:::tip[Hey there!]

  The 10k gas limit for external messages is based on the parameter we set by the
  validator for the whole blockchain of the `gas_limit` field. You can take
  the reference here:

  - https://docs.ton.org/develop/smart-contracts/guidelines/accept#external-messages
  - https://docs.ton.org/develop/howto/blockchain-configs#param-20-and-21

:::

### Unbounded Gas Usage After Message Acceptance

After you accept the gas, the contract can use as much gas as it wants. This is done to allow the contract to carry out any kind of processing. You should always test the gas usage of your contracts and verify that everything is working as intended, and avoid possible vulnerabilities that could drain the contract balance.

### No Context Available

When processing an external message, the `context` and `sender` functions are not available. This is because there is no context available for external messages. This means that you can't use the `context` and `sender` functions in external messages. You need to carefully test your contract to make sure that it doesn't use the `context` and `sender` functions.

## Enable External Messages Support

To enable external messages support, please enable it in the project configuration file:

```json
{
  "options": {
    "external": true
  }
}
```

## External receivers

External receivers are defined the same way as internal ones, but using the `external` keyword instead of `receive`:

```tact
contract SampleContract {
    external("Check Timeout") {

        // Check for contract timeout
        require(self.timeout > now(), "Not timeouted");

        // Accept message
        acceptMessage();

        // Timeout processing
        self.onTimeouted();
    }
}
```


## func.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/func.mdx)
---
title: Compatibility with FunC
description: "Tact compiles to FunC and maps all its entities directly to various FunC and TL-B types."
---

Tact itself compiles to FunC and maps all its entities directly to various FunC and TL-B types.

## Convert types

[Primitive types](/book/types#primitive-types) in Tact are directly mapped to FunC ones.

All rules about copying variables are the same. One of the big differences is that there are no visible mutation operators in Tact and most [`Slice{:tact}`](/book/cells#slices) operations mutate variables in place.

## Convert serialization

Serialization of [Structs](/book/structs-and-messages#structs) and [Messages](/book/structs-and-messages#messages) in Tact is automatic, unlike FunC where you need to define serialization logic manually.

Tact's auto-layout algorithm is greedy. This means that it takes the next variable, calculates its size, and tries to fit it into a current cell. If it doesn't fit, it creates a new cell and continues. All inner structs for auto-layout are flattened before allocation.

All optional types are serialized as `Maybe` in TL-B, except for [`Address{:tact}`](/book/types#primitive-types).

There is no support for `Either` since it does not define what to pick during serialization in some cases.

### Examples

```tact
// _ value1:int257 = SomeValue;
struct SomeValue {
    value1: Int; // Default is 257 bits
}
```

```tact
// _ value1:int256 value2:uint32 = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as uint32;
}
```

```tact
// _ value1:bool value2:Maybe bool = SomeValue;
struct SomeValue {
    value1: Bool;
    value2: Bool?;
}
```

```tact
// _ cell:^cell = SomeValue;
struct SomeValue {
    cell: Cell; // Always stored as a reference
}
```

```tact
// _ cell:^slice = SomeValue;
struct SomeValue {
    cell: Slice; // Always stored as a reference
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256] = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    value4: Int as int256;
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256] flag:bool = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    flag: Bool; // Flag is written before value4 to avoid auto-layout to allocate it to the next cell
    value4: Int as int256;
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256 flag:bool] = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    value4: Int as int256;
    flag: Bool;
}
```

```tact
// _ value1:int256 value2:^TailString value3:int256 = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: String;
    value3: Int as int256;
}
```

## Convert received messages to `op` operations

Tact generates a unique `op` for every received typed message, but it can be overwritten.

The following code in FunC:

```func
() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; incoming message code...

    ;; Receive MessageWithGeneratedOp message
    if (op == 1180414602) {
        ;; code...
    }

    ;; Receive MessageWithOverwrittenOP message
    if (op == 291) {
        ;; code...
    }

}
```

Becomes this in Tact:

```tact
message MessageWithGeneratedOp {
    amount: Int as uint32;
}

message(0x123) MessageWithOverwrittenOP {
    amount: Int as uint32;
}

contract Contract {
    // Contract Body...

    receive(msg: MessageWithGeneratedOp) {
        // code...
    }

    receive(msg: MessageWithOverwrittenOP) {
        // code...
    }

}
```

## Convert `get`-methods

You can express everything except `list-style-lists` in Tact that would be compatible with FunC's `get`-methods.

### Primitive return type

If a `get`-method returns a primitive in FunC, you can implement it the same way in Tact.

The following code in FunC:

```func
int seqno() method_id {
    return 0;
}
```

Becomes this in Tact:

```tact
get fun seqno(): Int {
    return 0;
}
```

### Tensor return types

In FunC there is a difference between tensor type `(int, int){:func}` and `(int, (int)){:func}`, but for TVM there are no differences, they all represent a stack of two integers.

To convert the tensor that returned from a FunC `get`-method, you need to define a [Struct](/book/structs-and-messages#structs) that has the same field types as the tensor and in the same order.

The following code in FunC:

```func
(int, slice, slice, cell) get_wallet_data() method_id {
    return ...;
}
```

Becomes this in Tact:

```tact
struct JettonWalletData {
    balance: Int;
    owner: Address;
    master: Address;
    walletCode: Cell;
}

contract JettonWallet {
    get fun get_wallet_data(): JettonWalletData {
        return ...;
    }
}
```

### Tuple return type

In FunC if you are returning a tuple, instead of a tensor you need to follow the process for a tensor type, but define the return type of a `get`-method as optional.

The following code in FunC:

```func
[int, int] get_contract_state() method_id {
    return ...;
}
```

Becomes this in Tact:

```tact
struct ContractState {
    valueA: Int;
    valueB: Int;
}

contract StatefulContract {
    get fun get_contract_state(): ContractState? {
        return ...;
    }
}
```

### Mixed tuple and tensor return types

When some of the tensors are a tuple, you need to define a struct as in previous steps and the tuple one must be defined as a separate [Struct](/book/structs-and-messages#structs).

The following code in FunC:

```func
(int, [int, int]) get_contract_state() method_id {
    return ...;
}
```

Becomes this in Tact:

```tact
struct ContractStateInner {
    valueA: Int;
    valueB: Int;
}

struct ContractState {
    valueA: Int;
    valueB: ContractStateInner;
}

contract StatefulContract {
    get fun get_contract_state(): ContractState {
        return ...;
    }
}
```

### Arguments mapping

Conversion of `get`-methods arguments is straightforward. Each argument is mapped _as-is_ to FunC one, and each tuple is mapped to a [Struct](/book/structs-and-messages#structs).

The following code in FunC:

```func
(int, [int, int]) get_contract_state(int arg1, [int,int] arg2) method_id {
    return ...;
}
```

Becomes this in Tact:

```tact
struct ContractStateArg2 {
    valueA: Int;
    valueB: Int;
}

struct ContractStateInner {
    valueA: Int;
    valueB: Int;
}

struct ContractState {
    valueA: Int;
    valueB: ContractStateInner;
}

contract StatefulContract {
    get fun get_contract_state(arg1: Int, arg2: ContractStateArg2): ContractState {
        return ContractState{
            valueA: arg1,
            valueB: ContractStateInner{
                valueA: arg2.valueA,
                valueB: arg2.valueB, // trailing comma is allowed
            }, // trailing comma is allowed
        };
    }
}
```


## functions.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/functions.mdx)
---
title: Functions
description: "Global, asm, native functions, as well as receivers, getters and storage functions, plus the many attributes that allow for great flexibility and expressivity of Tact language"
---

import { Badge } from '@astrojs/starlight/components';

Functions in Tact could be defined in different ways:

* Global static function
* Extension functions
* Mutation functions
* Native functions
* [Assembly functions](#asm)
* [Internal functions](/book/contracts#internal-functions)
* Receiver functions
* Getter functions

All functions, except for [receiver functions](#receiver-functions) can have a trailing comma in their definitions (parameter lists) and calls (argument lists):

```tact
fun foo(
    a: Int, // trailing comma in parameter lists is allowed
) {}

fun bar() {
    foo(
        5, // trailing comma in argument lists is allowed too!
    );
}
```

## Global static functions

You can define global function anywhere in your program:

```tact
fun customPow(a: Int, c: Int): Int {
  let res: Int = 1;
  repeat(c) {
    res *= a;
  }
  return res;
}
```

## Virtual and abstract functions

You can allow the contract inheriting a [traits](/book/types#traits) to modify an internal function, if it has the `virtual{:tact}` keyword, using `override{:tact}`. The function can be also marked as `abstract{:tact}`, in which case the inheriting contract has to define its implementation:

```tact
trait FilterTrait with Ownable {
    // Virtual functions can be overridden by users of this trait
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;
}

contract Filter with FilterTrait {
    // Overriding default behavior of the FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
````

## Extension function

Extension functions allow you to implement extensions for any possible type.

> **Warning**
> The name of the first argument MUST be named `self` and the type of this argument is the type you are extending.

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

## Mutation functions

Mutation functions are performing mutation of a value replacing it with an execution result. To perform mutation, the function must change the `self` value.

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

## Native functions

Native functions are direct bindings of FunC functions:

> **Note**
> Native functions could also be mutation and extension ones.

```tact
@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;
```

## Assembly functions, `asm` {#asm}

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

Read more about them on their dedicated page: [Assembly functions](/book/assembly-functions).

## Receiver functions

Receiver functions are special functions that are responsible for receiving messages in contracts and could be defined only within a contract or trait.

```tact
contract Treasure {
    // This means that this contract can receive the comment "Increment" and this function would be called for such messages
    receive("Increment") {
        self.counter += 1;
    }
}
```

## Getter Functions

Getter functions define getters on smart contracts and can be defined only within a contract or trait.
Getter functions cannot be used to read some other contract's state: if you need to obtain some data you need to do that by sending a message with a request and define a receiver which would process the request answer.

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```

### Explicit resolution of method ID collisions

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

Like other functions in TON contracts, getters have their _unique_ associated function selectors, which are $19$-bit signed integer identifiers commonly called _method IDs_.

Method IDs of getters are derived from their names using the [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithm as follows: `(crc16(<function_name>) & 0xffff) | 0x10000`. In addition, Tact compiler conditionally reserves some method IDs for use in [getters of supported interfaces](/book/contracts#interfaces), namely: $113617$ for `supported_interfaces`, $115390$ for `lazy_deployment_completed`, and $121275$ for `get_abi_ipfs`.

Sometimes, getters with different names end up with the same method ID. If this happens, you can either rename some of the getters or manually specify the method ID as a [compile-time](/ref/core-comptime) expression like so:

```tact
contract ManualMethodId {
    const methodId: Int = 16384 + 42;

    get(self.methodId)
    fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return crc32("crc32") + 42 & 0x3ffff | 0x4000;
    }
}
```

Unlike getters, method IDs for [internal functions](/book/contracts#internal-functions) and some special functions are obtained sequentially: integers in the inclusive range from $-4$ to $0$ are given to [certain message handlers](https://docs.ton.org/v3/documentation/smart-contracts/func/docs/functions#special-function-names), while internal functions are numbered with method IDs starting at $1$ and going up to $2^{14} - 1$ inclusive.

Since method IDs are $19$-bit signed integers and some of them are reserved, only the inclusive ranges from $-2^{18}$ to $-5$ and from $2^{14}$ to $2^{18} - 1$ are free to be used by users. To avoid collisions, it's recommended to specify method IDs only in these ranges, avoiding the method IDs of Tact-specific getters mentioned above.

[p]: /book/types#primitive-types
[struct]: /book/structs-and-messages#structs
[slice]: /book/cells#slices


## import.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/import.mdx)
---
title: Importing code
description: "Tact allows you to import Tact and FunC code, and has a versatile set of standard libraries"
---

Tact allows you to import Tact and [FunC](https://docs.ton.org/develop/func/overview) code — any given `.tact` or `.fc`/`.func` file can be imported into your project using the `import{:tact}` keyword.

Additionally, Tact compiler has a versatile set of standard libraries, which come bundled in, but not included right away, see [Standard libraries overview](/ref/standard-libraries).

:::caution

  All imported code is combined together with yours, so it's important to avoid name collisions and always double-check the sources!

:::

## Import Tact code

It's possible to import any Tact code using the `import{:tact}` statement and providing a relative path to the target `.tact` file like so:

```tact
import "./relative/path/to/the/target/tact/file.tact";
```

Specifying parent directories (`../`) is also possible:

```tact
import "../subfolder/imported/file.tact";
```

## Import FunC code

It's possible to import code written in FunC code directly just as it's done with Tact code imports:

```tact
// Relative import
import "./relative/path/to/the/target/func/file.fc";

// Specifying parent directories
import "../subfolder/imported/func/file.fc";
```

But in order to use functions from such file, one has to declare them as `native` functions first. For example, when standard library [`@stdlib/dns`](/ref/stdlib-dns) uses a `dns.fc` FunC file, it maps FunC functions to Tact ones like so:

```tact
// FunC code located in a file right next to the current Tact one:
import "./dns.fc";

// Mapping function signatures from FunC to Tact:
@name(dns_string_to_internal)
native dnsStringToInternal(str: String): Slice?;
```

## Standard libraries

See [Standard libraries overview](/ref/standard-libraries).


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/index.mdx)
---
title: Book overview
description: "Book section — an introductory book about the Tact language"
---

import { LinkCard, CardGrid, Steps } from '@astrojs/starlight/components';

Welcome to **The Tact Book** section (or just **The Book**), — an introductory book about the Tact language.

Here are its main contents:

<Steps>

1. #### Cheatsheets

   [Cheatsheets](/book/cs/from-func) are quick rundowns on Tact syntax and idioms with comparison to other blockchain languages, such as FunC (also on TON) and Solidity (Ethereum blockchain). Use those to transition to Tact as swiftly as possible.

   <CardGrid>
     <LinkCard
       title="Go to the first cheatsheet"
       href="/book/cs/from-func"
     />
   </CardGrid>

2. #### Book

   [**The Tact Book**](/book/types) is a cohesive and streamlined sequence of educational materials about Tact. In general, it assumes that you’re reading it in sequence from front to back. Later parts build on concepts in earlier parts, and earlier parts might not delve into details on a particular topic but will revisit the topic in a later part.

   Additionally, there are many references to the Language section of the documentation, where many primitives of the language are described in much more fine detail. Additionally, whenever there's an existing explanation of the broader TON concept in the main TON documentation, this Book tries to reference it as well.

   Book also assumes that you’ve written code in another programming language but doesn’t make any assumptions about which one. We’ve tried to make the material broadly accessible to those from a wide variety of programming backgrounds. We don’t spend a lot of time talking about what programming _is_ or how to think about it. If you’re entirely new to programming, you would be better served by reading a book that specifically provides an introduction to programming.

   <CardGrid>
     <LinkCard
       title="Proceed to the Book itself"
       href="/book/types"
     />
   </CardGrid>

</Steps>


## integers.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/integers.mdx)
---
title: Integers
description: "Arithmetic in smart contracts on TON is always done with integers and never with floats"
---

import { Badge } from '@astrojs/starlight/components';

Arithmetic in smart contracts on TON is always done with integers and never with floating-point numbers since the floats are [unpredictable](https://learn.microsoft.com/en-us/cpp/build/why-floating-point-numbers-may-lose-precision). Therefore, the big accent goes on integers and their handling.

The only primitive number type in Tact is `Int{:tact}`, for $257$-bit signed integers.\
It's capable of storing integers between $-2^{256}$ and $2^{256} - 1.$

## Notation

Tact supports various ways of writing primitive values of `Int{:tact}` as [integer literals](/book/expressions#integer-literals).

Most of the notations allow adding underscores (`_`) in-between digits, except for:
* Representations in strings, as seen in [nano-tons](#nanotoncoin) case.
* Decimal numbers written with a leading zero $0.$ Their use is generally discouraged, see [below](#decimal).

Additionally, several underscores in a row as in $4\_\_2$, or trailing underscores as in $42\_$ are **not** allowed.

### Decimal

Most common and most used way of representing numbers, using the [decimal numeral system](https://en.wikipedia.org/wiki/Decimal): $123456789.$\
You can use underscores (`_`) to improve readability: $123\_456\_789$ is equal to $123456789.$

:::caution
  Alternatively, you can prefix the number with one $0$, which prohibits use of underscores and only allows decimal digits: $0123 = 123.$
  Note, that using this notation with leading zero is **strongly discouraged** due to possible confusion with octal integer literals in TypeScript, which is often used alongside Tact to develop and test contracts.
:::

### Hexadecimal

Represent numbers using [hexadecimal numeral system](https://en.wikipedia.org/wiki/Hexadecimal), denoted by the $\mathrm{0x}$ (or $\mathrm{0X}$) prefix: $\mathrm{0xFFFFFFFFF}.$\
Use underscores (`_`) to improve readability: $\mathrm{0xFFF\_FFF\_FFF}$ is equal to $\mathrm{0xFFFFFFFFF}.$

### Octal

Represent numbers using [octal numeral system](https://en.wikipedia.org/wiki/Octal), denoted by the $\mathrm{0o}$ (or $\mathrm{0O}$) prefix: $\mathrm{0o777777777.}$\
Use underscores (`_`) to improve readability: $\mathrm{0o777\_777\_777}$ is equal to $\mathrm{0o777777777}.$

### Binary

Represent numbers using [binary numeral system](https://en.wikipedia.org/wiki/Binary_number), denoted by the $\mathrm{0b}$ (or $\mathrm{0B}$) prefix: $\mathrm{0b111111111.}$\
Use underscores (`_`) to improve readability: $\mathrm{0b111\_111\_111}$ is equal to $\mathrm{0b111111111}.$

### NanoToncoin

Arithmetic with dollars requires two decimal places after the dot — those are used for the cents value. But how would we represent the number \$$1.25$ if we're only able to work with integers? The solution is to work with _cents_ directly. This way, \$$1.25$ becomes $125$ cents. We simply memorize that the two rightmost digits represent the numbers after the decimal point.

Similarly, working with Toncoin, the main currency of TON Blockchain, requires nine decimal places instead of the two. One can say that nanoToncoin is the $\frac{1}{10^{9}}\mathrm{th}$ of the Toncoin.

Therefore, the amount of $1.25$ Toncoin, which can be represented in Tact as [`ton("1.25"){:tact}`](/ref/core-comptime#ton), is actually the number $1250000000$. We refer to such numbers as _nanoToncoin(s)_ (or _nano-ton(s)_) rather than _cents_.

## Serialization

When encoding `Int{:tact}` values to persistent state (fields of [contracts](/book/contracts) and [traits](/book/types#traits)), it's usually better to use smaller representations than $257$-bits to reduce [storage costs](https://docs.ton.org/develop/smart-contracts/fees#storage-fee). Usage of such representations is also called "serialization" due to them representing the native [TL-B][tlb] types which TON Blockchain operates on.

The persistent state size is specified in every declaration of a state variable after the `as{:tact}` keyword:

```tact
contract SerializationExample {
    // persistent state variables
    oneByte: Int as int8 = 0; // ranges from -128 to 127 (takes 8 bit = 1 byte)
    twoBytes: Int as int16;   // ranges from -32,768 to 32,767 (takes 16 bit = 2 bytes)

    init() {
        // needs to be initialized in the init() because it doesn't have the default value
        self.twoBytes = 55*55;
    }
}
```

Integer serialization is also available for the fields of [Structs](/book/structs-and-messages#structs) and [Messages](/book/structs-and-messages#messages), as well as in key/value types of [maps](/book/maps):

```tact
struct StSerialization {
    martin: Int as int8;
}

message MsgSerialization {
    seamus: Int as int8;
    mcFly: map<Int as int8, Int as int8>;
}
```

Motivation is very simple:
* Storing $1000$ $257$-bit integers in state [costs](https://docs.ton.org/develop/smart-contracts/fees#how-to-calculate-fees) about $0.184$ TON per year.
* Storing $1000$ $32$-bit integers only costs $0.023$ TON per year by comparison.

### Common serialization types

Name             | [TL-B][tlb]                 | Inclusive range             | Space taken
:--------------: | :-------------------------: | :-------------------------: | :------------------------:
`uint8{:tact}`   | [`uint8`][tlb-builtin]      | $0$ to $2^{8} - 1$          | $8$ bits = $1$ byte
`uint16{:tact}`  | [`uint16`][tlb-builtin]     | $0$ to $2^{16} - 1$         | $16$ bits = $2$ bytes
`uint32{:tact}`  | [`uint32`][tlb-builtin]     | $0$ to $2^{32} - 1$         | $32$ bits = $4$ bytes
`uint64{:tact}`  | [`uint64`][tlb-builtin]     | $0$ to $2^{64} - 1$         | $64$ bits = $8$ bytes
`uint128{:tact}` | [`uint128`][tlb-builtin]    | $0$ to $2^{128} - 1$        | $128$ bits = $16$ bytes
`uint256{:tact}` | [`uint256`][tlb-builtin]    | $0$ to $2^{256} - 1$        | $256$ bits = $32$ bytes
`int8{:tact}`    | [`int8`][tlb-builtin]       | $-2^{7}$ to $2^{7} - 1$     | $8$ bits = $1$ byte
`int16{:tact}`   | [`int16`][tlb-builtin]      | $-2^{15}$ to $2^{15} - 1$   | $16$ bits = $2$ bytes
`int32{:tact}`   | [`int32`][tlb-builtin]      | $-2^{31}$ to $2^{31} - 1$   | $32$ bits = $4$ bytes
`int64{:tact}`   | [`int64`][tlb-builtin]      | $-2^{63}$ to $2^{63} - 1$   | $64$ bits = $8$ bytes
`int128{:tact}`  | [`int128`][tlb-builtin]     | $-2^{127}$ to $2^{127} - 1$ | $128$ bits = $16$ bytes
`int256{:tact}`  | [`int256`][tlb-builtin]     | $-2^{255}$ to $2^{255} - 1$ | $256$ bits = $32$ bytes
`int257{:tact}`  | [`int257`][tlb-builtin]     | $-2^{256}$ to $2^{256} - 1$ | $257$ bits = $32$ bytes + $1$ bit
`coins{:tact}`   | [`VarUInteger 16`][varuint] | $0$ to $2^{120} - 1$        | between $4$ and $124$ bits, [see below](#serialization-coins)

### Arbitrary bit-width types

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

In addition to [common serialization types](#common-serialization-types), it's possible to specify arbitrary bit-width integers by using a prefix `int` or `uint` followed by digits. For example, writing `int7{:tact}` refers to a signed $7$-bit integer.

The minimum allowed bit-width of an `Int{:tact}` type is $1$, while the maximum is $257$ for `int` prefixes (signed integers) and $256$ for `uint` prefixes (unsigned integers).

Name             | [TL-B][tlb]            | Inclusive range                 | Space taken
:--------------: | :--------------------: | :-----------------------------: | :---------:
`uintX{:tact}`   | [`uintX`][tlb-builtin] | $0$ to $2^{X} - 1$              | $X$ bits, where $X$ is between $1$ and $256$
`intX{:tact}`    | [`intX`][tlb-builtin]  | $-2^{X - 1}$ to $2^{X - 1} - 1$ | $X$ bits, where $X$ is between $1$ and $257$

### Variable `coins` type {#serialization-coins}

In Tact, `coins{:tact}` is an alias to [`VarUInteger 16`][varuint] in [TL-B][tlb] representation, i.e. it takes a variable bit length depending on the optimal number of bytes needed to store the given integer and is commonly used for storing [nanoToncoin](/book/integers#nanotoncoin) amounts.

This serialization format consists of two [TL-B fields](https://docs.ton.org/develop/data-formats/tl-b-language#field-definitions):

* `len`, a $4$-bit unsigned big-endian integer storing the byte length of the value provided
* `value`, a $8 * len$-bit unsigned big-endian representation of the value provided

That is, integers serialized as `coins{:tact}` occupy between $4$ and $124$ bits ($4$ bits for `len` and $0$ to $15$ bytes for `value`) and have values in the inclusive range from $0$ to $2^{120} - 1$.

Examples:

```tact
struct Scrooge {
    // len: 0000, 4 bits (always)
    // value: none!
    // in total: 4 bits
    a: Int as coins = 0; // 0000

    // len: 0001, 4 bits
    // value: 00000001, 8 bits
    // in total: 12 bits
    b: Int as coins = 1; // 0001 00000001

    // len: 0010, 4 bits
    // value: 00000001 00000010, 16 bits
    // in total: 20 bits
    c: Int as coins = 258; // 0010 00000001 00000010

    // len: 1111, 4 bits
    // value: hundred twenty 1's in binary
    // in total: 124 bits
    d: Int as coins = pow(2, 120) - 1; // hundred twenty 1's in binary
}
```

:::note

  Read more on serialization here: [Compatibility with FunC](/book/func#convert-serialization)

:::

## Operations

All runtime calculations with numbers are done at 257-bits, so [overflows](https://en.wikipedia.org/wiki/Integer_overflow) are quite rare. Nevertheless, if any math operation overflows, an exception will be thrown, and the transaction will fail. You could say that Tact's math is safe by default.

Note, that there is no problem with mixing variables of [different state sizes](#serialization) in the same calculation. At runtime they are all the same type no matter what — $257$-bit signed, so overflows won't happen then.

However, this can still lead to **errors** in the [compute phase](https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase) of the transaction. Consider the following example:

```tact
import "@stdlib/deploy";

contract ComputeErrorsOhNo with Deployable {
    oneByte: Int as uint8; // persistent state variable, max value is 255

    init() {
        self.oneByte = 255; // initial value is 255, everything fits
    }

    receive("lets break it") {
        let tmp: Int = self.oneByte * 256; // no runtime overflow
        self.oneByte = tmp; // whoops, tmp value is out of the expected range of oneByte
    }
}
```

Here, `oneByte` is serialized as a [`uint8`](#common-serialization-types), which occupies only one byte and ranges from $0$ to $2^{8} - 1$, which is $255$. And when used in runtime calculations no overflow happens and everything is calculated as a $257$-bit signed integers. But the very moment we decide to store the value of `tmp` back into `oneByte` we get an error with the [exit code 5](/book/exit-codes#5), which states the following: `Integer out of the expected range`.

:::caution
  Therefore, be **very** careful with numbers and always double-check calculations when using serialization.
:::

[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[tlb-builtin]: https://docs.ton.org/develop/data-formats/tl-b-language#built-in-types
[varuint]: https://docs.ton.org/develop/data-formats/msg-tlb#varuinteger-n


## lifecycle.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/lifecycle.mdx)
---
title: Message Lifecycle
description: "Every transaction on TON Blockchain has multiple stages, where compute and action ones are the most important for message lifecycle"
---

There are several stages of message processing by a contract, there are more of them, but we would focus on the most important ones:

## Receive Phase

This phase combines multiple low-level phases. 

It starts by adding a **message value to the contract balance**. The value of an incoming message is the maximum price that a contract can pay for gas to process this message. The contract can overwrite this limit, but it is not recommended and is suitable only for advanced developers since it could lead to a contract being drained. 1 million of gas is the maximum amount that a contract can spend in a single contract which equals 0.4 TON for basechain (currently). If the message value is zero then execution is aborted.

Then some (usually small) amount of nanotons gets subtracted from the contract balance for storage. This means that you can't perfectly predict balance changes and have to adjust your code to this instability.

Then it deploys a contract if it is not deployed yet and the message contains the init package. If the init package isn't present, it will be ignored.

## Compute Phase

This phase executes the code of a smart contract and produces a list of actions or an exception. Currently, only two types of actions are supported: **send message** and **reserve**.

Sending a message could use a fixed value or a dynamic value like **remaining value of a message** - the remaining value of the incoming message. Sending a message could be with a flag `SendIgnoreErrors` that would ignore errors during message sending and would continue to the next action. This flag is useful if you have multiple actions. When sending a message with some value, it first subtracts this value from the incoming value and only then from the contract balance (before processing).

## Action Phase

Actions are executed in sequence, but bear in mind:
**EXCEPTION DURING PROCESSING ACTIONS WOULDN'T REVERT THE TRANSACTION**

For example, if you subtract 1 ton from a customer's balance and then send an invalid message, that could lead to a situation when the customer's balance is subtracted, but he wouldn't receive it.


## maps.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/maps.mdx)
---
title: Maps
description: "The composite type map is used as a way to associate keys with corresponding values of various types"
---

import { Badge } from '@astrojs/starlight/components';

The [composite type](/book/types#composite-types) `map<K, V>{:tact}` is used as a way to associate keys of type `K{:tact}` with corresponding values of type `V{:tact}`.

For example, `map<Int, Int>{:tact}` uses [`Int{:tact}`][int] type for its keys and values:

```tact
struct IntToInt {
    counters: map<Int, Int>;
}
```

## Allowed types

Allowed key types:

* [`Int{:tact}`][int]
* [`Address{:tact}`][p]

Allowed value types:

* [`Int{:tact}`][int]
* [`Bool{:tact}`](/book/types#booleans)
* [`Cell{:tact}`][cell]
* [`Address{:tact}`][p]
* [Struct](/book/structs-and-messages#structs)
* [Message](/book/structs-and-messages#messages)

## Operations

### Declare, `emptyMap()` {#emptymap}

As a [local variable](/book/statements#let), using `emptyMap(){:tact}` function of standard library:

```tact
let fizz: map<Int, Int> = emptyMap();
let fizz: map<Int, Int> = null; // identical to the previous line, but less descriptive
```

As a [persistent state variable](/book/contracts#variables):

```tact
contract Example {
    fizz: map<Int, Int>; // Int keys to Int values
    init() {
        self.fizz = emptyMap(); // redundant and can be removed!
    }
}
```

Note, that [persistent state variables](/book/contracts#variables) of type `map<K, V>{:tact}` are initialized empty by default and don't need default values or an initialization in the [`init(){:tact}` function](/book/contracts#init-function).

### Set values, `.set()` {#set}

To set or replace the value under a key call the `.set(){:tact}` [method](/book/functions#extension-function), which is accessible for all maps.

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a couple of values under different keys
fizz.set(7, 7);
fizz.set(42, 42);

// Overriding one of the existing key-value pairs
fizz.set(7, 68); // key 7 now points to value 68
```

### Get values, `.get()` {#get}

To check if a key is found in the map by calling the `.get(){:tact}` [method](/book/functions#extension-function), which is accessible for all maps. This will return `null{:tact}` if the key is missing, or the value if the key is found.

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a value
fizz.set(68, 0);

// Getting the value by its key
let gotButUnsure: Int? = fizz.get(68);          // returns Int or null, therefore the type is Int?
let mustHaveGotOrErrored: Int = fizz.get(68)!!; // explicitly asserting that the value must not be null,
                                                // which may crush at runtime if the value is, in fact, null

// Alternatively, we can check for the key in the if statement
if (gotButUnsure != null) {
    // Hooray, let's use !! without fear now and cast Int? to Int
    let definitelyGotIt: Int = fizz.get(68)!!;
} else {
    // Do something else...
}
```

### Replace values, `.replace()` {#replace}

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

To replace the value under a key, if such a key exists, use the `.replace(){:tact}` [method](/book/functions#extension-function). It returns `true{:tact}` on successful replacement and `false{:tact}` otherwise.

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a couple of values under different keys
fizz.set(7, 70);
fizz.set(42, 42);

// Overriding one of the existing key-value pairs
let replaced1 = fizz.replace(7, 68); // key 7 now points to value 68
replaced1; // true

// Trying to replace the value in a non-existing key-value pair will do nothing
let replaced2 = fizz.replace(8, 68); // no key 8, so nothing was altered
replaced2; // false
```

If the given value is [`null{:tact}`](/book/optionals) and the key exists, the entry will be deleted from the map.

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a couple of values under different keys
fizz.set(7, 70);
fizz.set(42, 42);

// Overriding one of the existing key-value pairs
let replaced1 = fizz.replace(7, null); // the entry under key 7 is now deleted
replaced1; // true

// Trying to replace the value in a non-existing key-value pair will do nothing
let replaced2 = fizz.replace(8, null); // no key 8, so nothing was altered
replaced2; // false
```

### Replace and get old value, `.replaceGet()` {#replaceget}

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

Like [`.replace()`](#replace), but instead of returning a [`Bool{:tact}`](/book/types#booleans) it returns the old (pre-replacement) value on successful replacement and [`null{:tact}`](/book/optionals) otherwise.

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a couple of values under different keys
fizz.set(7, 70);
fizz.set(42, 42);

// Overriding one of the existing key-value pairs
let oldVal1 = fizz.replaceGet(7, 68); // key 7 now points to value 68
oldVal1; // 70

// Trying to replace the value in a non-existing key-value pair will do nothing
let oldVal2 = fizz.replaceGet(8, 68); // no key 8, so nothing was altered
oldVal2; // null
```

If the given value is [`null{:tact}`](/book/optionals) and the key exists, the entry will be deleted from the map.

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a couple of values under different keys
fizz.set(7, 70);
fizz.set(42, 42);

// Overriding one of the existing key-value pairs
let oldVal1 = fizz.replaceGet(7, null); // the entry under key 7 is now deleted
oldVal1; // 70

// Trying to replace the value in a non-existing key-value pair will do nothing
let oldVal2 = fizz.replaceGet(8, null); // no key 8, so nothing was altered
oldVal2; // null
```

### Delete entries, `.del()` {#del}

To delete a single key-value pair (single entry), use the `.del(){:tact}` [method](/book/functions#extension-function). It returns `true{:tact}` in the case of successful deletion and `false{:tact}` otherwise.

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a couple of values under different keys
fizz.set(7, 123);
fizz.set(42, 321);

// Deleting one of the keys
let deletionSuccess: Bool = fizz.del(7); // true, because map contained the entry under key 7
fizz.del(7);                             // false, because map no longer has an entry under key 7

// Note, that assigning the `null` value to the key when using the `.set()` method
//   is equivalent to calling `.del()`, although such approach is much less descriptive
//   and is generally discouraged:
fizz.set(42, null); // the entry under key 42 is now deleted
```

To delete all the entries from the map, re-assign the map using the `emptyMap(){:tact}` function:

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a couple of values under different keys
fizz.set(7, 123);
fizz.set(42, 321);

// Deleting all of the entries at once
fizz = emptyMap();
fizz = null; // identical to the previous line, but less descriptive
```

With this approach all previous entries of the map are completely discarded from the contract even if the map was declared as its persistent state variable. As a result, assigning maps to `emptyMap(){:tact}` **does not** inflict any hidden or sudden [storage fees](https://docs.ton.org/develop/smart-contracts/fees#storage-fee).

### Check if entry exists, `.exists()` {#exists}

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

The `.exists(){:tact}` [method](/book/functions#extension-function) on maps returns `true{:tact}` if the value under the given key exists in the map and `false{:tact}` otherwise.

```tact
let fizz: map<Int, Int> = emptyMap();
fizz.set(0, 0);

if (fizz.exists(2 + 2)) { // false
    dump("Something doesn't add up!");
}

if (fizz.exists(1 / 2)) { // true
    dump("I told a fraction joke once. It was half funny.");
}

if (fizz.get(1 / 2) != null) { // also true, but consumes more gas
    dump("Gotta pump more!");
}
```

:::note

  Calling `m.exists(key){:tact}` is more gas-efficient than executing `m.get(key) != null{:tact}`, although both approaches yield the same results.

:::

### Check if empty, `.isEmpty()` {#isempty}

The `.isEmpty(){:tact}` [method](/book/functions#extension-function) on maps returns `true{:tact}` if the map is empty and `false{:tact}` otherwise:

```tact
let fizz: map<Int, Int> = emptyMap();

if (fizz.isEmpty()) {
    dump("Empty maps are empty, duh!");
}

// Note, that comparing the map to `null` behaves the same as `.isEmpty()` method,
// although such direct comparison is much less descriptive and is generally discouraged:
if (fizz == null) {
    dump("Empty maps are null, which isn't obvious");
}
```

### Compare with `.deepEquals()` {#deepequals}

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

The `.deepEquals(){:tact}` [method](/book/functions#extension-function) on maps returns `true{:tact}` if all entries of the map match corresponding entries of another map, ignoring possible differences in the [underlying serialization logic][hashmap]. Returns `false{:tact}` otherwise.

```tact
let fizz: map<Int, Int> = emptyMap();
let buzz: map<Int, Int> = emptyMap();

fizz.set(1, 2);
buzz.set(1, 2);

fizz.deepEquals(buzz); // true
fizz == buzz;          // true, and uses much less gas to compute
```

Using `.deepEquals(){:tact}` is very important in cases where a map comes from the third-party source that doesn't provide any guarantees about the [serialization layout][hashmap]. For one such example, consider the following code:

```typescript title="some-typescript-code.ts"
// First map, with long labels
const m1 = beginCell()
    .storeUint(2, 2) // long label
    .storeUint(8, 4) // key length
    .storeUint(1, 8) // key
    .storeBit(true)  // value
    .endCell();

// Second map, with short labels
const m2 = beginCell()
    .storeUint(0, 1)           // short label
    .storeUint(0b111111110, 9) // key length
    .storeUint(1, 8)           // key
    .storeBit(true)            // value
    .endCell();
```

There, both maps are formed manually and both contain the same key-value pair. If you were to send both of those maps in a message to the Tact contract, and then compare them with `.deepEquals(){:tact}` and [equality operator `=={:tact}`](/book/operators#binary-equality), the former would produce `true{:tact}` because both maps have the same entry, while the latter would produce `false{:tact}`, because it only does the shallow comparison of map hashes. And those differ since the maps are serialized differently.

:::note

  This function is very gas expensive, and for the majority of cases it'll be enough to use the shallow comparison via the [equality `=={:tact}`](/book/operators#binary-equality) or [inequality `!={:tact}`](/book/operators#binary-equality) operators.

:::

### Convert to a `Cell`, `.asCell()` {#ascell}

Use `.asCell(){:tact}` [method](/book/functions#extension-function) on maps to convert all their values to a [`Cell{:tact}`][cell] type. Be mindful, that [`Cell{:tact}`][cell] type is able to store up to 1023 bits, so converting larger maps to the Cell will result in error.

As an example, this method is useful for sending small maps directly in the body of the reply:

```tact
contract Example {
    // Persistent state variables
    fizz: map<Int, Int>; // our map

    // Constructor (initialization) function of the contract
    init() {
        // Setting a bunch of values
        self.fizz.set(0, 3);
        self.fizz.set(1, 14);
        self.fizz.set(2, 15);
        self.fizz.set(3, 926);
        self.fizz.set(4, 5_358_979_323_846);
    }

    // Internal message receiver, which responds to empty messages
    receive() {
        // Here we're converting the map to a Cell and making a reply with it
        self.reply(self.fizz.asCell());
    }
}
```

### Traverse over entries {#traverse}

To iterate over map entries there is a [`foreach{:tact}`](/book/statements#foreach-loop) loop statement:

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a couple of values under different keys
fizz.set(42, 321);
fizz.set(7, 123);

// Iterating over in a sequential order: from the smallest keys to the biggest ones
foreach (key, value in fizz) {
    dump(key); // will dump 7 on the first iteration, then 42 on the second
}
```

Read more about it: [`foreach{:tact}` loop in Book→Statements](/book/statements#foreach-loop).

Note, that it's also possible to use maps as simple arrays if you define a `map<Int, V>{:tact}` with an [`Int{:tact}`][int] type for the keys, any allowed `V{:tact}` type for values and keep track of the number of items in the separate variable:

```tact
contract Iteration {
    // Persistent state variables
    counter: Int as uint32;    // counter of map entries, serialized as a 32-bit unsigned
    record: map<Int, Address>; // Int to Address map

    // Constructor (initialization) function of the contract
    init() {
        self.counter = 0; // Setting the self.counter to 0
    }

    // Internal message receiver, which responds to a String message "Add"
    receive("Add") {
        // Get the Context Struct
        let ctx: Context = context();
        // Set the entry: counter Int as a key, ctx.sender Address as a value
        self.record.set(self.counter, ctx.sender);
        // Increase the counter
        self.counter += 1;
    }

    // Internal message receiver, which responds to a String message "Send"
    receive("Send") {
        // Loop until the value of self.counter (over all the self.record entries)
        let i: Int = 0; // declare usual i for loop iterations
        while (i < self.counter) {
           send(SendParameters{
                bounce: false,              // do not bounce back this message
                to: self.record.get(i)!!,   // set the sender address, knowing that key i exists in the map
                value: ton("0.0000001"),    // 100 nanoToncoins (nano-tons)
                mode: SendIgnoreErrors,     // send ignoring errors in transaction, if any
                body: "SENDING".asComment() // String "SENDING" converted to a Cell as a message body
            });
            i += 1; // don't forget to increase the i
        }
    }

    // Getter function for obtaining the value of self.record
    get fun map(): map<Int, Address> {
        return self.record;
    }

    // Getter function for obtaining the value of self.counter
    get fun counter(): Int {
        return self.counter;
    }
}
```

It's often useful to set an upper-bound restriction on such maps, so that you [don't hit the limits](#limits-and-drawbacks).

:::caution

  Note, that manually keeping track of number of items or checking the length of such map is very error-prone and generally discouraged. Instead, try to wrap your map into the [Struct](/book/structs-and-messages#structs) and define [extension functions](/book/functions#extension-function) on it. See example in the Cookbook: [How to emulate an array using a map wrapped in a Struct](/cookbook/data-structures#array).

:::

:::note

  This example was adapted from [howardpen9/while-example-tact](https://github.com/howardpen9/while-example-tact/blob/de5807fcd20dba5f6a3748d112511477fb22bfcc/contracts/awesome.tact#L19C10-L19C10).

  See other examples of map usage in the Cookbook:\
  [How to emulate a stack using a map wrapped in a Struct](/cookbook/data-structures#stack)\
  [How to emulate a circular buffer using a map wrapped in a Struct](/cookbook/data-structures#circular-buffer)

:::

## Serialization

It's possible to do [integer serialization](/book/integers#common-serialization-types) of map keys, values or both to [preserve space and reduce storage costs](/book/integers#serialization):

```tact
struct SerializedMapInside {
    // Both keys and values here would be serialized as 8-bit unsigned integers,
    // thus preserving the space and reducing storage costs:
    countersButCompact: map<Int as uint8, Int as uint8>;
}
```

:::note

  Read about other serialization options: [Compatibility with FunC](/book/func#convert-serialization).

:::

## Limits and drawbacks

While maps can be convenient to work with on a small scale, they cause a number of issues if the number of items is unbounded and map can significantly grow in size:

* As the upper bound of the smart contract state size is around $65\,000$ items of type [`Cell{:tact}`][cell], it constrains the storage limit of maps to be about $30\,000$ key-value pairs for the whole contract.

* The more entries you have in a map, the bigger [compute fees](https://docs.ton.org/develop/howto/fees-low-level#computation-fees) you'll get. Thus, working with large maps makes compute fees tough to predict and manage.

* Using a large map in a single contract doesn't allow to distribute its workload. Hence, it can make the overall performance much worse compared to  using a smaller map and a bunch of interacting smart contracts.

To resolve such issues you can set an upper-bound restriction on a map as a constant and check against it every time you're setting a new value to the map:

```tact
contract Example {
    // Declare a compile-time constant upper-bound for our map
    const MaxMapSize: Int = 42;

    // Persistent state variables
    arr: map<Int, Int>; // "array" of Int values as a map
    arrLength: Int = 0; // length of the "array", defaults to 0

    // Internal function for pushing an item to the end of the "array"
    fun arrPush(item: Int) {
        if (self.arrLength >= self.MaxMapSize) {
            // Do something, stop the operation, for example
        } else {
            // Proceed with adding new item
            self.arr.set(self.arrLength, item);
            self.arrLength += 1;
        }
    }
}
```

If you still need a large map or an unbound (infinitely large) map, it's better to architect your smart contracts according to the [asynchronous and actor-based model of TON blockchain](https://docs.ton.org/learn/overviews/ton-blockchain). That is, to use contract sharding and essentially make the whole blockchain a part of your map(s).

{/*
  TODO: Add reference to sharding page as per: https://github.com/tact-lang/tact-docs/issues/155
*/}

[p]: /book/types#primitive-types
[int]: /book/integers
[cell]: /book/cells#cells

[hashmap]: https://docs.ton.org/develop/data-formats/tl-b-types#hashmap


## message-mode.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/message-mode.mdx)
---
title: Message mode
description: "Messages are sent with the mode param of a struct SendParameters. It's an Int value, which is combined from base modes and optional flags, which are also Int values"
---

import { Badge } from '@astrojs/starlight/components';

As it was previously mentioned, messages are sent with the `mode` param of a struct `SendParameters{:tact}`. It's an [`Int{:tact}`][int] value, which is combined from base modes and optional flags, which are also [`Int{:tact}`][int] values.

It's possible to use raw [`Int{:tact}`][int] values and manually provide them for the `mode`, but for your convenience there's a set of constants which you may use to construct the compound `mode` with ease. Take a look at the following tables for more information on base modes and optional flags.

## Base modes

Mode value | Constant name                 | Description
---------: | :---------------------------- | -----------
$0$        | <Badge text="Since Tact 1.6" variant="tip"/> `SendDefaultMode{:tact}` | Ordinary message (default).
$64$       | `SendRemainingValue{:tact}`   | Carry all the remaining value of the inbound message in addition to the value initially indicated in the new message.
$128$      | `SendRemainingBalance{:tact}` | Carry all the remaining balance of the current smart contract instead of the value originally indicated in the message.

## Optional flags

Flag value | Constant name                   | Description
---------: | :------------------------------ | -----------
$+1$       | `SendPayGasSeparately{:tact}`   | Pay forward fees separately from the message value.
$+2$       | `SendIgnoreErrors{:tact}`       | Ignore any errors arising while processing this message during the action phase.
$+16$      | `SendBounceIfActionFail{:tact}` | Bounce transaction in case of any errors during action phase. Has no effect if flag $+2$, `SendIgnoreErrors{:tact}` is used.
$+32$      | `SendDestroyIfZero{:tact}`      | Current account must be destroyed if its resulting balance is zero (often used with mode $128$, `SendRemainingBalance{:tact}`).

## Combining modes with flags

To make the [`Int{:tact}`][int] value for `mode` field of `SendParameters{:tact}`, you just have to combine base modes with optional flags by applying the [bitwise OR](/book/operators#binary-bitwise-or) operation.

For example, if you want to send a regular message and pay transfer fees separately, use the mode $0$ (default) and a flag $+1$ to get `mode` $= 1$, which is equal to using `SendPayGasSeparately{:tact}` constant.

Alternatively, if you want to send the whole contract balance and destroy it immediately, use the mode $128$ and flag $+32$ to get `mode` $= 160$, which is equal to `SendRemainingBalance | SendDestroyIfZero{:tact}`.

Here's how the latter example would look in code:

```tact
let to: Address = address("...");
let value: Int = ton("1");
send(SendParameters{
    to: to,
    value: value,
    mode: SendRemainingBalance | SendDestroyIfZero,
    body: "Hello, World!".asComment(),
});
```

:::caution

  Note, that while adding ([`+{:tact}`](/book/operators#binary-add)) base modes together with optional flags is possible, it is discouraged due to the possibility of excess values. Use the bitwise OR ([`|{:tact}`](/book/operators#binary-bitwise-or)) instead, as it's designed to work with such flag and bit manipulations of the `mode`.

:::

:::note

  Also note, that there can be only one [base mode](#base-modes), but number of [optional flags](#optional-flags) may vary: you can use them all, none or just some.

:::

[int]: /book/integers


## operators.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/operators.mdx)
---
title: Operators
description: "This page lists all the operators in Tact in decreasing order of their precedence, with examples of usage"
prev:
  link: /book/exit-codes
  label: Exit codes
---

Almost every contract operates on data: transforms some values into another. Scope may vary, but operators lay in core of such modifications.

This page lists all the operators in Tact in decreasing order of their [precedence](#precedence), with examples of usage.

:::note

  Note, that there are no implicit type conversions in Tact, so operators can't be used to, say, add values of different type or compare them in terms of equality without explicitly casting to the same type. That's done with certain functions from the standard library. See [`Int.toString(){:tact}`](/ref/core-strings#inttostring) for an example of such function.

:::

## Table of operators {#table}

The following table lists operators in order of decreasing [precedence](#precedence): from highest to lowest.

Brief description | Operators
:---------------- | :--------------------------------------------------------------------
Parentheses       | [`(){:tact}`][paren]
Unary postfix     | [`!!{:tact}`][nna]
Unary prefix      | [`+{:tact}`][plus] &nbsp; [`-{:tact}`][neg] &nbsp; [`!{:tact}`][inv] &nbsp; [`~{:tact}`][b-not]
Multiplicative    | [`*{:tact}`][mul] &nbsp; [`/{:tact}`][div] &nbsp; [`%{:tact}`][mod]
Additive          | [`+{:tact}`][add] &nbsp; [`-{:tact}`][sub]
Shift             | [`>>{:tact}`][shr] &nbsp; [`<<{:tact}`][shl]
Relation          | [`>{:tact}`][gt] &nbsp; [`>={:tact}`][ge] &nbsp; [`<{:tact}`][lt] &nbsp; [`<={:tact}`][le]
Equality          | [`=={:tact}`][eq] &nbsp; [`!={:tact}`][eq]
Bitwise AND       | [`&{:tact}`][b-and]
Bitwise XOR       | [`^{:tact}`][b-xor]
Bitwise OR        | [`\|{:tact}`][b-or]
Logical AND       | [`&&{:tact}`][l-and]
Logical OR        | [`\|\|{:tact}`][l-or]
Ternary           | [`?:{:tact}`][ternary]
Assignment        | [`={:tact}`][assign] and [all augmented assignment operators](#augmented-assignment)

[paren]: #parentheses

[nna]: #unary-non-null-assert
[plus]: #unary-plus
[neg]: #unary-negate
[inv]: #unary-inverse
[b-not]: #unary-bitwise-not

[mul]: #binary-multiply
[div]: #binary-divide
[mod]: #binary-modulo

[add]: #binary-add
[sub]: #binary-subtract

[shr]: #binary-bitwise-shift-right
[shl]: #binary-bitwise-shift-left

[gt]: #binary-greater
[ge]: #binary-greater-equal
[lt]: #binary-less
[le]: #binary-less-equal

[eq]: #binary-equality

[b-and]: #binary-bitwise-and
[b-xor]: #binary-bitwise-xor
[b-or]: #binary-bitwise-or

[l-and]: #binary-logical-and
[l-or]: #binary-logical-or

[ternary]: #ternary

[assign]: #assignment

## Precedence

All operators on this page are given in order of decreasing precedence, from highest to lowest. Precedence is used to choose which operator would be considered in a particular situation. Whenever any ambiguity arises, Tact would prefer operators with higher precedence over those with lower.

For example, minus sign (`-{:tact}`) may be considered as a subtraction operator or as a negation operator, which reverses the sign of the expression from plus to minus, or vice-versa. As the latter has the higher precedence over the former in cases of ambiguity between the two Tact will first consider `-{:tact}` as a negation operator. And if that doesn't make sense for the given expression, only then it would consider it as a subtraction operator.

Consider the following code:

```tact
5 + -5; // here, the minus sign would be viewed as a negation operator
5 -5;   // while here it would be viewed as a subtraction operator, despite formatting
```

Even though this example may be simple, neglecting of precedence rules can often lead to confusing situations with operators. The correct order of operations can be ensured by wrapping every operation in [parentheses](#parentheses), since parentheses have the highest precedence of all expressions and operators there is.

## Parentheses, `()` {#parentheses}

Parentheses (also can be called round brackets, `(){:tact}`) are more of a punctuation symbols than actual operators, but their [precedence](#precedence) is higher than precedence of any other operator. Use parentheses to override order of operations:

```tact
5 * 5 - 2;   // 23
5 * (5 - 2); // 15
```

:::note

  The current maximum allowed nesting level of expressions is $83$. An attempt to write a deeper expression will result in a compilation error:

  ```tact
  fun elegantWeaponsForCivilizedAge(): Int {
      return
      ((((((((((((((((((((((((((((((((
          ((((((((((((((((((((((((((((((((
              (((((((((((((((((((( // 84 parens, compilation error!
                  42
              ))))))))))))))))))))
          ))))))))))))))))))))))))))))))))
      ))))))))))))))))))))))))))))))));
  }
  ```

:::

## Unary

Unary here means that they are applied only to one operand of the given expression. All unary operators, except for the [non-null assertion](#unary-non-null-assert), are of the same [precedence](#precedence).

Unary operators can be one of the two types:

* Prefix — placed before the expression.
* Postfix (or suffix) — placed after the expression.

### Non-null assert, `!!` {#unary-non-null-assert}

Unary double-exclamation mark (_non-null assertion_) operator `!!{:tact}` is a postfix operator, which enforces non-`null{:tact}` values and allows direct access to the value of the optional variable if it's not `null{:tact}`. Otherwise, raises a compilation error if the compiler can track it, and if not — throws an exception with [exit code 128](/book/exit-codes#128): `Null reference exception`. Can be applied to any optional variable regardless of its non-`null{:tact}` type.

:::note

  Read more about optional variables and fields here: [Optionals](/book/optionals)

:::

### Plus, `+` {#unary-plus}

Although unary plus sign operator `+{:tact}` is specified in the grammar of Tact compiler, it only exists as a [binary operator](#binary-add).

### Negate, `-` {#unary-negate}

Unary minus sign (_negation_) operator `-{:tact}` is a prefix operator, which reverses the sign of the expression. Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let five: Int = 5;
five + -five; // here, the minus sign is a negation operator, not a subtraction operator
-(-1);        // double application gives back the original value, which is 1
--1;          // 1
```

### Inverse, `!` {#unary-inverse}

Unary exclamation mark (_inversion_) operator `!{:tact}` is a prefix operator, which inverts the boolean value of the expression — changes `true{:tact}` to `false{:tact}`, and vice versa. Can only be applied to values of type [`Bool{:tact}`][bool]:

```tact
let iLikeTact: Bool = true;
!iLikeTact; // false
!false;     // true
!(!false);  // false
!!false;    // false
```

### Bitwise NOT, `~` {#unary-bitwise-not}

Unary tilde (_bitwise not_) operator `~{:tact}` is a prefix operator, which inverts or _flips_ each bit in the binary representation of the expression — changes each $1$ to $0$, and vice versa. Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let answer: Int = 42;
~answer;    // -43
~(~answer); // 42
~(~0);      // 0
~~0;        // 0
```

## Binary

Binary operators are split into several subsections, in order of decreasing [precedence](#precedence). Operators within each subsection have the same [precedence](#precedence) as the subsection itself.

### Multiplication {#binary-multiplication}

Multiply, divide or obtain a remainder.

#### Multiply, `*` {#binary-multiply}

Binary asterisk (_multiplication_) operator `*{:tact}` is used for multiplication of two values. Can cause [integer overflows](/book/integers#operations).

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two * two;         // 4
0 * 1_000_000_000; // 0
-1 * 5;            // -5

pow(2, 255) * pow(2, 255); // build error: integer overflow!
```

#### Divide, `/` {#binary-divide}

Binary slash (_division_) operator `/{:tact}` is used for integer division of two values, which truncates towards zero if result is positive, and away from zero if result is negative. This is also called [rounding down](https://en.wikipedia.org/wiki/Rounding#Rounding_down) (or rounding towards $-∞$).

An attempt to divide by zero would result in an error with [exit code 4](/book/exit-codes#4): `Integer overflow`.

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two / 2; // 1
two / 1; // 2
-1 / 5;  // -1
-1 / -5; // 0
1 / -5;  // -1
1 / 5;   // 0
6 / 5;   // 1, rounding down
-6 / 5;  // -2, rounding down (towards -∞)
```

:::note

  Note that the following relationship between the division and modulo operators always holds for `Int{:tact}` type:

  ```tact
  a / b * b + a % b == a; // true for any Int values of `a` and `b`,
                          //   except when `b` is equal to 0 and we divide `a` by 0,
                          //   which is an attempt to divide by zero resulting in an error
  ```

:::

#### Modulo, `%` {#binary-modulo}

Binary percent sign (_modulo_) operator `%{:tact}` is used for getting the modulo of an integer division, which must not be confused with getting a remainder. For two values of the same sign, modulo and remainder operations are equivalent, but when the operands are of different signs, the modulo result always has the same sign as the _divisor_ (value on the right), while the remainder has the same sign as the _dividend_ (value on the left), which can make them differ by one unit of the _divisor_.

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two % 2; // 0
two % 1; // 1

1 % 5;   // 1
-1 % 5;  // 4
1 % -5;  // -4
-1 % -5; // -1
```

The simplest way to avoid confusion between the two is to prefer using positive values via [`abs(x: Int){:tact}`](/ref/core-math#abs):

```tact
abs(-1) % abs(-5); // 1
```

:::note

  Did you know, that in JavaScript `%{:tact}` works as a _remainder_ operator, but not _modulo_ operator (like in Tact)?\
  [Remainder (%) - JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder#description)\
  [Modulo - Wikipedia](https://en.wikipedia.org/wiki/Modulo)

:::

### Addition {#binary-addition}

Add or subtract.

#### Add, `+` {#binary-add}

Binary plus (_addition_) operator `+{:tact}` is used for adding numbers together. Going beyond the maximum value of an [`Int{:tact}`][int] will result in an error with [exit code 4](/book/exit-codes#4): `Integer overflow`.

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two + 2; // 4
-1 + 1;  // 0

pow(2, 254) + pow(2, 254);     // 2 * 2^254
pow(2, 255) + pow(2, 255);     // build error: integer overflow!
pow(2, 255) - 1 + pow(2, 255); // 2^256 - 1, maximal value of any integer in Tact!
```

#### Subtract, `-` {#binary-subtract}

Binary minus (_subtraction_) operator `-{:tact}` is used for subtracting numbers from each other. Going beyond the minimum value of an [`Int{:tact}`][int] will result in an error with [exit code 4](/book/exit-codes#4): `Integer overflow`.

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two - 2; // 0
-1 - 1;  // -2

pow(2, 254) - pow(2, 254); // 0
pow(2, 255) - pow(2, 255); // 0
pow(2, 256) - pow(2, 256); // build error: integer overflow!
```

### Bitwise shifts {#binary-bitwise-shifts}

Shift bits to the left or to the right.

#### Shift right, `>>` {#binary-bitwise-shift-right}

Binary double greater than (_bitwise shift right_) operator `>>{:tact}` returns an integer which binary representation is the _left operand_ value shifted by the _right operand_ number of bits to the right. Excess bits shifted off to the right are discarded, and copies of the leftmost bit are shifted in from the left. This operation is also called "sign-propagating right shift" or "arithmetic right shift", because the sign of the resulting number is the same as the sign of the _left operand_. This is a more effective way to divide the _left operand_ by $2^n$, where $n$ is equal to the _right operand_.

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two >> 1; // 1
4 >> 1;   // 2
5 >> 1;   // 2, due to flooring of integer values

pow(2, 254) >> 254; // 1
```

:::note

  [Bit shifts - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts)\
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

#### Shift left, `<<` {#binary-bitwise-shift-left}

Binary double greater than (_bitwise shift left_) operator `<<{:tact}` returns an integer which binary representation is the _left operand_ value shifted by the _right operand_ number of bits to the left. Excess bits shifted off to the left are discarded, and zero bits are shifted in from the right. This is a more effective way to multiply the _left operand_ by $2^n$, where $n$ is equal to the _right operand_. Going beyond the maximum value of an [`Int{:tact}`][int] will result in an error with [exit code 4](/book/exit-codes#4): `Integer overflow`.

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two << 1; // 4
1 << 5;   // 1 * 2^5, which is 32
2 << 5;   // 2 * 2^5, which is 64

pow(2, 254) == (1 << 254); // true
pow(2, 254) == 1 << 254; // true, no parentheses needed due to higher precedence of >> over ==
pow(2, 255) == 1 << 255; // true, but we're very close to overflow here!
```

:::note

  [Bit shifts - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts)\
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### Relation {#binary-relation}

Find bigger, smaller or equal values.

#### Greater than, `>` {#binary-greater}

Binary _greater than_ operator `>{:tact}` returns `true{:tact}` if the left operand is greater than the right operand, and `false{:tact}` otherwise. Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two > 2; // false
-1 > -3; // true
```

#### Greater than or equal to, `>=` {#binary-greater-equal}

Binary _greater than or equal to_ operator `>={:tact}` returns `true{:tact}` if the left operand is greater than or to the right operand, and `false{:tact}` otherwise. Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two >= 2; // true
-1 >= -3; // true
```

#### Less than, `<` {#binary-less}

Binary _less than_ operator `<{:tact}` returns `true{:tact}` if the left operand is less than the right operand, and `false{:tact}` otherwise. Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two < 2; // false
-1 < -3; // false
```

#### Less than or equal to, `<=` {#binary-less-equal}

Binary _less than or equal to_ operator `<={:tact}` returns `true{:tact}` if the left operand is less than or equal to the right operand, and `false{:tact}` otherwise. Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two <= 2; // true
-1 <= -3; // false
```

### Equality and inequality, `==` `!=` {#binary-equality}

Binary equality (_equal_) operator `=={:tact}` checks whether its two operands are _equal_, returning a result of type [`Bool{:tact}`][bool].

Binary inequality (_not equal_) operator `!={:tact}` checks whether its two operands are _not equal_, returning a result of type [`Bool{:tact}`][bool].

Both operators require operands to be of the same type and both don't perform implicit type conversions, except for the [`Cell{:tact}`][cell] and [`Slice{:tact}`][slice] types, which are implicitly compared by their hashes.

Both operators can be applied to the following list of types and values:

* [`Int{:tact}`][int]
* [`Bool{:tact}`][bool]
* [`Address{:tact}`][p]
* [`Cell{:tact}`][cell], implicitly compares via [`.hash(){:tact}`](/ref/core-cells#cellhash)
* [`Slice{:tact}`][slice], implicitly compares via [`.hash(){:tact}`](/ref/core-cells#slicehash)
* [`String{:tact}`][p]
* [`map<K, V>{:tact}`](/book/maps), but only if their key and value types are identical
* [Optionals and `null{:tact}` value](/book/optionals)

```tact
// Int:
2 == 3; // false
2 != 3; // true

// Bool:
true == true;  // true
false != true; // true

// Address:
myAddress() == myAddress(); // true
myAddress() != myAddress(); // false

// Cell:
emptyCell() == emptyCell(); // true
emptyCell() != emptyCell(); // false

// Slice:
"A".asSlice() == "A".asSlice(); // true
"A".asSlice() != "A".asSlice(); // false

// String:
"A" == "A"; // true
"A" != "A"; // false

// map<K, V>:
let map1: map<Int, Int> = emptyMap();
let map2: map<Int, Int> = emptyMap();
map1 == map2; // true
map1 != map2; // false

// Optionals and null values themselves
let nullable: Int? = null;
nullable == null; // true
null == null;     // true
nullable != null; // false
null != null;     // false

let anotherNullable: Int? = 5;
nullable == anotherNullable; // false
nullable != anotherNullable; // true
```

:::note

  Binary equality `=={:tact}` and inequality `!={:tact}` operators implicitly compare [maps](/book/maps) by the hashes of their respective [cells][cell] via [`.hash(){:tact}`](/ref/core-cells#cellhash) function. While this is ok for the majority of cases because most map serializers work identically to the one from TON Blockchain sources, it's still possible to get false negative results by serializing a map manually or by changing the logic of the serializer in some library.

  If you need to guarantee that maps you're comparing are equal, and you're willing to pay a lot more gas for it, use the [`map.deepEquals(){:tact}`](/book/maps#deepequals) function.

:::

### Bitwise AND, `&` {#binary-bitwise-and}

Binary ampersand (_bitwise AND_) operator `&{:tact}` applies a [bitwise AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND), which performs the [logical AND](#binary-logical-and) operation on each pair of the corresponding bits of operands. This is useful when we want to clear selected bits off a number, where each bit represents an individual flag or a boolean state, which makes it possible to "store" up to $257$ boolean values per integer, as all integers in Tact are $257$-bit signed.

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two & 1; // 0
4 & 1;   // 0
3 & 1;   // 1
1 & 1;   // 1

255 & 0b00001111;        // 15
0b11111111 & 0b00001111; // 15
```

:::note

  [Bitwise AND - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#AND)\
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### Bitwise XOR, `^` {#binary-bitwise-xor}

Binary caret (_bitwise XOR_) operator `^{:tact}` applies a [bitwise XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR), which performs the [logical exclusive OR](https://en.wikipedia.org/wiki/Exclusive_or) operation on each pair of the corresponding bits of operands. The result in each position is $1$ if only one of the bits is $1$, but will be $0$ if both are $0$ or both are $1$. In this it performs the comparison of two bits, giving $1$ if the two bits are different, and $0$ if they are the same.

It is useful for inverting selected bits of an operand (also called toggle or flip), as any bit may be toggled by "XORing" it with $1$.

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two ^ 3; // 1
4 ^ 1;   // 0
3 ^ 1;   // 3
1 ^ 1;   // 0

255 ^ 0b00001111;        // 240
0b11111111 ^ 0b00001111; // 240
```

:::note

  [Bitwise XOR - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)\
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### Bitwise OR, `|` {#binary-bitwise-or}

Binary bar (_bitwise OR_) operator `|{:tact}` applies a [bitwise OR](https://en.wikipedia.org/wiki/Bitwise_operation#OR), which performs the [logical OR](#binary-logical-or) operation on each pair of the corresponding bits of operands. This is useful when we want to apply a specific [bitmask](https://en.wikipedia.org/wiki/Mask_(computing)).

For example, _bitwise OR_ is commonly used in Tact to [combine base modes with optional flags](/book/message-mode#combining-modes-with-flags) by masking specific bits to $1$ in order to construct a target [message `mode`](/book/message-mode).

Can only be applied to values of type [`Int{:tact}`][int]:

```tact
let two: Int = 2;
two | 1; // 3
4 | 1;   // 5
3 | 1;   // 3
1 | 1;   // 1

255 | 0b00001111;        // 255
0b11111111 | 0b00001111; // 255
```

:::note

  [Bitwise OR - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#OR)\
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### Logical AND, `&&` {#binary-logical-and}

Binary logical AND ([logical conjunction](https://en.wikipedia.org/wiki/Logical_conjunction)) operator `&&{:tact}` returns `true{:tact}` if both operands are `true{:tact}`, and `false{:tact}` otherwise. It's short-circuited, meaning that it would immediately evaluate the whole expression as `false{:tact}` if the left operand is `false{:tact}`, without evaluating the right one.

Can only be applied to values of type [`Bool{:tact}`][bool]:

```tact
let iLikeTact: Bool = true;
iLikeTact && true;  // true, evaluated both operands
iLikeTact && false; // false, evaluated both operands
false && iLikeTact; // false, didn't evaluate iLikeTact
```

### Logical OR, `||` {#binary-logical-or}

Binary logical OR ([logical disjunction](https://en.wikipedia.org/wiki/Logical_disjunction)) operator `||{:tact}` returns `false{:tact}` only if both operands are `false{:tact}`, and `true{:tact}` otherwise. It's short-circuited, meaning that it would immediately evaluate the whole expression as `true{:tact}` if the left operand is `true{:tact}`, without evaluating the right one.

Can only be applied to values of type [`Bool{:tact}`][bool]:

```tact
let iLikeSnails: Bool = false;
iLikeSnails || true;  // true, evaluated both operands
iLikeSnails || false; // false, evaluated both operands
true || iLikeSnails;  // true, didn't evaluate iLikeSnails
```

## Ternary, `?:` {#ternary}

Conditional (_ternary_) operator is the only Tact operator that takes three operands: a condition followed by a question mark (`?{:tact}`), then an expression to execute if the condition is evaluated to `true{:tact}` followed by a colon (`:{:tact}`), and finally the expression to execute if the condition is evaluated to `false{:tact}`. This operator is frequently used as an alternative to an [`if...else{:tact}`](/book/statements#if-else) statement.

Condition must resolve to type [`Bool{:tact}`][bool]:

```tact
// condition
// ↓
true ? "incredibly so" : "absolutely not"; // "incredibly so"
//     ---------------   ----------------
//     ↑                 ↑
//     |                 alternative, when condition is false
//     |
//     consequence, when condition is true

2 + 2 == 4 ? true : false; // true
```

Ternary operator is the only operator with right associativity, besides [assignment-related ones](#assignment). This means that in ambiguous situations Tact would prefer the longest matching sequence. In short, this makes bracket-less nesting of ternary operators possible, but only for alternative cases (the part that comes after the colon sign `:{:tact}`):

```tact
// don't need additional parentheses for alternative cases
false ? 1 : (false ? 2 : 3); // 3
false ? 1 : false ? 2 : 3;   // also 3
false ? 1 : true ? 2 : 3;    // 2

// need additional parentheses for consequence cases (parts in-between ? and :)
false ? (false ? 1 : 2) : 3; // 3
false ? false ? 1 : 2 : 3;   // SYNTAX ERROR!
true  ? (false ? 1 : 2) : 3; // 2
```

## Assignment, `=` {#assignment}

Assignment operator `={:tact}` is used to assign a value to a variable, or to a property of a [Message](/book/structs-and-messages#messages) or a [Struct](/book/structs-and-messages#structs). The assignment is a statement and it doesn't return a value.

```tact
let someVar: Int = 5;    // assignment operator = is used here...
someVar = 4;             // ...and here
someVar = (someVar = 5); // SYNTAX ERROR!
```

### Augmented assignment

Augmented (or compound) assignment operators such as `+={:tact}` combine an operation with an [assignment](#assignment). The augmented assignment is a statement and it doesn't return a value.

Augmented assignments are semantically equivalent to regular assignments, but with an operation:

```tact
let value: Int = 5;

// this:
value += 5;
// is equivalent to this:
value = value + 5;
```

List of augmented assignment operators:

* `+={:tact}`, which uses [addition operator `+{:tact}`](#binary-add). Can only be applied to values of type [`Int{:tact}`][int].
* `-={:tact}`, which uses [subtraction operator `-{:tact}`](#binary-subtract). Can only be applied to values of type [`Int{:tact}`][int].
* `*={:tact}`, which uses [multiplication operator `*{:tact}`](#binary-multiply). Can only be applied to values of type [`Int{:tact}`][int].
* `/={:tact}`, which uses [division operator `/{:tact}`](#binary-divide). Can only be applied to values of type [`Int{:tact}`][int].
* `%={:tact}`, which uses [modulo operator `%{:tact}`](#binary-modulo). Can only be applied to values of type [`Int{:tact}`][int].
* `&={:tact}`, which uses [bitwise AND operator `&{:tact}`](#binary-bitwise-and). Can only be applied to values of type [`Int{:tact}`][int].
* `^={:tact}`, which uses [bitwise XOR operator `^{:tact}`](#binary-bitwise-xor). Can only be applied to values of type [`Int{:tact}`][int].
* `|={:tact}`, which uses [bitwise OR operator `|{:tact}`](#binary-bitwise-or). Can only be applied to values of type [`Int{:tact}`][int].

```tact
let value: Int = 5;

// +=
value + 5;         // adds 5
value = value + 5; // adds 5 and assigns result back
value += 5;        // also adds 5 and assigns result back

// -=
value - 5;         // subtracts 5
value = value - 5; // subtracts 5 and assigns result back
value -= 5;        // also subtracts 5 and assigns result back

// *=
value * 5;         // multiplies by 5
value = value * 5; // multiplies by 5 and assigns result back
value *= 5;        // also multiplies by 5 and assigns result back

// /=
value / 5;         // divides by 5
value = value / 5; // divides by 5 and assigns result back
value /= 5;        // also divides by 5 and assigns result back

// %=
value % 5;         // gets modulo by 5
value = value % 5; // gets modulo by 5 and assigns result back
value %= 5;        // also gets modulo by 5 and assigns result back

// &=
value & 5;         // bitwise ANDs 5
value = value & 5; // bitwise ANDs 5 and assigns result back
value &= 5;        // also bitwise ANDs 5 and assigns result back

// ^=
value ^ 5;         // bitwise XORs 5
value = value ^ 5; // bitwise XORs 5 and assigns result back
value ^= 5;        // also bitwise XORs 5 and assigns result back

// |=
value | 5;         // bitwise ORs 5
value = value | 5; // bitwise ORs 5 and assigns result back
value |= 5;        // also bitwise ORs 5 and assigns result back
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[cell]: /book/cells#cells
[slice]: /book/cells#slices


## optionals.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/optionals.mdx)
---
title: Optionals
---

As it was mentioned in [type system overview](/book/types#optionals), all [primitive types](/book/types#primitive-types), [Structs](/book/structs-and-messages#structs) and [Messages](/book/structs-and-messages#messages) could be nullable. That is, they don't necessarily hold any value, aside from `null{:tact}` — a special value, which represents the intentional absence of any other value.

[Variables](/book/statements#let) or fields of [Structs](/book/structs-and-messages#structs) and [Messages](/book/structs-and-messages#messages) that can hold `null{:tact}` are called "optionals". They're useful to reduce state size when the variable isn't necessarily used.

You can make any variable or a field an optional by adding a question mark (`?{:tact}`) after its type declaration. The only exceptions are [`map<K, V>{:tact}`](/book/maps) and [`bounced<Msg>{:tact}`](/book/bounced), where you can't make them, inner key/value type (in case of a map) or the inner [Message](/book/structs-and-messages#messages) (in case of a bounced) optional.

Optional variables or optional fields that are not defined hold the `null{:tact}` value by default. You cannot access them without checking for `null{:tact}` first. But if you're certain they are not `null{:tact}` at a given moment, use the [non-null assertion operator `!!{:tact}`](/book/operators#unary-non-null-assert) to access their value.

Trying to access the value of an optional variable or an optional field without using [`!!{:tact}`](/book/operators#unary-non-null-assert) or without checking for `null{:tact}` beforehand will result in a compilation error if the compiler can track it, and if not — in an exception with [exit code 128](/book/exit-codes#128): `Null reference exception`.

Example of optionals:

```tact
struct StOpt {
    opt: Int?; // Int or null
}

message MsOpt {
    opt: StOpt?; // Notice, how the struct StOpt is used in this definition
}

contract Optionals {
    opt: Int?;
    address: Address?;

    init(opt: Int?) { // optionals as parameters
        self.opt = opt;
        self.address = null; // explicit null value
    }

    receive(msg: MsOpt) {
        let opt: Int? = 12; // defining a new variable
        if (self.opt != null) { // explicit check
            self.opt = opt!!; // using !! as we know that opt value isn't null
        }
    }
}
```


## receive.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/receive.mdx)
---
title: Receive messages
description: "The most common type of messages is the internal message - a message sent from one contract to another"
prev:
  link: /book/functions
  label: Functions
---

TON is a distributed blockchain which means that communication between contracts is done by sending and receiving messages. The most common type of messages is the internal message - a message sent from one contract (or a wallet) to another.

## Receive internal messages

To receive a message of the required type, you need to declare a receiver function, for example, `receive("increment"){:tact}`. This notation means the declaration of a receiver function that will be called when a text with the value `"increment"{:tact}` is sent to the contract. The function body can modify the state of the contract and send messages to other contracts. It is impossible to call a receiver directly. If you need to reuse some logic you can declare a function and call it from the receiver.

There are several receiver functions. All receiver functions are processed in the order they are listed below:

* `receive(){:tact}` - called when an empty message is sent to the contract
* `receive("message"){:tact}` - called when a text message with a specific comment is sent to the contract
* `receive(str: String){:tact}` - called when an arbitrary text message is sent to the contract
* `receive(msg: MyMessage){:tact}` - called when a binary message of type `MyMessage` is sent to the contract
* `receive(msg: Slice){:tact}` - called when binary message of unknown type is sent to the contract

```tact
message MyMessage {
    value: Int;
}

contract MyContract {
    receive() {
        // ...
    }
    receive("message") {
        // ...
    }
    receive(str: String) {
        // ...
    }
    receive(msg: MyMessage) {
        // ...
    }
    receive(msg: Slice) {
        // ...
    }
}
```

Naming a parameter of the receiver function with an underscore `_{:tact}` makes its value considered unused and discarded. This is useful when you don't need to inspect the message received and you only want it to convey a specific opcode:

```tact
message(42) UniverseCalls {}

contract Example {
    receive(_: UniverseCalls) {
        // Got a Message with opcode 42
    }
}
```


## security-best-practices.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/security-best-practices.mdx)
---
title: Security best practices
description: "Several anti-patterns and potential attack vectors, as well as best practices, that Tact smart contract developers should be aware of"
---

[//]: # (✅❌)

There are several anti-patterns and potential attack vectors that Tact smart contract developers should be aware of. These can affect the security, efficiency, and correctness of the contracts. Below we discuss the do's and don'ts specific to writing and maintaining secure Tact smart contracts.

For a deeper understanding, refer to the following resources:

* [Smart contracts guidelines in TON Docs](https://docs.ton.org/v3/guidelines/smart-contracts/guidelines)
* [Secure Smart Contract Programming in TON Docs](https://docs.ton.org/v3/guidelines/smart-contracts/security/secure-programming)
* [FunC Security Best Practices in GitHub repo](https://github.com/slowmist/Toncoin-Smart-Contract-Security-Best-Practices/blob/main/README.md)

In addition, consider reading the detailed article by CertiK, a Web3 smart contract auditor: [Secure Smart Contract Programming in Tact: Popular Mistakes in the TON Ecosystem](https://www.certik.com/resources/blog/secure-smart-contract-programming-in-tact-popular-mistakes-in-the-ton).

## Send sensitive data on-chain

The entire smart contract computation is transparent, and if you had some confidential values at run-time, they could be retrieved with a simple emulation.

##### Do's ✅

Do **not** send or store sensitive data on-chain.

##### Don'ts ❌

```tact
import "@stdlib/deploy";

message Login {
    privateKey: Int as uint256;
    signature: Slice;
    data: Slice;
}

contract Test with Deployable {
    receive(msg: Login) {
        let publicKey = getPublicKey(msg.privateKey);

        require(checkDataSignature(msg.data, msg.signature, publicKey), "Invalid signature!");
    }
}
```

## Misuse of signed integers

Unsigned integers are safer because they prevent most errors by design, while signed integers can have unpredictable consequences if not used carefully. Therefore, signed integers should be used only when absolutely necessary.

##### Do's ✅

Prefer to use unsigned integers unless signed integers are required.

##### Don'ts ❌

The following is an example of the incorrect use of a signed integer. In the `Vote{:tact}` [Message][message], the type of the `votes` field is `Int as int32{:tact}`, which is a $32$-bit singed integer. This can lead to spoofing if the attacker sends the negative number of votes instead of a positive one.

```tact
message Vote { votes: Int as int32 }

contract Sample {
    votes: Int as uint32 = 0;

    receive(msg: Vote) {
        self.votes += msg.votes;
    }
}
```

## Invalid throw values

[Exit codes](/book/exit-codes) $0$ and $1$ indicate normal execution of the compute phase of the transaction. Execution can be unexpectedly aborted by calling a [`throw(){:tact}`](/ref/core-debug#throw) or [similar functions](/ref/core-debug) directly with exit codes $0$ and $1$. This can make debugging very difficult since such aborted execution would be indistinguishable from a normal one.

##### Do's ✅

Prefer to use the [`require(){:tact}`](/ref/core-debug#require) function to state expectations.

```tact
require(isDataValid(msg.data), "Invalid data!");
```

##### Don'ts ❌

Don't throw $0$ or $1$ directly.

```tact
throw(0);
throw(1);
```

## Insecure random numbers

Generating truly secure random numbers in TON is challenging. The [`random()`](/ref/core-random#random) function is pseudo-random and depends on [logical time](https://docs.ton.org/develop/smart-contracts/guidelines/message-delivery-guarantees#what-is-a-logical-time). A hacker can predict the randomized number by [brute-forcing](https://en.wikipedia.org/wiki/Brute-force_attack) the logical time in the current block.

##### Do's ✅

* For critical applications **avoid relying solely on on-chain solutions**.

* Use [`random(){:tact}`](/ref/core-random#random) with randomized logical time to enhance security by making predictions harder for attackers without access to a validator node. Note, however, that it is still **not entirely foolproof**.

* Consider using the **commit-and-disclose scheme**:
  1. Participants generate random numbers off-chain and send their hashes to the contract.
  2. Once all hashes are received, participants disclose their original numbers.
  3. Combine the disclosed numbers (e.g., summing them) to produce a secure random value.

For more details, refer to the [Secure Random number generation page in TON Docs](https://docs.ton.org/v3/guidelines/smart-contracts/security/random-number-generation).

##### Don'ts ❌

Don't rely on the [`random(){:tact}`](/ref/core-random#random) function.

```tact
if (random(1, 10) == 7) {
  ... send reward ...
}
```

Don't use randomization in `external_message` receivers, as it remains vulnerable even with randomizing logical time.

## Optimized message handling

String parsing from human-friendly formats into machine-readable binary structures should be done **off-chain**. This approach ensures that only optimized and compact messages are sent to the blockchain, minimizing computational and storage costs while avoiding unnecessary gas overhead.

##### Do's ✅

Perform string parsing from human-readable formats into machine-readable binary structures **off-chain** to keep the contract efficient.

```tact
message Sample {
    parsedField: Slice;
}

contract Example {
    receive(msg: Sample) {
        // Process msg.parsedField directly
    }
}
```

##### Don'ts ❌

Avoid parsing strings from human-readable formats into binary structures **on-chain**, as this increases computational overhead and gas costs.

```tact
message Sample { field: String }

contract Example {
    receive(msg: Sample) {
        // Parsing occurs on-chain, which is inefficient
        let parsed = field.fromBase64();
    }
}
```

## Gas limitation

Be careful with the `Out of gas error`. It cannot be handled, so try to pre-calculate the gas consumption for each receiver [using tests](/book/debug#tests) whenever possible. This will help to avoid wasting extra gas because the transaction will fail anyway.

##### Do's ✅

```tact
message Vote { votes: Int as int32 }

contract Example {
    const voteGasUsage = 10000; // precompute with tests

    receive(msg: Vote) {
        require(context().value > getComputeFee(self.voteGasUsage, false), "Not enough gas!");
    }
}
```

## Identity validation

Always validate the identity of the sender if your contract logic revolves around trusted senders. This can be done using the [`Ownable{:tact}`](/ref/stdlib-ownable) trait or using [state init](/book/expressions#initof) validation. You can read more about [Jetton validation](/cookbook/jettons#accepting-jetton-transfer) and [NFT validation](/cookbook/nfts#accepting-nft-ownership-assignment).

##### Do's ✅

Use the [`Ownable{:tact}`](/ref/stdlib-ownable) trait.

```tact
import "@stdlib/ownable";

contract Counter with Ownable {
    owner: Address;
    val: Int as uint32;

    init() {
        self.owner = address("OWNER_ADDRESS");
        self.val = 0;
    }

    receive("admin-double") {
        self.requireOwner();
        self.val = self.val * 2;
    }
}
```

##### Don'ts ❌

Don't execute a message without validating the sender's identity!

```tact
contract Example with Deployable {
    myJettonWalletAddress: Address;
    myJettonAmount: Int as coins = 0;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.myJettonWalletAddress = calculateJettonWalletAddress(
            myAddress(),
            jettonMasterAddress,
            jettonWalletCode,
        );
    }

    receive(msg: JettonTransferNotification) {
        self.myJettonAmount += msg.amount;
    }
}
```

## Replay protection

Replay protection is a security mechanism that prevents an attacker from reusing a previous message. More information about replay protection can be found on the [External messages page in TON Docs](https://docs.ton.org/develop/smart-contracts/guidelines/external-messages).

##### Do's ✅

To differentiate messages, always include and validate a unique identifier, such as `seqno`. Update the identifier after successful processing to avoid duplicates.

Alternatively, you can implement a replay protection similar to the one in the [highload v3 wallet](https://github.com/ton-blockchain/highload-wallet-contract-v3/blob/main/contracts/highload-wallet-v3.func#L60), which is not based on `seqno`.

```tact
message Msg {
    newMessage: Cell;
    signature: Slice;
}

struct DataToVerify {
    seqno: Int as uint64;
    message: Cell;
}

contract Sample {
    publicKey: Int as uint256;
    seqno: Int as uint64;

    init(publicKey: Int, seqno: Int) {
        self.publicKey = publicKey;
        self.seqno = seqno;
    }

    external(msg: Msg) {
        require(checkDataSignature(DataToVerify{
            seqno: self.seqno,
            message: msg.newMessage
        }.toSlice(), msg.signature, self.publicKey), "Invalid signature");
        acceptMessage();
        self.seqno += 1;
        nativeSendMessage(msg.newMessage, 0);
    }
}
```

##### Don'ts ❌

Do not rely on signature verification without the inclusion of a sequence number. Messages without replay protection can be resent by attackers because there is nothing to distinguish a valid original message from a replayed one.

```tact
message Msg {
    newMessage: Cell;
    signature: Slice;
}

contract Sample {
    publicKey: Int as uint256;

    init(publicKey: Int, seqno: Int) {
        self.publicKey = publicKey;
    }

    external(msg: Msg) {
        require(checkDataSignature(msg.toSlice(), msg.signature, self.publicKey), "Invalid signature");
        acceptMessage();
        nativeSendMessage(msg.newMessage, 0);
    }
}
```

## Race condition of messages

A message cascade can be processed over many blocks. Assume that while one message flow is running, an attacker can initiate a second message flow in parallel. That is, if a property was checked at the beginning, such as whether the user has enough tokens, do not assume that it will still be satisfied at the third stage in the same contract.

## Handle/Send bounced messages

Send messages with the bounce flag set to `true{:tact}`, which is a default for the [`send(){:tact}`](/ref/core-common#send) function. Messages bounce when the execution of a contract has failed. You may want to deal with this by rolling back the state of the contract by wrapping code in [`try...catch{:tact}`](/book/statements#try-catch) statements and some additional processing depending on your logic.

##### Do's ✅

Handle bounced messages via a [bounced message receiver](/book/bounced/#bounced-message-receiver) to correctly react to failed messages.

```tact
contract JettonDefaultWallet {
    const minTonsForStorage: Int = ton("0.01");
    const gasConsumption: Int = ton("0.01");

    balance: Int;
    owner: Address;
    master: Address;

    init(master: Address, owner: Address) {
        self.balance = 0;
        self.owner = owner;
        self.master = master;
    }

    receive(msg: TokenBurn) {
        let ctx: Context = context();
        require(ctx.sender == self.owner, "Invalid sender");

        self.balance = self.balance - msg.amount;
        require(self.balance >= 0, "Invalid balance");

        let fwdFee: Int = ctx.readForwardFee();
        require(ctx.value > fwdFee + 2 * self.gasConsumption + self.minTonsForStorage, "Invalid value - Burn");

        send(SendParameters{
            to: self.master,
            value: 0,
            mode: SendRemainingValue,
            bounce: true,
            body: TokenBurnNotification{
                queryId: msg.queryId,
                amount: msg.amount,
                owner: self.owner,
                response_destination: self.owner
            }.toCell()
        });
    }

    bounced(src: bounced<TokenBurnNotification>) {
        self.balance = self.balance + src.amount;
    }
}
```

## Transaction and phases

From [Sending messages page](/book/send#outbound-message-processing) of the Book:

> Each transaction on TON Blockchain consists of multiple phases. Outbound messages are evaluated in compute phase, but are **not** sent in that phase. Instead, they're queued in order of appearance for the action phase, where all actions listed in compute phase, like outbound messages or reserve requests, are executed.

Hence, if the compute phase fails, [registers](https://docs.ton.org/v3/documentation/tvm/tvm-overview#control-registers) `c4` (persistent data) and `c5` (actions) won't be updated. However, it is possible to manually save their state using [`commit(){:tact}`](/ref/core-advanced/#commit) function.

## Return gas excesses carefully

If excess gas is not returned to the sender, the funds will accumulate in your contracts over time. Nothing terrible in principle, just a suboptimal practice. You can add a function to rake out excess, but popular contracts like TON Jetton still return to the sender with the [Message][message] with `0xd53276db` opcode.

##### Do's ✅

Return excesses using a [Message][message] with `0xd53276db` opcode.

```tact
message(0xd53276db) Excesses {}
message Vote { votes: Int as int32 }

contract Sample {
    votes: Int as uint32 = 0;

    receive(msg: Vote) {
        self.votes += msg.votes;

        send(SendParameters{
            to: sender(),
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
            body: Excesses{}.toCell(),
        });
    }
}
```

Also, you can leverage [`notify(){:tact}`](/ref/core-base/#self-notify) or [`forward(){:tact}`](/ref/core-base/#self-forward) standard functions.

```tact
message(0xd53276db) Excesses {}
message Vote { votes: Int as int32 }

contract Sample {
    votes: Int as uint32 = 0;

    receive(msg: Vote) {
        self.votes += msg.votes;

        self.notify(Excesses{}.toCell());
    }
}
```

## Pulling data from other contract

Contracts in the blockchain can reside in separate shards, processed by other set of validators, meaning that one contract cannot pull data from other contracts. That is, no contract can call a [getter function](/book/functions#getter-functions)) from other contracts.

Thus, any on-chain communication is asynchronous and done by sending and receiving messages.

##### Do's ✅

Exchange messages to pull data from other contract.

```tact
message ProvideMoney {}
message TakeMoney { money: Int as coins }

contract OneContract {
    money: Int as coins;

    init(money: Int) {
        self.money = money;
    }

    receive(msg: ProvideMoney) {
        self.reply(TakeMoney{money: self.money}.toCell());
    }
}

contract AnotherContract {
    oneContractAddress: Address;

    init(oneContractAddress: Address) {
        self.oneContractAddress = oneContractAddress;
    }

    receive("get money") {
        self.forward(self.oneContractAddress, ProvideMoney{}.toCell(), false, null);
    }

    receive(msg: TakeMoney) {
        require(sender() == self.oneContractAddress, "Invalid money provider!");
        // Money processing
    }
}
```

[struct]: /book/structs-and-messages#structs
[message]: /book/structs-and-messages#messages


## send.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/send.mdx)
---
title: Sending messages
description: "TON Blockchain is message-based — to communicate with other contracts and to deploy new ones you need to send messages."
---

TON blockchain is message-based — to communicate with other contracts and to deploy new ones you need to send messages.

Messages in Tact are commonly composed using a built-in [Struct](/book/structs-and-messages#structs) `SendParameters{:tact}`, which consists of:

Field    | Type                   | Description
:------- | :--------------------- | :----------
`bounce` | [`Bool{:tact}`][p]     | When set to `true` (default) message bounces back to the sender if the receiver contract doesn't exist or wasn't able to process the message.
`to`     | [`Address{:tact}`][p]  | Receiver internal [`Address{:tact}`][p] in TON blockchain.
`value`  | [`Int{:tact}`][int]    | The amount of [nanoToncoins][nano] you want to send with the message. This value is usually used to cover [forward fees][fwdfee], unless the optional flag [`SendPayGasSeparately{:tact}`](/book/message-mode#optional-flags) is used.
`mode`   | [`Int{:tact}`][int]    | An 8-bit value that configures how to send a message, defaults to $0$. See: [Message `mode`](/book/message-mode).
`body`   | [`Cell?{:tact}`][cell] | [Optional][opt] message body as a [`Cell{:tact}`][cell]
`code`   | [`Cell?{:tact}`][cell] | [Optional][opt] initial code of the contract (the compiled bytecode)
`data`   | [`Cell?{:tact}`][cell] | [Optional][opt] initial data of the contract (arguments of [`init(){:tact}` function](/book/contracts#init-function) of the contract)

Fields `code` and `data` are what's called an [init package](/book/expressions#initof), which is used in deployments of new contracts.

## Send simple reply

The simplest message is a reply to the incoming message returning all excess value of a message:

```tact
self.reply("Hello, World!".asComment()); // asComment converts a String to a Cell with a comment
```

## Send message

If you need more advanced logic you can use the `send(){:tact}` function and `SendParameters{:tact}` [Struct](/book/structs-and-messages#structs) directly.

In fact, the previous example with [`.reply(){:tact}`](#send-simple-reply) can be made using the following call to `send(){:tact}` function:

```tact
send(SendParameters{
    // bounce is set to true by default
    to: sender(), // sending message back to the sender
    value: 0, // don't add Toncoins to the message...
    mode: SendRemainingValue | SendIgnoreErrors, // ...except for ones received from the sender due to SendRemainingValue
    body: "Hello, World".asComment(), // asComment converts a String to a Cell with a comment
});
```

Another example sends a message to the specified [`Address{:tact}`][p] with a `value` of $1$ TON and the `body` of a comment with a [`String{:tact}`][p] `"Hello, World!"{:tact}`:

```tact
let recipient: Address = address("...");
let value: Int = ton("1");
send(SendParameters{
    // bounce is set to true by default
    to: recipient,
    value: value,
    mode: SendIgnoreErrors, // will send the message despite any errors
    body: "Hello, World!".asComment(),
});
```

The [optional flag](/book/message-mode#optional-flags) `SendIgnoreErrors{:tact}` means that even when an error occurs during message sending next messages would be sent anyway. **No error during the sending phase would revert a transaction.**

## Send typed message

To send a binary typed message you can use the following code:

```tact
let recipient: Address = address("...");
let value: Int = ton("1");
send(SendParameters{
    // bounce is set to true by default
    to: recipient,
    value: value,
    mode: SendIgnoreErrors, // don't stop in case of errors
    body: SomeMessage{arg1: 123, arg2: 1234}.toCell(),
});
```

## Deploy contract

To deploy a contract you need to calculate its address and initial state with [`initOf{:tact}`](/book/expressions#initof), then send them in the initialization message:

```tact
let init: StateInit = initOf SecondContract(arg1, arg2);
let address: Address = contractAddress(init);
let value: Int = ton("1");
send(SendParameters{
    // bounce is set to true by default
    to: address,
    value: value,
    mode: SendIgnoreErrors, // don't stop in case of errors
    code: init.code,
    data: init.data,
    body: "Hello, World!".asComment(), // not necessary, can be omitted
});
```

## Outbound message processing

Each transaction on TON Blockchain consists of [multiple phases][phases]. Outbound messages are evaluated in [compute phase][compute], but are **not** sent in that phase. Instead, they're queued in order of appearance for the [action phase][phases], where all actions listed in [compute phase][compute], like outbound messages or [reserve requests](/ref/core-advanced#nativereserve), are executed.

As all the values are computed in [compute phase][compute], all the fees computed by the end of it, and exceptions do not revert the transaction during [action phase][phases], outbound message sends can fail without bounce due to unsufficient [action fees](https://docs.ton.org/develop/howto/fees-low-level#action-fee) or [forward fees][fwdfee].

Consider the following example:

```tact
// This contract initially has 0 nanoToncoins on the balance
contract FailureIsNothingButAnotherStep {
    // And all the funds it gets are obtained from inbound internal messages
    receive() {
        // 1st outbound message evaluated and queued (but not sent yet)
        send(SendParameters{
            to: sender(),
            value: ton("0.042"), // plus forward fee due to SendPayGasSeparately
            mode: SendIgnoreErrors | SendPayGasSeparately,
        });

        // 2nd outbound message evaluated and queued (but not sent yet, and never will be!)
        send(SendParameters{
            to: sender(),
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
        });
    }
}
```

There, the second message won't actually be sent:

* After finishing the [compute phase][compute], the remaining value $\mathrm{R}$ of the contract is computed.

* During the outbound message processing and assuming that there was enough value provided in the inbound message, the first message leaves $\mathrm{R} - (0.042 + \mathrm{forward\_fees})$ [nanoToncoins](/book/integers#nanotoncoin) on the balance.

* When the second message is processed, contract tries to send $\mathrm{R}$ [nanoToncoins](/book/integers#nanotoncoin), but fails to do so because there is already a smaller amount left.

:::note

  Read more about all message sending functions in the Reference:
  * [`send(){:tact}`](/ref/core-common#send)
  * [`emit(){:tact}`](/ref/core-common#emit)
  * [`self.notify(){:tact}`](/ref/core-base#self-notify)
  * [`self.reply(){:tact}`](/ref/core-base#self-reply)
  * [`self.forward(){:tact}`](/ref/core-base#self-forward)
  * [`nativeSendMessage(){:tact}`](/ref/core-advanced#nativesendmessage)

:::

[p]: /book/types#primitive-types
[int]: /book/integers
[cell]: /book/cells#cells
[opt]: /book/optionals

[phases]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases
[compute]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase
[nano]: /book/integers#nanotoncoin
[fwdfee]: https://docs.ton.org/develop/howto/fees-low-level#forward-fees


## statements.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/statements.mdx)
---
title: Statements
description: "This page lists all the statements in Tact, which can appear anywhere in the function bodies"
---

import { Badge } from '@astrojs/starlight/components';

The following statements can appear anywhere in the [function](/book/functions) body.

## `let` statement {#let}

The `let{:tact}` statement allows local and [block](#block)-scoped variable declaration.

In Tact, declaring a local variable always requires an initial value. However, the type ascription can be omitted and Tact will try to infer it from the initial value:

```tact
let value: Int = 123; // full declaration with type and value
let vInferred = 123;  // inferred type Int

let vExplicitCtx: Context = context(); // explicit type Context, a built-in Struct
let vCtx = context();                  // inferred type Context
```

Note, that initial value of `null{:tact}` can mean both an empty [`map<K, V>{:tact}`](/book/maps) with arbitrary `K{:tact}` and `V{:tact}` types, and the intentional absence of any other value for the [optional](/book/optionals) type. That's why whenever you're declaring an [optional](/book/optionals) or a [`map<K, V>{:tact}`](/book/maps), you'll need to explicitly specify the type as it cannot be inferred:

```tact
let vOptional: Int? = null; // explicit type Int or null
let vOptInt = 42;           // implicit type Int
vOptInt = null;             // COMPILATION ERROR!

let vMap: map<Int, Int> = emptyMap(); // explicit type map<Int, Int>
let vMapWithSerialization: map<Int as uint8, Int as uint8> = emptyMap();
```

Naming a local variable with underscore `_{:tact}` makes its value considered unused and discarded. This is useful when you don't need a return value of some function with side effects, and want to explicitly mark the variable as unused. Note, that such wildcard variable name `_{:tact}` cannot be accessed:

```tact
let _ = someFunctionWithSideEffects(); // with type inference
let _: map<Int, Int> = emptyMap();     // with explicit type

dump(_); // COMPILATION ERROR! Cannot access _
```

## `return` statement {#return}

The `return{:tact}` statement ends [function](/book/functions) execution and specifies a value to be returned to the [function](/book/functions) caller.

```tact
// Simple wrapper over stdlib function now()
fun getTimeFromNow(offset: Int): Int {
    return now() + offset;
}
```

## Block

A block statement is used to group zero or more statements. The block is delimited by a pair of braces ("curly braces", `{}{:tact}`) and contains a list of zero or more statements and declarations.

Some statements, such as [`let{:tact}`](#let) or [`return{:tact}`](#return), must end with a terminating semicolon `;{:tact}`. However, the semicolon of the last statement in the block is optional and may be omitted.

```tact
{ // <- start of the block
    // arbitrary statements:
    let value: Int = 2 + 2;
    dump(value);
} // <- end of the block

{ dump(2 + 2) } // a block with only one statement,
                // omitted the last and only semicolon

{
    let nah = 3 * 3 * 3; // a block with two statements,
    let yay = nah + 42   // but without the last semicolon
}
```

## Expression

An expression statement is an expression used in a place where a statement is expected. The expression is evaluated and its result is discarded — therefore, it makes sense only for expressions that have side effects, such as executing a function or updating a variable.

```tact
dump(2 + 2); // stdlib function
```

## Assignment

Assignment statements use an [assignment operator](/book/operators#assignment) (`={:tact}`) or [augmented assignment operators](/book/operators#augmented-assignment) (assignments combined with an operation):

```tact
let value: Int; // declaration
value = 5;      // assignment
value += 5;     // augmented assignment (one of the many, see below)
```

:::note

  Read more about assignment and augmented assignment in their dedicated section: [assignment operators](/book/operators#assignment).

:::

## Destructuring assignment

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

The destructuring assignment is a concise way to unpack [Structs][s] and [Messages][m] into distinct variables. It mirrors the [instantiation syntax](/book/expressions#instantiation), but instead of creating a new [Struct][s] or [Message][m] it binds every field or some of the fields to their respective variables.

The syntax is derived from the [`let` statement](#let), and instead of specifying the variable name directly it involves specifying the structure type on the left side of the [assignment operator `={:tact}`](/book/operators#assignment), which corresponds to the structure type of the value on the right side.

```tact {9}
// Definition of Example
struct Example { number: Int }

// An arbitrary helper function
fun get42(): Example { return Example { number: 42 } }

fun basic() {
    // Basic syntax of destructuring assignment (to the left of "="):
    let Example { number } = get42();
    //  -------   ------     -------
    //  ↑         ↑          ↑
    //  |         |          gives the Example Struct
    //  |         definition of "number" variable, derived
    //  |         from the field "number" in Example Struct
    //  target structure type "Example"
    //  to destructure fields from

    // Same as above, but with an instantiation
    // to showcase how destructuring syntax mirrors it:
    let Example { number } = Example { number: 42 };
    //                       ----------------------
    //                       ↑
    //                       instantiation of Example Struct

    // Above examples of syntax are roughly equivalent
    // to the following series of statements:
    let example = Example { number: 42 };
    let number = example.number;
}
```

Just like in [instantiation](/book/expressions#instantiation), the trailing comma is allowed.

```tact
struct Example { number: Int }

fun trailblazing() {
    let Example {
        number,     // trailing comma inside variable list
    } = Example {
        number: 42, // trailing comma inside field list
    };
}
```

:::note

  [Augmented assignment operators](/book/operators#augmented-assignment) do not make sense for such assignments and will therefore be reported as parsing errors:

  ```tact
  struct Example { number: Int }
  fun get42(): Example { return Example { number: 42 } }

  fun basic() {
      let Example { number } += get42();
      //                     ^ this will result in the parse error:
      //                     expected "="
  }
  ```

:::

To create a binding under a different variable name, specify it after the semicolon `:{:tact}`.

```tact
// Similar definition, but this time field is called "field", not "number"
struct Example { field: Int }

fun naming(s: Example) {
    let Example { field: varFromField } = s;
    //                   ------------     ↑
    //                   ↑                |
    //                   |                instance of Example Struct, received
    //                   |                as a parameter of the function "naming"
    //                   definition of "varFromField" variable, derived
    //                   from the field "field" in Example Struct
}
```

Note, that the order of bindings doesn't matter — all the fields retain their values and types under their names no matter the order in which they stand in their definition in the respective [Struct][s] or [Message][m].

```tact
// "first" goes first, then goes "second"
struct Two { first: Int; second: String }

fun order(s: Two) {
    let Two { second, first } = s;
    //        ------  -----
    //        ↑       ↑
    //        |       this variable will be of type Int,
    //        |       same as the "first" field on Struct Two
    //        this variable will be of type String,
    //        same as the "second" field in Struct Two
}
```

Destructuring assignment is exhaustive and requires specifying all the fields as variables. To deliberately ignore some of the fields, use an underscore `_{:tact}`, which discards the considered field's value. Note, that such wildcard variable name `_{:tact}` cannot be accessed:

```tact
// "first" goes first, then goes "second"
struct Two { first: Int; second: String }

fun discard(s: Two) {
    let Two { second: _, first } = s;
    //              ---
    //              ↑
    //              discards the "second" field, only taking the "first"
}
```

To completely ignore the rest of the fields, use `..` at the end of the list:

```tact
struct Many { one: Int; two: Int; three: Int; fans: Int }

fun ignore(s: Many) {
    let Many { fans, .. } = s;
    //               --
    //               ↑
    //               ignores all the unspecified fields,
    //               defining only "fans"
}
```

:::caution

  At the moment, destructuring of nested [Structs][s] or [Messages][m] isn't allowed. That is, the following won't work:

  ```tact
  struct First { nested: Second }
  struct Second { field: Int }

  fun example() {
      let prep = First { nested: Second { field: 42 } };
      let First { nested: { field: thing } } = prep;
      //                  ^ this will result in the parse error:
      //                  expected "_", "A".."Z", or "a".."z"
  }
  ```

:::

## Branches

Control the flow of the code.

### `if...else` {#if-else}

:::caution

  Curly brackets (code blocks) are required!

:::

When executing an `if...else{:tact}` statement, first, the specified condition gets evaluated. If the resulting value is `true{:tact}`, the following statement block gets executed. Otherwise, if the condition evaluates to `false{:tact}`, the optional `else{:tact}` block will be executed. If the `else{:tact}` block is missing, nothing happens and execution continues further.

Regular `if{:tact}` statement:

```tact
// condition
// ↓
if (true) { // consequence, when condition is true
    dump(2 + 2);
}
```

With `else{:tact}` block:

```tact
// condition
// ↓
if (2 + 2 == 4) {
    // consequence, when condition is true
    dump(true);
} else {
    // alternative, when condition is false
    dump(false);
}
```

With nested `if...else{:tact}`:

```tact
// condition
// ↓
if (2 + 2 == 3) {
    // consequence, when condition is true
    dump("3?");
//        condition2
//        ↓
} else if (2 + 2 == 4) {
    // another consequence, when condition2 is true
    dump(true);
} else {
    // alternative, when both condition and condition2 are false
    dump(false);
}
```

:::note

  Tact also has a ternary expression `?:{:tact}`, which is described earlier in the Book: [Ternary](/book/operators#ternary).

:::

### `try...catch` {#try-catch}

The `try...catch{:tact}` statement is comprised of a `try{:tact}` block and an optional `catch{:tact}` block, which receives an [`Int{:tact}`][int] [exit code](/book/exit-codes) as its only argument. The code in the `try{:tact}` block is executed first, and if it fails, the code in the `catch{:tact}` block will be executed and changes made in `try{:tact}` block will be rolled back, if possible.

:::note

  Note, that some TVM state parameters, such as codepage and gas counters, will not be rolled back. That is, all gas usage in the `try{:tact}` block will be taken into account and the effects of opcodes that change the gas limit will be preserved.

:::

Regular `try{:tact}` statement:

```tact
fun braveAndTrue() {
    // Lets try and do something erroneous
    try {
        nativeThrow(42); // throwing with exit code 42
    }

    // The following will be executed as the erroneous code above was wrapped in a try block
    dump(42);
}
```

With `catch (e){:tact}` block:

```tact
fun niceCatch() {
    // Lets try and do something erroneous
    try {
        nativeThrow(42); // throwing with exit code 42
    } catch (err) {
        dump(err);       // this will dump the exit code caught, which is 42
    }
}
```

With nested `try...catch{:tact}`:

```tact
try {
    // Preparing an x equal to 0, in such a way that Tact compiler won't realize it (yet!)
    let xs: Slice = beginCell().storeUint(0, 1).endCell().beginParse();
    let x: Int = xs.loadUint(1); // 0

    try {
        throw(101);     // 1. throws with exit code 101
    } catch (err) {     // 2. catches the error and captures its exit code (101) as err
        return err / x; // 3. divides err by x, which is zero, throwing with exit code 4
    }

} catch (err) {         // 4. catches the new error and captures its exit code (4) as err
    //   ^^^ this works without name collisions because the previous err
    //       has a different scope and is only visible inside the previous catch block

    dump(err);          // 5. dumps the last caught exit code (4)
}
```

Note, that similar to [`let{:tact}` statement](#let), captured [exit code](/book/exit-codes) in the `catch (){:tact}` clause can be discarded by specifying an underscore `_{:tact}` in its place:

```tact
try {
    throw(42);
} catch (_) {
    dump("I don't know the exit code anymore");
}
```

:::note

  Read more about exit codes on the dedicated page: [Exit codes in the Book](/book/exit-codes).

:::

## Loops

Conditionally repeat certain blocks of code multiple times.

### `repeat` {#repeat-loop}

The `repeat{:tact}` loop executes a block of code a specified number of times. The number of repetitions should be given as a positive $32$-bit [`Int{:tact}`][int] in the inclusive range from $1$ to $2^{31} - 1$. If the value is greater, an error with the [exit code 5](/book/exit-codes#5), `Integer out of the expected range` would be thrown.

If the specified number of repetitions is equal to $0$ or any negative number in the inclusive range $-2^{256}$ to $-1$, it is ignored and the code block is not executed at all.

```tact
let twoPow: Int = 1;

// Repeat exactly 10 times
repeat (10) {
    twoPow *= 2;
}

// Skipped
repeat (-1) {
    twoPow *= 3333;
}

twoPow; // 1024
```

### `while` {#while-loop}

The `while{:tact}` loop continues executing the block of code as long as the given condition is `true{:tact}`.

In the following example, the value of `x` is decremented by $1$ on each iteration, so the loop will run $10$ times:

```tact
let x: Int = 10;
while (x > 0) {
    x -= 1;
}
```

### `do...until` {#do-until-loop}

The `do...until{:tact}` loop is a post-test loop that executes the block of code at least once, and then continues to execute it until the given condition becomes `true{:tact}`.

In the following example, the value of `x` is decremented by $1$ on each iteration, so the loop will run $10$ times:

```tact
let x: Int = 10;
do {
    x -= 1;  // executes this code block at least once
} until (x <= 0);
```

### `foreach` {#foreach-loop}

The `foreach{:tact}` loop operates on key-value pairs (entries) of [`map<K, V>{:tact}`](/book/maps) type in sequential order: from the smallest keys of the map to the biggest ones.

This loop executes a block of code for each entry in the given map, capturing the key and value on each iteration. This is handy when you don't know in advance how many items there is in the map or don't want to explicitly look for each of the entry using [`.get(){:tact}`](/book/maps#get) [method](/book/functions#extension-function) of maps.

Note, that the names of captured key and value pair on each iteration are arbitrary and can be any valid Tact identifier, provided that they're new to the current scope. The most common options are: `k` and `v`, or `key` and `value`.

In the following example, map `cells` has $4$ entries, so the loop will run $4$ times:

```tact
// Empty map
let cells: map<Int, Cell> = emptyMap();

// Setting four entries
cells.set(1, beginCell().storeUint(100, 16).endCell());
cells.set(2, beginCell().storeUint(200, 16).endCell());
cells.set(3, beginCell().storeUint(300, 16).endCell());
cells.set(4, beginCell().storeUint(400, 16).endCell());

// A variable for summing up the values
let sum: Int = 0;

// For each key and value pair in cells map, do:
foreach (key, value in cells) { // or just k, v
    let s: Slice = value.beginParse(); // convert Cell to Slice
    sum += s.loadUint(16);             // sum the Slice values
}
dump(sum); // 1000
```

It's also possible to iterate over a map in contract storage, and over maps as members of instances of [Struct](/book/structs-and-messages#structs) or [Message](/book/structs-and-messages#messages) types:

```tact
import "@stdlib/deploy";

struct Fizz { oh_my: map<Int, Int> }
message Buzz { oh_my: map<Int, Int> }

contract Iterated {
    oh_my: map<Int, Int>;

    receive("call to iterate!") {
        let oh_my: map<Int, Int> = emptyMap();
        oh_my.set(0, 42);
        oh_my.set(1, 27);

        self.oh_my = oh_my; // assigning local map to the storage one
        let fizz = Fizz{ oh_my }; // field punning
        let buzz = Buzz{ oh_my }; // field punning

        // Iterating over map in contract storage
        foreach (key, value in self.oh_my) {
            // ...
        }

        // Iterating over map member of a Struct Fizz instance
        foreach (key, value in fizz.oh_my) {
            // ...
        }

        // Iterating over map member of a Message Buzz instance
        foreach (key, value in buzz.oh_my) {
            // ...
        }
    }
}
```

Note, that similar to [`let{:tact}` statement](#let), either of captured key or value (or both) can be discarded by specifying an underscore `_{:tact}` in their place:

```tact
// Empty map
let quartiles: map<Int, Int> = emptyMap();

// Setting some entries
quartiles.set(1, 25);
quartiles.set(2, 50);
quartiles.set(3, 75);

// Discarding captured keys
// without modifying them in the map itself
foreach (_, value in quartiles) {}

// Discarding captured values
// without modifying them in the map itself
foreach (key, _ in quartiles) {}

// Discarding both keys and values
// without modifying them in the map itself
foreach (_, _ in quartiles) {
    // Can't access via _, but can do desired operations
    // n times, where n is the current length of the map
}
```

:::caution

  Note, that at the moment `foreach{:tact}` works only with explicitly provided map identifiers and nested identifier constructions, like `foo.bar.targetMap{:tact}` or `self.baz.targetMap{:tact}`. That is, returning a map from a function and trying to iterate over its entries won't work:

  ```tact
  foreach (k, v in emptyMap()) {
  //               ^ this will give the following error message:
  //                 foreach is only allowed over maps that are path expressions,
  //                 i.e. identifiers, or sequences of direct contract/struct/message accesses,
  //                 like "self.foo" or "self.structure.field"
  }
  ```

  Trying to iterate over a map member of a [Struct](/book/structs-and-messages#structs) returned from a function also won't work, because function call is an expression and not an identifier nor a nested identifier access:

  ```tact
  foreach (k, v in genCoolStruct().map) {
  //               ^ this will give the following error message:
  //                 foreach is only allowed over maps that are path expressions,
  //                 i.e. identifiers, or sequences of direct contract/struct/message accesses,
  //                 like "self.foo" or "self.structure.field"
  }
  ```

:::

:::note

  For additional loop examples see: [Loops in Tact-By-Example](https://tact-by-example.org/04-loops).

:::

[int]: /book/integers
[s]: /book/structs-and-messages#structs
[m]: /book/structs-and-messages#messages


## structs-and-messages.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/structs-and-messages.mdx)
---
title: Structs and Messages
description: "Structs can define complex data types that contain multiple fields of different types, while Messages also have a 32-bit header and are convenient to receive and sent message bodies on TON Blockchain"
---

import { Badge } from '@astrojs/starlight/components';

Tact supports a number of [primitive data types](/book/types#primitive-types) that are tailored for smart contract use. However, using individual means of storage often becomes cumbersome, so there are [Structs](#structs) and [Messages](#messages) which allow combining types together.

:::caution

  **Warning**: Currently circular types are **not** possible. This means that Struct/Message **A** can't have a field of a Struct/Message **B** that has a field of the Struct/Message **A**.

  Therefore, the following code **won't** compile:

  ```tact
  struct A {
      circularFieldA: B;
  }

  struct B {
      impossibleFieldB: A;
  }
  ```

:::

## Structs

Structs can define complex data types that contain multiple fields of different types. They can also be nested.

```tact
struct Point {
    x: Int as int64;
    y: Int as int64;
}

struct Line {
    start: Point;
    end: Point;
}
```

Structs can also contain default fields and define fields of [optional types](/book/optionals). This can be useful if you have a lot of fields, but don't want to keep having to specify common values for them in [new instances](#instantiate).

```tact
struct Params {
    name: String = "Satoshi"; // default value

    age: Int?; // field with an optional type Int?
               // and default value of null

    point: Point; // nested Structs
}
```

Structs are also useful as return values from getters or other internal functions. They effectively allow a single getter to return multiple return values.

```tact
contract StructsShowcase {
    params: Params; // Struct as a contract's persistent state variable

    init() {
        self.params = Params{
            point: Point{
                x: 4,
                y: 2,
            },
        };
    }

    get fun params(): Params {
        return self.params;
    }
}
```

Note, that the last semicolon `;` in Struct declaration is optional and may be omitted:

```tact
struct Mad { ness: Bool }

struct MoviesToWatch {
    wolverine: String;
    redFunnyGuy: String
}
```

The order of fields matters, as it corresponds to the resulting memory layout in [TL-B schemas](https://docs.ton.org/develop/data-formats/tl-b-language). However, unlike some languages with manual memory management, Tact does not have any padding between fields.

## Messages

Messages can hold [Structs](#structs) in them:

```tact
struct Point {
    x: Int;
    y: Int;
}

message Add {
    point: Point; // holds a struct Point
}
```

### Message opcodes

Messages are almost the same thing as [Structs](#structs) with the only difference that Messages have a 32-bit integer header in their serialization containing their unique numeric id, commonly referred to as an _opcode_ (operation code). This allows Messages to be used with [receivers](/book/receive) since the contract can tell different types of messages apart based on this id.

Tact automatically generates those unique ids (opcodes) for every received Message, but this can be manually overwritten:

```tact
// This Message overwrites its unique id (opcode) with 0x7362d09c
message(0x7362d09c) TokenNotification {
    forwardPayload: Slice as remaining;
}
```

This is useful for cases where you want to handle certain opcodes of a given smart contract, such as [Jetton standard](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md). The short-list of opcodes this contract is able to process is [given here in FunC](https://github.com/ton-blockchain/token-contract/blob/main/ft/op-codes.fc). They serve as an interface to the smart contract.

<Badge text="Available since Tact 1.6" variant="tip" size="small"/> A message opcode can be any [compile-time](/ref/core-comptime) expression that evaluates to a positive $32$-bit integer, so the following is also valid:

```tact
// This Message overwrites its unique id (opcode) with 898001897,
// which is the evaluated integer value of the specified compile-time expression
message((crc32("Tact") + 42) & 0xFFFF_FFFF) MsgWithExprOpcode {
    field: Int as uint4;
}
```

:::note

  For more in-depth information on this see:\
  [Convert received messages to `op` operations](/book/func#convert-received-messages-to-op-operations)\
  [Internal message body layout in TON Docs](https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#internal-message-body)\
  [Messages of the Jetton implementation in Tact](https://github.com/howardpen9/jetton-implementation-in-tact/blob/9eee917877a92af218002874a9f2bd3f9c619229/sources/messages.tact)\
  [Jetton Standard in Tact on Tact-by-Example](https://tact-by-example.org/07-jetton-standard)

:::

## Operations

### Instantiate

Creation of [Struct](#structs) and [Message](#messages) instances resembles [function calls](/book/expressions#static-function-call), but instead of paretheses `(){:tact}` one needs to specify arguments in braces `{}{:tact}` (curly brackets):

```tact
struct StA {
    field1: Int;
    field2: Int;
}

message MsgB {
    field1: String;
    field2: String;
}

fun example() {
    // Instance of a Struct StA
    StA{
        field1: 42,
        field2: 68 + 1, // trailing comma is allowed
    };

    // Instance of a Message MsgB
    MsgB{
        field1: "May the 4th",
        field2: "be with you!", // trailing comma is allowed
    };
}
```

When the name of a variable or constant assigned to a field coincides with the name of such field, Tact provides a handy syntactic shortcut sometimes called field punning. With it, you don't have to type more than it's necessary:

```tact
struct PopQuiz {
    vogonsCount: Int;
    nicestNumber: Int;
}

fun example() {
    // Let's introduce a couple of variables
    let vogonsCount: Int = 42;
    let nicestNumber: Int = 68 + 1;

    // You may instantiate the Struct as usual and assign variables to fields,
    // but that is a bit repetitive and tedious at times
    PopQuiz{ vogonsCount: vogonsCount, nicestNumber: nicestNumber };

    // Let's use field punning and type less,
    // because our variable names happen to be the same as field names
    PopQuiz{
        vogonsCount,
        nicestNumber, // trailing comma is allowed here too!
    };
}
```

:::note

  Because instantiation is an expression in Tact, it's also described on the related page: [Instantiation expression](/book/expressions#instantiation).

:::

### Convert to a `Cell`, `.toCell()` {#tocell}

It's possible to convert an arbitrary [Struct](#structs) or [Message](#messages) to the [`Cell{:tact}`][cell] type by using the `.toCell(){:tact}` [extension function](/book/functions#extension-function):

```tact
struct Big {
    f1: Int;
    f2: Int;
    f3: Int;
    f4: Int;
    f5: Int;
    f6: Int;
}

fun conversionFun() {
    dump(Big{
        f1: 10000000000, f2: 10000000000, f3: 10000000000,
        f4: 10000000000, f5: 10000000000, f6: 10000000000,
    }.toCell()); // x{...cell with references...}
}
```

:::note

  See those extension functions in the Reference:\
  [`Struct.toCell(){:tact}`](/ref/core-cells#structtocell)\
  [`Message.toCell(){:tact}`](/ref/core-cells#messagetocell)

:::

### Obtain from a `Cell` or `Slice`, `.fromCell()` and `.fromSlice()` {#fromcellslice}

Instead of manually parsing a [`Cell{:tact}`][cell] or [`Slice{:tact}`][slice] via a series of relevant `.loadSomething(){:tact}` function calls, one can use `.fromCell(){:tact}` and `.fromSlice(){:tact}` [extension functions](/book/functions#extension-function) for converting the provided [`Cell{:tact}`][cell] or [`Slice{:tact}`][slice] into the needed [Struct](#structs) or [Message](#messages).

Those extension functions only attempt to parse a [`Cell{:tact}`][cell] or [`Slice{:tact}`][slice] according to the structure of your [Struct](#structs) or [Message](#messages). In case layouts don't match, various exceptions may be thrown — make sure to wrap your code in [`try...catch{:tact}`](/book/statements#try-catch) blocks to prevent unexpected results.

```tact
struct Fizz { foo: Int }
message(100) Buzz { bar: Int }

fun constructThenParse() {
    let fizzCell = Fizz{foo: 42}.toCell();
    let buzzCell = Buzz{bar: 27}.toCell();

    let parsedFizz: Fizz = Fizz.fromCell(fizzCell);
    let parsedBuzz: Buzz = Buzz.fromCell(buzzCell);
}
```

:::note

  See those extension functions in the Reference:\
  [`Struct.fromCell(){:tact}`][st-fc]\
  [`Struct.fromSlice(){:tact}`][st-fs]\
  [`Message.fromCell(){:tact}`][msg-fc]\
  [`Message.fromSlice(){:tact}`][msg-fs]

:::

### Conversion laws

Whenever one converts between [`Cell{:tact}`][cell]/[`Slice{:tact}`][slice] and [Struct](#structs)/[Message](#messages) via `.toCell(){:tact}` and `.fromCell(){:tact}` functions, the following laws hold:

* For any instance of type [Struct](#structs)/[Message](#messages), calling `.toCell(){:tact}` on it, then applying `Struct.fromCell(){:tact}` (or `Message.fromCell(){:tact}`) to the result gives back the copy of the original instance:

```tact {8-9,13-14}
struct ArbitraryStruct {}
message(0x2A) ArbitraryMessage {}

fun lawOne() {
    let structInst = ArbitraryStruct{};
    let messageInst = ArbitraryMessage{};

    ArbitraryStruct.fromCell(structInst.toCell());   // = structInst
    ArbitraryMessage.fromCell(messageInst.toCell()); // = messageInst

    // Same goes for Slices, with .toCell().asSlice() and .fromSlice()

    ArbitraryStruct.fromSlice(structInst.toCell().asSlice());   // = structInst
    ArbitraryMessage.fromSlice(messageInst.toCell().asSlice()); // = messageInst
}
```

* For any [`Cell{:tact}`][cell] with the same [TL-B](https://docs.ton.org/develop/data-formats/tl-b-language) layout as a given [Struct](#structs)/[Message](#messages), calling `Struct.fromCell(){:tact}` (or `Message.fromCell(){:tact}`) on it, and then converting the result to a [`Cell{:tact}`][cell] via `.toCell(){:tact}` would give the copy of the original [`Cell{:tact}`][cell]:

```tact {9-10,15-16}
struct ArbitraryStruct { val: Int as uint32 }
message(0x2A) ArbitraryMessage {}

fun lawTwo() {
    // Using 32 bits to store 42 just so this cellInst can be
    // re-used for working with both ArbitraryStruct and ArbitraryMessage
    let cellInst = beginCell().storeUint(42, 32).endCell();

    ArbitraryStruct.fromCell(cellInst).toCell();  // = cellInst
    ArbitraryMessage.fromCell(cellInst).toCell(); // = cellInst

    // Same goes for Slices, with .fromSlice() and .toCell().asSlice()
    let sliceInst = cellInst.asSlice();

    ArbitraryStruct.fromSlice(sliceInst).toCell().asSlice();  // = sliceInst
    ArbitraryMessage.fromSlice(sliceInst).toCell().asSlice(); // = sliceInst
}
```

[st-fc]: /ref/core-cells#structfromcell
[st-fs]: /ref/core-cells#structfromslice
[msg-fc]: /ref/core-cells#messagefromcell
[msg-fs]: /ref/core-cells#messagefromslice

[p]: /book/types#primitive-types
[cell]: /book/cells#cells
[slice]: /book/cells#slices


## types.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/types.mdx)
---
title: Type system overview
description: "Every variable, item, and value in Tact programs has a type"
prev:
  link: /book/cs/from-solidity
  label: Coming from Solidity
---

Every variable, item, and value in Tact programs has a type. They can be:

* One of the [primitive types](#primitive-types)
* or [composite types](#composite-types)

Additionally, many of those types [can be made nullable](#optionals).

## Primitive types

Tact supports a number of primitive data types that are tailored for smart contract use:

* [`Int{:tact}`](/book/integers) — all numbers in Tact are $257$-bit signed integers, but [smaller representations](/book/integers#serialization) can be used to reduce storage costs.
* [`Bool{:tact}`](#booleans) — classical boolean with `true{:tact}` and `false{:tact}` values.
* `Address{:tact}` — standard [smart contract address](https://docs.ton.org/learn/overviews/addresses#address-of-smart-contract) in TON Blockchain.
* [`Cell{:tact}`](/book/cells#cells), [`Builder{:tact}`](/book/cells#builders), [`Slice{:tact}`](/book/cells#slices) — low-level primitives of [TVM][tvm].
* `String{:tact}` — immutable text strings.
* `StringBuilder{:tact}` — helper type that allows you to concatenate strings in a gas-efficient way.

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview

### Booleans {#booleans}

The primitive type `Bool{:tact}` is the classical boolean type, which can hold only the two values: `true{:tact}` and `false{:tact}`. It's convenient for boolean and logical operations, as well as for storing flags.

There are no implicit type conversions in Tact, so addition ([`+{:tact}`](/book/operators#binary-add)) of two boolean values isn't possible. Hovewer, many comparison [operators](/book/operators) are available, such as:

* `&&{:tact}` for [logical AND](/book/operators#binary-logical-and),
* `||{:tact}` for [logical OR](/book/operators#binary-logical-or),
* `!{:tact}` for [logical inversion](/book/operators#unary-inverse),
* `=={:tact}` and `!={:tact}` for checking [equality](/book/operators#binary-equality),
* and `!!{:tact}` for [non-null assertion](/book/optionals).

Persisting bools to state is very space-efficient, as they only take 1-bit. Storing 1000 bools in state [costs](https://ton.org/docs/develop/smart-contracts/fees#how-to-calculate-fees) about $0.00072$ TON per year.

## Composite types

Using individual means of storage often becomes cumbersome, so there are ways to combine multiple [primitive types](#primitive-types) together to create composite types:

* [Maps](#maps) — associations of keys with values.
* [Structs and Messages](#structs-and-messages) — data structures with typed fields.
* [Optionals](#optionals) — `null{:tact}` values for variables or fields of [Structs and Messages](#structs-and-messages).

In addition to the composite types above, Tact provides a special type constructor [`bounced<T>{:tact}`](/book/bounced), which can only be specified in [bounced message receivers](/book/bounced).

Note, while [contracts](#contracts) and [traits](#traits) are also considered a part of the Tacts type system, one can't pass them around like [Structs and Messages](#structs-and-messages). Instead, it's possible to obtain the initial state of the given contract by using the [`initOf{:tact}`](/book/expressions#initof) expression.

### Maps

The type [`map<K, V>{:tact}`][maps] is used as a way to associate keys of type `K{:tact}` with corresponding values of type `V{:tact}`.

Example of a [`map<K, V>{:tact}`][maps]:

```tact
let mapExample: map<Int, Int> = emptyMap(); // empty map with Int keys and values
```

Learn more about them on a dedicated page: [Maps][maps].

[maps]: /book/maps

### Structs and Messages

[Structs][structs] and [Messages][messages] are two main ways of combining multiple [primitive types](#primitive-types) into a composite one.

Example of a [Struct][structs]:

```tact
struct Point {
    x: Int;
    y: Int;
}
```

Example of a [Message][messages]:

```tact
// Custom numeric id of the Message
message(0x11111111) SetValue {
    key: Int;
    value: Int?; // Optional, Int or null
    coins: Int as coins; // Serialization into TL-B types
}
```

Learn more about them on a dedicated page: [Structs and Messages][s-n-m].

[s-n-m]: /book/structs-and-messages
[structs]: /book/structs-and-messages#structs
[messages]: /book/structs-and-messages#messages

### Optionals

All [primitive types](#primitive-types), as well as [Structs and Messages](#structs-and-messages) could be nullable and hold a special `null{:tact}` value.

Example of an [optional][optionals]:

```tact
let opt: Int? = null; // Int or null, with explicitly assigned null
```

Learn more about them on a dedicated page: [Optionals][optionals].

[optionals]: /book/optionals

### Contracts

[Contracts](/book/contracts) in Tact serve as the main entrypoints of smart contracts of TON blockchain. They hold all [functions](/book/functions), [getters](/book/functions#getter-functions), and [receivers](/book/functions#receiver-functions) of a TON contract, and much more.

Example of a [contract](/book/contracts):

```tact
contract HelloWorld {
    // Persistent state variable
    counter: Int;

    // Constructor function init(), where all the variables are initialized
    init() {
        self.counter = 0;
    }

    // Internal message receiver, which responds to a string message "increment"
    receive("increment") {
        self.counter += 1;
    }

    // Getter function with return type Int
    get fun counter(): Int {
        return self.counter;
    }
}
```

Read more about them on the dedicated page: [Contracts](/book/contracts).

### Traits

Tact doesn't support classical class inheritance, but instead introduces the concept of _traits_, which can be viewed as abstract contracts (like abstract classes in popular object-oriented languages). They have the same structure as [contracts](#contracts), but can't [initialize persistent state variables](/book/contracts#init-function).

A trait can also let the contract inheriting it to override the behavior of its [functions](/book/functions#virtual-and-abstract-functions) and the value of its [constants](/book/constants#virtual-and-abstract-constants).

Example of a trait [`Ownable{:tact}`](/ref/stdlib-ownable#ownable) from [`@stdlib/ownable`](/ref/stdlib-ownable):

```tact
trait Ownable {
    // Persistent state variable, which cannot be initialized in the trait
    owner: Address;

    // Internal function
    fun requireOwner() {
        nativeThrowUnless(132, context().sender == self.owner);
    }

    // Getter function with return type Address
    get fun owner(): Address {
        return self.owner;
    }
}
```

And the [contract](#contracts) that uses trait [`Ownable{:tact}`](/ref/stdlib-ownable#ownable):

```tact
contract Treasure with Ownable {
    // Persistent state variable, which MUST be defined in the contract
    owner: Address;

    // Constructor function init(), where all the variables are initialized
    init(owner: Address) {
        self.owner = owner;
    }
}
```


## upgrades.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/upgrades.mdx)
---
title: Contracts upgrades
description: "Tact currently does not allow contract upgrades, as Tact contracts are more complicated than those in FunC"
---

Tact currently does not allow contract upgrades, as Tact contracts are more complicated than those in FunC. It is theoretically possible, but the required tools are not here.


## from-func.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/cs/from-func.mdx)
---
title: Coming from FunC
description: "A cheat sheet to quickly transition from FunC to Tact"
sidebar:
  order: 1
---

:::danger[Not implemented]

  This page awaits implementation in [#54](https://github.com/tact-lang/tact-docs/issues/54)

:::


## from-solidity.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/book/cs/from-solidity.mdx)
---
title: Coming from Solidity
description: "A cheat sheet to quickly transition from Solidity to Tact and from Ethereum to TON Blockchain"
sidebar:
  order: 2
---

:::danger[Not implemented]

  This page awaits implementation in [#67](https://github.com/tact-lang/tact-docs/issues/67)

:::


## access.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/access.mdx)
---
title: Access control
description: "This page lists common examples of working with privileges, ownership and access control"
---

This page lists common examples of working with privileges, ownership and access control.

## How to check sender privileges using Ownable trait

```tact
// Ownable has to be imported from stdlib, as well as Deployable, for convenience:
import "@stdlib/ownable";
import "@stdlib/deploy";

message FooBarMsg {
    newVal: Int as uint32;
}

// Ownable trait can limit certain actions to the owner only
contract SenderChecker with Deployable, Ownable {
    // Persistent state variables
    owner: Address;     // Ownable trait requires you to add this exact state variable
    val: Int as uint32; // some value

    init() {
        // we can initialize owner to any value we want, the deployer in this case:
        self.owner = sender();
        self.val = 0;
    }

    receive("inc") {
        self.requireOwner(); // throws exit code 132 if the sender isn't an owner
        self.val += 1;
    }

    receive(msg: FooBarMsg) {
        self.requireOwner(); // throws exit code 132 if the sender isn't an owner
        self.val = msg.newVal;
    }
}
```

:::note[Useful links:]

  [`trait Ownable{:tact}` in Core library](/ref/stdlib-ownable#ownable)

:::

:::tip[Hey there!]

  Didn't find your favorite example of access control? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## algo.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/algo.mdx)
---
title: Algorithms
description: "Common algorithm implementations on Tact, generally geared towards contract development"
---

Algorithm is a finite sequence of rigorous instructions, typically used to solve a class of specific problems or to perform a computation.

:::danger[Not implemented]

  This page is a stub. [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## data-structures.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/data-structures.mdx)
---
title: Data structures
description: "This page lists a handy collection of data structures implemented in Tact for your day-to-day needs and beyond"
---

Data structures are data organization, management, and storage formats that are usually chosen for efficient access to data. More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data.

This page lists a handy collection of data structures implemented in Tact for your day-to-day needs and beyond.

All of the data structures listed here are made using the built-in [`map<K, V>{:tact}`][map] type. For the description and basic usage of maps see the [dedicated page in the Book][map].

## Array

An [array](https://en.wikipedia.org/wiki/Array_(data_structure)) is a data structure consisting of a continuous block of memory, which represents a collection of elements of same memory size, each identified by at least one array key or _index_.

Following example emulates an array using a [`map<Int, V>{:tact}`][map] wrapped in a [Struct](/book/structs-and-messages#structs), where `V{:tact}` can be any of the [allowed value types](/book/maps#allowed-types) of the map:

```tact
import "@stdlib/deploy"; // for Deployable trait

struct Array {
    m: map<Int as uint16, Int>; // array of Int values as a map of Ints to Ints,
                                // with serialization of its keys to uint16 to save space
    length: Int = 0;            // length of the array, defaults to 0
}

// Compile-time constant upper bound for our map representing an array.
const MaxArraySize: Int = 5_000; // 5,000 entries max, to stay reasonably far from limits

// Extension mutation function for adding new entries to the end of the array
extends mutates fun append(self: Array, item: Int) {
    require(self.length + 1 <= MaxArraySize, "No space in the array left for new items!");

    self.m.set(self.length, item); // set the entry (key-value pair)
    self.length += 1;              // increase the length field
}

// Extension mutation function for inserting new entries at the given index
extends mutates fun insert(self: Array, item: Int, idx: Int) {
    require(self.length + 1 <= MaxArraySize, "No space in the array left for new items!");
    require(idx >= 0, "Index of the item cannot be negative!");
    require(idx < self.length, "Index is out of array bounds!");

    // Move all items from idx to the right
    let i: Int = self.length; // not a typo, as we need to start from the non-existing place
    while (i > idx) {
        // Note, that we use !! operator as we know for sure that the value would be there
        self.m.set(i, self.m.get(i - 1)!!);
        i -= 1;
    }

    // And put the new item in
    self.m.set(idx, item); // set the entry (key-value pair)
    self.length += 1;      // increase the length field
}

// Extension function for getting the value at the given index
extends fun getIdx(self: Array, idx: Int): Int {
    require(self.length > 0, "No items in the array!");
    require(idx >= 0, "Index of the item cannot be negative!");
    require(idx < self.length, "Index is out of array bounds!");

    // Note, that we use !! operator as we know for sure that the value would be there
    return self.m.get(idx)!!;
}

// Extension function for returning the last value
extends fun getLast(self: Array): Int {
    require(self.length > 0, "No items in the array!");

    // Note, that we use !! operator as we know for sure that the value would be there
    return self.m.get(self.length - 1)!!;
}

// Extension mutation function for deleting and entry at the given index and returning its value
extends mutates fun deleteIdx(self: Array, idx: Int): Int {
    require(self.length > 0, "No items in the array to delete!");
    require(idx >= 0, "Index of the item cannot be negative!");
    require(idx < self.length, "Index is out of array bounds!");

    // Remember the value, which is going to be deleted
    let memorized: Int = self.m.get(idx)!!;

    // Move all items from idx and including to the left
    let i: Int = idx;
    while (i + 1 < self.length) {
        // Note, that we use !! operator as we know for sure that the value would be there
        self.m.set(i, self.m.get(i + 1)!!);
        i += 1;
    }

    self.m.set(self.length - 1, null); // delete the last entry
    self.length -= 1;                  // decrease the length field

    return memorized;
}

// Extension mutation function for deleting the last entry and returning its value
extends fun deleteLast(self: Array): Int {
    require(self.length > 0, "No items in the array!");

    // Note, that we use !! operator as we know for sure that the value would be there
    let lastItem: Int = self.m.get(self.length - 1)!!;
    self.m.set(self.length - 1, null); // delete the entry
    self.length -= 1;                  // decrease the length field

    return lastItem;
}

// Extension function for deleting all items in the Array
extends mutates fun deleteAll(self: Array) {
    self.m = emptyMap();
    self.length = 0;
}

// Global static function for creating an empty Array
fun emptyArray(): Array {
    return Array{m: emptyMap(), length: 0}; // length defaults to 0
}

// Contract, with emulating an Array using the map
contract MapAsArray with Deployable {
    // Persistent state variables
    array: Array;

    // Constructor (initialization) function of the contract
    init() {
        self.array = emptyArray();
    }

    // Internal message receiver, which responds to a String message "append"
    receive("append") {
        // Add a new item
        self.array.append(42);
    }

    // Internal message receiver, which responds to a String message "delete_5h"
    receive("delete_5th") {
        // Remove the 5th item if it exists and reply back with its value, or raise an error
        self.reply(self.array.deleteIdx(4).toCoinsString().asComment()); // index offset 0 + 4 gives the 5th item
    }

    // Internal message receiver, which responds to a String message "del_last"
    receive("del_last") {
        // Remove the last item and reply back with its value, or raise an error
        self.reply(self.array.deleteLast().toCoinsString().asComment());
    }

    // Internal message receiver, which responds to a String message "get_last"
    receive("get_last") {
        // Reply back with the latest item in the array if it exists, or raise an error
        self.reply(self.array.getLast().toCoinsString().asComment());
    }

    // Internal message receiver, which responds to a String message "delete_all"
    receive("delete_all") {
        self.array.deleteAll();
    }
}
```

## Stack

A [stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) is a data structure consisting of a collection of elements with two main operations:

* push, which adds an element to the end of the collection
* pop, which removes the most recently added element

Following example emulates a stack using a [`map<Int, V>{:tact}`][map] wrapped in a [Struct](/book/structs-and-messages#structs), where `V{:tact}` can be any of the [allowed value types](/book/maps#allowed-types) of the map:

```tact
import "@stdlib/deploy"; // for Deployable trait

struct Stack {
    m: map<Int as uint16, Int>; // stack of Int values as a map of Ints to Ints,
                                // with serialization of its keys to uint16 to save space
    length: Int = 0;            // length of the stack, defaults to 0
}

// Compile-time constant upper bound for our map representing an stack.
const MaxStackSize: Int = 5_000; // 5,000 entries max, to stay reasonably far from limits

// Extension mutation function for adding new entries to the end of the stack
extends mutates fun push(self: Stack, item: Int) {
    require(self.length + 1 <= MaxStackSize, "No space in the stack left for new items!");

    self.m.set(self.length, item); // set the entry (key-value pair)
    self.length += 1;              // increase the length field
}

// Extension mutation function for deleting the last entry and returning its value
extends mutates fun pop(self: Stack): Int {
    require(self.length > 0, "No items in the stack to delete!");

    // Note, that we use !! operator as we know for sure that the value would be there
    let lastItem: Int = self.m.get(self.length - 1)!!;
    self.m.set(self.length - 1, null); // delete the entry
    self.length -= 1;                  // decrease the length field

    return lastItem;
}

// Extension function for returning the last value
extends fun peek(self: Stack): Int {
    require(self.length > 0, "No items in the stack!");

    // Note, that we use !! operator as we know for sure that the value would be there
    return self.m.get(self.length - 1)!!;
}

// Extension function for deleting all items in the Stack
extends mutates fun deleteAll(self: Stack) {
    self.m = emptyMap();
    self.length = 0;
}

// Global static function for creating an empty Stack
fun emptyStack(): Stack {
    return Stack{m: emptyMap(), length: 0}; // length defaults to 0
}

contract MapAsStack with Deployable {
    // Persistent state variables
    stack: Stack; // our stack, which uses the map

    // Constructor (initialization) function of the contract
    init() {
        self.stack = emptyStack();
    }

    // Internal message receiver, which responds to a String message "push"
    receive("push") {
        // Add a new item
        self.stack.push(42);
    }

    // Internal message receiver, which responds to a String message "pop"
    receive("pop") {
        // Remove the last item and reply with it
        self.reply(self.stack.pop().toCoinsString().asComment());
    }

    // Internal message receiver, which responds to a String message "peek"
    receive("peek") {
        // Reply back with the latest item in the map if it exists, or raise an error
        self.reply(self.stack.peek().toCoinsString().asComment());
    }

    // Internal message receiver, which responds to a String message "delete_all"
    receive("delete_all") {
        self.stack.deleteAll();
    }

    // Getter function for obtaining the stack
    get fun stack(): map<Int as uint16, Int> {
        return self.stack.m;
    }

    // Getter function for obtaining the current length of the stack
    get fun length(): Int {
        return self.stack.length;
    }
}
```

## Circular buffer

A [circular buffer](https://en.wikipedia.org/wiki/Circular_buffer) (circular queue, cyclic buffer or ring buffer) is a data structure, which uses a single, fixed-size [buffer](https://en.wikipedia.org/wiki/Data_buffer) as it were connected end-to-end.

Following example emulates a circular buffer using a [`map<Int, V>{:tact}`][map] wrapped in a [Struct](/book/structs-and-messages#structs), where `V{:tact}` can be any of the [allowed value types](/book/maps#allowed-types) of the map:

```tact
import "@stdlib/deploy"; // for Deployable trait

struct CircularBuffer {
    m: map<Int as uint8, Int>; // circular buffer of Int values as a map of Ints to Ints,
                               // with serialization of its keys to uint8 to save space
    length: Int = 0;           // length of the circular buffer, defaults to 0
    start: Int = 0;            // current index into the circular buffer, defaults to 0
}

// Compile-time constant upper bound for our map representing a circular buffer.
const MaxCircularBufferSize: Int = 5;

// Extension mutation function for putting new items to the circular buffer
extends mutates fun put(self: CircularBuffer, item: Int) {
    if (self.length < MaxCircularBufferSize) {
        self.m.set(self.length, item); // store the item
        self.length += 1;              // increase the length field
    } else {
        self.m.set(self.start, item);                          // store the item, overriding previous entry
        self.start = (self.start + 1) % MaxCircularBufferSize; // update starting position
    }
}

// Extension mutation function for getting an item from the circular buffer
extends mutates fun getIdx(self: CircularBuffer, idx: Int): Int {
    require(self.length > 0, "No items in the circular buffer!");
    require(idx >= 0, "Index of the item cannot be negative!");

    if (self.length < MaxCircularBufferSize) {
        // Note, that we use !! operator as we know for sure that the value would be there
        return self.m.get(idx % self.length)!!;
    }

    // Return the value rotating around the circular buffer, also guaranteed to be there
    return self.m.get((self.start + idx) % MaxCircularBufferSize)!!;
}

// Extension function for iterating over all items in the circular buffer and dumping them to the console
extends fun printAll(self: CircularBuffer) {
    let i: Int = self.start;
    repeat (self.length) {
        dump(self.m.get(i)!!); // !! tells the compiler this can't be null
        i = (i + 1) % MaxCircularBufferSize;
    }
}

// Extension function for deleting all items in the CircularBuffer
extends mutates fun deleteAll(self: CircularBuffer) {
    self.m = emptyMap();
    self.length = 0;
    self.start = 0;
}

// Global static function for creating an empty CircularBuffer
fun emptyCircularBuffer(): CircularBuffer {
    return CircularBuffer{m: emptyMap(), length: 0, start: 0}; // length and start default to 0
}

// This contract records the last 5 timestamps of when "timer" message was received
contract MapAsCircularBuffer with Deployable {
    // Persistent state variables
    cBuf: CircularBuffer; // our circular buffer, which uses a map

    // Constructor (initialization) function of the contract
    init() {
        self.cBuf = emptyCircularBuffer();
    }

    // Internal message receiver, which responds to a String message "timer"
    // and records the timestamp when it receives such message
    receive("timer") {
        let timestamp: Int = now();
        self.cBuf.put(timestamp);
    }

    // Internal message receiver, which responds to a String message "get_first"
    // and replies with the first item of the circular buffer
    receive("get_first") {
        self.reply(self.cBuf.getIdx(0).toCoinsString().asComment());
    }

    // Internal message receiver, which responds to a String message "print_all"
    receive("print_all") {
        self.cBuf.printAll();
    }

    // Internal message receiver, which responds to a String message "delete_all"
    receive("delete_all") {
        self.cBuf.deleteAll();
    }
}
```

:::note

  This example is adapted from [Arrays page in Tact-By-Example](https://tact-by-example.org/04-arrays).

:::

:::tip[Hey there!]

  Didn't find your favorite example of working with data structures? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::

[map]: /book/maps


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/index.mdx)
---
title: Cookbook overview
description: "Cookbook section is focused on everyday tasks that every Tact developer resolves during the development of smart contracts"
---

import { LinkCard, Card, CardGrid, Steps } from '@astrojs/starlight/components';

The main reason for making the Tact Cookbook is to gather all the experiences of Tact developers in one place so that future developers can use it. This section of the documentation is more focused on everyday tasks that every Tact developer resolves during the development of smart contracts.

Use it as a recipe book for cooking up delightful smart contracts on TON Blockchain without re-inventing the wheel in the process.

<Steps>

1. #### Single contract {#single-contract}

   Following pages focus on single-contract examples and cover a wide range of topics:

   <CardGrid>
    <LinkCard
      title="1️⃣ Single-contract communication"
      href="/cookbook/single-communication"
    />
    <LinkCard
      title="⚙️ Type conversion"
      href="/cookbook/type-conversion"
    />
    <LinkCard
      title="📦 Data structures"
      href="/cookbook/data-structures"
    />
    <LinkCard
      title="🤖 Algorithms"
      href="/cookbook/algo"
    />
    <LinkCard
      title="📆 Time and date"
      href="/cookbook/time"
    />
    <LinkCard
      title="⚠️ Access control"
      href="/cookbook/access"
    />
    <LinkCard
      title="✨ Randomness"
      href="/cookbook/random"
    />
    <LinkCard
      title="🤔 Miscellaneous"
      href="/cookbook/misc"
    />
   </CardGrid>

2. #### Multiple contracts {#multiple-contracts}

   Following pages focus on multi-contract examples, exploring the scalable nature of TON Blockchain:

   <CardGrid>
     <LinkCard
       title="🧮 Multi-contract communication"
       href="/cookbook/multi-communication"
     />
     <LinkCard
       title="💎 Fungible Tokens (Jettons)"
       href="/cookbook/jettons"
     />
     <LinkCard
       title="🖼️ Non-Fungible Tokens (NFTs)"
       href="/cookbook/nfts"
     />
   </CardGrid>

   Additionally, there are examples of working with popular TON DEXes (Decentralized EXchanges), which often require many contracts and complex logic:

   <CardGrid>
     <LinkCard
       title="DeDust.io"
       href="/cookbook/dexes/dedust"
     />
     <LinkCard
       title="STON.fi"
       href="/cookbook/dexes/stonfi"
     />
   </CardGrid>

</Steps>


## jettons.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/jettons.mdx)
---
title: Fungible Tokens (Jettons)
description: "Common examples of working with Fungible Tokens (Jettons) in Tact"
---

This page lists common examples of working with [Fungible Tokens (Jettons)](https://docs.ton.org/develop/dapps/asset-processing/jettons).

Jettons are token standards on the TON Blockchain, designed to create fungible tokens (similar to ERC-20 on Ethereum) with a decentralized approach. They are implemented as a pair of smart contracts, typically consisting of two core components:

* Jetton Master Contract (Jetton master)
* Jetton Wallet Contract (Jetton wallet)

These contracts interact with each other to manage token supply, distribution, transfers, and other operations related to the Jetton.

## Jetton Master Contract

The Jetton Master Contract serves as the central entity for a given Jetton. It maintains critical information about the Jetton itself. Key responsibilities and data stored in the Jetton Master Contract include:

* Jetton metadata: Information such as the token's name, symbol, total supply, and decimals.

* Minting and Burning: When new Jettons are minted (created), the Jetton Master manages the creation process and distributes them to the appropriate wallets. It also manages the burning (destruction) of tokens as needed.

* Supply Management: The Jetton Master keeps track of the total supply of Jettons and ensures proper accounting of all issued Jettons.

## Jetton Wallet Contract

The Jetton Wallet Contract represents an individual holder's token wallet and is responsible for managing the balance and token-related operations for a specific user. Each user or entity holding Jettons will have its own unique Jetton Wallet Contract. Key features of the Jetton Wallet Contract include:

* Balance tracking: The wallet contract stores the user's token balance.

* Token Transfers: The wallet is responsible for handling token transfers between users. When a user sends Jettons, the Jetton Wallet Contract ensures proper transfer and communication with the recipient's wallet. The Jetton Master is not involved in this activity and does not create a bottleneck. Wallets can use TON's sharding capability in a great way

* Token burning: The Jetton Wallet interacts with the Jetton Master to burn tokens.

* Owner control: The wallet contract is owned and controlled by a specific user, meaning that only the owner of the wallet can initiate transfers or other token operations.

## Examples

Common examples of working with Jettons.

### Accepting Jetton transfer

Transfer notification message have the following structure.

```tact
message(0x7362d09c) JettonTransferNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    forwardPayload: Slice as remaining;
}
```

Use [receiver](/book/receive) function to accept token notification message.

:::caution

  Sender of transfer notification must be validated!

:::

The sender of a transfer notification must be validated because malicious actors could attempt to spoof notifications from an unauthorized account.
If this validation is not done, the contract may accept unauthorized transactions, leading to potential security vulnerabilities.

Validation is done using the Jetton address from the contract:

1. Sender sends message with `0xf8a7ea5` as its 32-bit header (opcode) to his Jetton wallet.
2. Jetton wallet transfers funds to contract's Jetton wallet.
3. After successful transfer accept, contract's Jetton wallet sends transfer notification to his owner contract.
4. Contract validates the Jetton message.

You may obtain contract's Jetton wallet is done using the [`contractAddress(){:tact}`](/ref/core-common#contractaddress) function or calculate this address offchain.

To obtain the Jetton wallet's state init, you need the wallet's data and code. While there is a common structure for the initial data layout, it may differ in some cases, such as with [USDT](#usdt-jetton-operations).

Since notifications originate from your contract's Jetton wallet, the function [`myAddress(){:tact}`](/ref/core-common#myaddress) should be used in `ownerAddress` field.

:::caution

  Notifications are not always guaranteed to be sent. By default, the implementation does not send a notification if the `forwardAmount` is set to zero. Therefore, in such cases, you cannot rely on notifications being sent.

:::

```tact
import "@stdlib/deploy";

struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(
    ownerAddress: Address,
    jettonMasterAddress: Address,
    jettonWalletCode: Cell
): Address {

    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{
        code: jettonWalletCode,
        data: initData.toCell(),
    });
}

message(0x7362d09c) JettonTransferNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    forwardPayload: Slice as remaining;
}

contract Example with Deployable {
    myJettonWalletAddress: Address;
    myJettonAmount: Int as coins = 0;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.myJettonWalletAddress = calculateJettonWalletAddress(
            myAddress(),
            jettonMasterAddress,
            jettonWalletCode,
        );
    }

    receive(msg: JettonTransferNotification) {
        require(
            sender() == self.myJettonWalletAddress,
            "Notification not from your jetton wallet!",
        );

        self.myJettonAmount += msg.amount;

        // Forward excesses
        self.forward(msg.sender, null, false, null);
    }
}
```

### Sending Jetton transfer

A Jetton transfer is the process of sending a specified amount of Jettons from one wallet (contract) to another.

To send Jetton transfer use [`send(){:tact}`](/book/send) function.

```tact
import "@stdlib/deploy";

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Slice as remaining;
}

const JettonTransferGas: Int = ton("0.05");

struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(
    ownerAddress: Address,
    jettonMasterAddress: Address,
    jettonWalletCode: Cell,
): Address {

    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{
        code: jettonWalletCode,
        data: initData.toCell(),
    });
}

message Withdraw {
    amount: Int as coins;
}

contract Example with Deployable {
    myJettonWalletAddress: Address;
    myJettonAmount: Int as coins = 0;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.myJettonWalletAddress = calculateJettonWalletAddress(
            myAddress(),
            jettonMasterAddress,
            jettonWalletCode,
        );
    }

    receive(msg: Withdraw) {
        require(
            msg.amount <= self.myJettonAmount,
            "Not enough funds to withdraw"
        );

        send(SendParameters{
            to: self.myJettonWalletAddress,
            value: JettonTransferGas,
            body: JettonTransfer{
                // To prevent replay attacks
                queryId: 42,
                // Jetton amount to transfer
                amount: msg.amount,
                // Where to transfer Jettons:
                // this is an address of the Jetton wallet
                // owner and not the Jetton wallet itself
                destination: sender(),
                // Where to send a confirmation notice of a successful transfer
                // and the rest of the incoming message value
                responseDestination: sender(),
                // Can be used for custom logic of Jettons themselves,
                // and without such can be set to null
                customPayload: null,
                // Amount to transfer with JettonTransferNotification,
                // which is needed for the execution of custom logic
                forwardTonAmount: 1, // if its 0, the notification won't be sent!
                // Compile-time way of expressing:
                //     beginCell().storeUint(0xF, 4).endCell().beginParse()
                // For more complicated transfers, adjust accordingly
                forwardPayload: rawSlice("F")
            }.toCell(),
        });
    }
}
```

### Burning Jetton

Jetton burning is the process of permanently removing a specified amount of Jettons from circulation, with no possibility of recovery.

```tact
import "@stdlib/deploy";

message(0x595f07bc) JettonBurn {
    queryId: Int as uint64;
    amount: Int as coins;
    responseDestination: Address?;
    customPayload: Cell? = null;
}

const JettonBurnGas: Int = ton("0.05");

struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(
    ownerAddress: Address,
    jettonMasterAddress: Address,
    jettonWalletCode: Cell,
): Address {

    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{
        code: jettonWalletCode,
        data: initData.toCell(),
    });
}

message ThrowAway {
    amount: Int as coins;
}

contract Example with Deployable {
    myJettonWalletAddress: Address;
    myJettonAmount: Int as coins = 0;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.myJettonWalletAddress = calculateJettonWalletAddress(
            myAddress(),
            jettonMasterAddress,
            jettonWalletCode,
        );
    }

    receive(msg: ThrowAway) {
        require(
            msg.amount <= self.myJettonAmount,
            "Not enough funds to throw away",
        );

        send(SendParameters{
            to: self.myJettonWalletAddress,
            value: JettonBurnGas,
            body: JettonBurn{
                // To prevent replay attacks
                queryId: 42,
                // Jetton amount you want to burn
                amount: msg.amount,
                // Where to send a confirmation notice of a successful burn
                // and the rest of the incoming message value
                responseDestination: sender(),
                // Can be used for custom logic of Jettons themselves,
                // and without such can be set to null
                customPayload: null,
            }.toCell(),
        });
    }
}
```

### USDT Jetton operations

Operations with USDT (on TON) remain the same, except that the `JettonWalletData` will have the following structure:

```tact
struct JettonWalletData {
    status: Int as uint4;
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
}

// And the function to calculate the wallet address may look like this:
fun calculateJettonWalletAddress(
    ownerAddress: Address,
    jettonMasterAddress: Address,
    jettonWalletCode: Cell
): Address {

    let initData = JettonWalletData{
        status: 0,
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
    };

    return contractAddress(StateInit{
        code: jettonWalletCode,
        data: initData.toCell(),
    });
}
```

:::tip[Hey there!]

Didn't find your favorite example of Jetton usage? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## misc.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/misc.mdx)
---
title: Miscellaneous
description: "Various niche examples which don't yet have a dedicated page, but are useful and interesting nonetheless"
---

Various niche examples which don't yet have a dedicated page, but are useful and interesting nonetheless.

## How to throw errors

The `throw(){:tact}` function in a contract is useful when we don't know how often to perform a specific action.

It allows intentional exception or error handling, which leads to the termination of the current transaction and reverts any state changes made during that transaction.

```tact
let number: Int = 198;

// the error will be triggered anyway
try { throw(36); } catch (exitCode) {}

// the error will be triggered only if the number is greater than 50
try { nativeThrowIf(35, number > 50); } catch (exitCode) {}

// the error will be triggered only if the number is NOT EQUAL to 198
try { nativeThrowUnless(39, number == 198); } catch (exitCode) {}
```

:::note[Useful links:]

  [`throw(){:tact}` in Core library](/ref/core-debug#throw)\
  [Errors in Tact-By-Example](https://tact-by-example.org/03-errors)

:::

:::tip[Hey there!]

  Didn't find your favorite example of working with something niche? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## multi-communication.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/multi-communication.mdx)
---
title: Multi-contract communication
description: "Common examples of communication between many deployed contracts on blockchain"
prev:
  link: /cookbook/misc
  label: Miscellaneous
---

:::danger[Not implemented]

  This page is a stub. [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## nfts.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/nfts.mdx)
---
title: Non-Fungible Tokens (NFTs)
description: "Common examples of working with Non-Fungible Tokens (NFTs) in Tact"
---

This page lists common examples of working with [NFTs](https://docs.ton.org/develop/dapps/asset-processing/nfts).

## Accepting NFT ownership assignment

Notification message of assigned NFT ownership has the following structure:

```tact
message(0x05138d91) NFTOwnershipAssigned {
    previousOwner: Address;
    forwardPayload: Slice as remaining;
}
```

Use [receiver](/book/receive) function to accept notification message.

:::caution

  Sender of notification must be validated!

:::

Validation can be done in two ways:

1. Directly store the NFT item address and validate against it.

```tact
import "@stdlib/deploy";

message(0x05138d91) NFTOwnershipAssigned {
    previousOwner: Address;
    forwardPayload: Slice as remaining;
}

contract SingleNft with Deployable {
    nftItemAddress: Address;

    init(nftItemAddress: Address) {
        self.nftItemAddress = nftItemAddress;
    }

    receive(msg: NFTOwnershipAssigned) {
        require(self.nftItemAddress == sender(), "NFT contract is not the sender");

        // your logic of processing nft ownership assign notification
    }
}
```

2. Use [`StateInit{:tact}`](/book/expressions#initof) and derived address of the NFT item.

```tact
import "@stdlib/deploy";

message(0x05138d91) NFTOwnershipAssigned {
    previousOwner: Address;
    forwardPayload: Slice as remaining;
}

struct NFTItemInitData {
    index: Int as uint64;
    collectionAddress: Address;
}

inline fun calculateNFTAddress(index: Int, collectionAddress: Address, nftCode: Cell): Address {
    let initData = NFTItemInitData{
        index,
        collectionAddress,
    };

    return contractAddress(StateInit{code: nftCode, data: initData.toCell()});
}

contract NftInCollection with Deployable {
    nftCollectionAddress: Address;
    nftItemIndex: Int as uint64;
    nftCode: Cell;

    init(nftCollectionAddress: Address, nftItemIndex: Int, nftCode: Cell) {
        self.nftCollectionAddress = nftCollectionAddress;
        self.nftItemIndex = nftItemIndex;
        self.nftCode = nftCode;
    }

    receive(msg: NFTOwnershipAssigned) {
        let expectedNftAddress = calculateNFTAddress(self.nftItemIndex, self.nftCollectionAddress, self.nftCode); // or you can even store expectedNftAddress
        require(expectedNftAddress == sender(), "NFT contract is not the sender");

        // your logic of processing nft ownership assign notification
    }
}
```

Since the initial data layout of the NFT item can vary, the first approach is often more suitable.

## Transferring NFT item

To send NFT item transfer use [`send(){:tact}`](/book/send) function.

```tact
import "@stdlib/deploy";

message(0x5fcc3d14) NFTTransfer {
    queryId: Int as uint64;
    newOwner: Address; // address of the new owner of the NFT item.
    responseDestination: Address; // address where to send a response with confirmation of a successful transfer and the rest of the incoming message coins.
    customPayload: Cell? = null; //  optional custom data. In most cases should be null
    forwardAmount: Int as coins; // the amount of nanotons to be sent to the new owner.
    forwardPayload: Slice as remaining; // optional custom data that should be sent to the new owner.
}

contract Example {
    nftItemAddress: Address;

    init(nftItemAddress: Address) {
        self.nftItemAddress = nftItemAddress;
    }

    // ... add more code from previous examples ...

    receive("transfer") {
        send(SendParameters{
            to: self.nftItemAddress,
            value: ton("0.1"),
            body: NFTTransfer{
                queryId: 42,
                // FIXME: Change this according to your needs
                newOwner: sender(),
                responseDestination: myAddress(),
                customPayload: null,
                forwardAmount: 1,
                forwardPayload: rawSlice("F"), // precomputed beginCell().storeUint(0xF, 4).endCell().beginParse()
            }.toCell(),
        });
    }
}
```

## Get NFT static info

Note, that TON Blockchain does not allow contracts to call each other [getters](https://docs.tact-lang.org/book/contracts#getter-functions).
In order to receive data from another contract, you must exchange messages.

```tact
message(0x2fcb26a2) NFTGetStaticData {
    queryId: Int as uint64;
}

message(0x8b771735) NFTReportStaticData {
    queryId: Int as uint64;
    index: Int as uint256;
    collection: Address;
}

struct NFTItemInitData {
    index: Int as uint64;
    collectionAddress: Address;
}

inline fun calculateNFTAddress(index: Int, collectionAddress: Address, nftCode: Cell): Address {
    let initData = NFTItemInitData{
        index,
        collectionAddress,
    };

    return contractAddress(StateInit{code: nftCode, data: initData.toCell()});
}

contract Example {
    nftCollectionAddress: Address;
    nftItemIndex: Int as uint64;
    nftCode: Cell;

    init(nftCollectionAddress: Address, nftItemIndex: Int, nftCode: Cell) {
        self.nftCollectionAddress = nftCollectionAddress;
        self.nftItemIndex = nftItemIndex;
        self.nftCode = nftCode;
    }

    // ... add more code from previous examples ...

    receive("get static data") {
        // FIXME: Put proper address("[NFT_ADDRESS]") here
        let nftAddress = sender();
        send(SendParameters{
            to: nftAddress,
            value: ton("0.1"),
            body: NFTGetStaticData{
                queryId: 42,
            }.toCell(),
        });
    }

    receive(msg: NFTReportStaticData) {
        let expectedNftAddress = calculateNFTAddress(msg.index, msg.collection, self.nftCode);
        require(expectedNftAddress == sender(), "NFT contract is not the sender");

        // Save nft static data or do something
    }
}
```

## Get NFT royalty params

NFT royalty params are described [here](https://github.com/ton-blockchain/TEPs/blob/master/text/0066-nft-royalty-standard.md).

```tact
message(0x693d3950) NFTGetRoyaltyParams {
    queryId: Int as uint64;
}

message(0xa8cb00ad) NFTReportRoyaltyParams {
    queryId: Int as uint64;
    numerator: Int as uint16;
    denominator: Int as uint16;
    destination: Address;
}

contract Example {
    nftCollectionAddress: Address;

    init(nftCollectionAddress: Address) {
        self.nftCollectionAddress = nftCollectionAddress;
    }

    // ... add more code from previous examples ...

    receive("get royalty params") {
        send(SendParameters{
            to: self.nftCollectionAddress,
            value: ton("0.1"),
            body: NFTGetRoyaltyParams{
                queryId: 42,
            }.toCell(),
        });
    }

    receive(msg: NFTReportRoyaltyParams) {
        require(self.nftCollectionAddress == sender(), "NFT collection contract is not the sender");

        // Do something with msg
    }
}
```

## NFT Collection methods


:::caution

  These methods are not part of any standard, and they will only work with [this specific implementation](https://github.com/ton-blockchain/token-contract/blob/main/nft/nft-collection.fc). Please keep this in mind before using them.

:::

Note that only NFT owners are allowed to use these methods.

### Deploy NFT

```tact
message(0x1) NFTDeploy {
    queryId: Int as uint64;
    itemIndex: Int as uint64;
    amount: Int as coins; // amount to sent when deploying nft
    nftContent: Cell;
}

contract Example {
    nftCollectionAddress: Address;

    init(nftCollectionAddress: Address) {
        self.nftCollectionAddress = nftCollectionAddress;
    }

    // ... add more code from previous examples ...

    receive("deploy") {
        send(SendParameters{
            to: self.nftCollectionAddress,
            value: ton("0.14"),
            body: NFTDeploy{
                queryId: 42,
                itemIndex: 42,
                amount: ton("0.1"),
                nftContent: beginCell().endCell() // FIXME: Should be your content, mostly generated offchain
            }.toCell(),
        });
    }
}
```

### Change owner

```tact
message(0x3) NFTChangeOwner {
    queryId: Int as uint64;
    newOwner: Address;
}

contract Example {
    nftCollectionAddress: Address;

    init(nftCollectionAddress: Address) {
        self.nftCollectionAddress = nftCollectionAddress;
    }

    // ... add more code from previous examples ...

    receive("change owner") {
        send(SendParameters{
            to: self.nftCollectionAddress,
            value: ton("0.05"),
            body: NFTChangeOwner{
                queryId: 42,
                // FIXME: Put proper address("NEW_OWNER_ADDRESS") here
                newOwner: sender(),
            }.toCell(),
        });
    }
}
```

:::tip[Hey there!]

  Didn't find your favorite example of a NFT communication? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## random.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/random.mdx)
---
title: Randomness
description: "Common examples of working with random numbers, uncertainty and randomness in general"
---

This page lists examples of working with random numbers, uncertainty and randomness in general.

## How to generate a random number

```tact
// Declare a variable to store the random number
let number: Int = 0;

// Generate a new random number, which is an unsigned 256-bit integer
number = randomInt();

// Generate a random number between 1 and 12
number = random(1, 12);
```

:::note[Useful links:]

  [`randomInt(){:tact}` in Core library](/ref/core-random#randomint)\
  [`random(){:tact}` in Core library](/ref/core-random#random)

:::

:::tip[Hey there!]

  Didn't find your favorite example of working with randomness? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## single-communication.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/single-communication.mdx)
---
title: Single-contract communication
description: "Common examples of communication of a single deployed contract with other contracts on blockchain"
prev:
  link: /cookbook
  label: Cookbook overview
---

This page lists examples of communication of a single deployed contract with other contracts on blockchain.

For examples of communication between multiple deployed contracts see: [Multi-contract communication](/cookbook/multi-communication).

## How to make a basic reply

```tact
contract Example {
    receive() {
        self.reply("Hello, World!".asComment()); // asComment converts a String to a Cell with a comment
    }
}
```

## How to send a simple message

```tact
contract Example {
    receive() {
        send(SendParameters{
            bounce: true, // default
            to: sender(), // or another destination address
            value: ton("0.01"), // attached amount of Tons to send
            body: "Hello from Tact!".asComment(), // comment (optional)
        });
    }
}
```

## How to send a message with the entire balance

If we need to send the whole balance of the smart contract, then we should use the `SendRemainingBalance{:tact}` send mode. Alternatively, we can use `mode: 128{:tact}`, which has the same meaning.

```tact
contract Example {
    receive() {
        send(SendParameters{
            // bounce = true by default
            to: sender(), // send the message back to the original sender
            value: 0,
            mode: SendRemainingBalance, // or mode: 128
            body: "Hello from Tact!".asComment(), // comment (optional)
        });
    }
}
```

## How to send a message with the remaining value

If we want to make a reply to the same sender, we can use the mode `SendRemainingValue{:tact}` (i.e. `mode: 64{:tact}`), which carries all the remaining value of the inbound message in addition to the value initially indicated in the new message.

```tact
contract Example {
    receive() {
        send(SendParameters{
            // bounce = true by default
            to: sender(), // send the message back to the original sender
            value: 0,
            mode: SendRemainingValue,
            body: "Hello from Tact!".asComment(), // comment (optional)
        });
    }
}
```

It's often useful to add the `SendIgnoreErrors{:tact}` flag too, in order to ignore any errors arising while processing this message during the action phaseL

```tact
contract Example {
    receive() {
        send(SendParameters{
            // bounce = true by default
            to: sender(), // send the message back to the original sender
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors, // prefer using | over + for the mode
            body: "Hello from Tact!".asComment(), // comment (optional)
        });
    }
}
```

The latter example is identical to using a [`.reply(){:tact}` function](#how-to-make-a-basic-reply).

## How to send a message with a long text comment

If we need to send a message with a lengthy text comment, we should create a [`String{:tact}`](/book/types#primitive-types) that consists of more than $127$ characters. To do this, we can utilize the [`StringBuilder{:tact}`](/book/types#primitive-types) primitive type and its methods called `beginComment(){:tact}` and `append(){:tact}`. Prior to sending, we should convert this string into a cell using the `toCell(){:tact}` method.

```tact
contract Example {
    receive() {
        let comment: StringBuilder = beginComment();
        let longString = "..."; // Some string with more than 127 characters.
        comment.append(longString);

        send(SendParameters{
            // bounce = true by default
            to: sender(),
            value: 0,
            mode: SendIgnoreErrors,
            body: comment.toCell(),
        });
    }
}
```

:::note[Useful links:]

  ["Sending messages" in the Book](/book/send#send-message)\
  ["Message `mode`" in the Book](/book/message-mode)\
  [`StringBuilder{:tact}` in the Book](/book/types#primitive-types)\
  [`Cell{:tact}` in Core library](/ref/core-cells)

:::

:::tip[Hey there!]

  Didn't find your favorite example of a single-contract communication? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## time.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/time.mdx)
---
title: Time and date
description: "Common examples of working with time and date in Tact"
---

## How to get the current time

Use the `now(){:tact}` method to obtain the current standard [Unix time](https://en.wikipedia.org/wiki/Unix_time).

If you need to store the time in state or encode it in a message, use the following [serialization](/book/integers#serialization): `Int as uint32{:tact}`.

```tact
let currentTime: Int = now();

if (currentTime > 1672080143) {
    // do something
}
```

:::note[Useful links:]

  [`now(){:tact}` in Core library](/ref/core-common#now)\
  ["Current Time" in Tact-By-Example](https://tact-by-example.org/04-current-time)

:::

:::tip[Hey there!]

  Didn't find your favorite example of working with time and date? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## type-conversion.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/type-conversion.mdx)
---
title: Type conversion
description: "Common examples of converting between primitive types and obtaining them from composite types"
---

This page shows examples of converting between [primitive types][p] and obtaining them from [composite types](/book/types#composite-types).

## `Int` ↔ `String` {#int-string}

### How to convert a `String` to an `Int`

```tact
// Defining a new extension function for type String that returns value of type Int
// Caution: produces unexpected results when String contains non-numeric characters!
extends fun toInt(self: String): Int {
    // Cast the String as a Slice for parsing
    let string: Slice = self.asSlice();

    // A variable to store the accumulated number
    let acc: Int = 0;

    // Loop until the String is empty
    while (!string.empty()) {
        let char: Int = string.loadUint(8); // load 8 bits (1 byte) from the Slice
        acc = (acc * 10) + (char - 48);     // using ASCII table to get numeric value
        // Note, that this approach would produce unexpected results
        //   when the starting String contains non-numeric characters!
    }

    // Produce the resulting number
    return acc;
}

fun runMe() {
    let string: String = "26052021";
    dump(string.toInt());
}
```

### How to convert an `Int` to a `String`

```tact
let number: Int = 261119911;

// Converting the [number] to a String
let numberString: String = number.toString();

// Converting the [number] to a float String,
//   where passed argument 3 is the exponent of 10^(-3) of resulting float String,
//   and it can be any integer between 0 and 76 including both ends
let floatString: String = number.toFloatString(3);

// Converting the [number] as coins to a human-readable String
let coinsString: String = number.toCoinsString();

dump(numberString); // "261119911"
dump(floatString);  // "261119.911"
dump(coinsString);  // "0.261119911"
```

:::note[Useful links:]

  [`Int.toString(){:tact}` in Core library](/ref/core-strings#inttostring)\
  [`Int.toFloatString(){:tact}` in Core library](/ref/core-strings#inttofloatstring)\
  [`Int.toCoinsString(){:tact}` in Core library](/ref/core-strings#inttocoinsstring)

:::

## `Struct` or `Message` ↔ `Cell` or `Slice` {#structmessage-cellslice}

### How to convert an arbitrary `Struct` or `Message` to a `Cell` or a `Slice`

```tact {19-20, 22-23}
struct Profit {
    big: String?;
    dict: map<Int, Int as uint64>;
    energy: Int;
}

message(0x45) Nice {
    maybeStr: String?;
}

fun convert() {
    let st = Profit{
        big: null,
        dict: null,
        energy: 42,
    };
    let msg = Nice{ maybeStr: "Message of the day!" };

    st.toCell();
    msg.toCell();

    st.toCell().asSlice();
    msg.toCell().asSlice();
}
```

:::note[Useful links:]

  [`Struct.toCell(){:tact}` in Core library](/ref/core-cells#structtocell)\
  [`Message.toCell(){:tact}` in Core library](/ref/core-cells#messagetocell)

:::

### How to convert a `Cell` or a `Slice` to an arbitrary `Struct` or `Message`

```tact {19-20, 22-23}
struct Profit {
    big: String?;
    dict: map<Int, Int as uint64>;
    energy: Int;
}

message(0x45) Nice {
    maybeStr: String?;
}

fun convert() {
    let stCell = Profit{
        big: null,
        dict: null,
        energy: 42,
    }.toCell();
    let msgCell = Nice{ maybeStr: "Message of the day!" }.toCell();

    Profit.fromCell(stCell);
    Nice.fromCell(msgCell);

    Profit.fromSlice(stCell.asSlice());
    Nice.fromSlice(msgCell.asSlice());
}
```

:::note[Useful links:]

  [`Struct.fromCell(){:tact}` in Core library](/ref/core-cells#structfromcell)\
  [`Struct.fromSlice(){:tact}` in Core library](/ref/core-cells#structfromslice)\
  [`Message.fromCell(){:tact}` in Core library](/ref/core-cells#messagefromcell)\
  [`Message.fromSlice(){:tact}` in Core library](/ref/core-cells#messagefromslice)

:::

:::tip[Hey there!]

  Didn't find your favorite example of type conversion? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::

[p]: /book/types#primitive-types


## dedust.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/dexes/dedust.mdx)
---
title: DeDust.io
description: "This page list examples of working with DeDust, a decentralized exchange and automated market maker built natively on TON Blockchain and DeDust Protocol"
sidebar:
  order: 1
---

[DeDust](https://dedust.io) is a decentralized exchange (DEX) and automated market maker (AMM) built natively on [TON Blockchain](https://ton.org) and [DeDust Protocol 2.0](https://docs.dedust.io/reference/tlb-schemes). DeDust is designed with a meticulous attention to user experience (UX), gas efficiency, and extensibility.

Before going further, familiarize yourself with the following:

* [Receiving messages](/book/receive/)
* [Sending messages](/book/send/)
* [Fungible Tokens (Jettons)](/cookbook/jettons/)
* [DeDust Docs: Concepts](https://docs.dedust.io/docs/concepts)

## Swaps

Read more about swaps in the [DeDust documentation](https://docs.dedust.io/docs/swaps).

:::caution

  It's important to ensure that contracts are deployed. Sending funds to an inactive contract could result in irretrievable loss.

:::

All kinds of swaps use `SwapStep{:tact}` and `SwapParams{:tact}` structures:

```tact
/// https://docs.dedust.io/reference/tlb-schemes#swapstep
struct SwapStep {
    // The pool that will do the swapping, i.e. pairs like TON/USDT or USDT/DUST
    poolAddress: Address;

    // A kind of swap to make, can only be 0 as of now
    kind: Int as uint1 = 0;

    // Minimum output of the swap
    // If the actual value is less than specified, the swap will be rejected
    limit: Int as coins = 0;

    // Reference to the next step, which can be used for multi-hop swaps
    // The type here is actually `SwapStep?`,
    // but specifying recursive types isn't allowed in Tact yet
    nextStep: Cell?;
}

/// https://docs.dedust.io/reference/tlb-schemes#swapparams
struct SwapParams {
    // Specifies a deadline for the swap to reject the swap coming to the pool late
    // Accepts the number of seconds passed since the UNIX Epoch
    // Defaults to 0, which removes the deadline
    deadline: Int as uint32 = 0;

    // Specifies an address where funds will be sent after the swap
    // Defaults to `null`, which makes the swap use the sender's address
    recipientAddress: Address? = null;

    // Referral address, required for the referral program of DeDust
    // Defaults to `null`
    referralAddress: Address? = null;

    // Custom payload that will be attached to the fund transfer upon a successful swap
    // Defaults to `null`
    fulfillPayload: Cell? = null;

    // Custom payload that will be attached to the fund transfer upon a rejected swap
    // Defaults to `null`
    rejectPayload: Cell? = null;
}
```

### Swap Toncoin for any Jetton

:::note
The guides below use the [Jetton vault](https://docs.dedust.io/docs/concepts#vault). To obtain its address for your Jetton, refer to [this guide](https://docs.dedust.io/docs/swaps#step-1-find-the-vault-scale).
:::

```tact
/// https://docs.dedust.io/reference/tlb-schemes#message-swap
message(0xea06185d) NativeSwap {
    // Unique identifier used to trace transactions across multiple contracts
    // Defaults to 0, which means we don't mark messages to trace their chains
    queryId: Int as uint64 = 0;

    // Toncoin amount for the swap
    amount: Int as coins;

    // Inlined fields of SwapStep Struct
    poolAddress: Address;
    kind: Int as uint1 = 0;
    limit: Int as coins = 0;
    nextStep: SwapStep? = null;

    // Set of parameters relevant for the whole swap
    swapParams: SwapParams;
}

// Let's say `swapAmount` is `ton("0.1")`, which is 10000000 nanoToncoins
fun swapToncoinForUSDT(swapAmount: Int) {
    send(SendParameters{
        // Address of TON vault to send the message to
        to: address("EQDa4VOnTYlLvDJ0gZjNYm5PXfSmmtL6Vs6A_CZEtXCNICq_"),
        // Amount to swap plus a trade fee
        value: swapAmount + ton("0.2"),
        body: NativeSwap{
            amount: swapAmount,
            // Address of the swap pool, which is the TON/USDT pair in this case
            poolAddress: address("EQA-X_yo3fzzbDbJ_0bzFWKqtRuZFIRa1sJsveZJ1YpViO3r"),
            // Set of parameters relevant for the whole swap
            swapParams: SwapParams{}, // use defaults
        }.toCell(),
    });
}

//
// Helper Structs described earlier on this page
//

struct SwapStep {
    poolAddress: Address;
    kind: Int as uint1 = 0;
    limit: Int as coins = 0;
    nextStep: Cell?;
}

struct SwapParams {
    deadline: Int as uint32 = 0;
    recipientAddress: Address? = null;
    referralAddress: Address? = null;
    fulfillPayload: Cell? = null;
    rejectPayload: Cell? = null;
}
```

### Swap a Jetton for another Jetton or Toncoin

```tact
/// https://docs.dedust.io/reference/tlb-schemes#message-swap-1
message(0xe3a0d482) JettonSwapPayload {
    // Inlined fields of SwapStep Struct
    poolAddress: Address;
    kind: Int as uint1 = 0;
    limit: Int as coins = 0;
    nextStep: SwapStep? = null;

    // Set of parameters relevant for the whole swap
    swapParams: SwapParams;
}

/// NOTE: To calculate and provide Jetton wallet address for the target user,
///       make sure to check links after this code snippet
fun swapJetton(targetJettonWalletAddress: Address) {
    send(SendParameters{
        to: targetJettonWalletAddress,
        value: ton("0.3"),
        body: JettonTransfer{
            // Unique identifier used to trace transactions across multiple contracts
            // Set to 0, which means we don't mark messages to trace their chains
            queryId: 0,
            // Jetton amount for the swap
            amount: 10, // NOTE: change to yours
            // Address of the Jetton vault to the send message to
            destination: address("EQAYqo4u7VF0fa4DPAebk4g9lBytj2VFny7pzXR0trjtXQaO"),
            // Where to return the exceeding funds
            responseDestination: myAddress(),
            forwardTonAmount: ton("0.25"),
            forwardPayload: JettonSwapPayload{
                // Address of the swap pool, which is the TON/USDT pair in this case
                poolAddress: address("EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs"),
                // Set of parameters relevant for the whole swap
                swapParams: SwapParams{}, // use defaults
            }.toCell(),
        }.toCell(),
    });
}

//
// Helper Structs described earlier on this page
//

struct SwapStep {
    poolAddress: Address;
    kind: Int as uint1 = 0;
    limit: Int as coins = 0;
    nextStep: Cell?;
}

struct SwapParams {
    deadline: Int as uint32 = 0;
    recipientAddress: Address? = null;
    referralAddress: Address? = null;
    fulfillPayload: Cell? = null;
    rejectPayload: Cell? = null;
}

//
// Messages from the Jetton standard
//

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Cell?; // slightly adjusted
}
```

:::note[Useful links:]

  [Retrieving Jetton wallet address in TON Docs](https://docs.ton.org/develop/dapps/asset-processing/jettons#retrieving-jetton-wallet-addresses-for-a-given-user)\
  [How to calculate user's Jetton wallet address (offline)?](https://docs.ton.org/v3/guidelines/dapps/cookbook#how-to-calculate-users-jetton-wallet-address-offline)

:::

## Liquidity Provisioning

To provide liquidity to a particular DeDust pool, you must provide both assets. The pool will then issue special _LP tokens_ to the depositor's address.

Read more about liquidity provisioning in the [DeDust documentation](https://docs.dedust.io/docs/liquidity-provisioning).

```tact
import "@stdlib/deploy";

/// https://docs.dedust.io/reference/tlb-schemes#message-deposit_liquidity-1
message(0x40e108d6) JettonDepositLiquidity {
    // Pool type: 0 for volatile, 1 for stable
    // Volatile pool is based on the "Constant Product" formula
    // Stable-swap pool is optimized for assets of near-equal value,
    // e.g. USDT/USDC, TON/stTON, etc.
    poolType: Int as uint1;

    // Provided assets
    asset0: Asset;
    asset1: Asset;

    // Minimal amount of LP tokens to be received
    // If there's less liquidity provided, the provisioning will be rejected
    // Defaults to 0, makes this value ignored
    minimalLpAmount: Int as coins = 0;

    // Target amount of the first asset
    targetBalances0: Int as coins;

    // Target amount of the second asset
    targetBalances1: Int as coins;

    // Custom payload attached to the transaction if the provisioning is successful
    // Defaults to `null`, which means no payload
    fulfillPayload: Cell? = null;

    // Custom payload attached to the transaction if the provisioning is rejected
    // Defaults to `null`, which means no payload
    rejectPayload: Cell? = null;
}

/// https://docs.dedust.io/reference/tlb-schemes#message-deposit_liquidity
message(0xd55e4686) NativeDepositLiquidity {
    // Unique identifier used to trace transactions across multiple contracts
    // Defaults to 0, which means we don't mark messages to trace their chains
    queryId: Int as uint64 = 0;

    // Toncoin amount for the deposit
    amount: Int as coins;

    // Inlined fields of JettonDepositLiquidity Message without the opcode prefix
    poolType: Int as uint1;
    asset0: Asset;
    asset1: Asset;
    minimalLpAmount: Int as coins = 0;
    targetBalances0: Int as coins;
    targetBalances1: Int as coins;
    fulfillPayload: Cell? = null;
    rejectPayload: Cell? = null;
}

/// https://docs.dedust.io/reference/tlb-schemes#asset
struct Asset {
    // Specify 0 for native (TON) and omit all following fields
    // Specify 1 for Jetton and then you must set non-null values for the following fields
    type: Int as uint4;

    workchain: Int as uint8 = 0; // Both this zeroes will be removed during .build() function. Only type will remain.
    address: Int as uint256 = 0; 
}

const PoolTypeVolatile: Int = 0;
const PoolTypeStable: Int = 1;

const AssetTypeNative: Int = 0b0000;
const AssetTypeJetton: Int = 0b0001;

const JettonProvideLpGas: Int = ton("0.5");
const JettonProvideLpGasFwd: Int = ton("0.4");
const TonProvideLpGas: Int = ton("0.15");

// This example directly uses the provided `myJettonWalletAddress`
// In real-world scenarios, it's more reliable to calculate this address on-chain or save it during initialization to prevent any issues
fun provideLiquidity(myJettonWalletAddress: Address) {
    let jettonMasterRaw = parseStdAddress(
        address("EQCxE6mUtQJKFnGfaROTKOt1lZbDiiX1kCixRv7Nw2Id_sDs")
        .asSlice()
    );

    // Step 1. Prepare input
    let jettonAmount = ton("1");
    let tonAmount = ton("1");

    let asset0 = Asset{
        type: AssetTypeNative,
    };
    let asset1 = Asset{
        type: AssetTypeJetton,
        workchain: jettonMasterRaw.workchain,
        address: jettonMasterRaw.address,
    };

    // Step 2. Deposit Jetton to Vault
    let jettonDepositBody = JettonDepositLiquidity{
        poolType: PoolTypeVolatile,
        asset0,
        asset1,
        targetBalances0: tonAmount,
        targetBalances1: jettonAmount,
    }.build(); // notice the .build() and not .toCell(),
               // since we want some custom serialization logic!

    send(SendParameters{
        to: myJettonWalletAddress,
        value: JettonProvideLpGas,
        body: JettonTransfer{
            queryId: 42,
            amount: jettonAmount,
            // Jetton Vault
            destination: address("EQAYqo4u7VF0fa4DPAebk4g9lBytj2VFny7pzXR0trjtXQaO"),
            responseDestination: myAddress(),
            forwardTonAmount: JettonProvideLpGasFwd,
            forwardPayload: jettonDepositBody,
        }.toCell()
    });

    // Step 3. Deposit TON to Vault
    let nativeDepositBody = NativeDepositLiquidity{
        queryId: 42,
        amount: tonAmount,
        poolType: PoolTypeVolatile,
        asset0,
        asset1,
        targetBalances0: tonAmount,
        targetBalances1: jettonAmount,
    }.build(); // notice the .build() and not .toCell(),
               // since we want some custom serialization logic!

    send(SendParameters{
        to: address("EQDa4VOnTYlLvDJ0gZjNYm5PXfSmmtL6Vs6A_CZEtXCNICq_"),
        value: tonAmount + TonProvideLpGas,
        body: nativeDepositBody,
    });
}

//
// Helper extension functions to build respective Structs and Messages
//

extends fun build(self: Asset): Cell {
    let assetBuilder = beginCell()
        .storeUint(self.type, 4);

    if (self.type == AssetTypeNative) {
        return assetBuilder.endCell();
    }

    if (self.type == AssetTypeJetton) {
        return assetBuilder
            .storeUint(self.workchain, 8)
            .storeUint(self.address, 256)
            .endCell();
    }

    // Unknown asset type
    return beginCell().endCell();
}

extends fun build(self: JettonDepositLiquidity): Cell {
    return beginCell()
        .storeUint(0x40e108d6, 32)
        .storeUint(self.poolType, 1)
        .storeSlice(self.asset0.build().asSlice())
        .storeSlice(self.asset1.build().asSlice())
        .storeCoins(self.minimalLpAmount)
        .storeCoins(self.targetBalances0)
        .storeCoins(self.targetBalances1)
        .storeMaybeRef(self.fulfillPayload)
        .storeMaybeRef(self.rejectPayload)
        .endCell();
}

extends fun build(self: NativeDepositLiquidity): Cell {
    return beginCell()
        .storeUint(0xd55e4686, 32)
        .storeUint(self.queryId, 64)
        .storeCoins(self.amount)
        .storeUint(self.poolType, 1)
        .storeSlice(self.asset0.build().asSlice())
        .storeSlice(self.asset1.build().asSlice())
        .storeRef(
            beginCell()
                .storeCoins(self.minimalLpAmount)
                .storeCoins(self.targetBalances0)
                .storeCoins(self.targetBalances1)
                .endCell()
        )
        .storeMaybeRef(self.fulfillPayload)
        .storeMaybeRef(self.rejectPayload)
        .endCell();
}

//
// Messages from the Jetton standard
//

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Cell?; // slightly adjusted
}
```

### Withdraw liquidity

To withdraw liquidity, burning LP tokens is required. You can refer to examples of Jetton burning in the [respective section of Jettons Cookbook page](/cookbook/jettons#burning-jetton). However, more Toncoins should be added than for the normal burn, since adding too few may result in LP tokens being burned, but no (or only partial) liquidity being sent from the pool. Therefore, consider attaching at least $0.5$ Toncoin — excess amount will be returned.

:::tip[Hey there!]

Didn't find your favorite example of DeDust interaction? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::


## stonfi.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/cookbook/dexes/stonfi.mdx)
---
title: STON.fi
description: "This page list examples of working with STON.fi, a decentralized automated market maker built on TON Blockchain"
sidebar:
  order: 2
---

[STON.fi](https://ston.fi) is a decentralized automated market maker (AMM) built on [TON blockchain](https://ton.org) providing virtually zero fees, low slippage, an extremely easy interface, and direct integration with TON wallets.

:::caution

  The examples on this page use STON.fi's API v2, which is currently under development. Thus, all addresses are given in [testnet][testnet].

  Proceed with caution and vigilance — do not attempt to send funds from the mainnet to the testnet and vice versa.

:::

Before going further, familiarize yourself with the following:

* [Receiving messages](/book/receive/)
* [Sending messages](/book/send/)
* [Fungible Tokens (Jettons)](/cookbook/jettons/)
* [STON.fi Docs: Glossary](https://docs.ston.fi/docs/user-section/glossary)
* [STON.fi Docs: Architecture](https://docs.ston.fi/docs/developer-section/architecture)

## Swaps

Read more about swaps in the [STON.fi documentation](https://docs.ston.fi/docs/developer-section/api-reference-v2/example_swap).

Swaps use `StonfiSwap{:tact}` [Message][message] and `SwapAdditionalData{:tact}` [Struct][struct]:

```tact
/// https://docs.ston.fi/docs/developer-section/api-reference-v2/router#swap-0x6664de2a
message(0x6664de2a) StonfiSwap {
    // Address of the other Router token wallet
    otherTokenWallet: Address;

    // Where to send refunds upon a failed swap
    refundAddress: Address;

    // Where to send excesses upon a successful swap
    excessesAddress: Address;

    // UNIX timestamp of execution deadline for the swap
    deadline: Int as uint64;

    // Reference to another Cell with additional data,
    // using the Tact's greedy auto-layout mechanism
    additionalData: SwapAdditionalData;
}

/// https://docs.ston.fi/docs/developer-section/api-reference-v2/router#additional_data-body
struct SwapAdditionalData {
    // Minimum required amount of tokens to receive
    // Defaults to 1, which causes the swap to fail
    //                only if no tokens are received
    minOut: Int as coins = 1;

    // Where to send tokens upon a successful swap
    receiverAddress: Address;

    // Forward fees for the `customPayload` if it's not `null`
    // Defaults to 0
    fwdGas: Int as coins = 0;

    // Custom payload that will be sent upon a successful swap
    // Defaults to `null`, which means no payload
    customPayload: Cell? = null;

    // Forward fees for `refundPayload` if it's not `null`
    // Defaults to 0
    refundFwdGas: Int as coins = 0;

    // Custom payload that will be sent upon a failed swap
    // Defaults to `null`, which means no payload
    refundPayload: Cell? = null;

    // Referral fee, between 0 (no fee) and 100 (1%)
    // Defaults to 10, which means 0.1% fee
    refFee: Int as uint16 = 10;

    // Address of the referral
    // Defaults to `null`
    referralAddress: Address? = null;
}
```

The [STON.fi SDK](https://github.com/ston-fi/sdk) defines some [constants to deal with fees](https://github.com/ston-fi/sdk/blob/786ece758794bd5c575db8b38f5e5de19f43f0d1/packages/sdk/src/contracts/dex/v2_1/router/BaseRouterV2_1.ts). Note that these are hardcoded values, but the best practice is to [calculate fees dynamically using current config params](https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation) instead.

```tact
/// Hardcoded fee value to pay for sending a message to the Jetton wallet
const FeeSwapJettonToJetton: Int = ton("0.3");
/// Hardcoded fee value to pay forward fees from the Jetton wallet
const FeeSwapJettonToJettonFwd: Int = ton("0.24");

/// Hardcoded fee value to pay for sending a message to the Jetton wallet
const FeeSwapJettonToToncoin: Int = ton("0.3");
/// Hardcoded fee value to pay for sending a message to the Jetton wallet
const FeeSwapJettonToToncoinFwd: Int = ton("0.24");

/// Hardcoded fee value to pay for sending a message and subsequent forwarding
const FeeSwapToncoinToJetton: Int = ton("0.01") + ton("0.3");
```

:::note[Useful links:]

  [Fees Calculation in TON Docs][fees-calc]

:::

### Jetton to Jetton {#swaps-jetton-to-jetton}

:::caution

  The following example uses STON.fi's API v2, which is currently under development. Thus, all addresses are given in [testnet][testnet].

  In addition, some variables such as `offerAmount` are hardcoded for demonstration purposes. Don't forget to change them in real life scenarios.

:::

```tact
// CPI Router v2.1.0
const RouterAddress: Address =
    address("kQALh-JBBIKK7gr0o4AVf9JZnEsFndqO0qTCyT-D-yBsWk0v");

// Router Jetton Wallet address
const RouterJettonWallet: Address =
    address("kQAtX3x2s-wMtYTz8CfmAyloHAB73vONzJM5S2idqXl-_5xK");

/// NOTE: To calculate and provide Jetton wallet address for the target user,
///       make sure to check links after this code snippet
fun jettonToJetton(myJettonWalletAddress: Address) {
    // Amount of Jettons to swap
    let offerAmount: Int = 100_000;

    // Prepare the payload
    let forwardPayload = StonfiSwap{
        otherTokenWallet: RouterJettonWallet,
        refundAddress: myAddress(),
        excessesAddress: myAddress(),
        // Deadline is set to 10,000 seconds from now
        deadline: now() + 10_000,
        additionalData: SwapAdditionalData{ receiverAddress: myAddress() },
    };

    // Start a swap with the message to the Jetton wallet
    send(SendParameters{
        to: myJettonWalletAddress,
        value: FeeSwapJettonToJetton,
        body: JettonTransfer{
            queryId: 42,
            amount: offerAmount,
            destination: RouterAddress,
            responseDestination: myAddress(),
            forwardTonAmount: FeeSwapJettonToJettonFwd,
            forwardPayload: forwardPayload.toCell(),
        }.toCell(),
    });
}

//
// Helper Messages, Structs and constants described earlier on this page
//

message(0x6664de2a) StonfiSwap {
    otherTokenWallet: Address;
    refundAddress: Address;
    excessesAddress: Address;
    deadline: Int as uint64;
    additionalData: SwapAdditionalData;
}

struct SwapAdditionalData {
    minOut: Int as coins = 1;
    receiverAddress: Address;
    fwdGas: Int as coins = 0;
    customPayload: Cell? = null;
    refundFwdGas: Int as coins = 0;
    refundPayload: Cell? = null;
    refFee: Int as uint16 = 10;
    referralAddress: Address? = null;
}

const FeeSwapJettonToJetton: Int = ton("0.3");
const FeeSwapJettonToJettonFwd: Int = ton("0.24");

//
// Messages from the Jetton standard
//

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Cell?; // slightly adjusted
}
```

:::note[Useful links:]

  [Retrieving Jetton wallet address in TON Docs][jetton-addr-online]\
  [How to calculate user's Jetton wallet address (offline)?][jetton-addr-offline]\
  [Discoverable Jetton wallets][discoverable-jetton-wallets]\
  [Fees Calculation in TON Docs][fees-calc]

:::

### Jetton to Toncoin {#swaps-jetton-to-toncoin}

Jetton to Toncoin swap is very similar to [Jetton to Jetton swap](#swaps-jetton-to-jetton) with the only difference that the `RouterJettonWallet{:tact}` address is replaced with `RouterProxyTonWallet{:tact}`.

:::caution

  The following example uses STON.fi's API v2, which is currently under development. Thus, all addresses are given in [testnet][testnet].

  In addition, some variables such as `offerAmount` are hardcoded for demonstration purposes. Don't forget to change them in real life scenarios.

:::

```tact
// CPI Router v2.1.0
const RouterAddress: Address =
    address("kQALh-JBBIKK7gr0o4AVf9JZnEsFndqO0qTCyT-D-yBsWk0v");

// Router's pTON address
const RouterProxyTonWallet: Address =
    address("kQBbJjnahBMGbMUJwhAXLn8BiigcGXMJhSC0l7DBhdYABhG7");

/// NOTE: To calculate and provide Jetton wallet address for the target user,
///       make sure to check links after this code snippet
fun jettonToToncoin(myJettonWalletAddress: Address) {
    // Amount of Jettons to swap
    let offerAmount: Int = 100_000;

    // Prepare the payload
    let forwardPayload = StonfiSwap{
        otherTokenWallet: RouterProxyTonWallet,
        refundAddress: myAddress(),
        excessesAddress: myAddress(),
        // Deadline is set to 10,000 seconds from now
        deadline: now() + 10_000,
        additionalData: SwapAdditionalData{ receiverAddress: myAddress() },
    };

    // Start a swap with the message to the Jetton wallet
    send(SendParameters{
        to: myJettonWalletAddress,
        value: FeeSwapJettonToToncoin,
        body: JettonTransfer{
            queryId: 42,
            amount: offerAmount,
            destination: RouterAddress,
            responseDestination: myAddress(),
            forwardTonAmount: FeeSwapJettonToToncoinFwd,
            forwardPayload: forwardPayload.toCell(),
        }.toCell(),
    });
}

//
// Helper Messages, Structs and constants described earlier on this page
//

message(0x6664de2a) StonfiSwap {
    otherTokenWallet: Address;
    refundAddress: Address;
    excessesAddress: Address;
    deadline: Int as uint64;
    additionalData: SwapAdditionalData;
}

struct SwapAdditionalData {
    minOut: Int as coins = 1;
    receiverAddress: Address;
    fwdGas: Int as coins = 0;
    customPayload: Cell? = null;
    refundFwdGas: Int as coins = 0;
    refundPayload: Cell? = null;
    refFee: Int as uint16 = 10;
    referralAddress: Address? = null;
}

const FeeSwapJettonToToncoin: Int = ton("0.3");
const FeeSwapJettonToToncoinFwd: Int = ton("0.24");

//
// Messages from the Jetton standard
//

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Cell?; // slightly adjusted
}
```

:::note[Useful links:]

  [Retrieving Jetton wallet address in TON Docs][jetton-addr-online]\
  [How to calculate user's Jetton wallet address (offline)?][jetton-addr-offline]\
  [Discoverable Jetton wallets][discoverable-jetton-wallets]\
  [Fees Calculation in TON Docs][fees-calc]

:::

### Toncoin to Jetton {#swaps-jetton-to-toncoin}

To swap Toncoin to Jetton, STON.fi requires the use of a so-called proxy Toncoin wallet (or pTON for short). To interact with it properly, we need to introduce a `ProxyToncoinTransfer{:tact}` [Message][message]:

```tact
/// https://github.com/ston-fi/sdk/blob/786ece758794bd5c575db8b38f5e5de19f43f0d1/packages/sdk/src/contracts/pTON/v2_1/PtonV2_1.ts
message(0x01f3835d) ProxyToncoinTransfer {
    // Unique identifier used to trace transactions across multiple contracts
    // Defaults to 0, which means we don't mark messages to trace their chains
    queryId: Int as uint64 = 0;

    // Toncoin amount for the swap
    tonAmount: Int as coins;

    // Where to send refunds upon a failed swap
    refundAddress: Address;

    // Optional custom payload to attach to the swap
    // Defaults to `null`
    forwardPayload: Cell?;
}
```

Notice that `ProxyToncoinTransfer{:tact}` is quite similar to `JettonTransfer{:tact}`, except that it doesn't require any addresses other than the refund address, nor does it require any forward amounts to be specified.

:::caution

  The following example uses STON.fi's API v2, which is currently under development. Thus, all addresses are given in [testnet][testnet].

  In addition, some variables such as `offerAmount` are hardcoded for demonstration purposes. Don't forget to change them in real life scenarios.

:::

```tact
// Router's pTON wallet address
const RouterProxyTonWallet: Address
    = address("kQBbJjnahBMGbMUJwhAXLn8BiigcGXMJhSC0l7DBhdYABhG7");

// Router's Jetton wallet address
const RouterJettonWallet: Address =
    address("kQAtX3x2s-wMtYTz8CfmAyloHAB73vONzJM5S2idqXl-_5xK");

fun toncoinToJetton() {
    // Amount of Toncoin to swap
    let offerAmount: Int = 1_000;

    // Prepare the payload
    let forwardPayload = StonfiSwap{
        otherTokenWallet: RouterJettonWallet,
        refundAddress: myAddress(),
        excessesAddress: myAddress(),
        // Deadline is set to 10,000 seconds from now
        deadline: now() + 10_000,
        additionalData: SwapAdditionalData{ receiverAddress: myAddress() },
    };

    // Start a swap with the message to the proxy Toncoin wallet
    send(SendParameters{
        to: RouterProxyTonWallet,
        value: FeeSwapToncoinToJetton + offerAmount,
        body: ProxyToncoinTransfer{
            tonAmount: offerAmount,
            refundAddress: myAddress(),
            forwardPayload: forwardPayload.toCell(),
        }.toCell(),
    });
}

//
// Helper Messages, Structs and constants described earlier on this page
//

message(0x01f3835d) ProxyToncoinTransfer {
    queryId: Int as uint64 = 0;
    tonAmount: Int as coins;
    refundAddress: Address;
    forwardPayload: Cell?;
}

message(0x6664de2a) StonfiSwap {
    otherTokenWallet: Address;
    refundAddress: Address;
    excessesAddress: Address;
    deadline: Int as uint64;
    additionalData: SwapAdditionalData;
}

struct SwapAdditionalData {
    minOut: Int as coins = 1;
    receiverAddress: Address;
    fwdGas: Int as coins = 0;
    customPayload: Cell? = null;
    refundFwdGas: Int as coins = 0;
    refundPayload: Cell? = null;
    refFee: Int as uint16 = 10;
    referralAddress: Address? = null;
}

const FeeSwapToncoinToJetton: Int = ton("0.3");
```

:::note[Useful links:]

  [Fees Calculation in TON Docs][fees-calc]

:::

## Liquidity provision

Read more about liquidity provision in the [STON.fi documentation](https://docs.ston.fi/docs/developer-section/api-reference-v2/example_lp_provide).

STON.fi allows you to deposit liquidity by specifying only one type of token - the pool will automatically perform the swap and mint liquidity provider (LP) tokens. To do this you need to set `bothPositive` field of `ProvideLiquidity{:tact}` [Message][message] to `false{:tact}`.

Liquidity deposits use `ProvideLiquidity{:tact}` [Message][message] and `ProvideLiqudityAdditionalData{:tact}` [Struct][struct]:

```tact
/// https://docs.ston.fi/docs/developer-section/api-reference-v2/router#provide_lp-0x37c096df
message(0x37c096df) ProvideLiquidity {
    // Address of the other Router token wallet
    otherTokenWallet: Address;

    // Where to send refunds if provisioning fails
    refundAddress: Address;

    // Where to send excesses if provisioning succeeds
    excessesAddress: Address;

    // UNIX timestamp of execution deadline for the provisioning
    deadline: Int as uint64;

    // Reference to another Cell with additional data,
    // using the Tact's greedy auto-layout mechanism
    additionalData: ProvideLiquidityAdditionalData;
}

/// https://docs.ston.fi/docs/developer-section/api-reference-v2/router#additional_data-body-1
struct ProvideLiquidityAdditionalData {
    // Minimum required amount of LP tokens to receive
    // Defaults to 1, which causes the provisioning to fail
    //                only if no tokens are received
    minLpOut: Int as coins = 1;

    // Where to send LP tokens if provisioning succeeds
    receiverAddress: Address;

    // Should both tokens in a pair have a positive quantity?
    // If not, then the pool would perform an additional swap for the lacking token
    // Defaults to `true`, which means that deposit would only go through
    //                     when both token amounts are non-zero
    bothPositive: Bool = true;

    // Forward fees for the `customPayload` if it's not `null`
    // Defaults to 0
    fwdGas: Int as coins = 0;

    // Custom payload that will be sent if provisioning succeeds
    // Defaults to `null`, which means no payload
    customPayload: Cell? = null;
}
```

The [STON.fi SDK](https://github.com/ston-fi/sdk) defines some [constants to deal with fees](https://github.com/ston-fi/sdk/blob/786ece758794bd5c575db8b38f5e5de19f43f0d1/packages/sdk/src/contracts/dex/v2_1/router/BaseRouterV2_1.ts). Note that these are hardcoded values, but the best practice is to [calculate fees dynamically using current config params](https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation) instead.

```tact
/// Hardcoded fee value to pay for sending a liquidity provisioning message
/// when depositing a certain amount of Jettons
const FeeSingleSideProvideLpJetton: Int = ton("1");

/// Hardcoded fee value to pay forward fees of subsequent messages for liquidity provisioning
const FeeSingleSideProvideLpJettonFwd: Int = ton("0.8");

/// Hardcoded fee value to pay for sending a liquidity provisioning message
/// when depositing a certain amount of Toncoins
const FeeSingleSideProvideLpToncoin: Int = ton("0.01") + ton("0.8");
```

:::note[Useful links:]

  [Fees Calculation in TON Docs][fees-calc]

:::

### Jetton deposit

:::caution

  The following example uses STON.fi's API v2, which is currently under development. Thus, all addresses are given in [testnet][testnet].

  In addition, some variables such as `offerAmount` are hardcoded for demonstration purposes. Don't forget to change them in real life scenarios.

:::

```tact
// CPI Router v2.1.0
const RouterAddress: Address =
    address("kQALh-JBBIKK7gr0o4AVf9JZnEsFndqO0qTCyT-D-yBsWk0v");

// Router's pTON wallet address
const RouterProxyTonWallet: Address =
    address("kQBbJjnahBMGbMUJwhAXLn8BiigcGXMJhSC0l7DBhdYABhG7");

// Router's Jetton wallet address
const RouterJettonWallet: Address =
    address("kQAtX3x2s-wMtYTz8CfmAyloHAB73vONzJM5S2idqXl-_5xK"); 

/// NOTE: To calculate and provide Jetton wallet address for the target user,
///       make sure to check links after this code snippet
fun jettonDeposit(myJettonWalletAddress: Address) {
    // Amount of Jettons for liquidity provisioning
    let offerAmount = 100_000;

    // Prepare the payload
    let forwardPayload = ProvideLiquidity{
        otherTokenWallet: RouterProxyTonWallet,
        refundAddress: myAddress(),
        excessesAddress: myAddress(),
        // Deadline is set to 1,000 seconds from now
        deadline: now() + 1_000,
        additionalData: ProvideLiquidityAdditionalData{
            receiverAddress: myAddress(),
            bothPositive: false, // i.e. single side
        },
    };

    send(SendParameters{
        to: myJettonWalletAddress,
        value: FeeSingleSideProvideLpJetton,
        body: JettonTransfer{
            queryId: 42,
            amount: offerAmount,
            destination: RouterAddress,
            responseDestination: myAddress(),
            forwardTonAmount: FeeSingleSideProvideLpJettonFwd,
            forwardPayload: forwardPayload.toCell(),
        }.toCell(),
    });
}

//
// Helper Messages, Structs and constants described earlier on this page
//

message(0x37c096df) ProvideLiquidity {
    otherTokenWallet: Address;
    refundAddress: Address;
    excessesAddress: Address;
    deadline: Int as uint64;
    additionalData: ProvideLiquidityAdditionalData;
}

struct ProvideLiquidityAdditionalData {
    minLpOut: Int as coins = 1;
    receiverAddress: Address;
    bothPositive: Bool = true;
    fwdGas: Int as coins = 0;
    customPayload: Cell? = null;
}

const FeeSingleSideProvideLpJetton: Int = ton("1");
const FeeSingleSideProvideLpJettonFwd: Int = ton("0.8");

//
// Messages from the Jetton standard
//

message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Cell?; // slightly adjusted
}
```

### Toncoin deposit

:::caution

  The following example uses STON.fi's API v2, which is currently under development. Thus, all addresses are given in [testnet][testnet].

  In addition, some variables such as `offerAmount` are hardcoded for demonstration purposes. Don't forget to change them in real life scenarios.

:::

```tact
// Router's pTON wallet address
const RouterProxyTonWallet: Address =
    address("kQBbJjnahBMGbMUJwhAXLn8BiigcGXMJhSC0l7DBhdYABhG7");

// Router's Jetton wallet address
const RouterJettonWallet: Address =
    address("kQAtX3x2s-wMtYTz8CfmAyloHAB73vONzJM5S2idqXl-_5xK");

fun toncoinDeposit() {
    // Amount of Jettons for liquidity provisioning
    let offerAmount = 100_000;

    // Prepare the payload
    let forwardPayload = ProvideLiquidity{
        otherTokenWallet: RouterJettonWallet,
        refundAddress: myAddress(),
        excessesAddress: myAddress(),
        deadline: now() + 1000,
        additionalData: ProvideLiquidityAdditionalData{
            receiverAddress: myAddress(),
            bothPositive: false, // i.e. single side
        },
    };

    send(SendParameters{
        to: RouterProxyTonWallet,
        value: FeeSingleSideProvideLpToncoin + offerAmount,
        body: ProxyToncoinTransfer{
            queryId: 42,
            tonAmount: offerAmount,
            refundAddress: myAddress(),
            forwardPayload: forwardPayload.toCell(),
        }.toCell(),
    });
}

//
// Helper Messages, Structs and constants described earlier on this page
//

message(0x01f3835d) ProxyToncoinTransfer {
    queryId: Int as uint64 = 0;
    tonAmount: Int as coins;
    refundAddress: Address;
    forwardPayload: Cell?;
}

message(0x37c096df) ProvideLiquidity {
    otherTokenWallet: Address;
    refundAddress: Address;
    excessesAddress: Address;
    deadline: Int as uint64;
    additionalData: ProvideLiquidityAdditionalData;
}

struct ProvideLiquidityAdditionalData {
    minLpOut: Int as coins = 1;
    receiverAddress: Address;
    bothPositive: Bool = true;
    fwdGas: Int as coins = 0;
    customPayload: Cell? = null;
}

const FeeSingleSideProvideLpToncoin: Int = ton("0.01") + ton("0.8");
```

### Withdraw liquidity

To withdraw liquidity, burning LP tokens is required. You can refer to examples of Jetton burning in the [respective section of Jettons Cookbook page](/cookbook/jettons#burning-jetton). However, more Toncoins should be added than for the normal burn, since adding too few may result in LP tokens being burned, but no (or only partial) liquidity being sent from the pool. Therefore, consider attaching at least $0.5$ Toncoin — excess amount will be returned.

:::tip[Hey there!]

Didn't find your favorite example of STON.fi interaction? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact/issues)

:::

[struct]: /book/structs-and-messages#structs
[message]: /book/structs-and-messages#messages

[testnet]: https://docs.ton.org/v3/documentation/smart-contracts/getting-started/testnet
[jetton-addr-online]: https://docs.ton.org/develop/dapps/asset-processing/jettons#retrieving-jetton-wallet-addresses-for-a-given-user
[jetton-addr-offline]: https://docs.ton.org/v3/guidelines/dapps/cookbook#how-to-calculate-users-jetton-wallet-address-offline
[discoverable-jetton-wallets]: https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md
[fees-calc]: https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ecosystem/index.mdx)
---
title: Ecosystem overview
description: "Ecosystem section — a bird-eye overview of Tact ecosystem, tools and ways you can start contributing"
---

import { CardGrid, LinkCard, Steps } from '@astrojs/starlight/components';

Welcome to the **Ecosystem** section — a bird-eye overview of Tact ecosystem, tools and ways you can start contributing to those and beyond!

Here are its main contents:

<Steps>

1. #### Tools

   Tools is a list of official and community-made tools made specifically for Tact, or whose that play along with the language and other tools. Each tool has a brief usage details and additional information, which sometimes is missing from the respective docs or is a convenient summary available only in the Tact documentation.
   
   <CardGrid>
    <LinkCard
      title="TypeScript"
      href="/ecosystem/typescript"
    />
    <LinkCard
      title="VS Code Extension"
      href="/ecosystem/vscode"
    />
    <LinkCard
      title="JetBrains IDEs Plugin"
      href="/ecosystem/jetbrains"
    />
    <LinkCard
      title="Misti Static Analyzer"
      href="/ecosystem/misti"
    />
   </CardGrid>

</Steps>


## jetbrains.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ecosystem/jetbrains.mdx)
---
title: TON development plugin for JetBrains IDEs
description: "Supports highlighting Tact's syntax in JetBrains IDEs versioned **2023.** and later, and also provides rich support of FunC and Fift languages of TON Blockchain, as well as TL-B schemas"
---

Supports highlighting Tact's syntax in JetBrains IDEs versioned **2023.** and later. Note, that besides support for Tact, it also includes a rich support of FunC and Fift languages of TON Blockchain, as well as TL-B schemas.

Plugin on the JetBrains Marketplace: [TON Development Plugin](https://plugins.jetbrains.com/plugin/23382-ton)

## Installation manual

1. Open your JetBrains IDE (IntelliJ IDEA, PyCharm, WebStorm, etc.)
2. Navigate to the **Plugin Marketplace** by selecting `File > Settings/Preferences > Plugins`
3. In the Plugin Marketplace's search bar, type "TON Development". You will see a dropdown with the extension provided by `TON Foundation`.
4. Click the **Install** button next to the plugin name. Wait for the installation to complete.
5. Once the plugin is installed, you will be prompted to restart your JetBrains IDE. Click the **Restart** button to apply changes.
6. After restarting, the TON Development plugin should now be successfully installed in your JetBrains IDE.

## Troubleshooting

If you encounter issues during the installation process, please consult the [plugin's GitHub repository](https://github.com/ton-blockchain/intellij-ton) for solutions and further information.

## References and Resources

- [Plugin on GitHub](https://github.com/ton-blockchain/intellij-ton)
- [Plugin on the JetBrains Marketplace](https://plugins.jetbrains.com/plugin/23382-ton)


## misti.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ecosystem/misti.mdx)
---
title: Misti Static Analyzer
description: "Static analysis of Tact contracts, custom detectors and CI/CD integration"
---

[Misti](https://nowarp.io/tools/misti/) is a static program analysis tool that supports Tact.

## What is Misti?

* **Static Program Analysis**: Misti analyzes code without executing it, scanning for [bugs and security flaws](https://nowarp.io/tools/misti/docs/detectors) by examining the structure and syntax. This approach catches issues early, preventing them from reaching production.
* **Custom Detectors**: Customize Misti to your specific needs by creating [custom detectors](https://nowarp.io/tools/misti/docs/hacking/custom-detector). This helps identify vulnerabilities that generic tools might miss, ensuring a thorough review of your code.
* **CI/CD Integration**: [Integrate](https://nowarp.io/tools/misti/docs/tutorial/ci-cd) Misti into your CI/CD pipeline to ensure continuous code quality checks, catching issues before they make it to production.

## Resources

* [Github](https://github.com/nowarp/misti)
* [Telegram Community](https://t.me/misti_dev)
* [Misti Documentation](https://nowarp.io/tools/misti/)


## typescript.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ecosystem/typescript.mdx)
---
title: TypeScript libraries
description: "The compiler of Tact automatically generates wrapper code for use with @ton/ton and @ton/core libraries"
prev:
  link: /ecosystem
  label: Ecosystem overview
---

The Tact language has built-in support for the [@ton/ton](https://github.com/ton-org/ton) and [@ton/core](https://github.com/ton-org/ton-core) TypeScript libraries. The compiler automatically generates code for these libraries, so you can use [@tact-lang/emulator](https://github.com/tact-lang/tact-emulator) or [@ton/sandbox](https://github.com/ton-org/sandbox), that work on top of them.

## Tact contract in TypeScript

The compiler generates files named `{project}_{contract}.ts` for each contract in your [project](/book/config#projects), which contain ready-to-use strongly typed wrappers for working with it in any TypeScript-powered environment: for [testing](/book/debug), [deployments](/book/deploy), etc.


## vscode.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ecosystem/vscode.mdx)
---
title: VS Code extension
description: "Extensive support for Tact language in the Visual Studio Code: syntax highlighting, error diagnostics, snippets, hover info and more"
---

Provides extensive support for Tact language in the Visual Studio Code:

* Syntax highlighting
* Error highlighting
* Snippets
* Information on hover
* Code completion for all variables, functions, global parameters and unique types of Tact
* Code completion for all contracts / libraries in the current file and all referenced imports
* Formatting

Extension on the VS Code Marketplace: [Tact Language Support for TON blockchain](https://marketplace.visualstudio.com/items?itemName=KonVik.tact-lang-vscode)

## Installation manual

1. Open Visual Studio Code (shortly referred to as VS Code).

2. Navigate to the Extensions view by clicking on the Extensions icon in the Activity Bar on the side of the window. It looks like a square within a square.

3. In the Extensions view input box, type "Tact Language". You should see a dropdown with the extension "Tact Language" provided by KonVik. Probably, you would see the similar extension provided by TON Community, but that one is deprecated and **we should use KonVik's one instead**.

4. Click on the install button next to the extension name. Wait until the installation is complete.

5. Once the extension is installed, you might need to reload VS Code. If necessary, there will be a Reload button next to the extension. Click on this button if it appears.

6. The Tact Language extension should now be installed on your VS Code.

## Enabling `Format on Save` {#format-on-save}

This guide will provide instructions on how to enable the Format on Save feature for the Tact Language extension in VS Code using the Command Palette and editing the JSON settings file.

1. Type `Preferences: Open Settings (JSON)` in the command palette. This will open your `settings.json` file.

2. Editing JSON Settings

   - You'll see a JSON object. We're going to add some properties to this object to enable format on save for the Tact Language extension.
   - Add the following lines inside the JSON object:

     ```json
     {
     	"[tact]": {
     		"editor.formatOnSave": true,
     		"editor.defaultFormatter": "KonVik.tact-lang-vscode"
     	}
     }
     ```

   - This will enable format on save (`"editor.formatOnSave": true`) and set the default formatter for Tact files (`"[tact]": {"editor.defaultFormatter": "KonVik.tact-lang-vscode"}`) to the Tact Language extension.

3. Saving and Closing Settings
   - Save your `settings.json` file after adding these lines (You can press `Ctrl+S` to save).
   - Close the `settings.json` tab or press `Ctrl+W`.

Your Tact Language VS Code extension should now automatically format your files when you save them. If you don't see these changes take effect immediately, you might need to reload VS Code.

## References and Resources

- [Extension on GitHub](https://github.com/tact-lang/tact-vscode)
- [Extension on the VS Code Marketplace](https://marketplace.visualstudio.com/items?itemName=KonVik.tact-lang-vscode)


## core-advanced.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-advanced.mdx)
---
title: Advanced
description: "Advanced, niche or dangerous functions from the Core library of Tact"
---

import { Badge } from '@astrojs/starlight/components';

Various niche, dangerous or unstable features which can produce unexpected results and are meant to be used by the more experienced users.

:::caution

  Proceed with caution.

:::

## gasConsumed

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun gasConsumed(): Int;
```

Returns the [nanoToncoin][nanotoncoin] [`Int{:tact}`][int] amount of [gas][gas] consumed by [TVM][tvm] in the current transaction so far. The resulting value includes the cost of calling this function.

Usage example:

```tact
let gas: Int = gasConsumed();
```

:::note[Useful links:]

  [Gas in TON Docs](https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/fees#gas)

:::

## myStorageDue

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun myStorageDue(): Int;
```

Returns the [nanoToncoin][nanotoncoin] [`Int{:tact}`][int] amount of the accumulated [storage fee][storage-fee] debt. Storage fees are deducted from the incoming message value before the new contract balance is calculated.

Usage example:

```tact
let debt: Int = myStorageDue();
```

:::note[Useful links:]

  [Storage fee in TON Docs][storage-fee]\
  [Storage fee calculation in TON Docs][storage-fee-calc]

:::

## getStorageFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getStorageFee(cells: Int, bits: Int, seconds: Int, isMasterchain: Bool): Int;
```

Calculates and returns the [storage fee][storage-fee] in [nanoToncoins][nanotoncoin] [`Int{:tact}`][int] for storing a contract with a given number of `cells` and `bits` for a number of `seconds`. Uses the prices of the [masterchain][masterchain] if `isMasterchain` is `true{:tact}`, otherwise the prices of the [basechain][basechain]. The current prices are obtained from the [config param 18 of TON Blockchain](https://docs.ton.org/develop/howto/blockchain-configs#param-18).

Note, that the values of `cells` and `bits` are taken modulo their maximum values plus $1$. That is, specifying values higher than those listed in [account state limits (`max_acc_state_cells` and `max_acc_state_bits`)](/book/exit-codes#50) will have the same result as with specifying the exact limits. In addition, make sure you take into account the [deduplication of cells with the same hash][deduplication].

Attempts to specify negative number of `cells`, `bits` or `seconds` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee: Int = getStorageFee(1_000, 1_000, 1_000, false);
//                           -----  -----  -----  -----
//                           ↑      ↑      ↑      ↑
//                           |      |      |      Isn't on the masterchain,
//                           |      |      |      but on the basechain
//                           |      |      Number of seconds to calculate
//                           |      |      the storage fee for
//                           |      Number of bits in a contract
//                           Number of cells in a contract
```

:::note[Useful links:]

  [Storage fee in TON Docs][storage-fee]\
  [Storage fee calculation in TON Docs][storage-fee-calc]

:::

## getComputeFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getComputeFee(gasUsed: Int, isMasterchain: Bool): Int;
```

Calculates and returns the [compute fee][compute-fee] in [nanoToncoins][nanotoncoin] [`Int{:tact}`][int] for a transaction that consumed `gasUsed` amount of [gas][gas]. Uses the prices of the [masterchain][masterchain] if `isMasterchain` is `true{:tact}`, otherwise the prices of the [basechain][basechain]. The current prices are obtained from the [config param 20 for the masterchain and config param 21 for the basechain][param-20-21] of TON Blockchain.

When the `gasUsed` is less than a certain threshold called [`flat_gas_limit`][param-20-21], there's a minimum price to pay based on the value of [`flat_gas_price`][param-20-21]. The less gas is used below this threshold, the higher the minimum price will be. See the example for [`getSimpleComputeFee(){:tact}`](#getsimplecomputefee) to derive that threshold.

Attempts to specify negative value of `gasUsed` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee: Int = getComputeFee(1_000, false);
//                           -----  -----
//                           ↑      ↑
//                           |      Isn't on the masterchain,
//                           |      but on the basechain
//                           Number of gas units
//                           consumed per transaction
```

:::note[Useful links:]

  [Compute fee in TON Docs][compute-fee]\
  [Compute fee calculation in TON Docs][compute-fee-calc]\
  [`getSimpleComputeFee(){:tact}`](#getsimplecomputefee)

:::

## getSimpleComputeFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getSimpleComputeFee(gasUsed: Int, isMasterchain: Bool): Int;
```

Similar to [`getComputeFee(){:tact}`](#getcomputefee), but without the [`flat_gas_price`][param-20-21], i.e. without a minimum price to pay if the `gasUsed` is less than a certain threshold called [`flat_gas_limit`][param-20-21]. Calculates and returns only the `gasUsed` times the current gas price.

Attempts to specify negative value of `gasUsed` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee = getComputeFee(0, false);
let feeNoFlat = getSimpleComputeFee(0, false);
let maxFlatPrice = fee - feeNoFlat;
```

:::note[Useful links:]

  [Compute fee in TON Docs][compute-fee]\
  [Compute fee calculation in TON Docs][compute-fee-calc]\
  [`getComputeFee(){:tact}`](#getcomputefee)

:::

## Context.readForwardFee

```tact
extends fun readForwardFee(self: Context): Int;
```

Extension function for the [`Context{:tact}`](/ref/core-common#context).

Reads [forward fee](https://docs.ton.org/develop/smart-contracts/guidelines/processing) and returns it as [`Int{:tact}`][int] amount of [nanoToncoins][nanotoncoin].

Usage example:

```tact
let fwdFee: Int = context().readForwardFee();
```

:::note[Useful links:]

  [`getOriginalFwdFee(){:tact}`](#getoriginalfwdfee)

:::

## getForwardFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getForwardFee(cells: Int, bits: Int, isMasterchain: Bool): Int;
```

Calculates and returns the [forward fee][forward-fee] in [nanoToncoins][nanotoncoin] [`Int{:tact}`][int] for an outgoing message consisting of a given number of `cells` and `bits`. Uses the prices of the [masterchain][masterchain] if `isMasterchain` is `true{:tact}`, otherwise the prices of the [basechain][basechain]. The current prices are obtained from the [config param 24 for the masterchain and config param 25 for the basechain][param-24-25] of TON Blockchain.

If both the source and the destination addresses are in the [basechain][basechain], then specify `isMasterchain` as `false{:tact}`. Otherwise, specify `true{:tact}`.

Note, that the values of `cells` and `bits` are taken modulo their maximum values plus $1$. That is, specifying values higher than those listed in [account state limits (`max_msg_cells` and `max_msg_bits`)](/book/exit-codes#50) will have the same result as with specifying the exact limits.

However, regardless of the values of `cells` and `bits`, this function always adds the minimum price based on the value of [`lump_price`][param-24-25]. See the example for [`getSimpleForwardFee(){:tact}`](#getsimpleforwardfee) to derive it. In addition, make sure you take into account the [deduplication of cells with the same hash][deduplication], since for example the root cell and its data bits don't count towards the forward fee and are covered by the [`lump_price`][param-24-25].

Attempts to specify negative number of `cells` or `bits` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee: Int = getForwardFee(1_000, 1_000, false);
//                           -----  -----  -----
//                           ↑      ↑      ↑
//                           |      |      Both source and destination
//                           |      |      isn't on the masterchain,
//                           |      |      but on the basechain
//                           |      Number of bits in a message
//                           Number of cells in a message
```

:::note[Useful links:]

  [Forward fee in TON Docs][forward-fee]\
  [Forward fee calculation in TON Docs][forward-fee-calc]\
  [`CDATASIZEQ` instruction for computing the number of distinct cells, data bits and refs in a `Cell{:tact}`](https://docs.ton.org/v3/documentation/tvm/instructions#F940)\
  [`getSimpleForwardFee(){:tact}`](#getsimpleforwardfee)\
  [`getOriginalFwdFee(){:tact}`](#getoriginalfwdfee)

:::

## getSimpleForwardFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getSimpleForwardFee(cells: Int, bits: Int, isMasterchain: Bool): Int;
```

Similar to [`getForwardFee(){:tact}`](#getforwardfee), but without the [`lump_price`][param-24-25], i.e. without the minimum price to pay regardless of the amount of `cells` or `bits`. Calculates and returns only the `cells` times the current cell price plus `bits` times the current bit price.

Attempts to specify negative number of `cells` or `bits` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fee = getForwardFee(1_000, 1_000, false);
let feeNoLump = getSimpleForwardFee(1_000, 1_000, false);
let lumpPrice = fee - feeNoLump;
```

:::note[Useful links:]

  [Forward fee in TON Docs][forward-fee]\
  [Forward fee calculation in TON Docs][forward-fee-calc]\
  [`getForwardFee(){:tact}`](#getforwardfee)

:::

## getOriginalFwdFee

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun getOriginalFwdFee(fwdFee: Int, isMasterchain: Bool): Int;
```

Calculates and returns the so-called _original_ [forward fee][forward-fee] in [nanoToncoins][nanotoncoin] [`Int{:tact}`][int] for an outgoing message based on the `fwdFee` obtained from the incoming message. If both the source and the destination addresses are in the [basechain][basechain], then specify `isMasterchain` as `false{:tact}`. Otherwise, specify `true{:tact}`.

This function is useful when the outgoing message depends heavily on the structure of the incoming message, so much so that you cannot fully predict the fee using [`getForwardFee(){:tact}`](#getforwardfee) alone. Even if you could, calculating the exact fee with [nanoToncoin][nanotoncoin]-level precision can be very expensive, so the approximation given by this function is often good enough.

Attempts to specify a negative value of `fwdFee` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let fwdFee: Int = context().readForwardFee();
let origFee: Int = getOriginalFwdFee(fee, false);
```

:::note[Useful links:]

  [Forward fee in TON Docs][forward-fee]\
  [Forward fee calculation in TON Docs][forward-fee-calc]\
  [`getForwardFee(){:tact}`](#getforwardfee)\
  [`Context.readForwardFee(){:tact}`](#contextreadforwardfee)

:::

## getConfigParam

```tact
fun getConfigParam(id: Int): Cell?;
```

Loads a [configuration parameter](https://docs.ton.org/develop/howto/blockchain-configs) of TON Blockchain by its `id` number.

Usage examples:

```tact
// Parameter 0, address of a special smart contract that stores the blockchain's configuration
let configAddrAsCell: Cell = getConfigParam(0)!!;

// Parameter 18, configuration for determining the prices for data storage
let dataStorageFeeConfig: Cell = getConfigParam(18)!!;
```

:::note

  Standard library [`@stdlib/config`](/ref/stdlib-config) provides two related helper functions:\
  [`getConfigAddress(){:tact}`](/ref/stdlib-config#getconfigaddress) for retrieving config [`Address{:tact}`][p]\
  [`getElectorAddress(){:tact}`](/ref/stdlib-config#getconfigaddress) for retrieving elector [`Address{:tact}`][p]

  Read more about other parameters: [Config Parameters in TON Docs](https://docs.ton.org/develop/howto/blockchain-configs).

:::

## acceptMessage

```tact
fun acceptMessage();
```

Agrees to buy some gas to finish the current transaction. This action is required to process external messages, which bring no value (hence no gas) with themselves.

Usage example:

```tact {10}
contract Timeout {
    timeout: Int;

    init() {
        self.timeout = now() + 5 * 60; // 5 minutes from now
    }

    external("timeout") {
        if (now() > self.timeout) {
            acceptMessage(); // start accepting external messages once timeout went out
        }
    }
}
```

:::note

  For more details, see: [Accept Message Effects in TON Docs](https://docs.ton.org/develop/smart-contracts/guidelines/accept).

:::

## commit

```tact
fun commit();
```

Commits the current state of [registers](https://docs.ton.org/learn/tvm-instructions/tvm-overview#control-registers) `c4` ("persistent data") and `c5` ("actions"), so that the current execution is considered "successful" with the saved values even if an exception in compute phase is thrown later.

Usage example:

```tact {1}
commit();  // now, transaction is considered "successful"
throw(42); // and this won't fail it
```

## nativePrepareRandom

```tact
fun nativePrepareRandom();
```

Prepares a random number generator by using [`nativeRandomizeLt(){:tact}`](#nativerandomizelt). Automatically called by [`randomInt(){:tact}`](/ref/core-random#randomint) and [`random(){:tact}`](/ref/core-random#random) functions.

Usage example:

```tact
nativePrepareRandom(); // prepare the RNG
// ... do your random things ...
```

## nativeRandomize

```tact
fun nativeRandomize(x: Int);
```

Randomizes the pseudo-random number generator with the specified seed `x`.

Usage example:

```tact
nativeRandomize();          // now, random numbers are less predictable
let idk: Int = randomInt(); // ???, it's random!
```

## nativeRandomizeLt

```tact
fun nativeRandomizeLt();
```

Randomizes the random number generator with the current [logical time](https://docs.ton.org/develop/smart-contracts/guidelines/message-delivery-guarantees#what-is-a-logical-time).

Usage example:

```tact
nativeRandomizeLt();        // now, random numbers are unpredictable for users,
                            // but still may be affected by validators or collators
                            // as they determine the seed of the current block.
let idk: Int = randomInt(); // ???, it's random!
```

## nativeRandom

```tact
fun nativeRandom(): Int;
```

Generates and returns an $256$-bit random number just like [`randomInt(){:tact}`](/ref/core-random#randomint), but doesn't initialize the random generator with [`nativePrepareRandom(){:tact}`](#nativepreparerandom) beforehand.

:::note

  Don't use this function directly, and prefer using [`randomInt(){:tact}`](/ref/core-random#randomint) instead.

:::

## nativeRandomInterval

```tact
fun nativeRandomInterval(max: Int): Int;
```

Generates and returns a $256$-bit random number in the range from $0$ to `max` similar to [`random(){:tact}`](/ref/core-random#random), but doesn't initialize the random generator with [`nativePrepareRandom(){:tact}`](#nativepreparerandom) beforehand.

:::note

  Don't use this function directly, and prefer using [`random(){:tact}`](/ref/core-random#random) instead.

:::

## nativeSendMessage

```tact
fun nativeSendMessage(cell: Cell, mode: Int);
```

[Queues the message](/book/send#outbound-message-processing) to be sent by specifying the complete `cell` and the [message `mode`](/book/message-mode).

:::note

  Prefer using a much more common and user-friendly [`send(){:tact}`](/ref/core-common#send) function unless you have a complex logic that can't be expressed otherwise.

:::

## nativeReserve

```tact
fun nativeReserve(amount: Int, mode: Int);
```

Calls native `raw_reserve` function with specified amount and mode. The `raw_reserve` is a function that creates an output action to reserve a specific amount of [nanoToncoins][nanotoncoin] from the remaining balance of the account.

It has the following signature in FunC:

```func
raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
```

The function takes two arguments:
* `amount`: The number of [nanoToncoins][nanotoncoin] to reserve.
* `mode`: Determines the reservation behavior.

Function `raw_reserve` is roughly equivalent to creating an outbound message carrying the specified `amount` of [nanoToncoins][nanotoncoin] (or `b` $-$ `amount` [nanoToncoins][nanotoncoin], where `b` is the remaining balance) to oneself. This ensures that subsequent output actions cannot spend more money than the remainder.

It's possible to use raw [`Int{:tact}`][int] values and manually provide them for the `mode`, but for your convenience there's a set of constants which you may use to construct the compound `mode` with ease. Take a look at the following tables for more information on base modes and optional flags.

:::caution

  Currently, `amount` must be a non-negative integer, and `mode` must be in the range $0..31$, inclusive.

:::

### Base modes {#nativereserve-base-modes}

The resulting `mode` value can have the following base modes:

Mode value | Constant name                 | Description
---------: | :---------------------------- | -----------
$0$        | `ReserveExact{:tact}`         | Reserves exactly the specified `amount` of [nanoToncoins][nanotoncoin].
$1$        | `ReserveAllExcept{:tact}`     | Reserves all, but the specified `amount` of [nanoToncoins][nanotoncoin].
$2$        | `ReserveAtMost{:tact}`        | Reserves at most the specified `amount` of [nanoToncoins][nanotoncoin].

### Optional flags {#nativereserve-optional-flags}

Additionally, the resulting `mode` can have the following optional flags added:

Flag value | Constant name                      | Description
---------: | :--------------------------------- | -----------
$+4$       | `ReserveAddOriginalBalance{:tact}` | Increases the `amount` by the original balance of the current account (before the compute phase), including all extra currencies.
$+8$       | `ReserveInvertSign{:tact}`         | Negates the `amount` value before performing the reservation.
$+16$      | `ReserveBounceIfActionFail{:tact}` | Bounces the transaction if reservation fails.

### Combining modes with flags {#nativereserve-combining-modes-with-flags}

To make the [`Int{:tact}`][int] value for `mode` parameter, you just have to combine base modes with optional flags by applying the [bitwise OR](/book/operators#binary-bitwise-or) operation:

```tact
nativeReserve(ton("0.1"), ReserveExact | ReserveBounceIfActionFail);
//            ----------  ----------------------------------------
//            ↑           ↑
//            |           mode, which would bounce the transaction if exact reservation would fail
//            amount of nanoToncoins to reserve
```

## parseStdAddress

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun parseStdAddress(slice: Slice): StdAddress;
```

Converts a [`Slice{:tact}`][slice] containing an address into the `StdAddress{:tact}` [Struct][s] and returns it. The `StdAddress{:tact}` is a built-in [Struct][s] that consists of:

Field       | Type                           | Description
:---------- | :----------------------------- | :----------
`workchain` | [`Int as int8{:tact}`][int]    | Workchain ID of the address, usually $0$ (basechain) or $-1$ (masterchain)
`address`   | [`Int as uint256{:tact}`][int] | Address in the specified `workchain`

Attempts to pass a [`Slice{:tact}`][slice] with layout different from the `StdAddress{:tact}` or to load more data than a given [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let addr = address("EQDtFpEwcFAEcRe5mLVh2N6C0x-_hJEM7W61_JLnSF74p4q2");
let parsedAddr = parseStdAddress(addr.asSlice());

parsedAddr.workchain; // 0
parsedAddr.address;   // 107...lots of digits...287

// Using newAddress() function with the contents of StdAddress will yield the initial Address:
let addr2: Address = newAddress(parsedAddr.workchain, parsedAddr.address);
addr2 == addr; // true
```

:::note

  For parsing addresses of variable length, see the [`parseVarAddress(){:tact}`](#parsevaraddress) function.

:::

## parseVarAddress

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun parseVarAddress(slice: Slice): VarAddress;
```

Converts a [`Slice{:tact}`][slice] containing an address of variable length into the `VarAddress{:tact}` [Struct][s] and returns it. The `VarAddress{:tact}` is a built-in [Struct][s] consisting of:

Field       | Type                         | Description
:---------- | :--------------------------- | :----------
`workchain` | [`Int as int32{:tact}`][int] | Workchain ID of the variable length address
`address`   | [`Slice{:tact}`][slice]      | Address in the specified `workchain`

Attempts to pass a [`Slice{:tact}`][slice] with layout different from the `VarAddress{:tact}` or to load more data than a given [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let varAddrSlice = beginCell()
    .storeUint(6, 3)     // to recognize the following as a VarAddress
    .storeUint(123, 9)   // make address occupy 123 bits
    .storeUint(234, 32)  // specify workchain ID of 234
    .storeUint(345, 123) // specify address of 345
    .asSlice();
let parsedVarAddr = parseVarAddress(varAddrSlice);

parsedVarAddr.workchain;             // 234
parsedVarAddr.address;               // CS{Cell{002...2b3} bits: 44..167; refs: 0..0}
parsedVarAddr.address.loadUint(123); // 345
```

:::caution

  Variable-length addresses are intended for future extensions, and while validators must be ready to accept them in inbound messages, the standard (non-variable) addresses are used whenever possible.

:::

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[slice]: /book/cells#slices
[s]: /book/structs-and-messages#structs
[masterchain]: https://docs.ton.org/v3/documentation/smart-contracts/shards/shards-intro#masterchain
[cell-hash]: /ref/core-cell#cellhash
[nanotoncoin]: /book/integers#nanotoncoin

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[basechain]: https://docs.ton.org/v3/concepts/ton-blockchain/smart-contract-addresses#address-components
[deduplication]: https://docs.ton.org/v3/documentation/data-formats/tlb/library-cells

[storage-fee]: https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/fees-low-level#storage-fee
[storage-fee-calc]: https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation#storage-fee

[gas]: https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/fees#gas
[compute-fee]: https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/fees-low-level#computation-fees
[compute-fee-calc]: https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation#computation-fee
[param-20-21]: https://docs.ton.org/v3/documentation/network/configs/blockchain-configs#param-20-and-21

[forward-fee]: https://docs.ton.org/v3/documentation/smart-contracts/transaction-fees/forward-fees
[forward-fee-calc]: https://docs.ton.org/v3/guidelines/smart-contracts/fee-calculation#forward-fee
[param-24-25]: https://docs.ton.org/v3/documentation/network/configs/blockchain-configs#param-24-and-25


## core-base.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-base.mdx)
---
title: Base trait
description: "Every contract and trait in Tact implicitly inherits the BaseTrait trait"
prev:
  link: /ref/evolution/otp-006
  label: "OTP-006: Contract Package"
---

Every [contract](/book/contracts) and [trait](/book/types#traits) in Tact implicitly [inherits](/book/contracts#traits) the `BaseTrait{:tact}` trait, which contains a number of the most useful [internal functions](/book/contracts#internal-functions) for any kind of contract, and a constant `self.storageReserve{:tact}` aimed at advanced users of Tact.

## Constants

### self.storageReserve {#self-storagereserve}

```tact
virtual const storageReserve: Int = 0;
```

Usage example:

```tact
contract AllYourStorageBelongsToUs {
    // This would change the behavior of self.forward() function,
    // causing it to try reserving this amount of nanoToncoins before
    // forwarding a message with SendRemainingBalance mode
    override const storageReserve: Int = ton("0.1");
}
```

## Functions

### self.reply {#self-reply}

```tact
virtual fun reply(body: Cell?);
```

An alias to calling the [`self.forward(){:tact}`](#self-forward) function with the following arguments:

```tact
self.forward(sender(), body, true, null);
//           ↑         ↑     ↑     ↑
//           |         |     |     init: StateInit?
//           |         |     bounce: Bool
//           |         body: Cell?
//           to: Address
```

Usage example:

```tact
// This message can bounce back to us!
self.reply("Beware, this is my reply to you!".asComment());
```

### self.notify {#self-notify}

```tact
virtual fun notify(body: Cell?);
```

An alias to calling the [`self.forward(){:tact}`](#self-forward) function with the following arguments:

```tact
self.forward(sender(), body, false, null);
//           ↑         ↑     ↑      ↑
//           |         |     |      init: StateInit?
//           |         |     bounce: Bool
//           |         body: Cell?
//           to: Address
```

Usage example:

```tact
// This message won't bounce!
self.notify("Beware, this is my reply to you!".asComment());
```

### self.forward {#self-forward}

```tact
virtual fun forward(to: Address, body: Cell?, bounce: Bool, init: StateInit?);
```

[Queues the message](/book/send#outbound-message-processing) (bounceable or non-bounceable) to be sent to the specified address `to`. Optionally, you may provide a `body` of the message and the [`init` package](/book/expressions#initof).

When [`self.storageReserve{:tact}`](#self-storagereserve) constant is overwritten to be $> 0$, before sending a message it also tries to reserve the `self.storageReserve{:tact}` amount of [nanoToncoins][nano] from the remaining balance before making the send in the [`SendRemainingBalance{:tact}`](https://docs.tact-lang.org/book/message-mode#base-modes) ($128$) mode.

In case reservation attempt fails and in the default case without the attempt, the message is sent with the [`SendRemainingValue{:tact}`](https://docs.tact-lang.org/book/message-mode#base-modes) ($64$) mode instead.

:::note

  Note, that `self.forward(){:tact}` never sends additional [nanoToncoins][nano] on top of what's available on the balance.\
  To be able to send more [nanoToncoins][nano] with a single message, use the the [`send(){:tact}`](/ref/core-common#send) function.

:::

Usage example:

```tact
import "@stdlib/ownable";

message PayoutOk {
    address: Address;
    value: Int as coins;
}

contract Payout with Ownable {
    completed: Bool;
    owner: Address;

    init(owner: Address) {
        self.owner = owner;
        self.completed = false;
    }

    // ... some actions there ...

    // Bounced receiver function, which is called when the specified outgoing message bounces back
    bounced(msg: bounced<PayoutOk>) {
        // Reset completed flag if our message bounced
        self.completed = false;

        // Send a notification that the payout failed using the remaining funds for processing this send
        self.forward(self.owner, "Payout failed".asComment(), false, null);
    }
}
```

[nano]: /book/integers#nanotoncoin


## core-cells.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-cells.mdx)
---
title: Cells, Builders and Slices
description: "Various Cell, Builder and Slice functions from the Core library of Tact"
---

import { Badge } from '@astrojs/starlight/components';

[`Cell{:tact}`][cell] is a low-level [primitive][p] that represents data in TON Blockchain. Cells consist of $1023$ bits of data with up to $4$ references to another cells. They are read-only and immutable, and cannot have cyclic references.

[`Builder{:tact}`][builder] is an immutable [primitive][p] to construct cells, and [`Slice{:tact}`][slice] is a mutable [primitive][p] to parse them.

:::note

  Be very careful when constructing and parsing cells manually, and always make sure to document their desired layout: a strict order of values and types for serialization and deserialization.

  To do so, advanced users are recommended to use [Type Language - Binary (TL-B) schemas][tlb].

  And every user is recommended to use [Structs][struct] and their [methods](/book/functions#extension-function) like [`Struct.toCell(){:tact}`](#structtocell) and [`Struct.fromCell(){:tact}`](#structfromcell) instead of manually constructing and parsing cells, because [Structs][struct] and [Messages][message] are closest to being the [living TL-B schemas of your contracts](/book/cells#cnp-structs).

:::

## beginCell

```tact
fun beginCell(): Builder;
```

Creates a new empty [`Builder{:tact}`][builder].

Usage example:

```tact
let fizz: Builder = beginCell();
```

## emptyCell

```tact
fun emptyCell(): Cell;
```

Creates and returns an empty [`Cell{:tact}`][cell] (without data and references). Alias to `beginCell().endCell(){:tact}`.

Usage example:

```tact
let fizz: Cell = emptyCell();
let buzz: Cell = beginCell().endCell();

fizz == buzz; // true
```

## emptySlice

```tact
fun emptySlice(): Slice;
```

Creates and returns an empty [`Slice{:tact}`][slice] (without data and references). Alias to `emptyCell().asSlice(){:tact}`.

Usage example:

```tact
let fizz: Slice = emptySlice();
let buzz: Slice = emptyCell().asSlice();

fizz == buzz; // true
```

## Cell.beginParse

```tact
extends fun beginParse(self: Cell): Slice;
```

Extension function for the [`Cell{:tact}`][cell].

Opens the [`Cell{:tact}`][cell] for parsing and returns it as a [`Slice{:tact}`][slice].

Usage example:

```tact
let c: Cell = emptyCell();
let fizz: Slice = c.beginParse();
```

## Cell.hash

```tact
extends fun hash(self: Cell): Int;
```

Extension function for the [`Cell{:tact}`][cell].

Calculates and returns an [`Int{:tact}`][int] value of the [SHA-256][sha-2] hash of the [standard `Cell{:tact}` representation][std-repr] of the given [`Cell{:tact}`][cell].

Usage example:

```tact
let c: Cell = emptyCell();
let fizz: Int = c.hash();
```

## Cell.asSlice

```tact
extends fun asSlice(self: Cell): Slice;
```

Extension function for the [`Cell{:tact}`][cell].

Converts the Cell to a [`Slice{:tact}`][slice] and returns it. Alias to `self.beginParse(){:tact}`.

Usage example:

```tact
let c: Cell = emptyCell();
let fizz: Slice = c.asSlice();
```

## Builder.endCell

```tact
extends fun endCell(self: Builder): Cell;
```

Extension function for the [`Builder{:tact}`][builder].

Converts a [`Builder{:tact}`][builder] into an ordinary [`Cell{:tact}`][cell].

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Cell = b.endCell();
```

## Builder.storeUint

```tact
extends fun storeUint(self: Builder, value: Int, bits: Int): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

Stores an unsigned `bits`-bit `value` into the copy of the [`Builder{:tact}`][builder] for $0 ≤$ `bits` $≤ 256$. Returns that copy.

Attempts to store a negative `value` or provide an insufficient or out-of-bounds `bits` number throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeUint(42, 6);
```

## Builder.storeInt

```tact
extends fun storeInt(self: Builder, value: Int, bits: Int): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

Stores a signed `bits`-bit `value` into the copy of the [`Builder{:tact}`][builder] for $0 ≤$ `bits` $≤ 257$. Returns that copy.

Attempts to provide an insufficient or out-of-bounds `bits` number throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeInt(42, 7);
```

## Builder.storeBool

```tact
extends fun storeBool(self: Builder, value: Bool): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

Stores a [`Bool{:tact}`][bool] `value` into the copy of the [`Builder{:tact}`][builder]. Writes $1$ as a single bit if `value` is `true{:tact}`, and writes $0$ otherwise. Returns that copy of the [`Builder{:tact}`][builder].

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeBool(true);  // writes 1
let buzz: Builder = b.storeBool(false); // writes 0
```

## Builder.storeBit

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends fun storeBit(self: Builder, value: Bool): Builder;
```

Extension function for the [`Builder{:tact}`][builder]. Alias to [`Builder.storeBool(){:tact}`](#builderstorebool).

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeBit(true);  // writes 1
let buzz: Builder = b.storeBit(false); // writes 0
```

## Builder.storeBuilder

```tact
extends fun storeBuilder(self: Builder, cell: Builder): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

Appends all data from a [`Builder{:tact}`][builder] `cell` to the copy of the [`Builder{:tact}`][builder]. Returns that copy.

Usage example:

```tact
let b: Builder = beginCell().storeCoins(42);
let fizz: Builder = beginCell().storeBuilder(b);
b.endCell() == fizz.endCell(); // true
```

## Builder.storeSlice

```tact
extends fun storeSlice(self: Builder, cell: Slice): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

Stores a [`Slice{:tact}`][slice] `cell` into the copy of the [`Builder{:tact}`][builder]. Returns that copy.

Usage example:

```tact
let b: Builder = beginCell();
let s: Slice = emptyCell().asSlice();
let fizz: Builder = b.storeSlice(s);
```

## Builder.storeCoins

```tact
extends fun storeCoins(self: Builder, value: Int): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

Stores (serializes) an unsigned [`Int{:tact}`][int] `value` in the range $0 .. 2^{120} − 1$ into the copy of the [`Builder{:tact}`][builder]. The serialization of `value` consists of a $4$-bit unsigned big-endian integer $l$, which is the smallest integer $l ≥ 0$, such that `value` $< 2^{8 * l}$, followed by an $8 * l$-bit unsigned big-endian representation of `value`. Returns that copy of the [`Builder{:tact}`][builder].

Attempts to store an out-of-bounds `value` throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

This is the most common way of storing [nanoToncoins](/book/integers#nanotoncoin).

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeCoins(42);
```

:::note[Useful links:]

  [Special `coins` serialization type](/book/integers#serialization-coins)

:::

## Builder.storeAddress

```tact
extends fun storeAddress(self: Builder, address: Address): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

Stores the `address` in the copy of the [`Builder{:tact}`][builder]. Returns that copy.

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeAddress(myAddress());
```

## Builder.storeRef

```tact
extends fun storeRef(self: Builder, cell: Cell): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

Stores a reference `cell` into the copy of the [`Builder{:tact}`][builder]. Returns that copy.

As a single [`Cell{:tact}`][cell] can store up to $4$ references, attempts to store more throw an exception with [exit code 8](/book/exit-codes#8): `Cell overflow`.

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Builder = b.storeRef(emptyCell());
```

## Builder.storeMaybeRef

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends fun storeMaybeRef(self: Builder, cell: Cell?): Builder;
```

Extension function for the [`Builder{:tact}`][builder].

If the `cell` is not `null{:tact}`, stores $1$ as a single bit and then reference `cell` into the copy of the [`Builder{:tact}`][builder]. Returns that copy.

If the `cell` is `null{:tact}`, only stores $0$ as a single bit into the copy of the [`Builder{:tact}`][builder]. Returns that copy.

As a single [`Cell{:tact}`][cell] can store up to $4$ references, attempts to store more throw an exception with [exit code 8](/book/exit-codes#8): `Cell overflow`.

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Builder = b
    .storeMaybeRef(emptyCell()) // stores a single 1 bit, then an empty cell
    .storeMaybeRef(null);       // stores only a single 0 bit
```

## Builder.refs

```tact
extends fun refs(self: Builder): Int;
```

Extension function for the [`Builder{:tact}`][builder].

Returns the number of cell references already stored in the [`Builder{:tact}`][builder] as an [`Int{:tact}`][int].

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Int = b.refs(); // 0
```

## Builder.bits

```tact
extends fun bits(self: Builder): Int;
```

Extension function for the [`Builder{:tact}`][builder].

Returns the number of data bits already stored in the [`Builder{:tact}`][builder] as an [`Int{:tact}`][int].

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Int = b.bits(); // 0
```

## Builder.asSlice

```tact
extends fun asSlice(self: Builder): Slice;
```

Extension function for the [`Builder{:tact}`][builder].

Converts the [`Builder{:tact}`][builder] to a [`Slice{:tact}`][slice] and returns it. Alias to `self.endCell().beginParse(){:tact}`.

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Slice = b.asSlice();
```

## Builder.asCell

```tact
extends fun asCell(self: Builder): Cell;
```

Extension function for the [`Builder{:tact}`][builder].

Converts the [`Builder{:tact}`][builder] to a [`Cell{:tact}`][cell] and returns it. Alias to `self.endCell(){:tact}`.

Usage example:

```tact
let b: Builder = beginCell();
let fizz: Cell = b.asCell();
```

## Slice.loadUint

```tact
extends mutates fun loadUint(self: Slice, l: Int): Int;
```

Extension mutation function for the [`Slice{:tact}`][slice].

Loads and returns an unsigned `l`-bit [`Int{:tact}`][int] from the [`Slice{:tact}`][slice] for $0 ≤$ `l` $≤ 256$.

Attempts to specify an out-of-bounds `l` value throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Attempts to load more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeUint(42, 7).asSlice();
let fizz: Int = s.loadUint(7);
```

## Slice.preloadUint

```tact
extends fun preloadUint(self: Slice, l: Int): Int;
```

Extension function for the [`Slice{:tact}`][slice].

Preloads and returns an unsigned `l`-bit [`Int{:tact}`][int] from the [`Slice{:tact}`][slice] for $0 ≤$ `l` $≤ 256$. Doesn't modify the [`Slice{:tact}`][slice].

Attempts to specify an out-of-bounds `l` value throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Attempts to preload more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeUint(42, 7).asSlice();
let fizz: Int = s.preloadUint(7);
```

## Slice.loadInt

```tact
extends mutates fun loadInt(self: Slice, l: Int): Int;
```

Extension mutation function for the [`Slice{:tact}`][slice].

Loads and returns a signed `l`-bit [`Int{:tact}`][int] from the [`Slice{:tact}`][slice] for $0 ≤$ `l` $≤ 257$.

Attempts to specify an out-of-bounds `l` value throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Attempts to load more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
let fizz: Int = s.loadInt(7);
```

## Slice.preloadInt

```tact
extends fun preloadInt(self: Slice, l: Int): Int;
```

Extension function for the [`Slice{:tact}`][slice].

Preloads and returns a signed `l`-bit [`Int{:tact}`][int] from the [`Slice{:tact}`][slice] for $0 ≤$ `l` $≤ 257$. Doesn't modify the [`Slice{:tact}`][slice].

Attempts to specify an out-of-bounds `l` value throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Attempts to preload more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
let fizz: Int = s.preloadInt(7);
```

## Slice.loadBits

```tact
extends mutates fun loadBits(self: Slice, l: Int): Slice;
```

Extension mutation function for the [`Slice{:tact}`][slice].

Loads $0 ≤$ `l` $≤ 1023$ bits from the [`Slice{:tact}`][slice], and returns them as a separate [`Slice{:tact}`][slice].

Attempts to specify an out-of-bounds `l` value throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Attempts to load more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
let fizz: Slice = s.loadBits(7);
```

## Slice.preloadBits

```tact
extends fun preloadBits(self: Slice, l: Int): Slice;
```

Extension function for the [`Slice{:tact}`][slice].

Preloads $0 ≤$ `l` $≤ 1023$ bits from the [`Slice{:tact}`][slice], and returns them as a separate [`Slice{:tact}`][slice]. Doesn't modify the original [`Slice{:tact}`][slice].

Attempts to specify an out-of-bounds `l` value throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Attempts to preload more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
let fizz: Slice = s.preloadBits(7);
```

## Slice.skipBits

```tact
extends mutates fun skipBits(self: Slice, l: Int);
```

Extension mutation function for the [`Slice{:tact}`][slice].

Loads all but the first $0 ≤$ `l` $≤ 1023$ bits from the [`Slice{:tact}`][slice].

Attempts to specify an out-of-bounds `l` value throw an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Attempts to load more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeInt(42, 7).asSlice();
s.skipBits(5);                   // all but first 5 bits
let fizz: Slice = s.loadBits(1); // load only 1 bit
```

## Slice.loadBool

```tact
extends mutates fun loadBool(self: Slice): Bool;
```

Extension mutation function for the [`Slice{:tact}`][slice].

Loads a single bit and returns a [`Bool{:tact}`][bool] value from the [`Slice{:tact}`][slice]. Reads `true{:tact}` if the loaded bit is equal to $1$, and reads `false{:tact}` otherwise.

Attempts to load such [`Bool{:tact}`][bool] when [`Slice{:tact}`][slice] doesn't contain it throw an exception with [exit code 8](/book/exit-codes#8): `Cell overflow`.

Attempts to load more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeBool(true).asSlice();
let fizz: Bool = s.loadBool(); // true
```

## Slice.loadBit

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends mutates fun loadBit(self: Slice): Bool;
```

Extension mutation function for the [`Slice{:tact}`][slice]. Alias to [`Slice.loadBool(){:tact}`](#sliceloadbool).

Usage example:

```tact
let s: Slice = beginCell().storeBit(true).asSlice();
let fizz: Bool = s.loadBit(); // true
```

## Slice.loadCoins

```tact
extends mutates fun loadCoins(self: Slice): Int;
```

Extension mutation function for the [`Slice{:tact}`][slice].

Loads and returns [serialized](#builderstorecoins) an unsigned [`Int{:tact}`][int] value in the range $0 .. 2^{120} - 1$ from the [`Slice{:tact}`][slice]. This value usually represents the amount in [nanoToncoins](/book/integers#nanotoncoin).

Attempts to load such [`Int{:tact}`][int] when [`Slice{:tact}`][slice] doesn't contain it throw an exception with [exit code 8](/book/exit-codes#8): `Cell overflow`.

Attempts to load more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeCoins(42).asSlice();
let fizz: Int = s.loadCoins();
```

:::note[Useful links:]

  [Special `coins` serialization type](/book/integers#serialization-coins)

:::

## Slice.loadAddress

```tact
extends mutates fun loadAddress(self: Slice): Address;
```

Extension mutation function for the [`Slice{:tact}`][slice].

Loads and returns an [`Address{:tact}`][p] from the [`Slice{:tact}`][slice].

Attempts to load such [`Address{:tact}`][p] when [`Slice{:tact}`][slice] doesn't contain it throw an exception with [exit code 8](/book/exit-codes#8): `Cell overflow`.

Attempts to load more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage example:

```tact
let s: Slice = beginCell().storeAddress(myAddress()).asSlice();
let fizz: Address = s.loadAddress();
```

## Slice.loadRef

```tact
extends mutates fun loadRef(self: Slice): Cell;
```

Extension mutation function for the [`Slice{:tact}`][slice].

Loads the next reference from the [`Slice{:tact}`][slice] as a [`Cell{:tact}`][cell].

Attempts to load such reference [`Cell{:tact}`][cell] when [`Slice{:tact}`][slice] doesn't contain it throw an exception with [exit code 8](/book/exit-codes#8): `Cell overflow`.

Attempts to load more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage examples:

```tact
let s1: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Cell = s1.loadRef();

let s2: Slice = beginCell()
    .storeRef(emptyCell())
    .storeRef(s1.asCell())
    .asSlice();
let ref1: Cell = s2.loadRef();
let ref2: Cell = s2.loadRef();
ref1 == ref2; // false
```

## Slice.preloadRef

```tact
extends fun preloadRef(self: Slice): Cell;
```

Extension function for the [`Slice{:tact}`][slice].

Preloads the next reference from the [`Slice{:tact}`][slice] as a [`Cell{:tact}`][cell]. Doesn't modify the original [`Slice{:tact}`][slice].

Attempts to preload such reference [`Cell{:tact}`][cell] when [`Slice{:tact}`][slice] doesn't contain it throw an exception with [exit code 8](/book/exit-codes#8): `Cell overflow`.

Attempts to preload more data than [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage examples:

```tact
let s1: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Cell = s1.preloadRef(); // didn't modify s1

let s2: Slice = beginCell()
    .storeRef(emptyCell())
    .storeRef(s1.asCell())
    .asSlice();
let ref1: Cell = s2.preloadRef();
let ref2: Cell = s2.preloadRef();
ref1 == ref2; // true
```

## Slice.refs

```tact
extends fun refs(self: Slice): Int;
```

Extension function for the [`Slice{:tact}`][slice].

Returns the number of references in the [`Slice{:tact}`][slice] as an [`Int{:tact}`][int].

Usage example:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Int = s.refs();
```

## Slice.bits

```tact
extends fun bits(self: Slice): Int;
```

Extension function for the [`Slice{:tact}`][slice].

Returns the number of data bits in the [`Slice{:tact}`][slice] as an [`Int{:tact}`][int].

Usage example:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Int = s.bits();
```

## Slice.empty

```tact
extends fun empty(self: Slice): Bool;
```

Extension function for the [`Slice{:tact}`][slice].

Checks whether the [`Slice{:tact}`][slice] is empty (i.e., contains no bits of data and no cell references). Returns `true{:tact}` if it's empty, `false{:tact}` otherwise.

Usage example:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Bool = s.empty();                     // false
let buzz: Bool = beginCell().asSlice().empty(); // true
```

:::note

  Unlike [`Slice.endParse(){:tact}`](#sliceendparse), this function doesn't throw any exceptions even when the [`Slice{:tact}`][slice] is empty.

:::

## Slice.dataEmpty

```tact
extends fun dataEmpty(slice: Slice): Bool;
```

Extension function for the [`Slice{:tact}`][slice].

Checks whether the [`Slice{:tact}`][slice] has no bits of data. Returns `true{:tact}` if it has no data, `false{:tact}` otherwise.

Usage example:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Bool = s.dataEmpty();  // true

let s2: Slice = beginCell().storeInt(42, 7).asSlice();
let buzz: Bool = s2.dataEmpty(); // false
```

## Slice.refsEmpty

```tact
extends fun refsEmpty(slice: Slice): Bool;
```

Extension function for the [`Slice{:tact}`][slice].

Checks whether the [`Slice{:tact}`][slice] has no references. Returns `true{:tact}` if it has no references, `false{:tact}` otherwise.

Usage example:

```tact
let s: Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz: Bool = s.refsEmpty();                     // false
let buzz: Bool = beginCell().asSlice().refsEmpty(); // true
```

## Slice.endParse

```tact
extends fun endParse(self: Slice);
```

Extension function for the [`Slice{:tact}`][slice].

Checks whether the [`Slice{:tact}`][slice] is empty (i.e., contains no bits of data and no cell references). If it's not, throws an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage examples:

```tact {2,6}
let emptyOne: Slice = emptySlice();
emptyOne.endParse(); // nothing, as it's empty

let paul: Slice = "Fear is the mind-killer".asSlice();
try {
    paul.endParse(); // throws exit code 9
}
```

## Slice.hash

```tact
extends fun hash(self: Slice): Int;
```

Extension function for the [`Slice{:tact}`][slice].

Calculates and returns an [`Int{:tact}`][int] value of the [SHA-256][sha-2] hash of the [standard `Cell{:tact}` representation][std-repr] of the given [`Slice{:tact}`][slice].

Usage example:

```tact
let s: Slice = beginCell().asSlice();
let fizz: Int = s.hash();
```

## Slice.asCell

```tact
extends fun asCell(self: Slice): Cell;
```

Extension function for the [`Slice{:tact}`][slice].

Converts the [`Slice{:tact}`][slice] to a [`Cell{:tact}`][cell] and returns it. Alias to `beginCell().storeSlice(self).endCell(){:tact}`.

Usage example:

```tact
let s: Slice = beginCell().asSlice();
let fizz: Cell = s.asCell();
let buzz: Cell = beginCell().storeSlice(s).endCell();

fizz == buzz; // true
```

## Address.asSlice

```tact
extends fun asSlice(self: Address): Slice;
```

Extension function for the [`Address{:tact}`][p].

Converts the [`Address{:tact}`][p] to a [`Slice{:tact}`][slice] and returns it. Alias to `beginCell().storeAddress(self).asSlice(){:tact}`.

Usage example:

```tact
let a: Address = myAddress();
let fizz: Slice = a.asSlice();
let buzz: Slice = beginCell().storeAddress(a).asSlice();

fizz == buzz; // true
```

## Struct.toCell

```tact
extends fun toCell(self: Struct): Cell;
```

Extension function for any structure type [Struct][struct].

Converts the [Struct][struct] to a [`Cell{:tact}`][cell] and returns it.

Usage example:

```tact
struct GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun coinCell(): Cell {
    let s: GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz: Cell = s.toCell();

    return fizz; // "x{12A11B}"
}
```

## Struct.toSlice

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends fun toSlice(self: Struct): Slice;
```

Extension function for any structure type [Struct][struct].

Converts the [Struct][struct] to a [`Slice{:tact}`][slice] and returns it. Alias to `self.toCell().asSlice(){:tact}`.

Usage example:

```tact
struct GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun coinSlice(): Slice {
    let s: GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz: Slice = s.toSlice();

    return fizz; // "CS{Cell{000612a11b} bits: 0..24; refs: 0..0}"
}
```

## Struct.fromCell

```tact
extends fun fromCell(self: Struct, cell: Cell): Struct;
```

Extension function for any structure type [Struct][struct].

Converts a [`Cell{:tact}`][cell] into the specified [Struct][struct] and returns that [Struct][struct].

Attempts to pass a [`Cell{:tact}`][cell] with layout different from the specified [Struct][struct] or to load more data than a [`Cell{:tact}`][cell] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage examples:

```tact
struct GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun directParse(payload: Cell): GuessCoin {
    return GuessCoin.fromCell(payload);
}

fun cautiousParse(payload: Cell): GuessCoin? {
    let coin: GuessCoin? = null;
    try {
        coin = GuessCoin.fromCell(payload);
    } catch (e) {
        dump("Cell payload doesn't match GuessCoin Struct!");
    }
    return coin;
}
```

## Struct.fromSlice

```tact
extends fun fromSlice(self: Struct, slice: Slice): Struct;
```

Extension function for any structure type [Struct][struct].

Converts a [`Slice{:tact}`][slice] into the specified [Struct][struct] and returns that [Struct][struct].

Attempts to pass a [`Slice{:tact}`][slice] with layout different from the specified [Struct][struct] or to load more data than a [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage examples:

```tact
struct GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun directParse(payload: Slice): GuessCoin {
    return GuessCoin.fromSlice(payload);
}

fun cautiousParse(payload: Slice): GuessCoin? {
    let coin: GuessCoin? = null;
    try {
        coin = GuessCoin.fromSlice(payload);
    } catch (e) {
        dump("Slice payload doesn't match GuessCoin Struct!");
    }
    return coin;
}
```

## Message.toCell

```tact
extends fun toCell(self: Message): Cell;
```

Extension function for any message type [Message][message].

Converts the [Message][message] to a [`Cell{:tact}`][cell] and returns it.

Usage example:

```tact
message GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun coinCell(): Cell {
    let s: GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz: Cell = s.toCell();

    return fizz; // "x{AB37107712A11B}"
}
```

## Message.toSlice

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
extends fun toSlice(self: Message): Slice;
```

Extension function for any message type [Message][message].

Converts the [Message][message] to a [`Slice{:tact}`][slice] and returns it. Alias to `self.toCell().asSlice(){:tact}`.

Usage example:

```tact
message GuessCoin {
    probably: Int as coins;
    nothing: Int as coins;
}

fun coinSlice(): Slice {
    let s: GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz: Slice = s.toSlice();

    return fizz; // "CS{Cell{000eab37107712a11b} bits: 0..56; refs: 0..0}"
}
```

## Message.fromCell

```tact
extends fun fromCell(self: Message, cell: Cell): Message;
```

Extension function for any message type [Message][message].

Converts a [`Cell{:tact}`][cell] into the specified [Message][message] and returns that [Message][message].

Attempts to pass a [`Cell{:tact}`][cell] with layout different from the specified [Message][message] or to load more data than a [`Cell{:tact}`][cell] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage examples:

```tact
message(0x777) TripleAxe {
    prize: Int as uint32;
}

fun directParse(payload: Cell): TripleAxe {
    return TripleAxe.fromCell(payload);
}

fun cautiousParse(payload: Cell): TripleAxe? {
    let coin: TripleAxe? = null;
    try {
        coin = TripleAxe.fromCell(payload);
    } catch (e) {
        dump("Cell payload doesn't match TripleAxe Message!");
    }
    return coin;
}
```

## Message.fromSlice


```tact
extends fun fromSlice(self: Message, slice: Slice): Message;
```

Extension function for any message type [Message][message].

Converts a [`Slice{:tact}`][slice] into the specified [Message][message] and returns that [Message][message].

Attempts to pass a [`Slice{:tact}`][slice] with layout different from the specified [Message][message] or to load more data than a [`Slice{:tact}`][slice] contains throw an exception with [exit code 9](/book/exit-codes#9): `Cell underflow`.

Usage examples:

```tact
message(0x777) TripleAxe {
    prize: Int as uint32;
}

fun directParse(payload: Slice): TripleAxe {
    return TripleAxe.fromSlice(payload);
}

fun cautiousParse(payload: Slice): TripleAxe? {
    let coin: TripleAxe? = null;
    try {
        coin = TripleAxe.fromSlice(payload);
    } catch (e) {
        dump("Slice payload doesn't match TripleAxe Message!");
    }
    return coin;
}
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[cell]: /book/cells#cells
[builder]: /book/cells#builders
[slice]: /book/cells#slices
[map]: /book/maps
[struct]: /book/structs-and-messages#structs
[message]: /book/structs-and-messages#messages

[std-repr]: /book/cells#cells-representation

[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[sha-2]: https://en.wikipedia.org/wiki/SHA-2#Hash_standard


## core-common.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-common.mdx)
---
title: Common
description: "Commonly used global static functions from the Core library of Tact"
---

List of the most commonly used built-in [global static functions](/book/functions#global-static-functions).

## Contextual

### now

```tact
fun now(): Int
```

Returns the current [Unix time](https://en.wikipedia.org/wiki/Unix_time).

Usage example:

```tact
let timeOffset: Int = now() + 1000; // thousand seconds from now()
```

### myBalance

```tact
fun myBalance(): Int;
```

Returns the [nanoToncoin](/book/integers#nanotoncoin) balance of the smart contract as it was at the start of the [compute phase](https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase) of the current transaction.

Usage example:

```tact
let iNeedADolla: Int = myBalance();
```

:::caution

  Beware, that [all message sending functions](/book/send) of Tact can change the _actual_ contract's balance, but they _won't_ update the value returned by this function.

:::

### myAddress

```tact
fun myAddress(): Address;
```

Returns the address of the current smart contract as an [`Address{:tact}`][p].

Usage example:

```tact
let meMyselfAndI: Address = myAddress();
```

### sender

```tact
fun sender(): Address;
```

Returns the [`Address{:tact}`][p] of the sender of the current message.

Usage example:

```tact
contract MeSee {
    receive() {
        let whoSentMeMessage: Address = sender();
    }
}
```

:::caution

  Behavior is undefined for [getter functions](/book/contracts#getter-functions), because they cannot have a sender nor can they send messages.

:::

:::note

  In order to reduce gas usage, prefer using this function over calling [`context().sender{:tact}`](#context) when you only need to know the sender of the message.

:::

### context

```tact
fun context(): Context;
```

Returns `Context{:tact}` [Struct](/book/structs-and-messages#structs), that consists of:

Field     | Type                  | Description
:-------- | :-------------------- | :----------
`bounced` | [`Bool{:tact}`][bool] | [Bounced](https://ton.org/docs/learn/overviews/addresses#bounceable-vs-non-bounceable-addresses) flag of the incoming message.
`sender`  | [`Address{:tact}`][p] | Internal address of the sender on the TON blockchain.
`value`   | [`Int{:tact}`][int]   | Amount of [nanoToncoins](/book/integers#nanotoncoin) in a message.
`raw`     | [`Slice{:tact}`][slice]   | The remainder of the message as a [`Slice{:tact}`][slice]. It follows [internal message layout](https://docs.ton.org/develop/smart-contracts/messages#message-layout) of TON starting from the destination [`Address{:tact}`][p] (`dest:MsgAddressInt ` in [TL-B notation](https://docs.ton.org/develop/data-formats/tl-b-language)).

Usage example:

```tact
let ctx: Context = context();
require(ctx.value != 68 + 1, "Invalid amount of nanoToncoins, bye!");
```

:::note

  Note, that if you only need to know who sent the message, use the [`sender(){:tact}`](#sender) function, as it's less gas-consuming.

:::

## Addressing

### newAddress

```tact
fun newAddress(chain: Int, hash: Int): Address;
```

Creates a new [`Address{:tact}`][p] based on the [`chain` id](https://ton-blockchain.github.io/docs/#/overviews/TON_blockchain_overview) and the [SHA-256](/ref/core-math#sha256) encoded [`hash` value](https://docs.ton.org/learn/overviews/addresses#account-id).

This function tries to resolve constant values in [compile-time](/ref/core-comptime) whenever possible.

Usage example:

```tact
let oldTonFoundationAddr: Address =
    newAddress(0, 0x83dfd552e63729b472fcbcc8c45ebcc6691702558b68ec7527e1ba403a0f31a8);
    //         ↑  ------------------------------------------------------------------
    //         |  ↑
    //         |  sha-256 hash of contract's init package (StateInit)
    //         chain id: 0 is a workchain, -1 is a masterchain
```

:::caution

  Make sure your specify only supported chain IDs: $0$ for the basechain and $-1$ for the masterchain.

:::

:::note[Useful links:]

  [`chain` (Workchain ID) in TON Docs](https://docs.ton.org/learn/overviews/addresses#workchain-id)\
  [`hash` (Account ID) in TON Docs](https://docs.ton.org/learn/overviews/addresses#account-id)\
  [Contract's init package (`StateInit{:tact}`)](/book/expressions#initof)

:::

### contractAddress

```tact
fun contractAddress(s: StateInit): Address;
```

Computes smart contract's [`Address{:tact}`][p] in a workchain $0$ based on its [`StateInit{:tact}`](/book/expressions#initof).

Usage example:

```tact
let foundMeSome: Address = contractAddress(initOf SomeContract());
```

### contractAddressExt

```tact
fun contractAddressExt(chain: Int, code: Cell, data: Cell): Address;
```

Computes smart contract's [`Address{:tact}`][p] based on the `chain` id, contract's `code` and contract's initial state `data`. Use [`initOf{:tact}`](/book/expressions#initof) expression to obtain initial `code` and initial `data` of a given contract.

Usage example:

```tact
let initPkg: StateInit = initOf SomeContract();
let hereBeDragons: Address = contractAddressExt(0, initPkg.code, initPkg.data);
```

:::caution

  Make sure your specify only supported chain IDs: $0$ for the basechain and $-1$ for the masterchain.

:::

:::note

  For this function to work, the compiler option `debug` has to be set to `true{:tact}` for the current project in the [configuration file](/book/config).\
  Read more about debugging on the dedicated page: [Debugging](/book/debug).

:::

## Communication

### send

```tact
fun send(params: SendParameters);
```

[Queues the message](/book/send#outbound-message-processing) to be sent using a [`SendParameters{:tact}`](/book/send) [Struct](/book/structs-and-messages#structs).

Usage example:

```tact
send(SendParameters{
    to: sender(),    // back to the sender,
    value: ton("1"), // with 1 Toncoin (1_000_000_000 nanoToncoin),
                     // and no message body
});
```

:::note[Useful links:]

  [Sending messages in the Book](/book/send)\
  [Message `mode` in the Book](/book/message-mode)\
  [Single-contract communication in the Cookbook](/cookbook/single-communication)

:::

### emit

```tact
fun emit(body: Cell);
```

[Queues the message](/book/send#outbound-message-processing) `body` to be sent to the outer world with the purpose of logging and analyzing it later off-chain. The message does not have a recipient and is gas-efficient compared to using any other message sending functions of Tact.

Usage example:

```tact
emit("Catch me if you can, Mr. Holmes".asComment()); // asComment() converts a String to a Cell
```

:::note

  To analyze `emit(){:tact}` calls, one has to look at [external messages](/book/external) produced by the contract.

  Read more: [Logging via `emit(){:tact}`](/book/debug#logging).

:::

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[slice]: /book/cells#slices


## core-comptime.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-comptime.mdx)
---
title: Compile-time
description: "Various compile-time global functions from the Core library of Tact"
---

import { Badge } from '@astrojs/starlight/components';

This page lists all the built-in [global static functions](/book/functions#global-static-functions), which are evaluated at the time of building the Tact project and cannot work with non-constant, run-time data. These functions are commonly referred to as "compile-time functions" or _comptime_ functions for short.

## address

```tact
fun address(s: String): Address;
```

A compile-time function that converts a [`String{:tact}`][p] with an address into the [`Address{:tact}`][p] type and embeds it into the contract.

Usage example:

```tact
contract Example {
    // Persistent state variables
    addr: Address =
        address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N"); // works at compile-time!
}
```

:::note

  The `address("...Address..."){:tact}` in Tact is equivalent to `"...Address..."a{:func}` in FunC.

:::

## cell

```tact
fun cell(bocBase64: String): Cell;
```

A compile-time function that embeds a base64-encoded [BoC][boc] `bocBase64` as a [`Cell{:tact}`][cell] into the contract.

Usage examples:

```tact
contract Example {
    // Persistent state variables
    stored: Cell =
        // Init package for Wallet V3R1 as a base64-encoded BoC
        cell("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA="); // works at compile-time!
}
```

## slice

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun slice(bocBase64: String): Slice;
```

A compile-time function that embeds a base64-encoded [BoC][boc] `bocBase64` as a [`Slice{:tact}`][slice] into the contract.

Usage examples:

```tact
contract Example {
    // Persistent state variables
    stored: Slice =
        // Works at compile-time!
        slice("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw="); // Hello world!
}
```

## rawSlice

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun rawSlice(hex: String): Slice;
```

A compile-time function that converts `hex` [`String{:tact}`][p] with hex-encoded and optionally bit-padded contents as a [`Slice{:tact}`][slice] into the contract.

Contents are bit-padded if there's an underscore `_` at the very end of [`String{:tact}`][p]. The padding removes all the trailing zeros and the last $1$ bit before them:

```tact
// Not bit-padded
rawSlice("4a").loadUint(8); // 74, or 1001010 in binary

// Bit-padded
rawSlice("4a_").loadUint(6); // 18, or 10010 in binary
```

Note, that this function is limited and only allows to specify up to $1023$ bits.

Usage example:

```tact
contract Example {
    // Persistent state variables
    stored: Slice =
        rawSlice("000DEADBEEF000");  // CS{Cell{03f...430} bits: 588..644; refs: 1..1}
    bitPadded: Slice =
        rawSlice("000DEADBEEF000_"); // CS{Cell{03f...e14} bits: 36..79; refs: 0..0}
}
```

:::note

  The `rawSlice("...Hex contents..."){:tact}` in Tact is equivalent to `"...Hex contents..."s{:func}` in FunC.

:::

## ascii

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun ascii(str: String): Int;
```

A compile-time function that concatenates the hexadecimal values of the characters in `str` into one and embeds the resulting [`Int{:tact}`][int] into the contract. Only works for strings that occupy up to $32$ bytes, which allows to represent up to $32$ [ASCII codes](https://en.wikipedia.org/wiki/ASCII#Control_code_chart) or up to $8$ $4$-byte [Unicode code points](https://en.wikipedia.org/wiki/List_of_Unicode_characters).

Usage example:

```tact
contract Example {
    // Persistent state variables
    a: Int = ascii("a");            // 97 or 0x61, one byte in total
    zap: Int = ascii("⚡");         // 14850721 or 0xE29AA1, 3 bytes in total
    doubleZap: Int = ascii("⚡⚡"); // 249153768823457 or 0xE29AA1E29AA1, 6 bytes in total
}
```

:::note

  The `ascii("...String contents..."){:tact}` in Tact is equivalent to `"...String contents..."u{:func}` in FunC.

:::

## crc32

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

```tact
fun crc32(str: String): Int;
```

A compile-time function that computes a checksum using [CRC-32](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) algorithm and embeds the resulting [`Int{:tact}`][int] value into the contract.

Usage example:

```tact
contract Example {
    // Persistent state variables
    checksum: Int = crc32("000DEADBEEF000"); // 1821923098
}
```

:::note

  The `crc32("...String contents..."){:tact}` in Tact is equivalent to `"...String contents..."c{:func}` in FunC.

:::

## ton

```tact
fun ton(value: String): Int;
```

A compile-time function that converts the given Toncoins `value` from a human-readable format [`String{:tact}`][p] to the [nanoToncoin](/book/integers#nanotoncoin) [`Int{:tact}`][int] format.

Usage example:

```tact
contract Example {
    // Persistent state variables
    one: Int = ton("1");            // one Toncoin, which is equivalent to 10^9 nanoToncoins
    pointOne: Int = ton("0.1");     // 0.1 Toncoin, which is equivalent to 10^8 nanoToncoins
    nano: Int = ton("0.000000001"); // 10^-9 Toncoins, which is equivalent to 1 nanoToncoin
                                    // works at compile-time!
}
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[cell]: /book/cells#cells
[slice]: /book/cells#slices

[boc]: /book/cells#cells-boc

[crc]: https://en.wikipedia.org/wiki/Cyclic_redundancy_check


## core-debug.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-debug.mdx)
---
title: Debug
description: "Various debugging functions from the Core library of Tact"
---

List of functions commonly used for debugging smart contracts in Tact.

Read more about debugging on the dedicated page: [Debugging](/book/debug).

## require

```tact
fun require(condition: Bool, error: String);
```

Checks the `condition` and throws an error with an [exit code](/book/exit-codes) generated from the `error` message if the `condition` is `false{:tact}`. Does nothing otherwise.

The algorithm for generating the exit code works as follows:

* First, the [SHA-256](https://en.wikipedia.org/wiki/SHA-2#Hash_standard) hash of `error` message [`String{:tact}`][p] is obtained.
* Then, its value is read as a 32-bit [big-endian](https://en.wikipedia.org/wiki/Endianness) number modulo $63000$ plus $1000$, in that order.
* Finally, it's put into the `.md` compilation report file, which resides with the other compilation artifacts in your project's `outputs/` or `build/` directories.

The generated exit code is guaranteed to be outside the common $0 - 255$ range reserved for TVM and Tact contract errors, which makes it possible to distinguish exit codes from `require(){:tact}` and any other [standard exit codes](/book/exit-codes).

Usage examples:

```tact
// now() has to return a value greater than 1000, otherwise an error message will be thrown
require(now() > 1000, "We're in the first 1000 seconds of 1 January 1970!");

try {
    // The following will never be true, so this require would always throw
    require(now() < -1, "Time is an illusion. Lunchtime doubly so.");
} catch (e) {
    // e will be outside of range 0-255
    dump(e);
}
```

## dump

```tact
fun dump(arg);
```

Prints the argument `arg` to the contract's debug console. Evaluated only if the `debug` option in the [configuration file](/book/config) is set to `true{:json}`, otherwise does nothing.

This function is computationally expensive and consumes a lot of gas because it prints the location from which it was called, i.e. the filename, line and column numbers, and the original expression that was the `arg` argument.

Can be applied to the following list of types and values:

* [`Int{:tact}`][int]
* [`Bool{:tact}`][bool]
* [`Address{:tact}`][p]
* [`Cell{:tact}`][cell], [`Builder{:tact}`][builder] or [`Slice{:tact}`][slice]
* [`String{:tact}`][p] or [`StringBuilder{:tact}`][p]
* [`map<K, V>{:tact}`](/book/maps)
* [Optionals and `null{:tact}` value](/book/optionals)
* `void`, which is implicitly returned when a function doesn't have return value defined

Usage examples:

```tact
// Int
dump(42); // prints:
          // File filename.tact:2:1
          // dump(42)
          // 42

// Bool
dump(true);
dump(false);

// Address
dump(myAddress());

// Cell, Builder or Slice
dump(emptyCell());  // Cell
dump(beginCell());  // Builder
dump(emptySlice()); // Slice

// String or StringBuilder
dump("Hello, my name is..."); // String
dump(beginTailString());      // StringBuilder

// Maps
let m: map<Int, Int> = emptyMap();
m.set(2 + 2, 4);
dump(m);

// Special values
dump(null);
dump(emit("msg".asComment())); // As emit() function doesn't return a value, dump() would print #DEBUG#: void.
```

:::note[Useful links:]

  [Debug with `dump(){:tact}`](/book/debug#tests-dump)

:::

## dumpStack

```tact
fun dumpStack();
```

Prints the total stack depth and up to $255$ of its values from the top to the contract's debug console. The values are positioned bottom-up: from the deepest value on the left to the topmost value on the right. Evaluated only if the `debug` option in the [configuration file](/book/config) is set to `true{:json}`, otherwise does nothing.

Usage example:

```tact
dumpStack(); // prints:
             // File filename.tact:1:1
             // dumpStack()
             // stack(3 values) : 100000000 C{96...C7} 0
```

:::note[Useful links:]

  [Debug with `dump(){:tact}`](/book/debug#tests-dump)\
  [Assembly functions](/book/assembly-functions)

:::

## throw

```tact
fun throw(code: Int);
```

An alias to [`nativeThrow(){:tact}`](#nativethrow).

## nativeThrow

```tact
fun nativeThrow(code: Int);
````

Throws an exception with an error code equal to `code`. Execution of the current context stops (the statements after `nativeThrow` won't be executed) and control will be passed to the first [`try...catch{:tact}` block](/book/statements#try-catch) in the call stack. If no `try{:tact}` or `try...catch{:tact}` block exists among caller functions, [TVM](https://docs.ton.org/learn/tvm-instructions/tvm-overview) will terminate the transaction.

Attempts to specify the `code` outside of $0 - 65535$ range cause an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage examples:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrow(42); // throwing with exit code 42
}

fun butThisDoesNot() {
    try {
        nativeThrow(42); // throwing with exit code 42
    }

    // ... follow-up logic ...
}
```

## nativeThrowIf

```tact
fun nativeThrowIf(code: Int, condition: Bool);
```

Similar to [`nativeThrow(){:tact}`](#nativethrow), but throws an exception conditionally, when `condition` is equal to `true{:tact}`. Doesn't throw otherwise.

Attempts to specify the `code` outside of $0 - 65535$ range cause an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage examples:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrowIf(42, true); // throwing with exit code 42
}

fun butThisDoesNot() {
    try {
        nativeThrowIf(42, true); // throwing with exit code 42
    }
    // ... follow-up logic ...
}
```

## nativeThrowUnless

```tact
fun nativeThrowUnless(code: Int, condition: Bool);
```

Similar to [`nativeThrow(){:tact}`](#nativethrow), but throws an exception conditionally, when `condition` is equal to `false{:tact}`. Doesn't throw otherwise.

Attempts to specify the `code` outside of $0 - 65535$ range cause an exception with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage examples:

```tact {2,7}
fun thisWillTerminate() {
    nativeThrowUnless(42, false); // throwing with exit code 42
}

fun butThisDoesNot() {
    try {
        nativeThrowUnless(42, false); // throwing with exit code 42
    }
    // ... follow-up logic ...
}
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[cell]: /book/cells#cells
[builder]: /book/cells#builders
[slice]: /book/cells#slices


## core-math.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-math.mdx)
---
title: Math
description: "Various math helper functions from the Core library of Tact"
---

Various math helper functions.

## min

```tact
fun min(x: Int, y: Int): Int;
```

Computes and returns the [minimum](https://en.wikipedia.org/wiki/Maximum_and_minimum) of two [`Int{:tact}`][int] values `x` and `y`.

Usage examples:

```tact
min(1, 2);        // 1
min(2, 2);        // 2
min(007, 3);      // 3
min(0x45, 3_0_0); // 69, nice
//  ↑     ↑
//  69    300
```

## max

```tact
fun max(x: Int, y: Int): Int;
```

Computes and returns the [maximum](https://en.wikipedia.org/wiki/Maximum_and_minimum) of two [`Int{:tact}`][int] values `x` and `y`.

Usage examples:

```tact
max(1, 2);        // 2
max(2, 2);        // 2
max(007, 3);      // 7
max(0x45, 3_0_0); // 300
//  ↑     ↑
//  69    300
```

## abs

```tact
fun abs(x: Int): Int
```

Computes and returns the [absolute value](https://en.wikipedia.org/wiki/Absolute_value) of the [`Int{:tact}`][int] value `x`.

Usage examples:

```tact
abs(42);        // 42
abs(-42);       // 42
abs(-(-(-42))); // 42
```

## log

```tact
fun log(num: Int, base: Int): Int;
```

Computes and returns the [logarithm](https://en.wikipedia.org/wiki/Logarithm) of a number `num` $> 0$ to the base `base` $≥ 1$. Results are [rounded down](https://en.wikipedia.org/wiki/Rounding#Rounding_down). Passing a non-positive `num` value or a `base` less than $1$ throws an error with [exit code 5](/book/exit-codes#5): `Integer out of expected range`.

Usage examples:

```tact
log(1000, 10); // 3, as 10^3 is 1000
//  ↑     ↑             ↑       ↑
//  num   base          base    num

log(1001, 10);  // 3
log(999, 10);   // 2
try {
  log(-1000, 10); // throws exit code 5 because of the non-positive num
}
log(1024, 2);   // 10
try {
  log(1024, -2);  // throws exit code 5 because of the base less than 1
}
```

:::note

  Note, that if you only need to obtain logarithms to the base $2$, use the [`log2(){:tact}`](#log2) function, as it's more gas-efficient.

:::

## log2

```tact
fun log2(num: Int): Int;
```

Similar to [`log(){:tact}`](#log), but sets the `base` to $2$.

Usage example:

```tact
log2(1024); // 10, as 2^10 is 1024
//   ↑                ↑       ↑
//   num              base₂   num
```

:::note

  In order to reduce gas usage, prefer using this function over calling [`log(){:tact}`](#log) when you only need to obtain logarithms to the base $2$.

:::

## pow

```tact
fun pow(base: Int, exp: Int): Int;
```

Computes and returns the [exponentiation](https://en.wikipedia.org/wiki/Exponentiation) involving two numbers: the `base` and the exponent (or _power_) `exp`. Exponent `exp` must be non-negative, otherwise an error with [exit code 5](/book/exit-codes#5) will be thrown: `Integer out of expected range`.

Note, that this function works both at run-time and at [compile-time](/ref/core-comptime).

Usage example:

```tact
contract Example {
    // Persistent state variables
    p23: Int = pow(2, 3); // raises 2 to the 3rd power, which is 8
    one: Int = pow(5, 0); // raises 5 to the power 0, which always produces 1
                          // works at compile-time!

    // Internal message receiver, which accepts message ExtMsg
    receive() {
        pow(self.p23, self.one + 1); // 64, works at run-time too!
        pow(0, -1);                  // ERROR! Exit code 5: Integer out of expected range
    }
}
```

:::note

  Note, that if you only need to obtain powers of $2$, use the [`pow2(){:tact}`](#pow2) function, as it's more gas-efficient.

:::

:::note

  List of functions, that only work at compile-time: [API Comptime](/ref/core-comptime).

:::

## pow2

```tact
fun pow2(exp: Int): Int;
```

Similar to [`pow(){:tact}`](#pow), but sets the `base` to $2$. Works both at run-time and at [compile-time](/ref/core-comptime).

Usage examples:

```tact
contract Example {
    // Persistent state variables
    p23: Int = pow2(3); // raises 2 to the 3rd power, which is 8
    one: Int = pow2(0); // raises 2 to the power 0, which always produces 1
                        // works at compile-time!

    // Internal message receiver, which accepts message ExtMsg
    receive() {
        pow2(self.one + 1); // 4, works at run-time too!
        pow2(-1);           // ERROR! Exit code 5: Integer out of expected range
    }
}
```

:::note

  In order to reduce gas usage, prefer using this function over calling [`pow(){:tact}`](#pow) when you only need to obtain powers of $2$.

:::

:::note

  List of functions, that only work at compile-time: [API Comptime](/ref/core-comptime).

:::

## checkSignature

```tact
fun checkSignature(hash: Int, signature: Slice, public_key: Int): Bool;
```

Checks the [Ed25519][ed] `signature` of the $256$-bit unsigned [`Int{:tact}`][int] `hash` using a `public_key`, represented by a $256$-bit unsigned [`Int{:tact}`][int] too. The signature must contain at least $512$ bits of data, but only the first $512$ bits are used.

Returns `true{:tact}` if the signature is valid, `false{:tact}` otherwise.

Usage example:

```tact {19-24}
message ExtMsg {
    signature: Slice;
    data: Cell;
}

contract Showcase {
    // Persistent state variables
    pub: Int as uint256; // public key as an 256-bit unsigned Int

    // Constructor function init(), where all the variables are initialized
    init(pub: Int) {
        self.pub = pub; // storing the public key upon contract initialization
    }

    // External message receiver, which accepts message ExtMsg
    external(msg: ExtMsg) {
        let hash: Int = beginCell().storeRef(msg.data).endCell().hash();
        let check: Bool = checkSignature(hash, msg.signature, self.pub);
        //                               ----  -------------  --------
        //                               ↑     ↑              ↑
        //                               |     |              public_key, stored in our contract
        //                               |     signature, obtained from the received message
        //                               hash, calculated using the data from the received message
        // ... follow-up logic ...
    }
}
```

## checkDataSignature

```tact
fun checkDataSignature(data: Slice, signature: Slice, public_key: Int): Bool;
```

Checks the [Ed25519][ed] `signature` of the `data` using a `public_key`, similar to [`checkSignature(){:tact}`](#checksignature). If the bit length of `data` is not divisible by $8$, this functions throws an error with [exit code 9](/book/exit-codes#9): `Cell underflow`. Verification itself is being done indirectly: on a [SHA-256][sha-2] hash of the `data`.

Returns `true{:tact}` if the signature is valid, `false{:tact}` otherwise.

Usage example:

```tact
let data: Slice = some_data;
let signature: Slice = some_signature;
let publicKey: Int = 42;

let check: Bool = checkSignature(data, signature, publicKey);
```

## sha256

```tact
fun sha256(data: Slice): Int;
fun sha256(data: String): Int;
```

Computes and returns the [SHA-256][sha-2] hash as a $256$-bit unsigned [`Int{:tact}`][int] from a passed [`Slice{:tact}`][slice] or [`String{:tact}`][p] `data`.

In case `data` is a [`String{:tact}`][p] it should have a number of bits divisible by $8$, and in case it's a [`Slice{:tact}`][slice] it must **also** have no references (i.e. only up to $1023$ bits of data in total). This function tries to resolve constant string values at [compile-time](/ref/core-comptime) whenever possible.

:::caution

  If the [`String{:tact}`][p] value cannot be resolved during [compilation time](/ref/core-comptime), then the hash is calculated at runtime by the [TVM][tvm] itself. Note, that hashing strings with more than $128$ bytes by the [TVM][tvm] can cause collisions if their first $128$ bytes are the same.

  Therefore, prefer using statically known strings whenever possible. When in doubt, use strings of up to $128$ bytes long.

:::

Usage examples:

```tact
sha256(beginCell().asSlice());
sha256("Hello, world!"); // will be resolved in compile-time
sha256(someVariableElsewhere); // will try to resolve at compile-time,
                               // and fallback to run-time evaluation
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[slice]: /book/cells#slices

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[ed]: https://en.wikipedia.org/wiki/EdDSA#Ed25519
[sha-2]: https://en.wikipedia.org/wiki/SHA-2#Hash_standard


## core-random.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-random.mdx)
---
title: Random number generation
description: "Various random number generation functions from the Core library of Tact"
---

Random number generation for Tact smart contracts.

## random

```tact
fun random(min: Int, max: Int): Int;
```

Generates and returns a new pseudo-random unsigned [`Int{:tact}`][int] value `x` in the provided semi-closed interval: `min` $≤$ `x` $<$ `max` or `min` $≥$ `x` $>$ `max`, if both `min` and `max` are negative. Note, that `max` value is never included in the interval.

Usage examples:

```tact
random(42, 43); // 42, always
random(0, 42);  // 0-41, but never a 42
```

## randomInt

```tact
fun randomInt(): Int;
```

Generates and returns a new pseudo-random unsigned $256$-bit [`Int{:tact}`][int] value `x`.

The algorithm works as follows: if `r` is the old value of the random seed considered a $32$-byte array (by constructing the big-endian representation of an unsigned $256$-bit [`Int{:tact}`][int]), then its `sha512(r){:tact}` is computed. The first $32$ bytes of this hash are stored as the new value `r'` of the random seed, and the remaining $32$ bytes are returned as the next random value `x`.

Usage example:

```tact
let allYourRandomBelongsToUs: Int = randomInt(); // ???, it's random :)
```

:::caution

  Advanced functions for working with random numbers are listed on a specialized page: [Advanced APIs](/ref/core-advanced).

:::

[int]: /book/integers


## core-strings.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/core-strings.mdx)
---
title: Strings and StringBuilders
description: "Various String and StringBuilder functions from the Core library of Tact"
---

Strings are immutable sequences of characters, which means that once a [`String{:tact}`][p] is created, it cannot be changed. Strings are useful to store text, and so they can be converted to [`Cell{:tact}`][cell] type to be used as message bodies.

To be able to concatenate strings in a gas-efficient way, use a [`StringBuilder{:tact}`][p].

To use [`String{:tact}`][p] literals directly, see: [String literals](/book/expressions#string-literals).

## beginString

```tact
fun beginString(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
```

## beginComment

```tact
fun beginComment(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p] for building a comment string, which prefixes the resulting [`String{:tact}`][p] with four null bytes. This format is used for passing text comments as message bodies.

Usage example:

```tact
let fizz: StringBuilder = beginComment();
```

## beginTailString

```tact
fun beginTailString(): StringBuilder;
```

Creates and returns an empty [`StringBuilder{:tact}`][p] for building a tail string, which prefixes the resulting [`String{:tact}`][p] with a single null byte. This format is used in various standards like NFT or Jetton.

Usage example:

```tact
let fizz: StringBuilder = beginTailString();
```

## beginStringFromBuilder

```tact
fun beginStringFromBuilder(b: StringBuilder): StringBuilder;
```

Creates and returns a new [`StringBuilder{:tact}`][p] from existing [`StringBuilder{:tact}`][p] `b`. Useful when you need to serialize an existing [`String{:tact}`][p] to a [`Cell{:tact}`][cell] with some other data.

Usage example:

```tact
let fizz: StringBuilder = beginStringFromBuilder(beginString());
```

## StringBuilder.append

```tact
extends mutates fun append(self: StringBuilder, s: String);
```

Extension mutation function for the [`StringBuilder{:tact}`][p].

Appends a [`String{:tact}`][p] `s` to the [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
fizz.append("oh");
fizz.append("my");
fizz.append("Tact!");
```

## StringBuilder.concat

```tact
extends fun concat(self: StringBuilder, s: String): StringBuilder;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns a new [`StringBuilder{:tact}`][p] after concatinating it with a [`String{:tact}`][p] `s`. Can be chained, unlike [`StringBuilder.append(){:tact}`](#stringbuilderappend).

Usage example:

```tact
let fizz: StringBuilder = beginString()
    .concat("oh")
    .concat("my")
    .concat("Tact!");
```

## StringBuilder.toString

```tact
extends fun toString(self: StringBuilder): String;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns a built [`String{:tact}`][p] from a [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
let buzz: String = fizz.toString();
```

## StringBuilder.toCell

```tact
extends fun toCell(self: StringBuilder): Cell;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns an assembled [`Cell{:tact}`][cell] from a [`StringBuilder{:tact}`][p].

Usage example:

```tact
let fizz: StringBuilder = beginString();
let buzz: Cell = fizz.toCell();
```

## StringBuilder.toSlice

```tact
extends fun toSlice(self: StringBuilder): Slice;
```

Extension function for the [`StringBuilder{:tact}`][p].

Returns an assembled [`Cell{:tact}`][cell] as a [`Slice{:tact}`][slice] from a [`StringBuilder{:tact}`][p]. Alias to [`self.toCell().asSlice(){:tact}`](/ref/core-cells#cellasslice).

Usage example:

```tact
let s: StringBuilder = beginString();
let fizz: Slice = s.toSlice();
let buzz: Slice = s.toCell().asSlice();

fizz == buzz; // true
```

## String.asSlice

```tact
extends fun asSlice(self: String): Slice;
```

Extension function for the [`String{:tact}`][p].

Returns a [`Slice{:tact}`][slice] from a [`String{:tact}`][p] by trying to pack all of its bits into a continuous list of [Cells][p], each referencing the next one and opening them all for future parsing.

Note, that there's no indication of how many bytes a particular character could take in the [`Slice{:tact}`][slice] or how deep the list of references is going to be, so use this function only if you know what you're doing.

Usage example:

```tact
let s: String = "It's alive! It's alive!!!";
let fizz: Slice = s.asSlice();
let buzz: Slice = s.asSlice().asString().asSlice();

fizz == buzz; // true, but be careful as it's not always the case
```

:::note

  See how `String.asSlice{:tact}` function can be used in practice: [How to convert a `String` to an `Int`](/cookbook/type-conversion#how-to-convert-a-string-to-an-int).

:::

## String.asComment

```tact
extends fun asComment(self: String): Cell;
```

Extension function for the [`String{:tact}`][p].

Returns a [`Cell{:tact}`][cell] from a [`String{:tact}`][p] by prefixing the latter with four null bytes. This format is used for passing text comments as message bodies.

Usage example:

```tact
let s: String = "When life gives you lemons, call them 'yellow oranges' and sell them for double the price.";
let fizz: Cell = s.asComment();

let b: StringBuilder = beginComment();
b.append(s);
let buzz: Cell = b.toCell();

fizz == buzz; // true
```

## String.fromBase64

```tact
extends fun fromBase64(self: String): Slice;
```

Extension function for the [`String{:tact}`][p].

Returns a [`Slice{:tact}`][slice] out of the decoded [Base64](https://en.wikipedia.org/wiki/Base64) [`String{:tact}`][p]. Alias to `self.asSlice().fromBase64(){:tact}`.

Note, that this function is limited and only takes the first $1023$ bits of data from the given [`String{:tact}`][p], without throwing an exception when the [`String{:tact}`][p] is larger (i.e. contains more than $1023$ bits of data).

If the given [`String{:tact}`][p] contains characters not from the Base64 set, an exception with [exit code 134](/book/exit-codes#134) will be thrown: `Invalid argument`.

Usage example:

```tact
let s: String = "SGVyZSdzIEpvaG5ueSE=";
let fizz: Slice = s.fromBase64();
let buzz: Slice = s.asSlice().fromBase64();

fizz == buzz; // true
```

## Slice.asString

```tact
extends fun asString(self: Slice): String;
```

Extension function for the [`Slice{:tact}`][slice].

Returns a [`String{:tact}`][p] from a [`Slice{:tact}`][slice] by trying to load all of its bits without looking for its references, if any.

Note, that this function doesn't look at the references at all and is truncates its output to $1023$ bits, so use it only if you know what you're doing.

Usage example:

```tact
let s: String = "Keep your Slices close, but your Strings closer.";
let fizz: String = s;
let buzz: String = s.asSlice().asString();

fizz == buzz; // true, but be careful as it's not always the case
```

## Slice.fromBase64

```tact
extends fun fromBase64(self: Slice): Slice;
```

Extension function for the [`Slice{:tact}`][slice].

Returns a new [`Slice{:tact}`][slice] out of the decoded [Base64](https://en.wikipedia.org/wiki/Base64) [`Slice{:tact}`][slice].

Note, that this function is limited and only takes the first $1023$ bits of data from the given [`Slice{:tact}`][slice], without throwing an exception if the [`Slice{:tact}`][slice] has more data (i.e., when it has any references).

If the given [`Slice{:tact}`][p] contains characters not from the Base64 set, an exception with [exit code 134](/book/exit-codes#134) will be thrown: `Invalid argument`.

Usage example:

```tact
let s: Slice = "SSBhbSBHcm9vdC4=".asSlice();
let fizz: Slice = s.fromBase64();
```

## Int.toString

```tact
extends fun toString(self: Int): String;
```

Extension function for the [`Int{:tact}`][int].

Returns a [`String{:tact}`][p] from an [`Int{:tact}`][int] value.

Usage example:

```tact
let fizz: String = (84 - 42).toString();
```

## Int.toFloatString

```tact
extends fun toFloatString(self: Int, digits: Int): String;
```

Extension function for the [`Int{:tact}`][int].

Returns a [`String{:tact}`][p] from an [`Int{:tact}`][int] value using a [fixed-point representation](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) of a fractional number, where `self` is a significant part of the number and `digits` is a number of digits in the fractional part.

More precisely, `digits` is an exponentiation parameter of $10^{-\mathrm{digits}}$ expression, which gives the represented fractional number when multiplied by the actual [`Int{:tact}`][int] value. Parameter `digits` is required to be in the closed interval: $0 <$ `digits` $< 78$, otherwise an exception with [exit code 134](/book/exit-codes#134) will be thrown: `Invalid argument`.

Usage example:

```tact
let fizz: String = (42).toFloatString(9); // "0.000000042"
```

## Int.toCoinsString

```tact
extends fun toCoinsString(self: Int): String;
```

Extension function for the [`Int{:tact}`][int].

Returns a [`String{:tact}`][p] from an [`Int{:tact}`][int] value using a [fixed-point representation](https://en.wikipedia.org/wiki/Fixed-point_arithmetic) of a fractional number. Alias to `self.toFloatString(9){:tact}`.

This is used to represent [nanoToncoin](/book/integers#nanotoncoin) [`Int{:tact}`][int] values using strings.

Usage example:

```tact
let nanotons: Int = 42;
let fizz: String = nanotons.toCoinsString();
let buzz: String = nanotons.toFloatString(9);

fizz == buzz; // true, both store "0.000000042"
```

## Address.toString

```tact
extends fun toString(self: Address): String;
```

Extension function for the [`Address{:tact}`][p].

Returns a [`String{:tact}`][p] from an [`Address{:tact}`][p].

Usage example:

```tact
let community: Address = address("UQDpXLZKrkHsOuE_C1aS69C697wE568vTnqSeRfBXZfvmVOo");
let fizz: String = community.toString();
```

[p]: /book/types#primitive-types
[bool]: /book/types#booleans
[int]: /book/integers
[cell]: /book/cells#cells
[slice]: /book/cells#slices


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/index.mdx)
---
title: Reference overview
description: "Reference section — a place for discovering the Tact's standard library, grammar specification and evolution process"
---

import { LinkCard, CardGrid, Steps } from '@astrojs/starlight/components';

Welcome to the **Reference** section of Tact documentation — a place for discovering the Tact's standard library, grammar specification and evolution process.

Here are its main contents:

<Steps>

1. #### Core library

   [Core library](/ref/core-base) gives a comprehensive list of auto-included functions, traits and other constructs with examples of their usage.

   <CardGrid>
     <LinkCard
       title="Go to the Core library"
       href="/ref/core-base"
     />
   </CardGrid>

2. #### Standard libraries

   [Standard libraries](/ref/standard-libraries) sub-section explains how to use the bundled libraries, lists all their contents with examples of their usage.
   
   <CardGrid>
     <LinkCard
       title="Go to Standard libraries"
       href="/ref/standard-libraries"
     />
   </CardGrid>

3. #### Specification

   [Specification](/ref/spec) page provides full Tact grammar written in Ohm language, which is used in the Tact's compiler. Aimed at more experienced programmers, but generally can still be very handy to quickly grasp all of the possible syntax in the language.
   
   <CardGrid>
     <LinkCard
       title="Go to the Specification"
       href="/ref/spec"
     />
   </CardGrid>

4. #### Evolution

   Finally, [Evolution](/ref/evolution/overview) sub-section gives insight on important decisions about language semantics, Tact's future and links to the up-to-date changelog of Tact updates.
   
   <CardGrid>
     <LinkCard
       title="Go to the Evolution"
       href="/ref/evolution/overview"
     />
   </CardGrid>

</Steps>


## spec.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/spec.mdx)
---
title: Tact Specification
description: "Tact grammar used in its compiler is written in an Ohm language, which is based on parsing expression grammars (PEGs), which are a formal way of describing syntax, similar to regular expressions and context-free grammars."
pagefind: false  # hide the page from the search index
---

:::danger[Not implemented]
  This page is mostly a stub until it's implemented in [#76](https://github.com/tact-lang/tact-docs/issues/76)
:::

Tact grammar used in its compiler is written in an [Ohm language](https://ohmjs.org), which is based on [parsing expression grammars](http://en.wikipedia.org/wiki/Parsing_expression_grammar) (PEGs), which are a formal way of describing syntax, similar to regular expressions and context-free grammars.

{/*
    This is a comment and it's hidden from the page.

    Shiki does a bad job of highlighting Ohm via TextMate grammar, although it works well in VSCode. I think the reason may be either due to Shiki highlighting line by line or that it uses a different RegEx engine. I'm not sure what's the issue there, so until it's fixed it's better to use tree-sitter-ohm and generate ANSI sequences using its `highlight` command. Then Shiki does the rest:
*/}

```ansi
[38;5;23mTact[0m [38;5;239m{[0m

    [3;38;5;245m// Starting point of the program[0m
    [38;5;26mProgram[0m [1;38;5;239m=[0m [38;5;26mProgramItem[0m[1;38;5;239m*[0m
    [38;5;26mProgramItem[0m [1;38;5;239m=[0m [38;5;26mStruct[0m
                [1;38;5;239m|[0m [38;5;26mContract[0m
                [1;38;5;239m|[0m [38;5;26mPrimitive[0m
                [1;38;5;239m|[0m [38;5;26mStaticFunction[0m
                [1;38;5;239m|[0m [38;5;26mNativeFunction[0m
                [1;38;5;239m|[0m [38;5;26mProgramImport[0m
                [1;38;5;239m|[0m [38;5;26mTrait[0m
                [1;38;5;239m|[0m [38;5;26mConstant[0m
    [38;5;26mProgramImport[0m [1;38;5;239m=[0m [38;5;26mimport[0m [38;5;26mstringLiteral[0m [38;5;28m";"[0m

    [3;38;5;245m// Built-in declarations[0m
    [38;5;26mPrimitive[0m [1;38;5;239m=[0m [38;5;28m"primitive"[0m [38;5;26mType[0m [38;5;28m";"[0m

    [3;38;5;245m// Static function[0m
    [38;5;26mStaticFunction[0m [1;38;5;239m=[0m [38;5;26mFunction[0m
    [38;5;26mNativeFunction[0m [1;38;5;239m=[0m [38;5;26mnameAttribute[0m [38;5;28m"("[0m [38;5;26mfuncId[0m [38;5;28m")"[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mnative[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m";"[0m [3;38;5;124m--withVoid[0m
                   [1;38;5;239m|[0m [38;5;26mnameAttribute[0m [38;5;28m"("[0m [38;5;26mfuncId[0m [38;5;28m")"[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mnative[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m";"[0m [3;38;5;124m--withType[0m

    [3;38;5;245m// Field declarations[0m
    [38;5;26mType[0m [1;38;5;239m=[0m [38;5;26mtypeLiteral[0m [38;5;28m"?"[0m [3;38;5;124m--optional[0m
         [1;38;5;239m|[0m [38;5;26mtypeLiteral[0m [3;38;5;124m--required[0m
         [1;38;5;239m|[0m [38;5;28m"map"[0m [38;5;28m"<"[0m [38;5;26mtypeLiteral[0m [38;5;239m([0m[38;5;26mas[0m [38;5;26mid[0m[38;5;239m)[0m[1;38;5;239m?[0m [38;5;28m","[0m [38;5;26mtypeLiteral[0m [38;5;239m([0m[38;5;26mas[0m [38;5;26mid[0m[38;5;239m)[0m[1;38;5;239m?[0m [38;5;28m">"[0m [3;38;5;124m--map[0m
         [1;38;5;239m|[0m [38;5;28m"bounced"[0m [38;5;28m"<"[0m [38;5;26mtypeLiteral[0m [38;5;28m">"[0m [3;38;5;124m--bounced[0m
    [38;5;26mField[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m";"[0m [3;38;5;124m--default[0m
          [1;38;5;239m|[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m [3;38;5;124m--defaultWithInit[0m
          [1;38;5;239m|[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;26mas[0m [38;5;26mid[0m [38;5;28m";"[0m [3;38;5;124m--withSerialization[0m
          [1;38;5;239m|[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;26mas[0m [38;5;26mid[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m [3;38;5;124m--withSerializationAndInit[0m

    [3;38;5;245m// Constant[0m
    [38;5;26mConstantAttribute[0m [1;38;5;239m=[0m [38;5;26mvirtual[0m    [3;38;5;124m--virtual[0m
                      [1;38;5;239m|[0m [38;5;26moverride[0m   [3;38;5;124m--override[0m
                      [1;38;5;239m|[0m [38;5;26mabstract[0m   [3;38;5;124m--abstract[0m
    [38;5;26mConstant[0m [1;38;5;239m=[0m [38;5;26mConstantAttribute[0m[1;38;5;239m*[0m [1;38;5;239m~[0m[38;5;26mfun[0m [38;5;26mconst[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m [3;38;5;124m--withValue[0m
             [1;38;5;239m|[0m [38;5;26mConstantAttribute[0m[1;38;5;239m*[0m [1;38;5;239m~[0m[38;5;26mfun[0m [38;5;26mconst[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m";"[0m                [3;38;5;124m--withEmpty[0m

    [3;38;5;245m// Struct[0m
    [38;5;26mStruct[0m [1;38;5;239m=[0m [38;5;28m"struct"[0m [38;5;26mtypeLiteral[0m [38;5;28m"{"[0m [38;5;26mStructBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--originary[0m
           [1;38;5;239m|[0m [38;5;28m"message"[0m [38;5;26mtypeLiteral[0m [38;5;28m"{"[0m [38;5;26mStructBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--message[0m
           [1;38;5;239m|[0m [38;5;28m"message"[0m [38;5;28m"("[0m [38;5;26mintegerLiteral[0m [38;5;28m")"[0m [38;5;26mtypeLiteral[0m [38;5;28m"{"[0m [38;5;26mStructBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--messageWithId[0m
    [38;5;26mStructBody[0m [1;38;5;239m=[0m [38;5;26mField[0m

    [3;38;5;245m// Contract[0m
    [38;5;26mContract[0m [1;38;5;239m=[0m [38;5;26mContractAttribute[0m[1;38;5;239m*[0m [38;5;26mcontract[0m [38;5;26mid[0m [38;5;28m"{"[0m [38;5;26mContractBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--simple[0m
             [1;38;5;239m|[0m [38;5;26mContractAttribute[0m[1;38;5;239m*[0m [38;5;26mcontract[0m [38;5;26mid[0m [38;5;26mwith[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mid[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m"{"[0m [38;5;26mContractBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withTraits[0m
    [38;5;26mContractInit[0m [1;38;5;239m=[0m [38;5;28m"init"[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m
    [38;5;26mContractBody[0m [1;38;5;239m=[0m [38;5;26mField[0m
                 [1;38;5;239m|[0m [38;5;26mContractInit[0m
                 [1;38;5;239m|[0m [38;5;26mReceiveFunction[0m
                 [1;38;5;239m|[0m [38;5;26mFunction[0m
                 [1;38;5;239m|[0m [38;5;26mConstant[0m

    [3;38;5;245m// Trait[0m
    [38;5;26mTrait[0m [1;38;5;239m=[0m [38;5;26mContractAttribute[0m[1;38;5;239m*[0m [38;5;26mtrait[0m [38;5;26mid[0m [38;5;28m"{"[0m [38;5;26mTraitBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--originary[0m
          [1;38;5;239m|[0m [38;5;26mContractAttribute[0m[1;38;5;239m*[0m [38;5;26mtrait[0m [38;5;26mid[0m [38;5;26mwith[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mid[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m"{"[0m [38;5;26mTraitBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withTraits[0m
    [38;5;26mTraitBody[0m [1;38;5;239m=[0m [38;5;26mField[0m
              [1;38;5;239m|[0m [38;5;26mReceiveFunction[0m
              [1;38;5;239m|[0m [38;5;26mFunction[0m
              [1;38;5;239m|[0m [38;5;26mConstant[0m

    [3;38;5;245m// Contract attributes[0m
    [38;5;26mContractAttribute[0m [1;38;5;239m=[0m [38;5;28m"@interface"[0m [38;5;28m"("[0m [38;5;26mstringLiteral[0m [38;5;28m")"[0m [3;38;5;124m--interface[0m

    [3;38;5;245m// Function[0m
    [38;5;26mFunctionAttribute[0m [1;38;5;239m=[0m [38;5;28m"get"[0m     [3;38;5;124m--getter[0m
                      [1;38;5;239m|[0m [38;5;26mmutates[0m   [3;38;5;124m--mutates[0m
                      [1;38;5;239m|[0m [38;5;26mextends[0m   [3;38;5;124m--extends[0m
                      [1;38;5;239m|[0m [38;5;26mvirtual[0m   [3;38;5;124m--virtual[0m
                      [1;38;5;239m|[0m [38;5;26moverride[0m  [3;38;5;124m--override[0m
                      [1;38;5;239m|[0m [38;5;26minline[0m    [3;38;5;124m--inline[0m
                      [1;38;5;239m|[0m [38;5;26mabstract[0m  [3;38;5;124m--abstract[0m
    [38;5;26mFunction[0m [1;38;5;239m=[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mfun[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withVoid[0m
             [1;38;5;239m|[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mfun[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withType[0m
             [1;38;5;239m|[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mfun[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m";"[0m [3;38;5;124m--abstractVoid[0m
             [1;38;5;239m|[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mfun[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m";"[0m [3;38;5;124m--abstractType[0m
    [38;5;26mFunctionArg[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m

    [38;5;26mReceiveFunction[0m [1;38;5;239m=[0m [38;5;28m"receive"[0m [38;5;28m"("[0m [38;5;26mFunctionArg[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--simple[0m
                    [1;38;5;239m|[0m [38;5;28m"receive"[0m [38;5;28m"("[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--empty[0m
                    [1;38;5;239m|[0m [38;5;28m"receive"[0m [38;5;28m"("[0m [38;5;26mstringLiteral[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--comment[0m
                    [1;38;5;239m|[0m [38;5;28m"bounced"[0m [38;5;28m"("[0m [38;5;26mFunctionArg[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--bounced[0m
                    [1;38;5;239m|[0m [38;5;28m"external"[0m [38;5;28m"("[0m [38;5;26mFunctionArg[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--externalSimple[0m
                    [1;38;5;239m|[0m [38;5;28m"external"[0m [38;5;28m"("[0m [38;5;26mstringLiteral[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--externalComment[0m
                    [1;38;5;239m|[0m [38;5;28m"external"[0m [38;5;28m"("[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--externalEmpty[0m

    [3;38;5;245m// Statements[0m
    [38;5;26mStatement[0m [1;38;5;239m=[0m [38;5;26mStatementLet[0m
              [1;38;5;239m|[0m [38;5;26mStatementBlock[0m
              [1;38;5;239m|[0m [38;5;26mStatementReturn[0m
              [1;38;5;239m|[0m [38;5;26mStatementExpression[0m
              [1;38;5;239m|[0m [38;5;26mStatementAssign[0m
              [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssign[0m
              [1;38;5;239m|[0m [38;5;26mStatementCondition[0m
              [1;38;5;239m|[0m [38;5;26mStatementWhile[0m
              [1;38;5;239m|[0m [38;5;26mStatementRepeat[0m
              [1;38;5;239m|[0m [38;5;26mStatementUntil[0m
    [38;5;26mStatementBlock[0m [1;38;5;239m=[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m
    [38;5;26mStatementLet[0m [1;38;5;239m=[0m [38;5;26mlet[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementReturn[0m [1;38;5;239m=[0m [38;5;26mreturn[0m [38;5;26mExpression[0m [38;5;28m";"[0m [3;38;5;124m--withExpression[0m
                    [1;38;5;239m|[0m [38;5;26mreturn[0m [38;5;28m";"[0m [3;38;5;124m--withoutExpression    [0m
    [38;5;26mStatementExpression[0m [1;38;5;239m=[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAssign[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssign[0m [1;38;5;239m=[0m [38;5;26mStatementAugmentedAssignAdd[0m
                             [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssignSub[0m
                             [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssignMul[0m
                             [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssignDiv[0m
                             [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssignRem[0m
    [38;5;26mStatementAugmentedAssignAdd[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"+="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssignSub[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"-="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssignMul[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"*="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssignDiv[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"/="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssignRem[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"%="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementCondition[0m [1;38;5;239m=[0m [38;5;26mif[0m [38;5;26mExpression[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [1;38;5;239m~[0m[38;5;26melse[0m [3;38;5;124m--simple[0m
                       [1;38;5;239m|[0m [38;5;26mif[0m [38;5;26mExpression[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [38;5;26melse[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withElse[0m
                       [1;38;5;239m|[0m [38;5;26mif[0m [38;5;26mExpression[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [38;5;26melse[0m [38;5;26mStatementCondition[0m [3;38;5;124m--withElseIf[0m
    [38;5;26mStatementWhile[0m [1;38;5;239m=[0m [38;5;26mwhile[0m [38;5;28m"("[0m [38;5;26mExpression[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m
    [38;5;26mStatementRepeat[0m [1;38;5;239m=[0m [38;5;26mrepeat[0m [38;5;28m"("[0m [38;5;26mExpression[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m
    [38;5;26mStatementUntil[0m [1;38;5;239m=[0m [38;5;26mdo[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [38;5;26muntil[0m [38;5;28m"("[0m [38;5;26mExpression[0m [38;5;28m")"[0m [38;5;28m";"[0m

    [3;38;5;245m// L-value[0m
    [38;5;26mLValue[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m"."[0m [38;5;26mLValue[0m [3;38;5;124m--more[0m
           [1;38;5;239m|[0m [38;5;26mid[0m [3;38;5;124m--single[0m

    [3;38;5;245m// Expressions[0m
    [38;5;26mExpression[0m [1;38;5;239m=[0m [38;5;26mExpressionConditional[0m
    [38;5;26mExpressionConditional[0m [1;38;5;239m=[0m [38;5;26mExpressionOr[0m [38;5;28m"?"[0m [38;5;26mExpressionOr[0m [38;5;28m":"[0m [38;5;26mExpressionConditional[0m [3;38;5;124m--ternary[0m
                          [1;38;5;239m|[0m [38;5;26mExpressionOr[0m
    [38;5;26mExpressionOr[0m [1;38;5;239m=[0m [38;5;26mExpressionOr[0m [38;5;28m"||"[0m [38;5;26mExpressionAnd[0m [3;38;5;124m--or[0m
                 [1;38;5;239m|[0m [38;5;26mExpressionAnd[0m
    [38;5;26mExpressionAnd[0m [1;38;5;239m=[0m [38;5;26mExpressionAnd[0m [38;5;28m"&&"[0m [38;5;26mExpressionCompare[0m [3;38;5;124m--and[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m
    [38;5;26mExpressionCompare[0m [1;38;5;239m=[0m [38;5;26mExpressionCompare[0m [38;5;28m"!="[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--not[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m"=="[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--eq[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m">"[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--gt[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m">="[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--gte[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m"<"[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--lt[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m"<="[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--lte[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionBinary[0m
    [38;5;26mExpressionBinary[0m [1;38;5;239m=[0m [38;5;26mExpressionBinary[0m [38;5;28m">>"[0m [38;5;26mExpressionAdd[0m [3;38;5;124m--shr[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionBinary[0m [38;5;28m"<<"[0m [38;5;26mExpressionAdd[0m [3;38;5;124m--shl[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionBinary[0m [38;5;28m"&"[0m [38;5;26mExpressionAdd[0m [3;38;5;124m--bin_and[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionBinary[0m [38;5;28m"|"[0m [38;5;26mExpressionAdd[0m [3;38;5;124m--bin_or[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionAdd[0m
    [38;5;26mExpressionAdd[0m [1;38;5;239m=[0m [38;5;26mExpressionAdd[0m [38;5;28m"+"[0m [1;38;5;239m~[0m[38;5;28m"+"[0m [38;5;26mExpressionMul[0m [3;38;5;124m--add[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionAdd[0m [38;5;28m"-"[0m [1;38;5;239m~[0m[38;5;28m"-"[0m [38;5;26mExpressionMul[0m [3;38;5;124m--sub[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionMul[0m
    [38;5;26mExpressionMul[0m [1;38;5;239m=[0m [38;5;26mExpressionMul[0m [38;5;28m"*"[0m [38;5;26mExpressionUnary[0m [3;38;5;124m--mul[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionMul[0m [38;5;28m"/"[0m [38;5;26mExpressionUnary[0m [3;38;5;124m--div[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionMul[0m [38;5;28m"%"[0m [38;5;26mExpressionUnary[0m [3;38;5;124m--rem[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionUnary[0m
    [38;5;26mExpressionUnary[0m [1;38;5;239m=[0m [38;5;28m"-"[0m [38;5;26mExpressionUnarySuffix[0m [3;38;5;124m--neg[0m
                    [1;38;5;239m|[0m [38;5;28m"+"[0m [38;5;26mExpressionUnarySuffix[0m [3;38;5;124m--add[0m
                    [1;38;5;239m|[0m [38;5;28m"!"[0m [38;5;26mExpressionUnarySuffix[0m [3;38;5;124m--not[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionUnarySuffix[0m
    [38;5;26mExpressionUnarySuffix[0m [1;38;5;239m=[0m [38;5;26mExpressionValue[0m [38;5;28m"!!"[0m [3;38;5;124m--notNull[0m
                          [1;38;5;239m|[0m [38;5;26mExpressionValue[0m
    [38;5;26mExpressionBracket[0m [1;38;5;239m=[0m [38;5;28m"("[0m [38;5;26mExpression[0m [38;5;28m")"[0m

    [3;38;5;245m// Order is important[0m
    [38;5;26mExpressionValue[0m [1;38;5;239m=[0m [38;5;26mExpressionCall[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionField[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionStaticCall[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionBracket[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionNew[0m
                    [1;38;5;239m|[0m [38;5;26mintegerLiteral[0m
                    [1;38;5;239m|[0m [38;5;26mboolLiteral[0m
                    [1;38;5;239m|[0m [38;5;26mid[0m
                    [1;38;5;239m|[0m [38;5;26mnull[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionInitOf[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionString[0m
    [38;5;26mExpressionString[0m [1;38;5;239m=[0m [38;5;26mstringLiteral[0m
    [38;5;26mExpressionField[0m [1;38;5;239m=[0m [38;5;26mExpressionValue[0m [38;5;28m"."[0m [38;5;26mid[0m [1;38;5;239m~[0m[38;5;28m"("[0m
    [38;5;26mExpressionCall[0m [1;38;5;239m=[0m [38;5;26mExpressionValue[0m [38;5;28m"."[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mExpression[0m[38;5;239m,[0m [38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m
    [38;5;26mExpressionNew[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m"{"[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mNewParameter[0m[38;5;239m,[0m [38;5;28m","[0m[38;5;239m>[0m [38;5;28m"}"[0m
    [38;5;26mNewParameter[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mExpression[0m
    [38;5;26mExpressionStaticCall[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mExpression[0m[38;5;239m,[0m [38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m
    [38;5;26mExpressionInitOf[0m [1;38;5;239m=[0m [38;5;26minitOf[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mExpression[0m[38;5;239m,[0m [38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m

    [3;38;5;245m// Type Literal[0m
    [38;5;26mtypeLiteral[0m [1;38;5;239m=[0m [38;5;26mletterAsciiUC[0m [38;5;26mtypeLiteralPart[0m[1;38;5;239m*[0m
    [38;5;26mtypeLiteralPart[0m [1;38;5;239m=[0m [38;5;26mletterAscii[0m [1;38;5;239m|[0m [1;38;5;26mdigit[0m [1;38;5;239m|[0m [38;5;28m"_"[0m

    [3;38;5;245m// Integer Literal[0m
    [3;38;5;245m// hexDigit defined in Ohm's built-in rules (otherwise: hexDigit = "0".."9" | "a".."f" | "A".."F")[0m
    [3;38;5;245m// digit defined in Ohm's built-in rules (otherwise: digit = "0".."9")[0m
    [38;5;26mintegerLiteral[0m [1;38;5;239m=[0m [38;5;26mintegerLiteralHex[0m [1;38;5;239m|[0m [38;5;26mintegerLiteralBin[0m [1;38;5;239m|[0m [38;5;26mintegerLiteralOct[0m [1;38;5;239m|[0m [38;5;26mintegerLiteralDec[0m [3;38;5;245m// Order is important[0m
    [38;5;26mintegerLiteralDec[0m [1;38;5;239m=[0m [38;5;26mnonZeroDigit[0m [38;5;239m([0m[38;5;28m"_"[0m[1;38;5;239m?[0m [1;38;5;26mdigit[0m[38;5;239m)[0m[1;38;5;239m*[0m  [3;38;5;124m--nonZeroIntegerLiteralDec[0m
                      [1;38;5;239m|[0m [38;5;28m"0"[0m [1;38;5;26mdigit[0m[1;38;5;239m*[0m                  [3;38;5;124m--integerLiteralWithLeadingZero[0m
    [38;5;26mintegerLiteralHex[0m [1;38;5;239m=[0m [38;5;239m([0m[38;5;28m"0x"[0m [1;38;5;239m|[0m [38;5;28m"0X"[0m[38;5;239m)[0m [1;38;5;26mhexDigit[0m [38;5;239m([0m[38;5;28m"_"[0m[1;38;5;239m?[0m [1;38;5;26mhexDigit[0m[38;5;239m)[0m[1;38;5;239m*[0m
    [38;5;26mintegerLiteralBin[0m [1;38;5;239m=[0m [38;5;239m([0m[38;5;28m"0b"[0m [1;38;5;239m|[0m [38;5;28m"0B"[0m[38;5;239m)[0m [38;5;26mbinDigit[0m [38;5;239m([0m[38;5;28m"_"[0m[1;38;5;239m?[0m [38;5;26mbinDigit[0m[38;5;239m)[0m[1;38;5;239m*[0m
    [38;5;26mintegerLiteralOct[0m [1;38;5;239m=[0m [38;5;239m([0m[38;5;28m"0o"[0m [1;38;5;239m|[0m [38;5;28m"0O"[0m[38;5;239m)[0m [38;5;26moctDigit[0m [38;5;239m([0m[38;5;28m"_"[0m[1;38;5;239m?[0m [38;5;26moctDigit[0m[38;5;239m)[0m[1;38;5;239m*[0m
    [38;5;26mbinDigit[0m [1;38;5;239m=[0m [38;5;28m"0"[0m [1;38;5;239m|[0m [38;5;28m"1"[0m
    [38;5;26moctDigit[0m [1;38;5;239m=[0m [38;5;28m"0"[0m[1;38;5;239m..[0m[38;5;28m"7"[0m
    [38;5;26mnonZeroDigit[0m [1;38;5;239m=[0m [38;5;28m"1"[0m[1;38;5;239m..[0m[38;5;28m"9"[0m

    [3;38;5;245m// Letters[0m
    [38;5;26mletterAsciiLC[0m [1;38;5;239m=[0m [38;5;28m"a"[0m[1;38;5;239m..[0m[38;5;28m"z"[0m
    [38;5;26mletterAsciiUC[0m [1;38;5;239m=[0m [38;5;28m"A"[0m[1;38;5;239m..[0m[38;5;28m"Z"[0m
    [38;5;26mletterAscii[0m [1;38;5;239m=[0m [38;5;26mletterAsciiLC[0m [1;38;5;239m|[0m [38;5;26mletterAsciiUC[0m
    [38;5;26mletterComment[0m [1;38;5;239m=[0m [38;5;26mletterAsciiLC[0m [1;38;5;239m|[0m [38;5;26mletterAsciiUC[0m [1;38;5;239m|[0m [1;38;5;26mdigit[0m [1;38;5;239m|[0m [38;5;28m"_"[0m

    [3;38;5;245m// ID Literal[0m
    [38;5;26midStart[0m [1;38;5;239m=[0m [38;5;26mletterAscii[0m [1;38;5;239m|[0m [38;5;28m"_"[0m
    [38;5;26midPart[0m [1;38;5;239m=[0m [38;5;26mletterAscii[0m [1;38;5;239m|[0m [1;38;5;26mdigit[0m [1;38;5;239m|[0m [38;5;28m"_"[0m
    [38;5;26mid[0m [1;38;5;239m=[0m [1;38;5;239m~[0m[38;5;26mreservedWord[0m [1;38;5;239m#[0m[38;5;26midStart[0m [1;38;5;239m#[0m[38;5;239m([0m[38;5;26midPart[0m[1;38;5;239m*[0m[38;5;239m)[0m

    [3;38;5;245m// FunC id[0m
    [38;5;26mfuncLetter[0m [1;38;5;239m=[0m [38;5;26mletterAscii[0m [1;38;5;239m|[0m [38;5;28m"_"[0m [1;38;5;239m|[0m [38;5;28m"'"[0m [1;38;5;239m|[0m [38;5;28m"?"[0m [1;38;5;239m|[0m [38;5;28m"!"[0m [1;38;5;239m|[0m [38;5;28m"::"[0m [1;38;5;239m|[0m [38;5;28m"&"[0m
    [38;5;26mfuncId[0m [1;38;5;239m=[0m [38;5;26mfuncLetter[0m [1;38;5;239m#[0m[38;5;239m([0m[38;5;26mfuncLetter[0m [1;38;5;239m|[0m [1;38;5;26mdigit[0m[38;5;239m)[0m[1;38;5;239m*[0m

    [3;38;5;245m// Bool Literal[0m
    [38;5;26mboolLiteral[0m [1;38;5;239m=[0m [38;5;239m([0m[38;5;28m"true"[0m [1;38;5;239m|[0m [38;5;28m"false"[0m[38;5;239m)[0m [1;38;5;239m~[0m[38;5;26midPart[0m

    [3;38;5;245m// String literal[0m
    [38;5;26mstringLiteralCharacter[0m [1;38;5;239m=[0m [1;38;5;239m~[0m[38;5;239m([0m[38;5;28m"[0m[38;5;30m\"[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;28m"[0m[38;5;30m\\[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;26mlineTerminator[0m[38;5;239m)[0m [1;38;5;26many[0m
    [38;5;26mstringLiteral[0m [1;38;5;239m=[0m [38;5;28m"[0m[38;5;30m\"[0m[38;5;28m"[0m [38;5;26mstringLiteralCharacter[0m[1;38;5;239m*[0m [38;5;28m"[0m[38;5;30m\"[0m[38;5;28m"[0m

    [3;38;5;245m// Keywords[0m
    [3;38;5;245m// NOTE Order is important[0m
    [38;5;26mkeyword[0m [1;38;5;239m=[0m [38;5;26mfun[0m
            [1;38;5;239m|[0m [38;5;26mlet[0m
            [1;38;5;239m|[0m [38;5;26mreturn[0m
            [1;38;5;239m|[0m [38;5;26mextend[0m
            [1;38;5;239m|[0m [38;5;26mnative[0m
            [1;38;5;239m|[0m [38;5;26mpublic[0m
            [1;38;5;239m|[0m [38;5;26mnull[0m
            [1;38;5;239m|[0m [38;5;26mif[0m
            [1;38;5;239m|[0m [38;5;26melse[0m
            [1;38;5;239m|[0m [38;5;26mwhile[0m
            [1;38;5;239m|[0m [38;5;26mrepeat[0m
            [1;38;5;239m|[0m [38;5;26mdo[0m
            [1;38;5;239m|[0m [38;5;26muntil[0m
            [1;38;5;239m|[0m [38;5;26mas[0m
            [1;38;5;239m|[0m [38;5;26mmutates[0m
            [1;38;5;239m|[0m [38;5;26mextends[0m
            [1;38;5;239m|[0m [38;5;26mimport[0m
            [1;38;5;239m|[0m [38;5;26mwith[0m
            [1;38;5;239m|[0m [38;5;26mtrait[0m
            [1;38;5;239m|[0m [38;5;26minitOf[0m
            [1;38;5;239m|[0m [38;5;26moverride[0m
            [1;38;5;239m|[0m [38;5;26mabstract[0m
            [1;38;5;239m|[0m [38;5;26mvirtual[0m
            [1;38;5;239m|[0m [38;5;26minline[0m
            [1;38;5;239m|[0m [38;5;26mconst[0m
    [38;5;26mcontract[0m [1;38;5;239m=[0m [38;5;28m"contract"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mlet[0m [1;38;5;239m=[0m [38;5;28m"let"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mfun[0m [1;38;5;239m=[0m [38;5;28m"fun"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mreturn[0m [1;38;5;239m=[0m [38;5;28m"return"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mextend[0m [1;38;5;239m=[0m [38;5;28m"extend"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mnative[0m [1;38;5;239m=[0m [38;5;28m"native"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mpublic[0m [1;38;5;239m=[0m [38;5;28m"public"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mnull[0m [1;38;5;239m=[0m [38;5;28m"null"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mif[0m [1;38;5;239m=[0m [38;5;28m"if"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26melse[0m [1;38;5;239m=[0m [38;5;28m"else"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mwhile[0m [1;38;5;239m=[0m [38;5;28m"while"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mrepeat[0m [1;38;5;239m=[0m [38;5;28m"repeat"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mdo[0m [1;38;5;239m=[0m [38;5;28m"do"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26muntil[0m [1;38;5;239m=[0m [38;5;28m"until"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mas[0m [1;38;5;239m=[0m [38;5;28m"as"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mmutates[0m [1;38;5;239m=[0m [38;5;28m"mutates"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mextends[0m [1;38;5;239m=[0m [38;5;28m"extends"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mimport[0m [1;38;5;239m=[0m [38;5;28m"import"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mwith[0m [1;38;5;239m=[0m [38;5;28m"with"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mtrait[0m [1;38;5;239m=[0m [38;5;28m"trait"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26minitOf[0m [1;38;5;239m=[0m [38;5;28m"initOf"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mvirtual[0m [1;38;5;239m=[0m [38;5;28m"virtual"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26moverride[0m [1;38;5;239m=[0m [38;5;28m"override"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26minline[0m [1;38;5;239m=[0m [38;5;28m"inline"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mconst[0m [1;38;5;239m=[0m [38;5;28m"const"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mabstract[0m [1;38;5;239m=[0m [38;5;28m"abstract"[0m [1;38;5;239m~[0m[38;5;26midPart[0m

    [3;38;5;245m// Attributes[0m
    [38;5;26mnameAttribute[0m [1;38;5;239m=[0m [38;5;28m"@name"[0m

    [3;38;5;245m// Reserved[0m
    [38;5;26mreservedWord[0m [1;38;5;239m=[0m [38;5;26mkeyword[0m

    [3;38;5;245m// Comments[0m
    [38;5;26mspace[0m [1;38;5;239m+=[0m [38;5;26mcomment[0m [1;38;5;239m|[0m [38;5;26mlineTerminator[0m
    [38;5;26mcomment[0m [1;38;5;239m=[0m [38;5;26mmultiLineComment[0m [1;38;5;239m|[0m [38;5;26msingleLineComment[0m
    [38;5;26mlineTerminator[0m [1;38;5;239m=[0m [38;5;28m"[0m[38;5;30m\n[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;28m"[0m[38;5;30m\r[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;28m"[0m[38;5;30m\u2028[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;28m"[0m[38;5;30m\u2029[0m[38;5;28m"[0m
    [38;5;26mmultiLineComment[0m [1;38;5;239m=[0m [38;5;28m"/*"[0m [38;5;239m([0m[1;38;5;239m~[0m[38;5;28m"*/"[0m [1;38;5;26many[0m[38;5;239m)[0m[1;38;5;239m*[0m [38;5;28m"*/"[0m
    [38;5;26msingleLineComment[0m [1;38;5;239m=[0m [38;5;28m"//"[0m [38;5;239m([0m[1;38;5;239m~[0m[38;5;26mlineTerminator[0m [1;38;5;26many[0m[38;5;239m)[0m[1;38;5;239m*[0m
[38;5;239m}[0m
```


## standard-libraries.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/standard-libraries.mdx)
---
title: Standard libraries overview
description: "Some libraries come bundled with Tact compiler, but aren't automatically included to your project until explicitly made to"
prev:
  link: /ref/core-advanced
  label: Advanced
---

Some libraries (also referred to as standard libraries or stdlibs) come bundled with Tact compiler, but aren't automatically included to your project until explicitly made to.

To import any standard library, use the [`import{:tact}` keyword](/book/import) followed by the name of that library in a [string][p], like so:

```tact
// This would include everything from @stdlib/deploy into your codebase:
import "@stdlib/deploy";
```

## List of standard libraries: {#list}

Library                  | Description                                                      | Commonly used APIs
:----------------------- | :--------------------------------------------------------------- | :-----------------
[`@stdlib/config`][1]    | Config and elector address retrieval.                            | [`getConfigAddress(){:tact}`][gca], [`getElectorAddress(){:tact}`][gea]
[`@stdlib/content`][2]   | Encoding off-chain link [strings][p] to a [`Cell{:tact}`][cell]. | [`createOffchainContent(){:tact}`][coff]
[`@stdlib/deploy`][3]    | Unified mechanism for deployments.                               | [`Deployable{:tact}`][dep], [`FactoryDeployable{:tact}`][fcd]
[`@stdlib/dns`][4]       | Resolution of [DNS][dns] names.                                  | [`DNSResolver{:tact}`][dnsr], [`dnsInternalVerify(){:tact}`][dnsi]
[`@stdlib/ownable`][5]   | Traits for ownership management.                                 | [`Ownable{:tact}`][own], [`OwnableTransferable{:tact}`][ownt]
[`@stdlib/stoppable`][6] | Traits that allow contract stops. Requires [@stdlib/ownable][5]. | [`Stoppable{:tact}`][stp], [`Resumable{:tact}`][res]

[1]: /ref/stdlib-config
[gca]: /ref/stdlib-config#getconfigaddress
[gea]: /ref/stdlib-config#getelectoraddress

[2]: /ref/stdlib-content
[coff]: /ref/stdlib-content#createoffchaincontent

[3]: /ref/stdlib-deploy
[dep]: /ref/stdlib-deploy#deployable
[fcd]: /ref/stdlib-deploy#factorydeployable

[4]: /ref/stdlib-dns
[dnsr]: /ref/stdlib-dns#dnsresolver
[dnsi]: /ref/stdlib-dns#dnsinternalverify

[5]: /ref/stdlib-ownable
[own]: /ref/stdlib-ownable#ownable
[ownt]: /ref/stdlib-ownable#ownabletransferable

[6]: /ref/stdlib-stoppable
[stp]: /ref/stdlib-stoppable#stoppable
[res]: /ref/stdlib-stoppable#resumable

[p]: /book/types#primitive-types
[cell]: /book/cells#cells
[dns]: https://docs.ton.org/participate/web3/dns


## stdlib-config.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/stdlib-config.mdx)
---
title: "@stdlib/config"
description: "Provides functions for config and elector Address retrieval"
---

Provides functions for config and elector Address retrieval.

To use this library, import `@stdlib/config`:

```tact
import "@stdlib/config";
```

## Functions

### getConfigAddress

```tact
fun getConfigAddress(): Address;
```

Retrieves config parameter $0$ as an [`Address{:tact}`][p].

Source code:

```tact
fun getConfigAddress(): Address {
    let cell: Cell = getConfigParam(0)!!;
    let sc: Slice = cell.beginParse();
    return newAddress(-1, sc.loadUint(256));
}
```

### getElectorAddress

```tact
fun getElectorAddress(): Address;
```

Retrieves config parameter $1$ as an [`Address{:tact}`][p].

Source code:

```tact
fun getElectorAddress(): Address {
    let cell: Cell = getConfigParam(1)!!;
    let sc: Slice = cell.beginParse();
    return newAddress(-1, sc.loadUint(256));
}
```

## Sources

* [config.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/config.tact)

[p]: /book/types#primitive-types


## stdlib-content.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/stdlib-content.mdx)
---
title: "@stdlib/content"
description: "Provides a function for encoding an off-chain link from a String to a Cell"
---

Provides a function for encoding an off-chain link from a [`String{:tact}`][p] to a [`Cell{:tact}`][cell].

To use this library, import `@stdlib/content`:

```tact
import "@stdlib/content";
```

## Functions

### createOffchainContent

```tact
fun createOffchainContent(link: String): Cell;
```

Encodes an off-chain `link` from a [`String{:tact}`][p] to a [`Cell{:tact}`][cell].

Source code:

```tact
fun createOffchainContent(link: String): Cell {
    let builder: StringBuilder = beginStringFromBuilder(beginCell().storeUint(0x01, 8));
    builder.append(link);
    return builder.toCell();
}
```

## Sources

* [content.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/content.tact)

[p]: /book/types#primitive-types
[cell]: /book/cells#cells


## stdlib-deploy.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/stdlib-deploy.mdx)
---
title: "@stdlib/deploy"
description: "Provides unified mechanisms for deployments"
---

Provides unified mechanisms for deployments.

To use this library, import `@stdlib/deploy`:

```tact
import "@stdlib/deploy";
```

## Messages

### Deploy

```tact
message Deploy {
    queryId: Int as uint64;
}
```

### DeployOk

```tact
message DeployOk {
    queryId: Int as uint64;
}
```

### FactoryDeploy

```tact
message FactoryDeploy {
    queryId: Int as uint64;
    cashback: Address;
}
```

## Traits

### Deployable

Simplest trait `Deployable{:tact}` that provides a handy unified mechanism for deployments by implementing a simple receiver for the [Deploy](#deploy) message.

All contracts are deployed by sending them a message. While any message can be used for this purpose, best practice is to use the special [Deploy](#deploy) message.

This message has a single field, `queryId`, provided by the deployer (usually set to zero). If the deployment succeeds, the contract will reply with a [DeployOk](#deployok) message and echo the same `queryId` in the response.

Source code:

```tact
trait Deployable {
    receive(deploy: Deploy) {
        self.notify(DeployOk{queryId: deploy.queryId}.toCell());
    }
}
```

Usage example:

```tact /Deployable/
import "@stdlib/deploy";

contract ExampleContract with Deployable {
    // Now, this contract has a receiver for Deploy message
}
```

### FactoryDeployable

Trait `FactoryDeployable{:tact}` provides a handy unified mechanism for chained deployments.

Source code:

```tact
trait FactoryDeployable  {
    receive(deploy: FactoryDeploy) {
        self.forward(deploy.cashback, DeployOk{queryId: deploy.queryId}.toCell(), false, null);
    }
}
```

Usage example:

```tact /FactoryDeployable/
import "@stdlib/deploy";

contract ExampleContract with FactoryDeployable {
    // Now, this contract has a receiver for FactoryDeploy message
}
```

## Sources

* [deploy.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/deploy.tact)


## stdlib-dns.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/stdlib-dns.mdx)
---
title: "@stdlib/dns"
description: "Provides means for resolution of DNS names on TON"
---

Provides means for resolution of [DNS](https://docs.ton.org/participate/web3/dns) names.

To use this library, import `@stdlib/dns`:

```tact
import "@stdlib/dns";
```

## Structs

### DNSResolveResult

```tact
struct DNSResolveResult {
    prefix: Int;
    record: Cell?;
}
```

## Functions

### dnsStringToInternal

```tact
@name(dns_string_to_internal)
native dnsStringToInternal(str: String): Slice?;
```

Converts a DNS string to a [`Slice{:tact}`][slice] or [`null{:tact}`](/book/optionals), if it's impossible.

Source code (FunC): [dns.fc#L1](https://github.com/tact-lang/tact/blob/e69c7fc99dc9be3fa5ff984456c03ffe8fed3677/stdlib/libs/dns.fc#L1)

### dnsInternalNormalize

```tact
@name(dns_internal_normalize)
native dnsInternalNormalize(src: Slice): Slice;
```

Normalizes the internal DNS representation of the [`Slice{:tact}`][slice]. The passed [`Slice{:tact}`][slice] must not have any references, otherwise an exception with [exit code 134](/book/exit-codes#134) will be thrown: `Invalid argument`.

Source code (FunC): [dns.fc#L125](https://github.com/tact-lang/tact/blob/e69c7fc99dc9be3fa5ff984456c03ffe8fed3677/stdlib/libs/dns.fc#L125)

### dnsInternalVerify

```tact
@name(dns_internal_verify)
native dnsInternalVerify(subdomain: Slice): Bool;
```

Verifies the internal DNS representation of the subdomain [`Slice{:tact}`][slice].

Source code (FunC): [dns.fc#L81](https://github.com/tact-lang/tact/blob/e69c7fc99dc9be3fa5ff984456c03ffe8fed3677/stdlib/libs/dns.fc#L81)

### dnsExtractTopDomainLength

```tact
fun dnsExtractTopDomainLength(subdomain: Slice): Int;
```

Calculates length of a top domain in the `subdomain` [`Slice{:tact}`][slice].

Source code:

```tact
fun dnsExtractTopDomainLength(subdomain: Slice): Int {
    let i: Int = 0;
    let needBreak: Bool = false;
    do {
        let char: Int = subdomain.loadUint(8); // we do not check domain.length because it MUST contain \0 character
        needBreak = char == 0;
        if (!needBreak) {
            i += 8;
        }
    } until (needBreak);
    require(i != 0, "Invalid DNS name");
    return i;
}
```

### dnsExtractTopDomain

```tact
fun dnsExtractTopDomain(subdomain: Slice): Slice;
```

Extracts top domain from a `subdomain` [`Slice{:tact}`][slice].

Source code:

```tact
fun dnsExtractTopDomain(subdomain: Slice): Slice {
    let len: Int = dnsExtractTopDomainLength(subdomain);
    return subdomain.loadBits(len);
}
```

### dnsResolveNext

```tact
fun dnsResolveNext(address: Address): Cell;
```

Resolves an `address` [`Address{:tact}`][p] into a [`Cell{:tact}`][cell].

Source code:

```tact
fun dnsResolveNext(address: Address): Cell {
    return beginCell()
        .storeUint(0xba93, 16)
        .storeAddress(address)
        .endCell();
}
```

### dnsResolveWallet

```tact
fun dnsResolveWallet(address: Address): Cell;
```

Resolves a wallet `address` [`Address{:tact}`][p] into a [`Cell{:tact}`][cell].

Source code:

```tact
fun dnsResolveWallet(address: Address): Cell {
    return beginCell()
        .storeUint(0x9fd3, 16)
        .storeAddress(address)
        .storeUint(0, 8)
        .endCell();
}
```

## Traits

### DNSResolver

Trait `DNSResolver` provides two helper functions for DNS resolution:

1. [getter function](/book/functions#getter-functions) `dnsresolve(){:tact}`, which corresponds to its [FunC variant](https://docs.ton.org/develop/howto/subresolvers#dnsresolve-code).
2. virtual function `doResolveDNS(){:tact}`, which creates a struct [DNSResolveResult](#dnsresolveresult) out of subdomain [`Slice{:tact}`][slice] bits.

Source code:

```tact
trait DNSResolver {
    get fun dnsresolve(subdomain: Slice, category: Int): DNSResolveResult {
        // Normalize
        let delta: Int = 0;
        if (subdomain.preloadUint(8) == 0) {
            subdomain.loadUint(8); // Skip first byte
            delta += 8;
        }

        // Checks correctness
        require(dnsInternalVerify(subdomain), "Invalid DNS name");

        // Resolve
        let res: DNSResolveResult = self.doResolveDNS(subdomain, category);
        return DNSResolveResult{prefix: res.prefix + delta, record: res.record};
    }
    virtual fun doResolveDNS(subdomain: Slice, category: Int): DNSResolveResult {
        return DNSResolveResult{prefix: subdomain.bits(), record: null};
    }
}
```

Usage example:

```tact
import "@stdlib/dns";

contract ExampleContract with DNSResolver {
    // Now, this contract has a:
    // 1. dnsresolve getter function
    // 2. doResolveDNS virtual function
}
```

## Sources

* [dns.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/dns.tact)
* [dns.fc](https://github.com/tact-lang/tact/blob/e69c7fc99dc9be3fa5ff984456c03ffe8fed3677/stdlib/libs/dns.fc)

[p]: /book/types#primitive-types
[cell]: /book/cells#cells
[slice]: /book/cells#slices


## stdlib-ownable.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/stdlib-ownable.mdx)
---
title: "@stdlib/ownable"
description: "Provides traits for ownable contracts, which are commonly required by other traits"
---

Provides [traits](/book/types#composite-types) for ownable contracts. These traits are commonly required by other traits.

To use this library, import `@stdlib/ownable`:

```tact
import "@stdlib/ownable";
```

## Messages

### ChangeOwner

```tact
message ChangeOwner {
    queryId: Int as uint64;
    newOwner: Address;
}
```

### ChangeOwnerOk

```tact
message ChangeOwnerOk {
    queryId: Int as uint64;
    newOwner: Address;
}
```

## Traits

### Ownable

[Trait](/book/types#composite-types) `Ownable{:tact}` declares an owner (non-editable) of a [contract](/book/contracts) and provides a helper function `requireOwner(){:tact}` that checks that a message was sent by an owner.

This [trait](/book/types#composite-types) requires a field `owner: Address{:tact}` to be declared and exposes a [getter function](/book/functions#getter-functions) `owner(){:tact}`, which reads it from the [contract](/book/contracts).

Source code:

```tact
@interface("org.ton.ownable")
trait Ownable {
    owner: Address;

    fun requireOwner() {
        nativeThrowUnless(132, sender() == self.owner);
    }

    get fun owner(): Address {
        return self.owner;
    }
}
```

Usage example:

```tact /Ownable/
import "@stdlib/ownable";

contract ExampleContract with Ownable {
    owner: Address;

    init(owner: Address) {
        self.owner = owner;
    }
}
```

### OwnableTransferable

`OwnableTransferable{:tact}` is an extension of an [`Ownable{:tact}`](#ownable) that allows to transfer ownership of a contract to another address. It provides a secure handle [Message](/book/structs-and-messages#messages) [`ChangeOwner{:tact}`](#changeowner) that could be called by an owner to transfer ownership.

If the owner transfer request succeeds, the contract will reply with a [`ChangeOwnerOk{:tact}`](#changeownerok) [Message](/book/structs-and-messages#messages).

Source code:

```tact
@interface("org.ton.ownable.transferable.v2")
trait OwnableTransferable with Ownable {
    owner: Address;

    receive(msg: ChangeOwner) {
        // Check if the sender is the owner
        self.requireOwner();

        // Update owner
        self.owner = msg.newOwner;

        // Reply result
        self.reply(ChangeOwnerOk{ queryId: msg.queryId, newOwner: msg.newOwner }.toCell());
    }
}
```

Usage example:

```tact /OwnableTransferable/
import "@stdlib/ownable";

contract ExampleContract with OwnableTransferable {
    owner: Address;

    init(owner: Address) {
        self.owner = owner;
    }
}
```

## Sources

* [ownable.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/ownable.tact)


## stdlib-stoppable.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/stdlib-stoppable.mdx)
---
title: "@stdlib/stoppable"
description: "Provides traits that allow to stop a contract, which are useful for emergency or maintenance modes"
---

Provides [traits](/book/types#composite-types) that allow to stop a [contract](/book/contracts). Useful for emergency or maintenance modes. Requires an [`Ownable{:tact}`](/ref/stdlib-ownable#ownable) trait from [`@stdlib/ownable`](/ref/stdlib-ownable). This trait just manages a single flag `stopped` in the contract and handling stopped state have to be done in the contract itself.

To use this library, import `@stdlib/stoppable`:

```tact
import "@stdlib/stoppable"; // this would automatically import @stdlib/ownable too!
```

## Traits

### Stoppable

[Trait](/book/types#composite-types) `Stoppable{:tact}` implements receiver for the [Message](/book/structs-and-messages#messages) [string](/book/types#primitive-types) "Stop" that can be sent by owner, implements `stopped(){:tact}` [getter function](/book/functions#getter-functions) that returns `true{:tact}` if contract is stopped (or `false{:tact}` otherwise) and provides private (non-getter) functions `requireNotStopped(){:tact}` and `requireStopped(){:tact}`.

Source code:

```tact
@interface("org.ton.stoppable")
trait Stoppable with Ownable {
    stopped: Bool;
    owner: Address;

    fun requireNotStopped() {
        require(!self.stopped, "Contract stopped");
    }

    fun requireStopped() {
        require(self.stopped, "Contract not stopped");
    }

    receive("Stop") {
        self.requireOwner();
        self.requireNotStopped();
        self.stopped = true;
        self.reply("Stopped".asComment());
    }

    get fun stopped(): Bool {
        return self.stopped;
    }
}
```

Usage example:

```tact /Stoppable/
import "@stdlib/ownable";
import "@stdlib/stoppable";

contract MyContract with Stoppable {
    owner: Address;
    stopped: Bool;

    init(owner: Address) {
        self.owner = owner;
        self.stopped = false;
    }
}
```

### Resumable

`Resumable{:tact}` [trait](/book/types#composite-types) extends [`Stoppable{:tact}`](#stoppable) trait and allows to resume [contract](/book/contracts) execution.

Source code:

```tact
@interface("org.ton.resumable")
trait Resumable with Stoppable {
    stopped: Bool;
    owner: Address;

    receive("Resume") {
        self.requireOwner();
        self.requireStopped();
        self.stopped = false;
        self.reply("Resumed".asComment());
    }
}
```

Usage example:

```tact /Resumable/
import "@stdlib/ownable";
import "@stdlib/stoppable";

contract MyContract with Resumable {
    owner: Address;
    stopped: Bool;

    init(owner: Address) {
        self.owner = owner;
        self.stopped = false;
    }
}
```

## Sources

* [stoppable.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/stoppable.tact)


## otp-001.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/evolution/otp-001.mdx)
---
title: "OTP-001: Supported Interfaces"
description: "This proposal recommends a way to introspect smart contracts and find out what interfaces they support"
sidebar:
  order: 1
---

This proposal recommends a way to introspect smart contracts and find out what interfaces they support.

## Motivation

Right now it is impossible to guess what a user wants to do with a contract or can't figure out what the transaction is about because there is no clear way to find what a contract is about. Humans need to remember or guess what this was about in most ways.

## Guide

When human tries to sign a transaction, they need to understand clearly what they are doing: minting, token transfer, staking, DAO voting. While Ethereum wallets support signing arbitrary structures it is still not clear what are you signing and what's the implications of doing so. In the same way, explorers can't show what's going on in a nice form.

The start of a working with specific contract is a performing introspection - figuring out what the contract declares about itself. When the app knows what this contract is about it could build a good UI, show transaction history, and verify what a human tries to sign.

This proposal describes a way to report what interfaces the contract supports.

Interfaces are defined in a free-form specification. Unlike most of the other approaches, this proposal defines interface as not only the technical interface of a contract (get methods, internal messages, etc) but also a description of its behavior. Attaching a hash of the representation of a technical interface of a contract could cause conflicts between different standards and because of this proposal defines interfaces loosely. Also, it allows an interface to be more fluid, for example token that couldn't be transferred could be just a contract that will have to get the method `can_transfer` that returns `false` and this would mean that this token doesn't support transfers at all without the need to implement this method.

Interface IDs are hashes of reverse domain names (like packages in Java), this avoids clashes of names between different teams if they want to build something just for themselves.

## Specification

In order to support the introspection contract MUST implement the supports_interface GET method:

```(int...) supported_interfaces()```
Which returns a list of supported interface codes. The first value MUST be `hash("org.ton.introspection.v0")` = `123515602279859691144772641439386770278`.
If the first value is incorrect app MUST stop attempting to introspect the contract.
Example
```func
_ supported_interfaces() method_id {
    return (123515602279859691144772641439386770278);
}
```

The hash of an interface is defined as truncated to 128 bits SHA256.

## Drawbacks

This proposal doesn't guarantee that the contract would behave correctly to an interface, also it doesn't provide a guaranteed way to avoid name clashes between different interfaces. This is a non-goal for this proposal.

This proposal isn't tied to a specific technical interface. This could lead to multiple interfaces that do the same thing but with different IDs. This is a non-goal for this proposal since a centralized registry would be very useful for existing interfaces and a custom one would be used mostly in-house.

## Rationale and alternatives

- Why 128 bit? We are looking at a global namespace that we need to keep without conflicts, we can't use anything much smaller since the probability of conflicts would be much higher. We are looking at UUID-like entropy that is exactly 128-bit and is time-proven. More than 128 is too wasteful.
- Why freeform? As mentioned before, it is easier just to define some ID to start work early and then eventually build a standard. Also interfaces (like ERC20) usually not just a technical interface, but also a number of rules on how to work with it.
- Why not find out what contract supports by decompiling? Explicit is always better than implicit in open-world scenarios. We can't rely on our "disassembling" capabilities to perform introspections, even small errors could be fatal.
- Why not hash of representation? Right now there are no compilers that support that, also this proposal is future-proof. If anyone would want to build something more automated they could easily build their own hashes by their own rules keeping everything the same for external observers.

## Prior art

[Ethereum Interface Detection](https://eips.ethereum.org/EIPS/eip-165)


## otp-002.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/evolution/otp-002.mdx)
---
title: "OTP-002: Contract ABI"
description: "This proposal defines an ABI to communicate with deployed smart contracts"
sidebar:
  order: 2
---

ABI defines how to communicate with smart contracts. It contains information about the contract's receivers, data structures, etc.

## Motivation

ABI is an essential tool that allows developers to generate handy bindings, UIs, etc. One of the best consumer usages would be using a DAO and being able to confirm what exactly it is trying to do before signing a transaction.

## Guide

This OTP is based on types that are defined in TLB+ and it is advised to know them before reading this OTP.

## Specification

ABI is a JSON file:

```json
{
  "name": "MyContract",
  "types": [
    {
      "name": "MyRequest",
      "header": 12315123,
      "fields": [
        {
          "name": "queryId",
          "type": {
            "kind": "simple",
            "type": "int",
            "optional": false,
            "format": "uint256"
          }
        }
      ]
    }
  ],
  "receivers": [
    { "type": "binary", "kind": "internal", "name": "MyRequest" },
    { "type": "binary", "kind": "internal" },
    { "type": "comment", "kind": "internal", "comment": "Vote!" },
    { "type": "comment", "kind": "internal" },
    { "type": "empty", "kind": "internal" }
  ],
  "getters": [
    { "name": "getOwner", "type": "address", "args": [] },
    {
      "name": "getBalance",
      "type": "coins",
      "args": [
        {
          "name": "invested",
          "type": {
            "kind": "simple",
            "type": "uint",
            "format": "coins"
          }
        }
      ]
    }
  ],
  "errors": {
    "123": "Error description",
    "124": "Division by zero"
  }
}
```

## Drawbacks

- Binary and compact representation of ABI could be better, but it is not critical for now.

## Prior art

- OTP-001, that is complimentary to this OTP.


## otp-003.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/evolution/otp-003.mdx)
---
title: "OTP-003: Self-ABI reporting"
description: "This proposal defines how to report the contract's ABI using the IPFS link"
sidebar:
  order: 3
---

This proposal defines how to report the contract's ABI using the IPFS link.

## Motivation

Usually, ABI is supplied separately using a third-party service or via some repository on GitHub. This proposal suggests adding a new self-reporting of the contract's ABI using a link to an IPFS. This would allow us to avoid any third-party dependency and allow anyone to build tools that rely on ABI such as explorers, wallets, etc.

## Specification

To support this proposal, the contract should implement OTP-001 and report an interface `org.ton.abi.ipfs.v0`. Then implement a get method `get_abi_ipfs` that returns a string with an IPFS link to the ABI file. The link should be in the format `ipfs://<hash>`.

## Drawbacks

- No way to upgrade ABI without updating a contract. This is a drawback exists only for hardcoded links.


## otp-004.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/evolution/otp-004.mdx)
---
title: "OTP-004: Auto Encoder"
description: "This proposal defines a way to automatically build a serialization layout for a given structure"
sidebar:
  order: 4
---

This proposal defines a way to automatically build a serialization layout for a given structure.

## Motivation

Designing a serialization layout in TLB is a very risky task. Developers have to take care of the size limitations of cells and remember how many bits are used by each field. This is a very error-prone task and it is very easy to make a mistake. This proposal aims to solve this problem by providing a way to automatically build a serialization layout for a given structure.

## Specification

We define auto-encoder as an eager algorithm that builds a serialization layout for a given structure. The algorithm is defined as follows:

```text
Define available references and bits in a current cell 
   as `available_references` and `available_bits` respectively.
   NOTE: there must be at least one reference reserved for the serialization tail and one 
         bit for an optional flag. Depending on context more references or bits may be reserved. 

For each field in A:
    (size_bits, size_ref) = get_field_max_size(field);
    if (available_bits >= size_bits && available_references >= size_ref) {
        Push field to a current cell
    } else {
        available_references = (1023 - 1);
        available_bits = (4 - 1);
        Allocate a new tail and continue from the current field
    }
```

## Drawbacks

- This is an implicit algorithm. It is not clear results of this allocator have to be checked to make compatible serialization.


## otp-005.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/evolution/otp-005.mdx)
---
title: "OTP-005: Argument-addressable contracts"
description: "This proposal defines a way to address contracts by their arguments instead of their initial data"
sidebar:
  order: 5
---

This proposal defines a way to address contracts by their arguments instead of their initial data.

## Motivation

Init data could be very different from the arguments. This allows us to avoid executing untrusted code from another contract in the context of a current one or executing TVM code off-chain for deployment that could be risky in some cases.

## Specification

This specification defines a way to write arguments to an init data cell to be read by the contract code during deployment.

### Prefix

The prefix is defined by a smart contract itself, but by default, it is assumed as a `single zero bit`. Prefix is used by the contract code to distinguish between deployed and not-deployed state.

### Arguments encoding

Arguments are encoded using [Auto Encoder](/ref/evolution/otp-004).

### Contract Requirements

- Contract MUST expose `lazy_deployment_completed` get method that returns `true` if the contract is deployed and `false` otherwise.
- Contract MUST expose `org.ton.deploy.lazy.v0` interface.

## Drawbacks

- Contracts could be in a semi-deployed state
- There are multiple ways to write arguments that would end up in a different init data and a different address
- You can deploy a pre-initialized contract and it would have a different address while being fully functional
- Unpredictable gas usage on deployment. Deployments are usually expensive, but this proposal makes it even more expensive.


## otp-006.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/evolution/otp-006.mdx)
---
title: "OTP-006: Contract Package"
description: "This proposal defines a way to package compile contracts, their dependencies, and all related metadata into a single file"
sidebar:
  order: 6
---

This proposal defines a way to package compile contracts, their dependencies, and all related metadata into a single file.

## Motivation

A unified package format is needed to simplify the process of deploying and upgrading contracts using various tools without the need to configure them.

## Specification

The package file has an extension `.pkg` and is a JSON file:

```json
{
  "name": "My Contract",
  "code": "... boc of code ...",
  "abi": "ABI string to be uploaded as is to IPFS or Ton Storage",
  "init": {
    "kind": "direct", // Means that this contract can be deployed as is
    "args": {
      // ... Arguments in ABI format
    },
    "prefix": {
      // Optional prefix for contract init state
      "bits": 0, // Number of bits in prefix
      "value": 0 // Value of prefix
    },
    "deployment": {
      "kind": "system-cell", // Means that this contract can be deployed as is
      "system": "... boc of system cell ..."
    }
  },
  "sources": {
    "file.ton": "... base64 encoded source file ..."
  },
  "compiler": {
    "name": "func",
    "version": "0.4.1",
    "parameters": "..." // Optional string parameters
  }
}
```

## Drawbacks

None

## Reference

- Bags of Cells (BoC): https://docs.ton.org/develop/data-formats/cell-boc#packing-a-bag-of-cells


## overview.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/ref/evolution/overview.mdx)
---
title: Evolution overview
description: "Evolution sub-section contains all standards that are defined by the Tact Foundation and are used in the evolution process of the Tact and TON ecosystem"
sidebar:
  label: Overview
  order: 0
---

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

This sub-section contains all standards that are defined by the Tact Foundation and are used in the evolution process of the Tact and TON ecosystem.
Additionally, it features TEPs (TON Enhancement Proposals) and the up-to-date changelog of Tact updates.

## Open Tact Proposals (OTPs)

<CardGrid>
  <LinkCard
    title="OTP-001"
    href="/ref/evolution/otp-001"
  />
  <LinkCard
    title="OTP-002"
    href="/ref/evolution/otp-002"
  />
  <LinkCard
    title="OTP-003"
    href="/ref/evolution/otp-003"
  />
  <LinkCard
    title="OTP-004"
    href="/ref/evolution/otp-004"
  />
  <LinkCard
    title="OTP-005"
    href="/ref/evolution/otp-005"
  />
  <LinkCard
    title="OTP-006"
    href="/ref/evolution/otp-006"
  />
</CardGrid>

## TON Enhancement Protocols (TEPs)

The main goal of TON Enhancement Proposals is to provide a convenient and formal way to propose changes to TON Blockchain and standardize ways of interaction between different parts of ecosystem. Proposal management is done using GitHub pull requests, the process is described formally in [TEP-1](https://github.com/ton-blockchain/TEPs/blob/master/text/0001-tep-lifecycle.md).

List of [merged TEPs](https://github.com/ton-blockchain/TEPs#merged-teps).

## Changelog

All notable changes to the main Tact repository are documented in the [CHANGELOG.md](https://github.com/tact-lang/tact/blob/main/CHANGELOG.md).


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/index.mdx)
---
title: 学习⚡ Tact 中的所有编程知识
description: Tact 是 TON 区块链的一种新编程语言，注重效率和简便性。 它设计得易于学习和使用，并且非常适合智能合约。
template: splash
hero:
  tagline: Tact 是 TON 区块链的一种新编程语言，注重效率和简便性。 它设计得易于学习和使用，并且非常适合智能合约。 Tact 是一种静态类型语言，具有简单的语法和强大的类型系统。
  image:
    dark: /public/logomark-dark.svg
    light: /public/logomark-light.svg
    alt: Tact 徽标
  actions:
    - text: 书籍
      link: /zh-cn/book
      variant: minimal
      icon: right-arrow

    - text: 🍲烹饪书
      link: /zh-cn/cookbook
      variant: minimal
      icon: right-arrow

    - text: 🔬 参考资料
      link: /zh-cn/ref
      variant: minimal
      icon: right-arrow

    - text: 🗺️ 生态系统
      link: /zh-cn/ecosystem
      variant: minimal
      icon: right-arrow
---

import { LinkCard, CardGrid, Tabs, TabItem, Steps } from '@astrojs/starlight/components';

      {/* icon: right-arrow */}


## 🚀 我们开始吧！ {#start}

<p>ㅤ</p>

<Steps>

1. #### 确保已安装受支持的 Node.js 版本并可用 {#start-1}

    要检查它，请运行 `node --version{:shell}` --它应该会显示 22.0.0 或更高版本。

2. #### 运行以下命令 {#start-2}

   它将创建一个带有简单计数器合同的新项目：

   <Tabs>
     <TabItem label="yarn" icon="seti:yarn">
       ```shell
       # 推荐
       yarn create ton simple-counter --type tact-counter --contractName SimpleCounter
       ```
     </TabItem>
     <TabItem label="npm" icon="seti:npm">
       ```shell
       npm create ton@latest -- simple-counter --type tact-counter --contractName SimpleCounter
       ```
     </TabItem>
     <TabItem label="pnpm" icon="pnpm">
       ```shell
       pnpm create ton@latest simple-counter --type tact-counter --contractName SimpleCounter
       ```
     </TabItem>
     <TabItem label="bun" icon="bun">
       ```shell
       bun create ton@latest simple-counter --type tact-counter --contractName SimpleCounter
       ```
     </TabItem>
   </Tabs>

3. #### 就是这样！ {#start-3}

   您的第一个合同项目已经编写完成！

   进入相关目录查看 - `cd simple-counter/contracts{:shell}`。 这就是它的样子：

   ```tact
   import "@stdlib/deploy";

   message Add {
       queryId：Int as uint64;
       amount：Int as uint32;
   }

   contract SimpleCounter with Deployable {
       id: Int as uint32;
       counter：

       init(id: Int) {
           self.id = id;
           self.counter = 0;
       }

       receive(msg: Add) {
           self.counter += msg.amount;

           // 通知调用者接收器已执行，并将余值转回
           self.notify("Cashback".asComment());
       }

       get fun counter()：Int {
           return self.counter;
       }

       get fun id()：Int {
           return self.id;
       }
   }
   ```

   要重新编译或部署，请参考新创建项目根目录下 `package.json` 中脚本部分的命令，以及 [Blueprint](https://github.com/ton-org/blueprint) 的文档 - 这是我们用来在 Tact 中创建和编译第一个简单计数器合约的工具。 事实上，Blueprint 的功能远不止这些：包括测试、定制等。

</Steps>

## 🤔 下一站去哪里？ {#next}

<p>ㅤ</p>

<Steps>

1. #### 已经掌握了一些区块链知识？ {#next-1}

   请参阅 [Tact Cookbook](/zh-cn/cookbook)，它是每个 Tact 开发人员在智能合约开发过程中面临的日常任务（和解决方案）的便捷集合。 使用它可以避免重复发明轮子。

   此外，还可以查看以下小抄，快速入门：

   <CardGrid>
     <LinkCard
       title="💎 来自 FunC (TON)"
       href="/zh-cn/book/cs/from-func"
     />
     <LinkCard
       title="🔷 来自 Solidity (Ethereum)"
       href="/zh-cn/book/cs/from-solidity"
     />
   </CardGrid>

2. #### 想了解更多吗？ {#next-2}

   有关编译、测试和部署的进一步指导，请参阅相关页面：

   - [测试和调试](/zh-cn/book/debug) 页面将为您介绍有关 Tact 合同调试的所有内容。
   - [部署](/zh-cn/book/deploy)页面展示了部署的样子，并帮助你利用[蓝图](https://github.com/ton-org/blueprint) 的力量进行部署。

   有关您最喜欢的编辑器和其他工具的自定义插件，请参阅 [生态系统](/zh-cn/ecosystem) 部分。

   或者，也可以查看以下更广泛的章节：

   - [书籍](/zh-cn/book) 帮助您逐步学习语言
   - [Cookbook](/zh-cn/cookbook)为您提供现成的 Tact 代码食谱
   - [参考资料](/zh-cn/ref) 提供了标准库、语法和演变过程的完整词汇表
   - 最后，[生态系统](/zh-cn/ecosystem)描述了 Tact 和 TON 生态系统中的 "外面有什么"。

   <CardGrid>
     <LinkCard
       title="📚 阅读《战术书》"
       href="/zh-cn/book"
     />
     <LinkCard
       title="🍲 研磨烹饪书"
       href="/zh-cn/cookbook"
     />
     <LinkCard
       title="🔬 浏览参考资料"
       href="/zh-cn/ref"
     />
     <LinkCard
       title="🗺️ 拥抱生态系统"
       href="/zh-cn/ecosystem"
     />
   </CardGrid>

3. #### 感觉有点不舒服？ {#next-3}

   如果遇到困难，请尝试搜索--搜索框就在文档顶部。 还有一个方便的<kbd>Ctrl</kbd>+<kbd>K</kbd>快捷键，可以在输入时快速对焦并开始搜索。

   如果您在文档中找不到答案，或者您尝试进行了一些本地测试，但仍然无济于事，请不要犹豫，联系 Tact 活跃的社区：

   <CardGrid>
     <LinkCard
       title="✈️ Telegram Group"
       href="https://t.me/tactlang"
     />
     <LinkCard
       title="🐦 X/Twitter"
       href="https://twitter.com/tact_language"
     />
   </CardGrid>

   祝你在⚡ Tact 的编码冒险中好运！

</Steps>


## bounced.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/bounced.mdx)
---
title: 退信
---

当一个合约发送的信息的反弹标志设置为 true 时，如果信息没有被正确处理，它就会反弹回发送者。当你想确认信息是否被正确处理，如果没有，就可以恢复更改，这个功能非常有用。

## 注意事项

目前，在 TON 中，被退回的报文只有 224 个可用数据位，没有引用。 这意味着您无法从被退回的邮件中恢复大部分数据。 这是 TON 区块链的局限性，将来会得到修复。 Tact helps you to check if your message fits the limit and if not - it will suggest to use a special type modifier `bounced<T>` for the receiver that would construct a partial representation that fits into the required limits.

## 退信接收器

:::caution

  目前暂不支持文本消息回退

:::

要接收退回的信息，您需要在合同或特性中定义一个 “退回 ”接收器:

```tact {2-4}
contract MyContract {
    bounced(src: bounced<MyMessage>) {
        // ...
    }
}
```

要手动处理被退回的信息，您可以使用回退定义，直接处理原始的 [`Slice{:tact}`](/zh-cn/book/cells#slices)。请注意，这样的接收器将获得由您的合约产生的**所有**被退回的信息：

```tact /rawMsg: Slice/
contract MyContract {
    bounced(src: Slice) {
        // ...
    }
}
```


## cells.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/cells.mdx)
---
title: 细胞、建造者和切片
---

[单元](#cells)、[构建器](#builders)和[切片](#slices)是 TON 区块链的底层[基元][p]。 TON 区块链的虚拟机 [TVM][tvm]使用单元格来表示持久存储中的所有数据结构，以及内存中的大部分数据结构。

## Cells

`Cell{:tact}`是一种[基元][p]和数据结构，它[通常](#cells-kinds)由多达 $1023$ 个连续排列的比特和多达 $4$ 个指向其他单元格的引用(refs)组成。 禁止循环引用，也不能通过[TVM][tvm]的方式创建循环引用，这意味着单元格可以被视为[四叉树][quadtree]或[有向无环图（DAG）](https://en.wikipedia.org/wiki/Directed_acyclic_graph)。 合同代码本身由单元格树形结构表示。

单元和 [单元基元](#cells-immutability) 是面向比特的，而不是面向字节的：[TVM][tvm] 将保存在单元中的数据视为最多为 $1023$ 比特的序列（字符串或数据流），而不是字节。 如有必要，合约可以自由使用 $21$-bit 整数字段，将其序列化为 [TVM][tvm] 单元，从而使用更少的持久存储字节来表示相同的数据。

### Kinds {#cells-kinds}

虽然 [TVM][tvm] 类型 [`单元格{:tact}`](#cells)指的是所有单元格，但有不同的单元格类型，其内存布局也各不相同。 前面描述的单元格（#cells）通常被称为_ordinary_（或 simple）单元格--这是最简单、最常用的单元格，只能包含数据。 绝大多数关于细胞及其用法的描述、指南和[参考文献](/zh-cn/ref/core-cells)都假定细胞是普通的。

其他类型的细胞统称为_外来细胞_（或特殊细胞）。 它们有时会出现在 TON 区块链上的区块和其他数据结构的实际表示中。 它们的内存布局和用途与普通电池大不相同。

所有细胞的种类（或亚型）都由 $-1$ 和 $255$之间的整数编码。 普通单元格用 $-1$编码，特殊单元格可用该范围内的任何其他整数编码。 奇异单元的子类型存储在其数据的前 $8$ 位，这意味着有效的奇异单元总是至少有 $8$ 个数据位。

[TVM][tvm]目前支持以下奇异细胞子类型：

- [剪枝单元格][c-pruned]，子类型编码为 $1$ - 它们代表删除的单元格子树。
- [图书馆引用单元][c-library]，子类型编码为 $2$ - 它们用于存储图书馆，通常在[masterchain](/zh-cn/book/masterchain)上下文中使用。
- [梅克尔证明单元][c-mproof]，子类型编码为 $3$ - 它们用于验证其他单元的树数据的某些部分是否属于完整树。
- [梅克尔更新单元][c-mupdate]，子类型编码为 $4$ - 它们总是有两个引用，对这两个引用的行为类似于[梅克尔证明][mproof]。

:::note[Useful links:]

  [TON Docs 中的剪枝单元][c-pruned]  
  [TON Docs 中的 Merkle 证明单元][c-mproof]  
  [TON Docs 中的 Merkle 更新单元][c-mupdate]  
  [TON Docs 中的简单证明验证示例][mproof]

:::

[c-pruned]: https://docs.ton.org/develop/data-formats/exotic-cells#pruned-branch
[c-library]: https://docs.ton.org/develop/data-formats/library-cells
[c-mproof]: https://docs.ton.org/develop/data-formats/exotic-cells#merkle-proof
[c-mupdate]: https://docs.ton.org/develop/data-formats/exotic-cells#merkle-update
[mproof]: https://docs.ton.org/develop/data-formats/exotic-cells#simple-proof-verifying-example

### Levels {#cells-levels}

作为 [四叉树][quadtree]，每个单元格都有一个名为 _level_ 的属性，它由 $0$ 和 $3$之间的整数表示。 [普通](#cells-kinds) 单元格的级别总是等于其所有引用级别的最大值。 也就是说，没有引用的普通单元格的电平等于 $0$。

[外来](#cells-kinds)细胞有不同的规则来决定它们的等级，这些规则在[TON Docs 的本页](https://docs.ton.org/develop/data-formats/exotic-cells)上有描述。

### Serialization {#cells-serialization}

在通过网络传输单元格或在磁盘上存储单元格之前，必须对其进行序列化。 有几种常用格式，如[标准 `Cell{:tact}` 表示法](#cells-representation)和[BoC](#cells-boc)。

#### Standard representation {#cells-representation}

标准[`单元格{:tact}`](#cells)表示法是[tvm.pdf](https://docs.ton.org/tvm.pdf)中首次描述的单元格通用序列化格式。 它的算法以八进制（字节）序列表示单元，首先将称为描述符的第一个 $2$ 字节序列化：

- _Refs descriptor_ 的计算公式如下： $r + 8 * k + 32 * l$，其中 $r$ 是单元格中包含的引用数（介于 $0$ 和 $4$之间）， $k$ 是单元格类型标志（$0$ 表示 [ordinary](#cells-kinds) 和 $1$ 表示 [exotic](#cells-kinds) ）， $l$ 是单元格的 [level](#cells-levels) （介于 $0$ 和 $3$之间）。
- _Bits descriptor_ 的计算公式为 $\lfloor\frac{b}{8}\rfloor + \lceil\frac{b}{8}\rceil$，其中 $b$ 是单元格中的位数（介于 $0$ 和 $1023$之间）。

然后，单元本身的数据位被序列化为 $\lceil\frac{b}{8}\rceil$ $8$-bit octets（字节）。 如果 $b$ 不是 8 的倍数，则在数据位上附加一个二进制 $1$ 和最多六个二进制 $0$s。

接下来， $2$ 字节存储了引用的深度，即单元格树根（当前单元格）和最深引用（包括它）之间的单元格数。 例如，如果一个单元格只包含一个引用而没有其他引用，则其深度为 $1$，而被引用单元格的深度为 $0$。

最后，为每个参考单元存储其标准表示的[SHA-256][sha-2] 哈希值，每个参考单元占用 $32$ 字节，并递归重复上述算法。 请注意，不允许循环引用单元格，因此递归总是以定义明确的方式结束。

如果我们要计算这个单元格的标准表示的哈希值，就需要将上述步骤中的所有字节连接在一起，然后使用 [SHA-256][sha-2] 哈希值进行散列。 这是[TVM][tvm]的[`HASHCU`和`HASHSU`指令](https://docs.ton.org/learn/tvm-instructions/instructions)以及 Tact 的[`Cell.hash(){:tact}`](/zh-cn/ref/core-cells#cellhash)和[`Slice.hash(){:tact}`](/zh-cn/ref/core-cells#slicehash)函数背后的算法。

#### Bag of Cells {#cells-boc}

如 [boc.tlb](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25) [TL-B schema][tlb] 所述，Bag of Cells（简称 _BoC_）是一种将单元格序列化和去序列化为字节数组的格式。

在 TON Docs 中阅读有关 BoC 的更多信息：[细胞袋](https://docs.ton.org/develop/data-formats/cell-boc#bag-of-cells)。

:::note

  关于[`单元格{:tact}`](#cells)序列化的高级信息：[Canonical `Cell{:tact}` 序列化](https://docs.ton.org/develop/research-and-development/boc)。

:::

### Immutability {#cells-immutability}

单元格是只读和不可变的，但 [TVM][tvm] 中有两组主要的 [ordinary](#cells-kinds) 单元格操作指令：

- 单元格创建（或序列化）指令，用于根据先前保存的值和单元格构建新单元格；
- 单元格解析（或反序列化）指令，用于提取或加载之前通过序列化指令存储到单元格中的数据。

此外，[exotic](#cells-kinds)单元格有专门的指令来创建它们并预期它们的值。不过，[普通](#cells-kinds) 单元格解析指令仍可用于[奇异](#cells-kinds) 单元格，在这种情况下，它们会在反序列化尝试中被自动替换为[普通](#cells-kinds) 单元格。

所有单元操作指令都需要将 [`Cell{:tact}`](#cells) 类型的值转换为 [`Builder{:tact}`](#builders)或 [`Slice{:tact}`](#slices)类型，然后才能修改或检查这些单元。

## Builders

`Builder{:tact}` 是一种用于使用单元格创建指令的单元格操作[基元][p]。 它们就像单元格一样不可改变，可以用以前保存的值和单元格构建新的单元格。 与单元格不同，`Builder{:tact}`类型的值只出现在[TVM][tvm]堆栈中，不能存储在持久存储区中。 举例来说，这意味着类型为 `Builder{:tact}`的持久存储字段实际上是以单元格的形式存储的。

`Builder{:tact}` 类型表示部分组成的单元格，为其定义了追加整数、其他单元格、引用其他单元格等快速操作：

- [核心库中的 `Builder.storeUint(){:tact}`][b-2]
- [核心库中的 `Builder.storeInt(){:tact}`][b-3]
- [核心库中的 `Builder.storeBool(){:tact}`][b-4]
- [核心库中的 `Builder.storeSlice(){:tact}`][b-5]
- [核心库中的 `Builder.storeCoins(){:tact}`][b-6]
- [核心库中的 `Builder.storeAddress(){:tact}`][b-7]
- [核心库中的 `Builder.storeRef(){:tact}`][b-8]

虽然您可以使用它们来[手动构建](#cnp-manually)单元格，但强烈建议使用[结构体][structs]：[使用结构体构建单元格](#cnp-structs)。

## Slices

`Slice{:tact}` 是使用单元格解析指令的单元格操作[基元][p]。 与单元格不同，它们是可变的，可以通过序列化指令提取或加载之前存储在单元格中的数据。 此外，与单元格不同，`Slice{:tact}`类型的值只出现在[TVM][tvm]堆栈中，不能存储在持久存储区中。 举例来说，这就意味着类型为 `Slice{:tact}`的持久存储字段实际上是以单元格的形式存储的。

`Slice{:tact}` 类型表示部分解析单元格的剩余部分，或位于此类单元格内并通过解析指令从中提取的值（子单元格）：

- [核心库中的`Slice.loadUint(){:tact}`][s-2]
- [核心库中的`Slice.loadInt(){:tact}`][s-3]
- [核心库中的`Slice.loadBool(){:tact}`][s-4]
- [核心库中的`Slice.loadBits(){:tact}`][s-5]
- [核心库中的`Slice.loadCoins(){:tact}`][s-6]
- [核心库中的`Slice.loadAddress(){:tact}`][s-7]
- [核心库中的`Slice.loadRef(){:tact}`][s-8]

虽然您可以将它们用于单元格的 [手动解析](#cnp-manually)，但强烈建议使用 [结构体][structs]：[使用结构体解析单元格](#cnp-structs)。

## Serialization types

与 [`Int{:tact}`](/zh-cn/book/integers)类型的序列化选项类似，`Cell{:tact}`、`Builder{:tact}` 和`Slice{:tact}` 在以下情况下也有不同的值编码方式：

- 作为 [contracts](/zh-cn/book/contracts) 和 [traits](/zh-cn/book/types#traits) 的 [storage variables](/zh-cn/book/contracts#variables) 、
- 以及 [Structs](/zh-cn/book/structs and-messages#structs) 和 [Messages](/zh-cn/book/structs and-messages#messages) 的字段。

```tact {2-3}
contract SerializationExample {
    someCell: Cell as remaining;
    someSlice：Slice as bytes32;

    // 构造函数，
    // 本示例合同编译所必需的
    init() {
        self.someCell = emptyCell();
        self.someSlice = beginCell().storeUint(42, 256).asSlice();
    }
}
```

### `remaining` {#serialization-remaining}

`remaining{:tact}` 序列化选项可应用于 [`Cell{:tact}`](#cells)、[`Builder{:tact}`](#builders)和 [`Slice{:tact}`](#slices)类型的值。

它通过直接存储和加载单元格值而不是作为引用来影响单元格值的构建和解析过程。 与 [单元操作指令](#cells-immutability) 相似，指定 `remaining{:tact}` 就像使用 [`Builder.storeSlice(){:tact}`][b-5] 和 [`Slice.loadBits(){:tact}`][s-5] 而不是 [`Builder.storeRef(){:tact}`][b-8] 和 [`Slice.loadRef(){:tact}`][s-8]，后者是默认使用的。

此外，Tact 产生的 [TL-B][tlb] 表示也会发生变化：

```tact {3-5, 8-10}
contract SerializationExample {
    // 默认情况下
    cRef: Cell; // ^cell in TL-B
    bRef: Builder; // ^builder in TL-B
    sRef: Slice; // ^slice in TL-B

    // With `remaining`
    cRem：Cell as remaining; // remainder<cell> in TL-B
    bRem：Builder as remaining; // remainder<builder> in TL-B
    sRem：Slice as remaining; // remainder<slice> in TL-B

    // 构造函数，
    // 本示例合同编译所必需
    init() {
        self.cRef = emptyCell();
        self.bRef = beginCell();
        self.sRef = emptySlice();
        self.cRem = emptyCell();
        self.bRem = beginCell();
        self.sRem = emptySlice();
    }
}
```

其中，[TL-B][tlb] 语法中的 `^cell`、`^builder` 和 `^slice` 分别表示对 [`cell{:tact}`](#cells)、[`builder{:tact}`](#builders)和 [`slice{:tact}`](#slices)值的引用、而 `cell`、`builder` 或 `slice` 的 `remainder<…>` 则表示给定值将直接存储为 `Slice{:tact}`，而不是作为引用。

现在，举一个真实世界的例子，想象一下你需要注意到智能合约中的入站 [jetton][jetton] 传输并做出反应。 相应的 [信息][消息] 结构如下：

```tact /remaining/
message(0x7362d09c) JettonTransferNotification {
    queryId：Int as uint64; // 任意请求编号，以防止重放攻击
    amount：Int as coins; // 传输的捷通数量
    sender：地址; // 净币发送方的地址
    forwardPayload：Slice as remaining; // 可选自定义有效载荷
}
```

合同中的 [receiver][recv] 应该是这样的：

```tact
receive(msg: JettonTransferNotification) {
    // ... you do you ...
}
```

收到 [jetton][jetton] 传输通知消息后，其单元体会被转换为 [`Slice{:tact}`](#slices)，然后解析为 `JettonTransferNotification{:tact}` [消息][消息]。在此过程结束时，`forwardPayload` 将包含原始信息单元的所有剩余数据。

在这里，将 `forwardPayload: Slice as remaining` 字段放在 `JettonTransferNotification{:tact}` [消息][消息]中的任何其他位置都不会违反 [jetton][jetton] 标准。这是因为 Tact 禁止在 [Structs][结构] 和 [Messages][消息] 的最后一个字段之外的任何字段中使用 `as remaining{:tact}`，以防止滥用合约存储空间并减少 gas 消耗。

:::note

  注意，通过 `as remaining{:tact}` 序列化的单元格不能是 [可选](/zh-cn/book/optionals)。 也就是说，指定类似 `Cell? as remaining{:tact}`, `Builder? 作为剩余{:tact}` 或 `切片？ 剩余的{:tact}` 会导致编译错误。

  另外请注意，将 `Cell{:tact}` 指定为[map](/zh-cn/book/maps) 值类型的 `remaining{:tact}` 会被视为错误，无法编译。

:::

### `bytes32` {#serialization-bytes32}

:::note

  由 [#94](https://github.com/tact-lang/tact-docs/issues/94) 解决。

:::

### `bytes64` {#serialization-bytes64}

:::note

  由 [#94](https://github.com/tact-lang/tact-docs/issues/94) 解决。

:::

## Operations

### Construct and parse {#operations-cnp}

在 Tact 中，至少有两种构建和解析单元格的方法：

- [手动](#cnp-manually)，其中涉及积极使用[`Builder{:tact}`](#builders)、[`Slice{:tact}`](#slices)和[相关方法](/zh-cn/ref/core-cells)。
- [使用结构体](#cnp-structs)，这是一种值得推荐且更加方便的方法。

#### Manually {#cnp-manually}

| 通过 `Builder{:tact}`进行建造                | 通过 `切片{:tact}` 进行解析                  |
| :------------------------------------- | :------------------------------------ |
| [`beginCell(){:tact}`][b-1]            | [`Cell.beginParse(){:tact}`][s-1]。    |
| [`.storeUint(42, 7){:tact}`][b-2]      | [`Slice.loadUint(7){:tact}`][s-2]     |
| [`.storeInt(42, 7){:tact}`][b-3]       | [`Slice.loadInt(7){:tact}`][s-3]      |
| [`.storeBool(true){:tact}`][b-4]       | [`Slice.loadBool(true){:tact}`][s-4]  |
| [`.storeSlice(slice){:tact}`][b-5]     | [`Slice.loadBits(slice){:tact}`][s-5] |
| [`.storeCoins(42){:tact}`][b-6]        | [`Slice.loadCoins(42){:tact}`][s-6]   |
| [`.storeAddress(address){:tact}`][b-7] | [`Slice.loadAddress(){:tact}`][s-7]   |
| [`.storeRef(cell){:tact}`][b-8]        | [`Slice.loadRef(){:tact}`][s-8]       |
| [`.endCell(){:tact}`][b-9]             | [`Slice.endParse(){:tact}`][s-9]      |

[b-1]: /zh-cn/ref/core-cells#begincell
[b-2]: /zh-cn/ref/core-cells#builderstoreuint
[b-3]: /zh-cn/ref/core-cells#builderstoreint
[b-4]: /zh-cn/ref/core-cells#builderstorebool
[b-5]: /zh-cn/ref/core-cells#builderstoreslice
[b-6]: /zh-cn/ref/core-cells#builderstorecoins
[b-7]: /zh-cn/ref/core-cells#builderstoreaddress
[b-8]: /zh-cn/ref/core-cells#builderstoreref
[b-9]: /zh-cn/ref/core-cells#builderendcell
[s-1]: /zh-cn/ref/core-cells#cellbeginparse
[s-2]: /zh-cn/ref/core-cells#sliceloaduint
[s-3]: /zh-cn/ref/core-cells#sliceloadint
[s-4]: /zh-cn/ref/core-cells#sliceloadbool
[s-5]: /zh-cn/ref/core-cells#sliceloadbits
[s-6]: /zh-cn/ref/core-cells#sliceloadcoins
[s-7]: /zh-cn/ref/core-cells#sliceloadaddress
[s-8]: /zh-cn/ref/core-cells#sliceloadref
[s-9]: /zh-cn/ref/core-cells#sliceendparse

#### Using Structs {#cnp-structs}

[结构][struct]和[消息][messages]几乎就是活生生的[TL-B 模式][tlb]。 也就是说，它们本质上是用可维护、可验证和用户友好的 Tact 代码表达的[TL-B 模式][tlb]。

强烈建议使用它们及其 [方法](/zh-cn/book/functions#extension-function)，如 [`Struct.toCell(){:tact}`][st-tc]和 [`Struct.fromCell(){:tact}`][st-fc]，而不是手动构造和解析单元格，因为这样可以得到更多声明性和不言自明的合约。

[上文](#cnp-manually)的手动解析示例可以使用[Structs][struct]重新编写，如果愿意，还可以使用字段的描述性名称：

```tact /fromCell/ /toCell/
// First Struct
struct Showcase {
    id: Int as uint8;
    someImportantNumber: Int as int8;
    isThatCool：Bool;
    payload：Slice;
    nanoToncoins：Int as coins;
    wackyTacky: Address;
    jojoRef: Adventure; // another Struct
}

// Here it is
struct Adventure {
    bizarre: Bool = true;
    time：Bool = false;
}

fun example() {
    // Basics
    let s = Showcase.fromCell(
        Showcase{
            id: 7,
            someImportantNumber: 42,
            isThatCool: true,
            payload: emptySlice(),
            nanoToncoins: 1330 + 7,
            wackyTacky: myAddress(),
            jojoRef: Adventure{ bizarre: true, time: false },
        }.toCell());
    s.isThatCool; // true
}
```

请注意，Tact 的自动布局算法是贪婪的。例如，`struct Adventure{:tact}` 占用的空间很小，它不会以引用 [`Cell{:tact}`](#cells) 的形式存储，而是直接以 [`Slice{:tact}`](#slices) 的形式提供。

通过使用 [结构][struct] 和 [消息][messages]，而不是手动 [`Cell{:tact}`](#cells) 组成和解析，这些细节将被简化，在优化布局发生变化时也不会造成任何麻烦。

:::note[Useful links:]

  [Convert serialization](/zh-cn/book/func#convert-serialization)
  [`Struct.toCell(){:tact}` 在核心库中][st-tc]  
  [`Struct.fromCell(){:tact}` 在核心库中][st-fc]  
  [`Struct.fromSlice(){:tact}` 在核心库中][st-fs]  
  [`Message.toCell(){:tact}` 在核心库中][msg-tc]  
  [`Message.fromCell(){:tact}` 在核心库中][msg-fc]  
  [`Message.fromSlice(){:tact}` 在核心库中][msg-fs]

:::

[st-tc]: /zh-cn/ref/core-cells#structtocell
[st-fc]: /zh-cn/ref/core-cells#structfromcell
[st-fs]: /zh-cn/ref/core-cells#structfromslice
[msg-tc]: /zh-cn/ref/core-cells#messagetocell
[msg-fc]: /zh-cn/ref/core-cells#messagefromcell
[msg-fs]: /zh-cn/ref/core-cells#messagefromslice

### Check if empty {#operations-empty}

[`Cell{:tact}`](#cells)和[`Builder{:tact}`](#builders)都不能直接检查空性，需要先将它们转换为[`Slice{:tact}`](#slices)。

要检查是否有任何位，请使用[`Slice.dataEmpty(){:tact}`][s-de]。要检查是否存在引用，请使用[`Slice.refsEmpty(){:tact}`][s-re]。要同时检查这两项，请使用[`Slice.empty(){:tact}`][s-e]。

如果[`Slice{:tact}`](#slices)不完全为空，也要抛出[exit code 9](/zh-cn/book/exit-codes#9)，请使用[`Slice.endParse(){:tact}`][s-ep]。

```tact
// 准备工作
let someCell = beginCell().storeUint(42, 7).endCell();
let someBuilder = beginCell().storeRef(someCell);

// 获取切片
let slice1 = someCell.asSlice();
let slice2 = someBuilder.asSlice();

// .dataEmpty()
slice1.dataEmpty(); // false
slice2.dataEmpty(); // true

// .refsEmpty()
slice1.refsEmpty(); // true
slice2.refsEmpty(); // false

// .empty()
slice1.empty(); // false
slice2.empty(); // false

// .endParse()
try {
    slice1.endParse();
    slice2.endParse();
} catch (e) {
    e; // 9
}
```

:::note[Useful links:]

  [`Cell.asSlice(){:tact}` 在核心库中](/zh-cn/ref/core-cells#cellasslice)\
  [`Builder.asSlice(){:tact}` 在核心库中](/zh-cn/ref/core-cells#builderasslice)\
  [`Slice.dataEmpty(){:tact}` 在核心库中][s-de]\
  [`Slice.refsEmpty(){:tact}` 在核心库中][s-re]\
  [`Slice.empty(){:tact}` 在核心库中][s-e]\
  [`Slice.endParse(){:tact}` 在核心库中][s-ep]

:::

[咝--咝]: /zh-cn/ref/core-cells#slicedataempty
[re]: /zh-cn/ref/core-cells#slicerefsempty
[s-e]: /zh-cn/ref/core-cells#sliceempty
[s-ep]: /zh-cn/ref/core-cells#sliceendparse

### Check if equal {#operations-equal}

不能使用二进制相等 [`=={:tact}`][bin-eq] 或不等式 [`!={:tact}`][bin-eq] 操作符直接比较 [`Builder{:tact}`](#builders) 类型的值。但是，[`Cell{:tact}`](#cells) 和 [`Slice{:tact}`](#slices) 类型的值可以。

直接比较：

```tact
让 a = beginCell().storeUint(123, 8).endCell();
让 aSlice = a.asSlice();

让 b = beginCell().storeUint(123, 8).endCell();
让 bSlice = b. asSlice(); 让 areCellsEqual = a == b; // true 让 areCellsNotEqual = a !asSlice();

let areCellsEqual = a == b; // true
let areCellsNotEqual = a != b; // false

let areSlicesEqual = aSlice == bSlice; // true
let areSlicesNotEqual = aSlice != bSlice; // false
```

请注意，通过 `=={:tact}` 或 `!={:tact}` 操作符进行的直接比较隐含地使用了[标准 `Cell{:tact}` 表示法](#cells-representation)的 [SHA-256](https://en.wikipedia.org/wiki/SHA-2#Hash_standard) 哈希值。

还可使用 `.hash(){:tact}` 进行显式比较：

```tact
let a = beginCell().storeUint(123, 8).endCell();
let aSlice = a.asSlice();

let b = beginCell().storeUint(123, 8).endCell();
let bSlice = b.asSlice();

let areCellsEqual = a.hash() == b.hash(); // true let areCellsNotEqual = a.hash() != b.hash(); // false let areSliceEqual = aSlice.asSlice(); // truehash(); // true
let areCellsNotEqual = a.hash() != b.hash(); // false

let areSlicesEqual = aSlice.hash() == bSlice.hash(); // true
let areSlicesNotEqual = aSlice.hash() != bSlice.hash(); // false
```

:::note[Useful links:]

  [核心库中的 `Cell.hash(){:tact}`](/zh-cn/ref/core-cells#cellhash)/
  [核心库中的 `Slice.hash(){:tact}`](/zh-cn/ref/core-cells#slicehash)/
  [`=={:tact}`和`!={:tact}`][bin-eq]。

:::

[p]: /zh-cn/book/types#primitive-types
[struct]: /zh-cn/book/structs-and-messages#structs
[message]: /zh-cn/book/structs-and-messages#messages
[recv]: /zh-cn/book/contracts#receiver-functions

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview
[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[jetton]: https://docs.ton.org/develop/dapps/asset-processing/jettons
[sha-2]: https://en.wikipedia.org/wiki/SHA-2#Hash_standard

[quadtree]: https://en.wikipedia.org/wiki/Quadtree
[bin-eq]: /zh-cn/book/operators#binary-equality


## config.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/config.mdx)
---
title: 配置
---

`tact.config.json` 是 Tact 项目的入口点。它是一个 JSON 文件，包含所有项目和编译器参数的列表。

本页列出了 [模式](#schema)中的所有配置选项。 请查看右侧的目录，以方便浏览。

:::note

  对该文件的唯一要求是它是一个有效的 JSON 文件，包含 [适当的字段](#schema)，因此可以任意命名。 不过，将配置文件命名为 `tact.config.json` 是所有使用 Tact 的工具都鼓励和支持的通用约定。

:::

## `$schema` {#schema}

编辑器可使用[JSON 模式](https://json-schema.org/) 文件提供自动完成和悬停提示：[configSchema.json](http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json)。

只需在配置文件顶部添加 `$schema` 字段即可：

```json filename="tact.config.json" {2}
{
  "$schema": "http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json",
  "projects"：[]
}
```

## 项目 {#projects}

带有相应编译选项的 Tact 项目列表。 每个 `.tact` 文件都代表自己的 Tact 项目。

```json filename="tact.config.json" {3,4}
{
  "projects"：[
    { },
    { }
  ]
}
```

### `name` {#projects-name}

`name` 是项目名称。所有生成的文件都以此为前缀。

在 [Blueprint][bp] 中，"name "指合同本身的名称。

```json filename="tact.config.json" {4,7}
{
  "projects"：[
    {
      "name"："some_prefix"
    },
    {
      "name"："ContractUnderBlueprint"
    }
  ]
}
```

### `path` {#projects-path}

项目 Tact 文件的路径。 每个项目只能指定一个 Tact 文件。

在 [Blueprint][bp] 中，`path` 被 `wrappers/ContractName.compile.ts` 中的 `target` 字段取代。

```json filename="tact.config.json" {5}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact"
    }
  ]
}
```

### `output` {#projects-output}

`output` 是放置所有生成文件的目录路径。

在 [蓝图][bp] 中，不使用 `output` ，所有生成的文件始终放在 `build/ProjectName/` 中。

```json filename="tact.config.json" {6}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output"
    }
  ]
}
```

### `options` {#projects-options}

项目的编译选项。

在 [Blueprint][bp] 中，除非在`wrappers/ContractName.compile.ts`中进行修改，否则它们将作为默认设置运行。

```json filename="tact.config.json" {7,11}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {}
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {}
    }
  ]
}
```

#### `debug` {#options-debug}

默认为 `false{:json}`。

`debug: true`. 启用合约的调试输出。这对调试非常有用。启用此合约将报告它是在调试模式下使用 `supported_interfaces` 方法编译的。

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "debug": true
      }
    }
  ]
}
```

:::note

  更多信息，请访问专用页面：[调试](/zh-cn/book/debug)。

:::

#### `masterchain` {#options-masterchain}

默认为 `false{:json}`。

如果设置为 `true{:json}`，则启用 [masterchain](/zh-cn/book/masterchain) 支持。

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "masterchain": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "masterchain": true
      }
    }
  ]
}
```

:::note

  更多信息，请访问专用页面：[大师链](/zh-cn/book/masterchain)。

:::

#### `external` {#options-external}

默认为 `false{:json}`。

如果设置为 `true{:json}`，则启用对 [external](/zh-cn/book/external) 消息接收器的支持。

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "external": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "external": true
      }
    }
  ]
}
```

:::note

  更多信息，请访问专用页面：[外部信息](/zh-cn/book/external)。

:::

#### `ipfsAbiGetter` {#options-ipfsabigetter}

默认为 `false{:json}`。

如果设置为 `true{:json}`，则可生成带有描述合同 ABI 的 IPFS 链接的[getter](/zh-cn/book/contracts#getter-functions)。

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "ipfsAbiGetter": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "ipfsAbiGetter": true
      }
    }
  ]
}
```

:::note

  在专用网页上阅读更多信息：[OTP-003：自我 ABI 报告](/zh-cn/ref/evolution/otp-003)。

:::

#### `interfacesGetter` {#options-interfacesgetter}

默认为 `false{:json}`。

如果设置为 `true{:json}`，则可生成包含合约所提供接口列表的 [getter]（/book/contracts#getter-functions）。

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "interfacesGetter": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "interfacesGetter": true
      }
    }
  ]
}
```

:::note

  了解更多信息：[支持的接口](/zh-cn/book/contracts#interfaces)。

:::

#### Experimental

将来可能会取消的试验性选项。 谨慎使用！

```json filename="tact.config.json" {8,14}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "experimental": {}
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "experimental": {}
      }
    }
  ]
}
```

##### `inline` {#experimental-inline}

默认为 `false{:json}`。

`inline: true`. 启用合同中所有函数的内联。这可以减少gas的使用，但代价是需要更大的合约。

```json filename="tact.config.json" {9,17}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "options": {
        "experimental": {
          "inline": true
        }
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "experimental": {
          "inline": true
        }
      }
    }
  ]
}
```

### `mode` {#projects-mode}

项目的编译模式。 有效值为

Value                            | Description
:------------------------------- | :----------
`"full"{:json}`                  | (默认) 运行整个编译流水线，并生成 FunC 代码、BoC 和各种实用程序文件，包括 TypeScript 的封装器。
`"fullWithDecompilation"{:json}` | 运行整个编译管道，如 `“full”{:json}`，并以 BoC 格式反编译生成的二进制代码。
`"funcOnly"{:json}`              | 只输出中间 FunC 代码，阻止进一步编译。
`"checkOnly"{:json}`             | 仅执行语法和类型检查，阻止进一步编译。

在 [Blueprint][bp] 中，"mode "始终设置为`"full"{:json}`，且不可覆盖。

```json filename="tact.config.json" {7,13}
{
  "projects": [
    {
      "name": "some_prefix",
      "path": "./contract.tact",
      "output": "./contract_output",
      "mode": "full"
    },
    {
      "name": "func_only",
      "path": "./contract.tact",
      "output": "./contract_output",
      "mode": "funcOnly"
    }
  ]
}
```

## Full example

```json filename="tact.config.json" copy=false
{
  "$schema": "http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json",
  "projects": [
    {
      "name": "basic",
      "path": "./basic.tact",
      "output": "./basic_output",
      "mode": "full"
    },
    {
      "name": "func_only",
      "path": "./basic.tact",
      "output": "./basic_output",
      "mode": "funcOnly"
    },
    {
      "name": "debugPrefix",
      "path": "./contracts/contract.tact",
      "output": "./contracts/output",
      "options": {
        "debug": true
      }
    },
    {
      "name": "ContractUnderBlueprint",
      "options": {
        "debug": false,
        "masterchain": false,
        "external": false,
        "ipfsAbiGetter": true,
        "interfacesGetter": true,
        "experimental": {
          "inline": false
        }
      }
    }
  ]
}
```

[bp]: https://github.com/ton-org/blueprint


## constants.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/constants.mdx)
---
title: 常数
---

Tact 中的常量可以比流行语言中的常量更先进一些：它们可以是虚拟的、抽象的。 智能合约通常需要实现多个特征，有时您需要在编译时配置其中的一些特征。 禁止使用特质中的构造函数，因为它们的行为是无法预测的。 因此，我们必须使用常量和字段来传递值。 主合同的职责是为所有特性实现值和常量。

## 简单常数

让我们从一个简单的常数开始。 这是一个在编译时定义的值，不能更改。 您可以在顶层或合约/特质中定义常量。 让我们在顶层定义一个常量：

```tact
const MY_CONSTANT: Int = 42；
```

特征和合同也类似：

```tact
trait MyTrait {
    const MY_CONSTANT: Int = 42;
}

contract MyContract {
    const MY_CONSTANT: Int = 42;
}
```

## 虚拟常量和抽象常量 {#virtual-and-abstract-constants}

虚拟常量是可以在特质中定义但在合约中改变的常量。 当您需要在编译时配置某些特征时，它非常有用。 让我们定义一个虚拟常量和一个抽象常量：

```tact
trait MyTrait {
    virtual const MY_FEE: Int = ton("1.0");
}

trait MyAbstractTrait {
    abstract const MY_DEVFEE: Int;
}
```

现在，您可以覆盖合同中的默认设置：

```tact
contract MyContract with MyTrait, MyAbstractTrait {
    override const MY_FEE: Int = ton("0.5");
    override const MY_DEVFEE: Int = ton("1000");
}
```

这对于帮助编译器在编译时获得某些值可能非常有用，例如，您可以启用或禁用功能，而无需修改代码，也不会浪费 gas 。

```tact
trait Treasure {
    virtual const ENABLE_TIMELOCK: Bool = true;

    receive("Execute") {
        if (self.ENABLE_TIMELOCK) {
            //
            // This branch would be removed in compile time if ENABLE_TIMELOCK is false
            //
        }
    }
}

contract MyContract with Treasure {
    override const ENABLE_TIMELOCK: Bool = false;
}

```


## contracts.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/contracts.mdx)
---
title: 合同
---

Tact 中的合约类似于流行的面向对象语言中的类，只是它们的实例部署在区块链上，不能像 [Structs and Messages](/zh-cn/book/structs-and-messages) 那样被传递。

## Self-references {#self}

契约和[特质][trait]有一个内置的[标识符](/zh-cn/book/expressions#identifiers) `self{:tact}`，用于引用它们的字段（持久状态[变量](#variables)和[常量](#constants)）和方法（[内部函数](#internal-functions)）：

```tact
contract Example {
    // 持久状态变量
    foo：Int;

    init() {
        self.foo = 42; // <- 通过 self 引用变量 foo。
    }
}
```

## Structure

每份合同可包括:

* [Inherited traits](#traits)
* [Supported interfaces](#interfaces)
* [Persistent state variables](#variables)
* [Constructor function `init(){:tact}`](#init-function)
* [Contract constants](#constants)
* [Getter functions](#getter-functions)
* [Receiver functions](#receiver-functions)
* [Internal functions](#internal-functions)

### Inherited traits, `with{:tact}` {#traits}

契约可以继承[traits][trait]的所有声明和定义，并覆盖它们的某些默认行为。除此之外，每个契约和特质都隐式继承了特殊的[`BaseTrait{:tact}` trait](/zh-cn/ref/core-base)。

要继承[trait][trait]，请在合约声明中的关键字`with{:tact}`后指定其名称。要同时继承多个特质，请在逗号分隔的列表中指定它们的名称，并在后面加上逗号。

```tact /with/
trait InheritMe {}
trait InheritMeToo {}

// 继承单个特质的合约
合约 Single with InheritMe {}

// 继承多个特质的合约
合约 Plural with
    InheritMe,
    InheritMeToo, // 允许使用逗号结尾
{}
```

由于[traits][trait]不允许有[`init(){:tact}`函数](#init-function)，因此继承了声明了任何[持久状态变量](#variables)的trait的合约必须通过提供自己的[`init(){:tact}`函数](#init-function)来初始化这些变量。

```tact
trait Supe { omelander: Bool }

contract Vot with Supe {
    init() {
        self.omelander = true;
    }
}
```

如果在特质中声明或定义了内部函数和常量，则可将其标记为[虚拟或抽象](/zh-cn/book/functions#virtual-and-abstract-functions)，并在从特质继承的合约中重写。

### Supported interfaces, `@interface(…)` {#interfaces}

如果不查看源代码，就很难弄清一个合约是做什么的，有哪些[接收器](#receiver-functions)和[获取器](#getter-functions)。有时，无法获得或无法访问源代码，剩下的办法就是尝试拆解合同，并以这种方式对其进行反省，这是一种非常混乱且容易出错的方法，其收益会递减，而且没有真正的可重复性。

为了解决这个问题，创建了[OTP-001：支持的接口](/zh-cn/ref/evolution/otp-001)。据此，Tact 合约[可以报告](/zh-cn/book/config#options-interfacesgetter)支持的接口列表，作为特殊的`supported_interfaces` [getter](#getter-functions)的返回值。使用任何 TON 区块链浏览器都可以在链外访问该获取器--只需指定"supported_interfaces"作为要执行的方法，即可获得十六进制值列表。

这些十六进制值被截断为受支持接口的原始[`String{:tact}`][p]值的[SHA-256](https://en.wikipedia.org/wiki/SHA-2#Hash_standard)哈希值的前 128 位。该列表中的第一个值**必须**等于$\mathrm{0x5cec3d5d2cae7b1e84ec39d64a851b66}$（[十六进制符号](/zh-cn/book/integers#hexadecimal)），即`"org.ton.introspection.v0"{:tact}`的 SHA-256 哈希值的前半部分。如果第一个值是错误的，就必须停止反省合同，因为它不符合[支持的接口](/zh-cn/ref/evolution/otp-001)建议。

要声明支持某个接口，可在 contract 和[trait][trait]声明之前添加一个或多个`@interface("…"){:tact}`属性：

```tact
@interface("His name is")
@interface("John")
contract SeeNah with Misc {
    // ...
}

@interface("name_of_your_org - miscellaneous")
trait Misc {
    // ...
}
```

Tact 有一小套在特定条件下提供的接口：

- `"org.ton.abi.ipfs.v0"{:tact}`，根据 [OTP-003: Self-ABI Reporting](/zh-cn/ref/evolution/otp-003) - 通过 [`ipfsAbiGetter`](/zh-cn/book/config#options-ipfsabigetter)配置属性选择加入
- `"org.ton.deploy.lazy.v0"{:tact}`，符合[OTP-005：参数可寻址合约](/zh-cn/ref/evolution/otp-005)
- `"org.ton.debug.v0"{:tact}`，但只有在启用了[调试模式](/zh-cn/book/debug#debug-mode)时才会这样做

[标准库](/zh-cn/ref/standard-libraries)中的一些[traits][trait]也定义了它们的接口：

- [`Ownable{:tact}`](/zh-cn/ref/stdlib-ownable#ownable) trait 指定`"org.ton.ownable"{:tact}`
- [`OwnableTransferable{:tact}`](/zh-cn/ref/stdlib-ownable#ownabletransferable) trait 指定`"org.ton.ownable.transferable.v2"{:tact}`
- [`Stoppable{:tact}`](/zh-cn/ref/stdlib-stoppable#stoppable) trait 指定`"org.ton.stoppable"{:tact}`
- [`Resumable{:tact}`](/zh-cn/ref/stdlib-stoppable#resumable) trait 指定`"org.ton.resumable"{:tact}`

要启用 `supported_interfaces` [getter](#getter-functions) 生成并在 Tact 合约中使用 `@interface(){:tact}` 属性，请修改项目根目录下的 [`tact.config.json`](/zh-cn/book/config) 文件（如果该文件不存在，则创建该文件），并 [将 `interfacesGetter` 属性设置为 `true{:json}`](/zh-cn/book/config#options-interfacesgetter)。

如果您的项目基于 [Blueprint][bp]，您可以在合约的编译配置中启用`supported_interfaces`，这些配置位于名为`wrappers/`的目录中：

```typescript title="wrappers/YourContractName.compile.ts" {7}
import { CompilerConfig } from '@ton/blueprint';

export const compile：CompilerConfig = {
  lang: 'tact',
  target: 'contracts/your_contract_name.tact',
  options：{
    interfacesGetter: true, // ← that's the stuff！
  }
};
```

除此之外，[蓝图][bp] 项目中仍可使用 [`tact.config.json`](/zh-cn/book/config)。 在这种情况下，除非在 `wrappers/` 中进行修改，否则 [`tact.config.json`](/zh-cn/book/config)中指定的值将作为默认值。

:::caution
  请注意，添加接口并不能保证合约实际实现任何特定功能，也不能保证以任何特定方式实现这些功能。 这只是一种可验证的链外承诺，即合同中可能包含某些特定代码。 您应该相信但要核实这些说法。

  此外，不同接口之间也不能保证不会发生名称冲突，尽管这种情况不太可能发生，因为即使是 SHA-256 的前 128 位也能提供足够的[抗碰撞性](https://en.wikipedia.org/wiki/Collision_resistance)。
:::

### Persistent state variables {#variables}

合约可以定义在合约调用之间持续存在的状态变量。 TON 中的合约[支付租金](https://docs.ton.org/develop/smart-contracts/fees#storage-fee) 与它们消耗的持久空间成正比，因此鼓励[通过序列化进行紧凑表示](/zh-cn/book/integers#serialization)。

```tact
contract Example {
    // 持久状态变量
    val: Int; // Int
    val32: Int as uint32; // Int 序列化为 32 位无符号
    mapVal: map<Int, Int>; // Int keys to Int values
    optVal: Int?; // Int or null
}
```

状态变量必须有默认值或在 [`init(){:tact}`](#init-function) 函数中初始化，该函数在部署合约时运行。唯一的例外是 [`map<K, V>{:tact}`](/zh-cn/book/maps) 类型的持久状态变量，因为它们默认初始化为空。

:::note

  请注意，Tact 也支持非持续状态的局部变量，请参阅：[变量声明](/zh-cn/book/statements#let)。

:::

### Contract constants {#constants}

与 [变量](#variables) 不同，常量不能更改。 它们的值是在*编译时*计算的，在执行过程中不会改变。

在合约外定义的常量（全局常量）和在合约内定义的常量（合约常量）没有太大区别。 项目中的其他合同可以使用外部定义的常量。

常量初始化必须相对简单，并且只依赖于编译时已知的值。 例如，如果您将两个数字相加，编译器会在编译过程中计算出结果，并将结果放入已编译的代码中。

您可以在 [接收器](#receiver-functions) 和 [获取器](#getter-functions) 中读取常量。

与[合约变量](#variables)不同，**合约常量不会占用持久状态**的空间。 它们的值直接存储在合约的代码 [`单元格`](/zh-cn/book/cells#cells)中。

```tact
// 全局常量在编译时计算，不能更改
const GlobalConst1：Int = 1000 + ton("42") + pow(10, 9);

contract Example {
    // 合同常量也是在编译时计算的，不能更改
    const ContractConst1：Int = 2000 + ton("43") + pow(10, 9);

    // 合同常量可以轻松替代枚举
    const StateUnpaid：Int = 0;
    const StatePaid: Int = 1;
    const StateDelivered：Int = 2;
    const StateDisputed：Int = 3;

    get fun sum()：Int {
        // access constants from anywhere
        return GlobalConst1 + self.ContractConst1 + self.StatePaid;
    }
}
```

有关常量的更多信息，请访问其专门页面：[常量](/zh-cn/book/constants)。

### Constructor function `init()` {#init-function}

在部署合约时，会运行构造函数 `init(){:tact}`。

如果合约有任何未指定默认值的[持久状态变量](#variables)，则必须在此函数中对其进行初始化。

```tact
contract Example {
    // 持久状态变量
    var1: Int = 0; // 以默认值 0 初始化
    var2: Int; // 必须在 init() 函数中初始化

    // 构造函数
    init() {
        self.var2 = 42;
    }
}
```

如果合约没有任何持久状态变量，或所有持久状态变量都指定了默认值，则可以完全省略 `init(){:tact}` 函数声明。 这是因为除非明确声明，否则所有合约中都默认存在空的 `init(){:tact}` 函数。

下面是一个有效空合同的示例：

```tact
合同 IamEmptyAndIKnowIt {}
```

为方便起见，`init(){:tact}` 的参数列表可以使用逗号：

```tact
contract TheySeeMeTrailing {
    init(
        param1: Int,
        param2: Int, // trailing comma is allowed
    ){
        // ...
    }
}
```

:::note

  要获取 [内部函数](#internal-functions)、[接收器](#receiver-functions) 或 [getters](#getter-functions) 中目标合约的初始状态，请使用 [`initOf{:tact}`](/zh-cn/book/expressions#initof)表达式。

:::

### Getter functions

[获取函数](/zh-cn/book/functions#getter-functions) **不能从其他合约访问，只能导出到链外世界**。

此外，**获取器不能修改合约的状态变量**，只能读取它们的值并在表达式中使用。

```tact
contract HelloWorld {
    foo：Int;

    init() {
        self.foo = 0;
    }

    // 返回类型为 Int 的 getter 函数
    get fun foo()：Int {
        return self.foo; // 这里不能更改 self.foo
    }
}
```

请在其专门章节中阅读更多相关信息：[获取函数](/zh-cn/book/functions#getter-functions)

### Receiver functions

Tact 中的[接收器函数](/zh-cn/book/functions#receiver-functions)可以是以下三种之一：

- [`receive(){:tact}`](/zh-cn/book/receive)，用于接收内部消息（来自其他合约）。
- [`bounced(){:tact}`](/zh-cn/book/bounced)，当该合约发出的消息被退回时会调用。
- [`external(){:tact}`](/zh-cn/book/external)，没有发送者，世界上任何人都可以发送。

```tact
message CanBounce {
    counter：Int;
}

contract HelloWorld {
    counter：Int;

    init() {
        self.counter = 0;
    }

    get fun counter()：Int {
        return self.counter;
    }

    // 内部消息接收器，响应字符串消息 "increment"
    receive("increment") {
        self.counter += 1;

        // 发送消息回发送者
        send(SendParameters{
            to: sender(),
            value: 0,
            mode：SendRemainingValue | SendIgnoreErrors,
            body：CanBounce{counter: self.counter}.toCell(),
        });
    }

    // 被弹回的消息接收器，当消息弹回本合约时被调用
    bounced(src: bounced<MsBounced>) {
        self.counter = 0; // 重置计数器以防消息弹回
    }

    // 外部消息接收器，用于回复链外消息 "你好，是我"
    external("hello, it's me") {
        // 无法回复，因为没有发件人！
        self.counter = 0;
    }
}
```

用下划线`_{:tact}`命名接收函数的参数时，其值将被视为未使用的值并被丢弃。当您不需要检查接收到的信息，而只想让它传达特定的操作码时，这就很有用了：

```tact
message(42) UniverseCalls {}

contract Example {
    receive(_: UniverseCalls) {
        // Got a Message with opcode 42
    }
}
```

### Internal functions

这些函数的行为类似于流行的面向对象语言中的私有方法——它们是合约的内部函数，可以通过在其前缀添加特殊的[标识符 `self{:tact}`](#self)来调用。因此，内部函数有时也被称为"契约方法"。

内部函数可以访问合约的[持久状态变量](#variables)和[常量](#constants)。

它们只能从[接收器](#receiver-functions)、[获取器](#getter-functions)和其他内部函数中调用，而不能从其他合约或[`init(){:tact}`](#init-function)中调用。

```tact
contract Functions {
    val: Int = 0;

    // 该契约方法只能在该契约内部调用，并访问其变量
    fun onlyZeros() {
        require(self.val == 0, "Only zero are permitted!");
    }

    // 接收函数，调用内部函数 onlyZeros
    receive("only zeros") {
        self.onlyZeros();
    }
}
```
:::note
  请注意，Tact 还支持其他类型的函数，请参阅[函数](/zh-cn/book/functions)。
:::

[p]: /zh-cn/book/types#primitive-types
[特质]: /zh-cn/book/types#traits
[bp]: https://github.com/ton-org/blueprint


## debug.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/debug.mdx)
---
title: 调试 Tact 合约
---

import { LinkCard, CardGrid, Steps, Tabs, TabItem } from '@astrojs/starlight/components';

作为智能合约开发人员，我们编写的代码并不总是能实现我们的预期。 有时，它做的事情完全不同！ 当意外发生时，接下来的任务就是找出原因。 为此，有多种方法可以揭示代码中的问题或 "错误"。 让我们开始_调试_！

<CardGrid>
  <LinkCard
    title="一般方法"
    href="#approach"
  />
  <LinkCard
    title="调试模式"
    href="#debug-mode"
  />
  <LinkCard
    title="测试结构"
    href="#tests-structure"
  />
  <LinkCard
    title="转储值"
    href="#tests-dump"
  />
  <LinkCard
    title="预期某些状态"
    href="#tests-errors"
  />
  <LinkCard
    title="发送消息"
    href="#tests-send"
  />
  <LinkCard
    title="观察费用"
    href="#tests-fees"
  />
  <LinkCard
    title="预期退出代码"
    href="#tests-errors"
  />
  <LinkCard
    title="模拟时间"
    href="#tests-time"
  />
  <LinkCard
    title="发射和记录消息"
    href="#logging"
  />
  <LinkCard
    title="处理退回的消息"
    href="#bounced"
  />
  <LinkCard
    title="实验实验室设置"
    href="#lab"
  />
</CardGrid>

## 一般方法 {#approach}

目前，Tact 还没有步进式调试器。 尽管如此，仍然可以使用["printf 调试"](https://en.wikipedia.org/wiki/Debugging#printf_debugging) 方法。

这包括在整个代码中主动调用 [`dump(){:tact}`][dump]和 [`dumpStack(){:tact}`](/zh-cn/ref/core-debug#dumpstack)函数，并观察特定时间点的变量状态。 请注意，这些函数只在 [调试模式]（#debug-mode）下工作，否则不会执行。

:::note

  请参阅如何使用 [`dump(){:tact}`][dump]进行调试：[使用 `dump() 调试{:tact}`](#tests-dump)。

:::

除了转储值之外，使用 [`require(){:tact}`](/zh-cn/ref/core-debug#require)、[`nativeThrowIf(){:tact}`](/zh-cn/ref/core-debug#nativethrowif)和 [`nativeThrowUnless(){:tact}`](/zh-cn/ref/core-debug#nativethrowunless)等自信的函数通常也很有帮助。 它们有助于明确说明你的假设，并方便设置 "绊线"，以便在将来发现问题。

如果您没有找到或无法解决您的问题，请尝试在 Tact 的[Telegram 聊天][tg]中询问社区；如果您的问题或疑问与 TON 的关系大于与 Tact 的关系，请进入[TON Dev Telegram 聊天](https://t.me/tondev_eng)。

## 常用调试功能 {#debug-functions}

Tact 提供了大量对调试有用的各种函数：[核心库 → 调试](/zh-cn/ref/core-debug)。

## 在编译选项中启用调试模式 {#debug-mode}

Using `@tact-lang/emulator`

To make `dump` work you need to enable the feature `debug` in `tact.conf.json`.

如果您正在处理基于 [Blueprint][bp] 的项目，可以在合约的编译配置中启用调试模式，这些配置位于名为 `wrappers/` 的目录中：

```typescript title="wrappers/YourContractName.compile.ts" {7}
import { CompilerConfig } from '@ton/blueprint';

export const compile：CompilerConfig = {
  lang: 'tact',
  target: 'contracts/your_contract_name.tact',
  options：{
    debug: true, // ← that's the stuff！
  }
};
```

请注意，从 0.20.0 开始的 [Blueprint][bp] 版本会自动为新合约启用 `wrappers/` 中的调试模式。

除此之外，[蓝图][bp] 项目中仍可使用 [`tact.config.json`](/zh-cn/book/config)。 在这种情况下，除非在 `wrappers/` 中修改，否则 [`tact.config.json`](/zh-cn/book/config)中指定的值将作为默认值。

:::note

:::

## 在蓝图中编写测试，使用 Sandbox 和 Jest {#tests}

[蓝图][bp] 是一个流行的开发框架，用于在 TON 区块链上编写、测试和部署智能合约。

Ton Emulator allows you to have a small virtual blockchain in your Node.js code. This library is built specifically for testing smart contracts in unit tests.

无论何时创建一个新的 [Blueprint][bp] 项目，或在现有项目中使用 "blueprint create "命令，都会创建一个新的合同以及测试套件文件。

这些文件被放在`tests/`文件夹中，并用[Jest][jest]执行。 默认情况下，除非指定特定组或测试关闭，否则所有测试都会运行。 有关其他选项，请参阅 Jest CLI 中的简要文档：`jest --help`。

### 测试文件的结构 {#tests-structure}

假设我们有一份名为 `Playground` 的合同，写在 `contracts/playground.tact` 文件中。 如果我们通过 [Blueprint][bp] 创建了该合约，那么它也会为我们创建一个 `tests/Playground.spec.ts` 测试套件文件。

测试文件包含一个 `describe(){:typescript}` [Jest][jest] 函数调用，表示一个测试组。

在该组中，有三个变量在所有测试中都可用：

- `blockchain` - 由[沙盒][sb]提供的本地区块链实例
- deployer\` - 一个 TypeScript 封装器，用于部署我们的 Playground 合约或我们希望部署的任何其他合约
- `playground` - 我们的 `Playground` 合约的 TypeScript 封装器

:::note

  更新 `.tact` 代码和运行测试而不先进行构建是一个常见错误。 这是因为 [Blueprint][bp] 中的测试依赖于 Tact 编译器生成的 TypeScript 封装程序，并与最新的构建程序一起工作。

  这就是为什么每次更改 Tact 代码时，都要确保在执行测试套件之前使用 `npx blueprint build` 进行构建。 为方便起见，您可以将构建和测试合并为一条命令，如 [实验性实验室设置](#lab-4) 所示。

:::

然后，调用一个 `beforeEach(){:tact}` [Jest][jest] 函数--它指定了在每个后续测试闭包之前要执行的所有代码。

:::note

  强烈建议不要修改 `beforeEach(){:tact}` 中的内容，除非您确实需要为每个测试闭包设置某些特定行为，或者 [`init(){:tact}`](/zh-cn/book/contracts#init-function)函数的参数发生了变化。

:::

最后，通过调用 `it(){:tact}` [Jest][jest] 函数来描述每个测试闭包--这就是实际编写测试的地方。

Example of a minimal test file:

```typescript
it('should deploy', async () => {
  // 检查是在 beforeEach 内部进行的，因此此处可以为空
})；
```

### 使用 `dump()` 调试 {#tests-dump}

要查看 [`dump(){:tact}`][dump]函数调用的结果，并使用["printf 调试"](#approach) 方法，就必须

1. 在代码的相关位置调用 [`dump(){:tact}`][dump]和其他[常用调试函数](#debug-functions)。
2. 运行 [Jest][jest]测试，这些测试将调用目标函数并向目标接收器发送信息。

假设你已经创建了一个 [新计数器合约项目](/zh-cn/#start)，让我们来看看它是如何实际运行的。

首先，让我们在 `contracts/simple_counter.tact` 中调用 [`dump(){:tact}`][dump]，这将把 `msg{:tact}` [Struct][struct] 中传递的 `amount` 输出到合约的调试控制台：

```tact title="contracts/simple_counter.tact" {3}
// ...
receive(msg: Add) {
    dump(msg.amount);
    // ...
}
// ...
```

接下来，让我们注释掉 `tests/SimpleCounter.spec.ts` 文件中所有现有的 `it(){:typescript}` 测试闭包。 然后再加上下面一条：

```typescript title="tests/SimpleCounter.spec.ts"
it('should dump', async () => {
  await playground.send(
    deployer.getSender(),
    { value: toNano('0.5') },
    { $$type: 'Add', queryId: 1n, amount: 1n },
  );
})；
```

它向我们合约的 `receive(msg: Add){:tact}` [接收器](/zh-cn/book/receive) 发送信息，而不存储[发送结果](#tests-send)。

现在，如果我们使用 `yarn build{:shell}` 构建我们的合约，并使用 `yarn test{:shell}` 运行我们的测试套件，我们将在测试日志中看到以下内容：

```txt
console.log
  #DEBUG#: [DEBUG] File contracts/simple_counter.tact:17:9
  #DEBUG#: 1

    at SmartContract.runCommon (node_modules/@ton/sandbox/dist/blockchain/SmartContract.js:221:21)
```

这是由我们上面的 [`dump(){:tact}`][dump]调用产生的。

:::note

  了解有关在测试中向合约发送消息的更多信息：[向合约发送消息](#tests-send)。

:::

### 使用`expect()`说明期望 {#tests-expect}

编写测试不可或缺的部分是确保你的期望与观察到的现实相吻合。 为此，[Jest][jest] 提供了一个函数 `expect(){:tact}`，使用方法如下：

1. 首先，提供一个观测变量。
2. 然后，调用特定的方法来检查该变量的某个属性。

下面是一个更复杂的示例，它使用 `expect(){:tact}` 函数来检查计数器合约是否确实正确地增加了计数器：

```typescript
it('should increase counter', async () => {
  const increaseTimes = 3;
  for (let i = 0; i < increaseTimes; i++) {
    console.log(`increase ${i + 1}/${increaseTimes}`);

    const increaser = await blockchain.treasury('increaser' + i);

    const counterBefore = await simpleCounter.getCounter();
    console.log('counter before increasing', counterBefore);

    const increaseBy = BigInt(Math.floor(Math.random() * 100));
    console.log('increasing by', increaseBy);

    const increaseResult = await simpleCounter.send(
      increaser.getSender(),
      { value: toNano('0.05') },
      { $$type: 'Add', queryId: 0n, amount: increaseBy }
    );

    expect(increaseResult.transactions).toHaveTransaction({
      from: increaser.address,
      to: simpleCounter.address,
      success: true,
    });

    const counterAfter = await simpleCounter.getCounter();
    console.log('counter after increasing', counterAfter);

    expect(counterAfter).toBe(counterBefore + increaseBy);
  }.
});
```

:::note

  查看 [Sandbox][sb] 文档中的更多测试示例：
  [Testing flow (FunC)](https://github.com/ton-org/sandbox/blob/main/docs/testing-key-points.md)
  [Writing tests for Tact](https://github.com/ton-org/sandbox/blob/main/docs/tact-testing-examples.md)

:::

### 实用方法 {#tests-jest-utils}

由 [Blueprint][bp] 生成的测试文件导入了 `@ton/test-utils` 库，该库为 `expect(){:typescript}` [Jest][jest] 函数的结果类型提供了一些额外的辅助方法。 请注意，`toEqual(){:typescript}`等常规方法仍然存在，随时可以使用。

#### 有交易

方法 `expect(…).toHaveTransaction(){:typescript}` 检查事务列表中是否有符合你指定的某些属性的事务：

```typescript {2}
const res = await yourContractName.send(…);
expect(res.transactions).toHaveTransaction({
  // For example, let's check that a transaction to your contract was successful:
  to: yourContractName.address,
  success: true,
})；
```

要了解此类属性的完整列表，请查看编辑器或集成开发环境提供的自动完成选项。

#### toEqualCell

方法 `expect(…).toEqualCell(){:typescript}` 检查两个 [单元格](/zh-cn/book/cells#cells)是否相等：

```typescript {3}
expect(oneCell).toEqualCell(anotherCell)；
```

#### 对等切片

方法 `expect(…).toEqualSlice(){:typescript}` 检查两个 [slices](/zh-cn/book/cells#slices) 是否相等：

```typescript {3}
expect(oneSlice).toEqualSlice(anotherSlice)；
```

#### toEqualAddress

方法 `expect(…).toEqualAddress(){:typescript}` 检查两个 [地址](/zh-cn/book/types#primitive-types)是否相等：

```typescript {3}
expect(oneAddress).toEqualAddress(anotherAddress)；
```

### 发送信息至 {#tests-send}

要向合约发送消息，请在其 TypeScript 封装器上使用 `.send(){:typescript}` 方法，如下所示：

```typescript
// 它接受 3 个参数：
await yourContractName.send(
  // 1. 消息的发送者
  deployer.getSender(), // 这是一个默认的宝库，可以替换

  // 2. 值和（可选）反弹，默认为 true
  { value: toNano('0.5'), bounce: false },

  // 3. 消息正文，如果有的话
  'Look at me!',
)；
```

消息体可以是简单的字符串，也可以是指定 [消息](/zh-cn/book/structs-and-messages#messages)类型字段的对象：

```typescript {4-8}
await yourContractName.send(
  deployer.getSender(),
  { value: toNano('0.5') },
  {
    $$type: 'NameOfYourMessageType',
    field1: 0n, // bigint zero
    field2: 'yay',
  },
)；
```

通常情况下，存储此类发送的结果非常重要，因为它们包含发生的事件、进行的事务和发送的外部信息：

```typescript
const res = await yourContractName.send(…);
// res.events - 发生的事件数组
// res.externals - 外部输出消息数组
// res.transactions - 完成的交易数组
```

这样，我们就可以轻松地过滤或检查某些交易：

```typescript
expect(res.transactions).toHaveTransaction(…)；
```

### 遵守收费和价值 {#tests-fees}

[沙盒][sb]提供了一个辅助函数 `printTransactionFees(){:typescript}`，它可以漂亮地打印所提供交易的所有值和费用。 它对观察 [纳米通币]（/book/integers#nanotoncoin）的流动非常方便。

要使用它，请在测试文件顶部修改来自 `@ton/sandbox` 的导入：

```typescript
import { Blockchain, SandboxContract, TreasuryContract, printTransactionFees } from '@ton/sandbox';
// ^^^^^^^^^^^^^^^^^^^^
```

然后，提供一个事务数组作为参数，就像这样：

```typescript
printTransactionFees(res.transactions)；
```

要处理计算和操作 [阶段](https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases)的总费用或费用的单个值，请逐个检查每笔交易：

```typescript {11,17,21}
// 将接收方处理的交易存储在一个单独的常量中
const receiverHandledTx = res.transactions[1];
expect(receiverHandledTx.description.type).toEqual('generic');

// 为了满足 TypeScript 的要求
if (receiverHandledTx.description.type !== 'generic') {
  throw new Error('Generic transaction expected');
} // Total fees

// 总费用
console.log('Total fees: ', receiverHandledTx.totalFees);

// 计算费用
const computeFee = receiverHandledTx.description.computePhase.type === 'vm'
  ?receiverHandledTx.description.computePhase.gasFees
  : undefined;
console.log('Compute fee: ', computeFee);

// Action fee
const actionFee = receiverHandledTx.description.actionPhase?.totalActionFees;
console.log('Action fee: ', actionFee);

// 现在我们可以进行一些相关检查，比如将费用限制在 1 Toncoin
expect(
  (computeFee ?? 0n)
  + (actionFee ?? 0n)
).toBeLessThanOrEqual(toNano('1'))；
```

:::note

  [沙盒][sb]还有很多实用功能，通常都很方便。 例如，它提供了 `prettyLogTransaction(){:typescript}` 和 `prettyLogTransactions(){:typescript}`，分别对单个或多个事务进行操作，并漂亮地打印地址之间的值流。

:::

### 有故意错误的交易 {#tests-errors}

有时，进行负面测试也很有用，它可以故意出错并抛出特定的[退出代码](/zh-cn/book/exit-codes)。

[蓝图][bp]中此类[Jest][jest]测试闭包的示例：

```typescript title="tests/YourTestFileHere.spec.ts" {9,15}
it('throws specific exit code', async () => {
  // 向我们的合约发送特定消息并存储结果
  const res = await your_contract_name.send(
    deployer.getSender(),
    {
      value: toNano('0.5'), // 值以发送的 nanoToncoins 为单位
      bounce: true, // (default) bounceable message
    },
    'the message your receiver expects', // ← change it to yours
  );

  // Expect the transaction to our contract fail with a certain exit code
  expect(res.transactions).toHaveTransaction({
    to: your_contract_name.address,
    exitCode：5, // ← 更改为您的
  });
})；
```

请注意，要跟踪具有特定退出代码的事务，只需在 `expect(){:typescript}` 方法的 `toHaveTransaction(){:typescript}` 对象参数中指定 `exitCode` 字段即可。

不过，通过指定收件人地址 "to "来缩小范围是很有用的，这样 Jest 就只能查看我们发送给合同的消息所引起的事务。

### 模拟时间流逝 {#tests-time}

由 [Sandbox][bp] 提供的本地区块链实例中的 Unix 时间从 `beforeEach(){:typescript}` 块中创建这些实例的时刻开始。

```typescript {2}
beforeEach(async () => {
  blockchain = await Blockchain.create(); // ← here
  // ...
});
```

在此之前，我们曾被警告不要修改 `beforeEach(){:typescript}` 块，除非我们真的需要这样做。 而现在，我们要做的，就是稍稍推翻时间和时空旅行。

让我们在末尾添加下面一行，将 `blockchain.now` 明确设置为处理部署消息的时间：

```typescript {3}
beforeEach(async () => {
  // ...
  blockchain.now = deployResult.transactions[1].now;
})；
```

现在，我们可以在测试子句中操作时间了。 例如，让我们在部署一分钟后进行一次交易，两分钟后再进行一次交易：

```typescript {2,4}
it('your test clause title', async () => {
  blockchain.now += 60; // 60 seconds late
  const res1 = await yourContractName.send(…);
  blockchain.now += 60; // another 60 seconds late
  const res2 = await yourContractName.send(…);
})；
```

## 通过 `emit` 记录 {#logging}

[全局静态函数](/zh-cn/book/functions#global-static-functions) [`emit(){:tact}`](/zh-cn/ref/core-common#emit)向外部世界发送信息--它没有特定的接收者。

该功能对于记录和分析链外数据非常方便，只需查看合约生成的 [external messages](/zh-cn/book/external) 即可。

### 本地沙箱测试中的日志 {#logging-local}

在 [Sandbox][sb] 中部署时，您可以从 [receiver function](/zh-cn/book/contracts#receiver-functions) 中调用 [`emit(){:tact}`](/zh-cn/ref/core-common#emit)，然后观察已发送的 [external messages](/zh-cn/book/external) 列表：

```typescript {9-10}
it('emits', async () => {
  const res = await simpleCounter.send(
    deployer.getSender(),
    { value: toNano('0.05') },
    'emit_receiver', // ← change to the message your receiver handles
  );

  console.log("Address of our contract: " + simpleCounter.address);
  console.log(res.externals); // ← 在这里可以看到 emit() 调用的结果，
                              // 以及所有外部消息
})；
```

### 已部署合同的日志 {#logging-deployed}

TON 区块链上的每笔交易都[包含`out_msgs`](https://docs.ton.org/develop/data-formats/transaction-layout#transaction) - 这是一个字典，保存着执行交易时创建的传出消息列表。

要查看字典中 [`emit(){:tact}`](/zh-cn/ref/core-common#emit)的日志，请查找没有收件人的外部消息。 在各种 TON 区块链探索器中，此类交易将被标记为 "外部输出"，目的地指定为"-"或 "空"。

请注意，有些探索者会为你反序列化发送的信息体，而有些则不会。 不过，您可以随时在本地[自行解析]（#logging-parsing）。

### 解析已发送信息的正文 {#logging-parsing}

Example:

```tact
// 我们有一个结构
struct Ballroom {
    meme：Bool;
    in：Int;
    theory：String;
}

// 还有一个简单的合约，
contract Bonanza {
    // 可以接收一个字符串消息，
    receive("time to emit") {
        // 发送一个字符串
        emit("But to the Supes?Absolutely diabolical.".asComment());

        // and a Struct
        emit(Ballroom{meme: true, in：42, theory: "Duh"}.toCell());
    }
}
```

现在，让我们为 "Bonanza "合同制作一个简单的 [测试条款]（#tests-structure）：

```typescript /bonanza/
it('emits', async () => {
  const res = await bonanza.send(
    deployer.getSender(),
    { value: toNano('0.05') },
    'time to emit',
  );
})；
```

在这里，`res` 对象的`externals`字段将包含已发送的[外部信息]（/book/external）列表。 让我们访问它，以解析通过调用 Tact 代码中的 [`emit(){:tact}`](/zh-cn/ref/core-common#emit)（或简称 _emitted_）发送的第一条信息：

```typescript /body/
it('emits', async () => {
  // ... 之前的代码 ...

  // 我们只需要观察到的消息正文：
  const firstMsgBody = res.externals[0].body;

  // 现在，我们来解析它，因为我们知道它是一条文本消息。
  // NOTE: In a real-world scenario,
  // you'd want to check that first or wrap this in a try...catch
  const firstMsgText = firstMsgBody.asSlice().loadStringTail();

  // "But to the Supes?绝对邪恶。"
  console.log(firstMsgText);
})；
```

要解析第二条发出的信息，我们可以手动使用一堆 `.loadSomething(){:typescript}` 函数，但这样做太麻烦了--如果 `Ballroom{:tact}` [Struct][struct] 的字段发生变化，就需要重新开始。 当你以这种方式编写大量测试时，可能会适得其反。

幸运的是，Tact 编译器会自动为合约生成 TypeScript 绑定（或封装），在测试套件中重新使用它们非常容易。 它们不仅有一个你正在测试的合约的包装器，而且还导出了一堆辅助函数来存储或加载合约中定义的 [Structs][struct] 和 [Messages][message] 。 后者的命名方式与 [Structs][struct] 和 [Messages][message] 一样，只是在前面加上了 `load` 前缀。

例如，在我们的例子中，我们需要一个名为 `loadBallroom(){:typescript}` 的函数，用于将 [`Slice{:tact}`][slice]解析为 TypeScript 中的 `Ballroom{:tact}` [Struct][struct] 。 要导入它，要么键入名称，让集成开发环境建议自动导入，要么查看测试套件文件的顶部--应该有类似的一行：

```typescript
import { Bonanza } from '../wrappers/Bonanza';
// ^ 这里可以导入 loadBallroom
```

现在，让我们来解析第二条发出的信息：

```typescript
it('emits', async () => {
  // ... 之前的代码 ...

  // 我们只需要观察到的消息正文：
  const secondMsgBody = res.externals[1].body;

  // 现在，让我们解析它，知道它是 Ballroom Struct。
  // NOTE: In a real-world scenario,
  // you'd want to check that first or wrap this in a try...catch
  const secondMsgStruct = loadBallroom(secondMsgBody.asSlice());

  // { '$$type': 'Ballroom', meme: true, in：42n, theory: 'Duh' }
  console.log(secondMsgStruct);
})；
```

请注意，即使在我们的测试套件之外，也可以解析已部署合约的发射信息。您只需获取发射的消息体，然后像上面的示例一样，在 `@ton/core` 库旁使用自动生成的 Tact 的 TypeScript 绑定。

## 处理退回的邮件 {#bounced}

当 [send](/zh-cn/book/send) 带有 `bounce: true{:tact}` 时，信息会在出错时反弹。确保编写相关的 [`bounced(){:tact}`](/zh-cn/book/bounced) 消息[接收器](/zh-cn/book/contracts#receiver-functions)，并优雅地处理被退回的消息：

```tact
bounced(msg: YourMessage) {
    // ...alright squad, let's bounce!...
}
```

请记住，在 TON 中被退回的邮件正文中只有 $224$ 个可用数据位，而且没有任何引用，因此无法从中恢复很多数据。 不过，您仍然可以看到邮件是否被退回，从而可以创建更稳健的合同。

了解更多有关退信和收信人的信息：[退信](/zh-cn/book/bounced)。

## 实验实验室设置 {#lab}

如果你对 [Blueprint][bp] 的测试设置感到不知所措，或者只是想快速测试一些东西，不用担心--有一种方法可以建立一个简单的游戏场作为实验实验室，来测试你的想法和假设。

<Steps>

1. #### 创建新的蓝图项目 {#lab-1}

   这将防止任意代码和测试污染您现有的程序。

   新项目可以取任何名字，但我会取名为 "Playground"，以表达正确的意图。

   要创建它，请运行以下命令：

   <Tabs>
     <TabItem label="yarn" icon="seti:yarn">
       ```shell
       # 推荐
       yarn create ton tact-playground --type tact-empty --contractName Playground
       ```
     </TabItem>
     <TabItem label="npm" icon="seti:npm">
       ```shell
       npm create ton@latest -- tact-playground --type tact-empty --contractName Playground
       ```
     </TabItem>
     <TabItem label="pnpm" icon="pnpm">
       ```shell
       pnpm create ton@latest tact-playground --type tact-empty --contractName Playground
       ```
     </TabItem>
     <TabItem label="bun" icon="bun">
       ```shell
       bun create ton@latest tact-playground --type tact-empty --contractName Playground
       ```
     </TabItem>
   </Tabs>

   从 0.20.0 开始的 [Blueprint][bp] 版本会自动为新合约启用 `wrappers/` 中的调试模式，因此我们只需调整测试套件并准备好我们的 `Playground` 合约即可进行测试。

2. #### 更新测试套件 {#lab-2}

   移动到新创建的 `tact-playground/` 项目，在 `tests/Playground.spec.ts` 中，将 `"should deploy"{:tact}` 测试闭包改为以下内容：

   ```typescript title="tests/Playground.spec.ts"
   it('plays', async () => {
     const res = await playground.send(
       deployer.getSender(),
       { value: toNano('0.5') }, // ← 在这里你可以增加发送的纳币值
       'plays',
     );

     console.log("Address of our contract: " + playground.address);
     console.log(res.externals); // ← 在这里可以看到 emit() 调用的结果
   })；
   ```

3. #### 修改合同 {#lab-3}

   用以下代码替换`contracts/playground.tact`中的代码：

   ```tact title="contracts/playground.tact" {4-6}
   import "@stdlib/deploy";

   合同 Playground with Deployable {
       receive("plays") {
           // NOTE: write your test logic here！
       }
   }
   ```

   此设置的基本思想是将要测试的代码放入 [receiver function](/zh-cn/book/contracts#receiver-functions) 中，以响应 [string](/zh-cn/book/types#primitive-types) 消息 `"plays"{:tact}`。

   请注意，您仍然可以在[接收器]（/book/contracts#receiver-functions）之外编写任何有效的 Tact 代码。 但为了测试它，你需要在其中编写相关的测试逻辑。

4. #### 我们来测试一下！ {#lab-4}

   这样，我们的实验装置就完成了。 要执行我们为 "Playground "合约准备的单个测试，请运行以下程序：

   ```shell
   yarn test -t plays
   ```

   从现在起，您只需修改 Tact 合同文件中已测试的 [receiver function]（/book/contracts#receiver-functions）的内容，然后重新运行上述命令，就可以对某些内容进行测试。 冲洗并重复这个过程，直到你测试了你想测试的东西。

   为了简化和更干净的输出，您可以在 `package.json` 中为 `scripts` 添加一个新字段，这样您只需运行 `yarn lab{:shell}` 即可在一个字段中完成构建和测试。

   在 Linux 或 macOS 上，它看起来就像这样：

   ```json filename="package.json" {3}
   {
     "脚本"：{
       "lab"："blueprint build 1>/dev/null && yarn test -t plays"
     }
   }
   ```

   下面是它在 Windows 上的样子：

   ```json filename="package.json" {3-4}
   {
     "脚本"：{
       "build"："blueprint build | out-null",
       "lab"："yarn build && yarn test -t plays"
     }
   }
   ```

   要运行

   ```shell
   纱线实验室
   ```

</Steps>

[转储]: /zh-cn/ref/core-debug#dump
[结构]: </book/structs and-messages#structs>
[信息]: </book/structs and-messages#messages>
[电池]: /zh-cn/book/cells#cells
[一片]: /zh-cn/book/cells#slices
[tg]: https://t.me/tactlang
[bp]: https://github.com/ton-org/blueprint
[某人]: https://github.com/ton-org/sandbox
[笑话]: https://jestjs.io


## deploy.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/deploy.mdx)
---
title: 部署
---

Tact Deployer 是一个与 [TON Verifier](https://verifier.ton.org) 集成的小型库，可让您使用自己喜欢的钱包安全地部署合约，而无需管理密钥或手动部署合约。 Tact Deployer 还能自动验证合同的源代码，确保编译器不受损害。

## 要求

要使用 Tact Deployer，您的合约必须具有 `@stdlib/deploy` 包中的 `Deployer` 特性。

## 安装

要在项目中添加 Tact 部署器，只需使用 `yarn`：

```bash
yarn add @tact-lang/deployer
```

## 如何使用

当你使用 Tact 构建智能合约时，它会生成一个包（\*.pkg）文件，其中包含所构建智能合约的所有必要信息。要在 TON 中部署智能合约，你需要发送一条附有`init`数据的消息。

```typescript
import * as fs from 'fs';
import * as path from 'path';
import { Address, contractAddress } from "ton";
import { SampleTactContract } from "./output/sample_SampleTactContract";
import { prepareTactDeployment } from "@tact-lang/deployer";

// Parameters
let testnet = true; // Flag for testnet or mainnet
let packageName = 'sample_SampleTactContract.pkg'; // 要部署的软件包名称
let outputPath = path.resolve(__dirname, 'output'); // 输出目录的路径
let owner = Address.parse('<put_address_here>'); // 我们的示例合同有一个所有者
let init = await SampleTactContract.init(owner); // 为我们的合同创建初始数据

// 计算
let address = contractAddress(0, init); // 计算合同地址。MUST match with the address in the verifier
let data = init.data.toBoc(); // Create init data
let pkg = fs.readFileSync( // Read package file
    path.resolve(outputPath, packageName)
);

// Prepare deploy
let link = await prepareTactDeployment({ pkg, data, testnet });

// Present a deployment link and contract address
console.log('Address：' + address.toString({ testOnly: testnet }));
console.log('Deploy link: ' + link)；
```

点击此链接后，您就可以部署和验证您的智能合约。


## exit-codes.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/exit-codes.mdx)
---
title: 退出代码
---

:::caution
  根据 [#106] (https://github.com/tact-lang/tact-docs/issues/106)，本页正在重建中。 所有锚链接 (`#`) 今后都可能发生变化！
:::

退出代码是一个 $16$-bit 无符号整数，范围在 $0$ 到 $65535$ 之间（或 2_{16} - 1$）。

$0$ 至 $127$ 的代码分配给 FunC (TVM)， $128$ 至 $255$ 的代码分配给 Tact。 从 $256$ 到 $65535$ 的范围内，开发人员可自由定义退出代码。

预先分配的退出代码列表：

| 退出代码 | 相位 | 说明 |
| :--- | :--- | :--- |
| $0$ | [计算阶段][c] | 标准成功执行退出代码 |
| $2$ | [计算阶段][c] | 堆栈下溢。最后一个操作码消耗的元素多于堆栈中的元素数量 |
| $3$ | [计算阶段][c] | 堆栈溢出。堆栈中存储的值超过了该版本 TVM 的允许值 |
| $4$ | [计算阶段][c] | 整数溢出。整数不适合 $-2^{256} \leq x < 2^{256}$ 或发生了零除法 |
| $5$ | [计算阶段][c] | 整数超出预期范围 |
| $6$ | [计算阶段][c] | 操作码无效。在当前的 TVM 版本中，指令不详 |
| $7$ | [计算阶段][c] | 类型检查错误。基元参数的值类型不正确 |
| $8$ | [计算阶段][c] | 电池溢出。不可能将数据写入生成器，因为操作后将有超过 1023 位或 4 个引用 |
| $9$ | [计算阶段][c] | 单元下溢。从片原始码读取数据时，试图读取的比特或引用数多于现有比特或引用数 |
| $10$ | [计算阶段][c] | 词典错误。处理字典（哈希图）时出错 |
| $13$ | [计算阶段][c] |  gas 耗尽错误。当剩余 gas 变为负值时，由 TVM 抛出 |
| $-14$ | [计算阶段][c] | 这意味着 gas 耗尽错误，与 $13$ 相同。否定，因为无法伪造 |
| $32$ | [行动阶段][a] | 操作列表无效。如果执行后的 c5 寄存器包含不可解析对象，则在操作阶段设置该寄存器 |
| $34$ | [行动阶段][a] | 操作无效或不支持。如果无法执行当前操作，则在操作阶段设置 |
| $37$ | [行动阶段][a] | 不够吨。信息发送的吨数过多（或扣除费用后吨数不足） |
| $38$ | [行动阶段][a] | 额外货币不足 |
| $128$ | 塔克（编译） | 空引用异常--编译器预期是一个整数或单元格，但传递了一个空值 |
| $129$ | 塔克（编译） | 无效序列化前缀--如果与之前的操作码检查有任何不一致，将抛出此退出代码 |
| $130$ | 塔克（编译） | 收到的报文无效 - 未找到合适的操作 |
| $131$ | 塔克（编译） | 制约因素错误 |
| $132$ | 塔克（编译） | 拒绝访问 - 所有者以外的其他人向合同发送了信息 |
| $133$ | 塔克（编译） | 合同已停止 - 已向停止的合同发送信息 |
| $134$ | 塔克（编译） | 无效参数 - 无效 Base64 字符串 |
| $135$ | 塔克（编译） | 未找到合同代码 - 字典调用的假标记 |
| $136$ | 塔克（编译） | 无效地址 - 非 $267$- 位地址或无效链 id（非 0 或 -1） |
| $137$ | 塔克（编译） | 此合约未启用主链支持 |

[c]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase
[a]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases

问：**在哪里可以看到项目中所有自动生成的退出代码列表？**
答：Tact 编译器会在 \*.md 文件末尾收集所有退出代码，您可以在
路径"./ProjectFolder/build/ProjectName/tact_ProjectName.md "下的目录中跟踪它们。

问：** 如何观察抛出的退出代码？**
答：在 Tact 中，打印交易来查看结果是不明智的，因为它们不容易读取。 如果想查看事务的退出代码，
，在 Typescript 本地测试中使用下面的模板：

```typescript
const sender = await blockchain.treasury('sender');
const result = await contractName.send(sender.getSender(), { value: toNano('0.05'), }, { transactionData });

expect(result.transactions).toHaveTransaction(
    { from: sender.address, to: contractName.address, exitCode: YOUR_DESIRED_EXIT_CODE }
)；
```

- 第一行定义发件人。
- 第二行发送交易。
- 在第三行中，您要检查结果中是否有从发送方到您的合约的交易，以及您所需的退出代码。

## 计算阶段

### $0$：成功执行 {#0}

该退出代码表示事务的计算阶段已成功完成。

### $4$：整数溢出 {#4}

在 TVM 中，整数的范围可以是 $-2^{256} < x < 2^{256}$。
如果计算过程中的值超出了这个范围，就会抛出 4 个退出代码。

例如

```tact
self.id = 1; // 使用存储变量强制不忽略它
repeat(256) {
    self.id = 2 * self.id;
}
```

### $5$：超出预期范围的整数 {#5}

如果整数值超出预期范围，则抛出 5 个退出代码。
例如，如果在 .store_uint() 函数中使用了负值。 在 Tact 中，还有其他一些新情况，例如：
1- 如你所知，你可以在 Tact 中定义更多有限的整数（小于 257 位的整数）。2- 根据 ````storeUint(self: Builder, value: Int, bits: Int)```函数，不能使用 ````storeUint(0, 257)``` 因为 ``0 ≤ bits ≤ 256```。

例如

```tact
// 选项 1 -> id: Int as uint32
self.id = 1; // 强制使用存储变量不忽略它
repeat(32) {
    self.id = 2 * self.id;
}

// 选项 2 -> 根据 storeUint(self: Builder, value: Int, bits: Int) 函数，不可能使用 storeUint(0, 1024) 因为 0 ≤ bits ≤ 256
let s：Slice = beginCell().storeUint(0, 257).asSlice()；
```

### $8$：单元格溢出 {#8}

一个单元可存储 1023 位数据和 4 个指向其他单元的引用。
如果尝试写入超过 1023 位或超过 4 个引用，则会抛出 8 个退出代码。

例如

```tact
// 根据 storeUint(self: Builder, value: Int, bits: Int) 函数，无法使用 storeUint(0, 1024) 因为 0 ≤ bits ≤ 256
let s：Slice = beginCell().storeUint(0, 256).storeUint(0, 256).storeUint(0, 256).storeUint(0, 256).asSlice()；
```

### $9$：单元下溢 {#9}

如果尝试从片段中读取的数据多于其包含的数据，则会抛出 9 个退出代码。

例如

```tact
让 s：Slice = emptySlice();
self.id = s.loadUint(1); // 使用存储变量强制不忽略它
```

### $13$: 气用尽错误 {#13}

如果没有足够的 TON 来处理计算阶段，则会抛出此错误。

在处理过程中，将对该值执行 NOT 操作，从而将该值更改为 -14。 这样做是为了防止使用 throw 函数伪造退出代码，因为所有此类函数都只接受正值的退出代码，这一点在前面已经讨论过。

例如

```tact
repeat(10000) {
    self.id += 1;
}
```

## 行动阶段

### $34$行动无效或不支持 {#34}

在处理操作时，该退出代码会导致大部分错误：无效信息、不正确操作等。

例如

```tact
nativeSendMessage(emptyCell(), 0)；
```

### $37$TON {#37}

这意味着没有足够的 TON 来发送指定的数量。

例如

```tact
send(SendParameters{to: context().sender, value: ton("10")})；
```

## 塔克（编译）

### 128：空引用异常 {#128}

如果有一个非空断言，例如 [`!!{:tact}`](/zh-cn/book/operators#unary-non-null-assert)操作符，而检查值是 [`null{:tact}`](/zh-cn/book/optionals)，则会抛出一个退出代码为 $128$ 的错误："空引用异常"。

```tact
let gotcha: String? = null;

try {
    // Asserting that the value isn't null, which isn't the case!
    dump(gotcha!!);
} catch (exitCode) {
    exitCode; // 128
}
```

### $130$来信无效 {#130}

向合约发送信息时，信息体的前 32 位是操作码。 它决定了必须进行的操作。
在 FunC 中，如果找不到操作码，就会抛出 0xffff。 在 Tact 中，将抛出 130 个退出代码。

例如

1. 首先，像下面这样定义一个空合约：

```tact
合同烟花 {}
```

2. 然后，给这份合同发送信息。 由于没有找到合适的操作，您将得到此退出代码。

### $132$: 拒绝访问 {#132}

首先，你应该导入并继承 Ownable Trait。 之后，您的合同就有了所有者。
您可以在函数中调用 ```self.requireOwner();``` 要求检查。 这将确保只有所有者才能向您的合同发送信息。

例如

```tact
import "@stdlib/deploy";
import "@stdlib/ownable";

message FakeLaunch {

}

contract Fireworks with
    Deployable,
    Ownable,
{
    owner: Address;

    init(){
        self.owner = sender();
    }

    receive(msg: FakeLaunch){
        self.requireOwner();
    }
}

fun requireOwner() {
        nativeThrowUnless(132, sender() == self.owner);
}
```

### $133$: 合同停止 {#133}

stoppable 特性允许停止合约。
如果向已停止的合约发送信息，而合约通过运行 \`\`self.requireNotStopped();\`\`\`\` 要求检查，则会抛出此退出代码。
在当前版本的 Tact 中，将抛出 40368 而不是 133 的退出代码。

例如

```tact
import "@stdlib/deploy";
import "@stdlib/ownable";
import "@stdlib/stoppable";

message FakeLaunch {}

contract Fireworks with
    Deployable,
    Ownable,
    Stoppable,
{
    owner: Address;
    stopped：Bool;

    init() {
        self.owner = sender();
        self.stopped = false;
    }

    receive(msg: FakeLaunch) {
        self.stopped = true;
        self.requireNotStopped();
    }
}

fun requireNotStopped() {
    require(!self.stopped, "Contract stopped");
}
```

### $134$参数无效 {#134}

下面的 FunC 函数（在一堆 if 条件的最后一部分）将抛出这个问题。 该函数从 Base64 中读取内容。

如果输入字符不符合 base64 字符，就会出现此退出代码。

例如

```tact
让代码Slice = beginCell().storeUint(0, 8).asSlice().fromBase64();
// 0 不是有效的 ASCII 码，因此无法转换为 Base64 码。
```

### $135$：未找到合同代码 {#135}

它将检查字典键搜索的返回标志。

例如

```tact
// copy & paste the below line in wrapper file(../build/ContractName/tact_ContractName.ts) instead of the second line of ContractName_init() function - this is a dictionary containing another smart contract code which leads to 135 exit code
// const __system = Cell.fromBase64('te6cckECIwEAB1EAAQHAAQEFodSXAgEU/wD0pBP0vPLICwMCAWIPBAIBIA0FAgEgDAYCAUgLBwIBIAkIAHWs3caGrS4MzmdF5eotqc1vCmiu5ihm5iaqaEpGiYzo5syoyYptJmhuDSoKamwmziqo5spNKy0NLapwQAIRrt7tnm2eNijAIAoAAiQAEbCvu1E0NIAAYACVu70YJwXOw9XSyuex6E7DnWSoUbZoJwndY1LStkfLMi068t/fFiOYJwIFXAG4BnY5TOWDquRyWyw4JwnZdOWrNOy3M6DpZtlGbopIAhG+KO7Z5tnjYowgDgACIwN+0AHQ0wMBcbCjAfpAASDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IhUUFMDbwT4YQL4Yts8VRTbPPLggts8IBIQARbI+EMBzH8BygBVQBEA8lBUINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiM8WWCDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IjPFgEgbpUwcAHLAY4eINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiM8W4hL0AAHIgQEBzwDJAczJ7VQC9gGSMH/gcCHXScIflTAg1wsf3iCCEIQwhou6jtYw0x8BghCEMIaLuvLggfpAASDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IgBgQEB1wD6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIQzBsE+AgghAF6DTmuhkTAvyO0DDTHwGCEAXoNOa68uCB+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiAH6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIEmwS4CCCEHKDsbi6jpQw0x8BghByg7G4uvLggdQBMds8f+DAAAHXScEhsJF/4HAXFATw+EFvJBAjXwMkbrOOF4ERTVNxxwWSMX+ZJSBu8tCAWMcF4vL0mSaBEU0CxwXy9OL4ACDIAYIQcoOxuFjLH8zJI9s8kyBus48kICBu8tCAbyIxggkxLQAjfwNwQwNtbds8IG7y0IBvIjBSQNs86FtwgwYmA39VMG1tFh4dFQEE2zweADSBAQH0hG+lwP+dIG7y0IABIG7y0IBvAuBbbQLQNPhBbyQQI18D+ENUECfbPAGBEU0CcFnIcAHLAXMBywFwAcsAEszMyfkAyHIBywFwAcsAEsoHy//J0CDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IgixwXy9ANwgEBwVSBtbW3bPH8YHgDaAtD0BDBtAYIA6ksBgBD0D2+h8uCHAYIA6ksiAoAQ9BfIAcj0AMkBzHABygBAA1kg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIzxYBINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiM8WyQKi+EFvJDAyJ26zjheBEU1ToccFkjF/mSggbvLQgFjHBeLy9JkpgRFNAscF8vTiJYEBASRZ9AxvoZIwbd9ujo8TXwNwgEBwVSBtbW3bPAHjDQF/HhoC+iTBFI72FYEBAVQQNCBulTBZ9FowlEEz9BTiA6QBggr68IChJnAGyFmCEAXoNOZQA8sfASDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IjPFgEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIzxbJQVBDMHABbW3bPOMOHhsD6jBTQds8IG6OhDAk2zzeIG7y0IBvIjFwUEOAQAPIVSCCEIQwhotQBMsfWCDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IjPFoEBAc8AASDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IjPFsl/VTBtbds8AR0cHgA0gQEB9IxvpcD/nSBu8tCAASBu8tCAbwLgW20ANgGBAQH0eG+lwP+dIG7y0IABIG7y0IBvAuBbbQHKyHEBygFQBwHKAHABygJQBSDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IjPFlAD+gJwAcpoI26zkX+TJG6z4pczMwFwAcoA4w0hbrOcfwHKAAEgbvLQgAHMlTFwAcoA4skB+wAfAJh/AcoAyHABygBwAcoAJG6znX8BygAEIG7y0IBQBMyWNANwAcoA4iRus51/AcoABCBu8tCAUATMljQDcAHKAOJwAcoAAn8BygACyVjMArjtRNDUAfhj0gAB4wL4KNcLCoMJuvLgifpAASDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IgB+kABINdJgQELuvLgiCDXCwoggQT/uvLQiYMJuvLgiBIC0QHbPCIhAAgBbW1wAPr6QAEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIAfpAASDXSYEBC7ry4Igg1wsKIIEE/7ry0ImDCbry4IgB+kAh1wsBwwCOHQEg10mBAQu68uCIINcLCiCBBP+68tCJgwm68uCIkjFt4gH0BNQB0IEBAdcAMBUUQzBsFUhhij0=');
let ctx: Context = context();
let fireworks_init: StateInit = initOf Fireworks(0);
```

### $136$: 无效地址 {#136}

在 TON 中，所有地址都是 267 位。 如果您违反了这一规则，您将面临这个退出代码。

目前，TON 只支持两个链 id。0 代表基础链，-1 代表主链。 如果地址不是来自 basechain，则会抛出 136 个退出代码。

例如

```tact
// fun newAddress(chain: Int, hash: Int)：Address;
// 从链和哈希值创建一个新地址。
let zeroAddress：Address = newAddress(1, 0); // 无效的链零地址
```

### $137$：该合约未启用主链支持 {#137}

目前，TON 只支持两个链 id。0 代表基础链，-1 代表主链。

Tact 仅支持 basechain，如果您的地址来自 masterchain，则会抛出 137 个退出代码。

例如

```tact
// fun newAddress(chain: Int, hash: Int)：Address;
// 根据链和哈希值创建新地址。
let zeroAddress：Address = newAddress(-1, 0); // 主链零地址
```


## expressions.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/expressions.mdx)
---
title: 表达式
---

Tact 中的每个运算符都能构成一个表达式，但 Tact 还提供了更多的表达式选项供您选择。

## Literals

字面表示 Tact 中的值。 这些是固定值，而不是变量，是您在代码中实际提供的。 Tact 中的所有字面量都是表达式本身。

您还可以调用定义在某些 [基元类型][p]上的 [扩展函数](/zh-cn/book/functions#extension-function)，这些 [基元类型][p] 与字面值相对应：

```tact
// 在整数字面量上调用为 Int 定义的 toString() 函数：
42.toString();

// 在字符串字面量上调用为 String 定义的 asComment() 函数：
"Tact is awesome!".asComment()；
```

### Integer literals

整数字面可以用[十进制](/zh-cn/book/integers#decimal)（基 $10$）、[十六进制](/zh-cn/book/integers#hexadecimal)（基 $16$）、[八进制](/zh-cn/book/integers#octal)（基 $8$）和[二进制](/zh-cn/book/integers#binary)（基 $2$）符号书写：

- 一个 [_decimal_ integer](/zh-cn/book/integers#decimal) 字面量是一串数字（$\mathrm{0 - 9}$）。

- 前导 $\mathrm{0x}$（或 $\mathrm{0X}$）表示[十六进制整数](/zh-cn/book/integers#hexadecimal) 字面量。 它们可以包括数字（$\mathrm{0 - 9}$）和字母 $\mathrm{a - f}$ 和 $\mathrm{A - F}$。 请注意，字符的大小写不会改变其值。 因此：$\mathrm{0xa}$ = $\mathrm{0xA}$ = $10$ 和 $\mathrm{0xf}$ = $\mathrm{0xF}$ = $15$。

- 前导 $\mathrm{0o}$（或 $\mathrm{0O}$）表示 [octal integer](/zh-cn/book/integers#octal) 字面量。 它们只能包括数字 $\mathrm{0 - 7}$。

- 前导 $\mathrm{0b}$（或 $\mathrm{0B}$）表示 [二进制整数](/zh-cn/book/integers#binary) 字面量。 它们只能包括数字 $0$ 和 $1$。

:::caution
  需要注意的是，在 Tact 中，以 $0$ 为前导的整数字面量仍被视为小数，而在 JavaScript/TypeScript 中，以 $0$ 为前导的整数字面量表示八进制！
:::

一些整数字面的例子

```tact
// 十进制，基数 10：
0, 42, 1_000, 020

// 十六进制，基数 16：
0xABC, 0xF, 0x0011

// 八进制，基数 8：
0o777, 0o001

// 二进制，基数 2：
0b01111001_01101111_01110101_00100000_01100001_01110010_01100101_00100000_01100001_01110111_01100101_01110011_01101111_01101101_01100101
```

有关整数和 [`Int{:tact}`](/zh-cn/book/integers)类型的更多信息，请访问专门页面：[整数](/zh-cn/book/integers)。

### Boolean literals

[`Bool{:tact}`](/zh-cn/book/types#booleans)类型只有两个字面值：`true{:tact}`和`false{:tact}`。

```tact
true == true;
true != false；
```

有关布尔和 [`Bool{:tact}`](/zh-cn/book/types#booleans)类型的更多信息，请参阅专门章节：[布尔](/zh-cn/book/types#booleans)。

### String literals

字符串字面量是用双引号（`"`"）括起来的零个或多个字符。 所有字符串字面量都是 [`字符串{:tact}`][p]类型的对象。

```tact
"foo";
"1234"；
```

Tact 字符串支持一系列从反斜杠字符开始的[转义序列](https://en.wikipedia.org/wiki/Escape_sequence)：

- `\\{:tact}` - 字面反斜线
- `\"{:tact}` - 双引号
- `\n{:tact}` - 换行
- `\r{:tact}` - 回车
- `\t{:tact}` - tab
- `\v{:tact}` - 垂直标签
- `\b{:tact}` - 退格
- `\f{:tact}` - 表格供稿
- `\x00{:tact}`至`\xFF{:tact}` - [代码点](https://en.wikipedia.org/wiki/Code_point)，长度必须正好是两个十六进制数字
- `\u0000{:tact}`至`\uFFFF{:tact}` - [Unicode 代码点][unicode]，长度必须正好是四个十六进制数字
- `\u{0}{:tact}` 到 `\u{FFFFFF}{:tact}` - [Unicode 代码点][unicode]，长度可以是 $1$ 到 $6$ 的十六进制数

[unicode]: https://en.wikipedia.org/wiki/Unicode#Codespace_and_code_points

```tact
//
"escape （escape）if （you）can （can）";

//
"this （"litally （"） works";

// \n
"line \n another line";

// \r
"Shutters \r Like \r This \r One";

// \t
"spacing \t granted！";

// \v
"those \v words \v are \v aligned";

// \b
"rm\b\bcreate！";

// \f
"form \f feed";

// \x00 - \xFF
"this \x22literally\x22 works"; // \x22 表示双引号

// \u0000 - \uFFFF
"danger, \u26A1 high voltage \u26A1"；// \u26A1 代表⚡表情符号

// \u{0} - \u{FFFFFF}
"\u{1F602} LOL \u{1F602}"; // \u{1F602} 代表😂表情符号
```

:::note

  阅读更多关于字符串和[`字符串{:tact}`][p]类型：\
  [书中的原始类型][p]\
  [参考资料中的字符串和字符串构造器](/zh-cn/ref/core-strings)的内容

:::

### `null` literal

`空{:tact}`值将以`null{:tact}` 字面形式写入。它**不是[标识符](#identifiers)**，也不指向任何对象。它也**不是[原始类型][p]的实例**。相反，`null{:tact}`表示缺乏标识和故意不存在任何价值。

```tact
让 var：= null; // variable, which can hold null value
var = 42;
if (var != null) {
    var!！+ var!!;
}
```

有关使用 `null{:tact}`的更多信息，请访问专门页面：[选项](/zh-cn/book/optionals)。

## Identifiers

标识符是代码中的一串字符，用于标识[变量](/zh-cn/book/statements#let)、[常量](/zh-cn/book/constants)、[映射](/zh-cn/book/maps)和[函数](/zh-cn/book/functions)，以及[结构][s]、[消息][m]、[契约](/zh-cn/book/contracts)、[特质](/zh-cn/book/types#traits)或它们的字段和方法。 标识符区分大小写，不加引号。

在 Tact 中，标识符可以包含拉丁小写字母 (`a-z`)、拉丁大写字母 (`A-Z`)、下划线 (`_`)和数字 ($\mathrm{0 - 9}$)，但不能以数字开头。 标识符与 [字符串]（#string-literals）的区别在于，字符串是数据，而标识符是代码的一部分。

请注意，当[基元类型][p]的标识符以大写字母开头时。 已使用定义的 [复合类型](/zh-cn/book/types#composite-types)，如 [Structs][s] 和 [Messages][m] 也必须大写。

## Instantiation

您可以创建以下类型的实例：

- [结构][s]
- [信息][m]

```tact
struct StExample {
    fieldInit：Int = 1;
    fieldUninit：Int;
}

fun example() {
    // 带有 fieldInit 默认值的实例
    StExample{ fieldUninit: 2 };

    // 带有两个字段设置的实例
    StExample{
        fieldInit：0,
        fieldUninit: 2, // 允许使用尾部逗号
    };
}
```

## Field access

您可以直接访问以下类型的字段：

- [结构][s]
- [信息][m]

```tact
struct StExample {
    fieldInit：Int = 1;
    fieldUninit：Int;
}

fun example()：Int {
    let struct：StExample = StExample{ fieldUninit: 2 }; // 实例化

    struct.fieldInit; // 访问字段
    return struct.fieldUninit; // 从函数中返回字段值
}
```

## Extension function call

[扩展函数](/zh-cn/book/functions#extension-function)仅在特定类型中定义。 它们的调用方式类似于许多其他语言中的方法调用：

```tact
42.toString(); // toString() 是针对 Int 类型定义的 stdlib 函数。
```

## Static function call

在函数体的任何位置，都可以调用全局 [static function](/zh-cn/book/functions#global-static-functions) 或 [contract](/zh-cn/book/contracts) 的内部函数：

```tact
contract ExampleContract {
    receive() {
        now(); // now() 是 stdlib 的静态函数
        let expiration：Int = now() + 1000; // 运算和变量声明
        expiration = self.answerQuestion(); // 内部函数
    }
    fun answerQuestion()：Int {
        return 42;
    }
}
```

## `initOf`

表达式 `initOf{:tact}` 计算 [contract](/zh-cn/book/contracts) 的初始状态 (`StateInit{:tact}`)：

```tact
// 合同的 init() 函数的参数值
// ↓ ↓
initOf ExampleContract(42, 100); // 返回一个 Struct StateInit{}
// ---------------
// ↑
// 合同名称
// ↓
// ---------------
initOf ExampleContract(
    42, // 第一个参数
    100, // 第二个参数，允许使用逗号
)；
```

其中，`StateInit{:tact}`是一个内置[结构][s]，由以下部分组成：

| 现场  | 类型                  | 说明                                                |
| :-- | :------------------ | :------------------------------------------------ |
| 代码  | [`单元格{:tact}`][单元格] | [合同](/zh-cn/book/contracts)的初始代码（编译后的字节码                 |
| 数据  | [`单元格{:tact}`][单元格] | [合同](/zh-cn/book/contracts)的初始数据（合同的 `init(){:tact}`函数参数 |

[p]: /zh-cn/book/types#primitive-types
[cell]: /zh-cn/book/cells#cells
[s]: /zh-cn/book/structs-and-messages#structs
[m]: /zh-cn/book/structs-and-messages#messages

## external.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/external.mdx)
---
title: 外部信息
---

:::caution
  必须在项目配置中明确启用外部信息支持。
  如果不启用它，编译工作就会失败。
:::

外部信息是没有发件人的信息，世界上任何人都可以发送。 外部信息是与链外系统集成或对合同进行一般维护的良好工具。 处理外部信息与处理内部信息不同。 本节将介绍如何处理外部信息。

## 外部信息有何不同

外部报文与内部报文有以下不同：

### 合同自行支付天然气使用费

在处理内部信息时，发件人通常会支付燃气使用费。 处理外部报文时，合同支付燃气使用费。 这意味着您需要谨慎使用外部信息中的 gas 。 您应该经常测试合同的燃气使用情况，并确认一切正常。

### 信息必须手动接收

外部信息不会自动接收。 您需要手动接受它们。 这是通过调用 `acceptMessage` 函数实现的。 如果不调用 `acceptMessage` 函数，信息将被拒绝。 这样做是为了防止外部信息垃圾邮件。

### 接受信息前的 10k  gas 限值

10k  gas 是一个非常小的限制，而 Tact 本身在到达你的代码之前就已经消耗了相当数量的 gas 。 您应该经常测试合同的燃气使用情况，并确认一切正常。

:::tip[Hey there!]
  The 10k gas limit for external messages is based on the parameter we set by the
  validator for the whole blockchain of the `gas_limit` field. 您可以在此查阅
  ：
    - https://docs.ton.org/develop/smart-contracts/guidelines/accept#external-messages
    - https://docs.ton.org/develop/howto/blockchain-configs#param-20-and-21

  :::

### 接受信息后的无约束 gas 使用量

您接受 gas 后，合同可以随意使用 gas 。 这样做是为了允许合同进行任何类型的处理。 您应该经常测试合同的 gas 使用情况，并验证一切正常，避免出现可能耗尽合同余额的漏洞。

### 无背景资料

处理外部报文时，"上下文 "和 "发件人 "函数不可用。 这是因为外部信息没有上下文。 这意味着您不能在外部信息中使用 `context` 和 `sender` 函数。 您需要仔细测试您的合约，确保它没有使用 `context` 和 `sender` 函数。

## 启用外部信息支持

要启用外部信息支持，请在项目配置文件中启用：

```json
{
  "options": {
    "external": true
  }
}
```

## 外部接收器

外部接收器的定义方法与内部接收器相同，但使用的是 "外部 "关键字，而不是 "接收"：

```tact
contract SampleContract {
    external("Check Timeout") {

        // Check for contract timeout
        require(self.timeout > now(), "Not timeouted");

        // Accept message
        acceptMessage();

        // Timeout processing
        self.onTimeouted();
    }
}
```


## func.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/func.mdx)
---
title: 与 func 的兼容性
---

Tact 本身编译为 FunC，并将其所有实体直接映射到各种 FunC 和 TL-B 类型。

## 转换类型 {#convert-types}

Tact 中的 [原始类型](/zh-cn/book/types#primitive-types)可直接映射到 FunC 中的类型。

所有关于复制变量的规则都是一样的。其中一个最大的不同是，在 Tact 中没有可见的突变操作符，大多数 [`切片{:tact}`](/zh-cn/book/cells#slices)操作都是就地突变变量。

## 转换序列化 {#convert-serialization}

在 Tact 中，[Structs](/zh-cn/book/structs-and-messages#structs)和[Messages](/zh-cn/book/structs-and-messages#messages)的序列化是自动进行的，不像 FunC 需要手动定义序列化逻辑。

Tact 的自动布局算法是贪婪的。这意味着它会获取下一个变量，计算其大小，并尝试将其放入当前单元格。如果不合适，它就会创建一个新单元格并继续。所有用于自动布局的内部结构都会在分配前被扁平化。

除了 [`Address{:tact}`](/zh-cn/book/types#primitive-types) 以外，所有可选类型在 TL-B 中都序列化为 `Maybe`。

没有对 `Either` 的支持，因为它没有定义在某些情况下序列化时应选择什么。

### 实例

```tact
// _ value1:int257 = SomeValue;
struct SomeValue {
    value1: Int; // 默认为 257 位
}
```

```tact
// _ value1:int256 value2:uint32 = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2：int as uint32;
}
```

```tact
// _ value1:bool value2:Maybe bool = SomeValue;
struct SomeValue {
    value1: Bool;
    value2：Bool?;
}
```

```tact
// _ cell:^cell = SomeValue;
struct SomeValue {
    cell：Cell; // 总是作为引用存储
}
```

```tact
// _ cell:^slice = SomeValue;
struct SomeValue {
    cell：Slice; // 总是作为引用存储
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256] = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    value4: Int as int256;
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256] flag:bool = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    flag：Bool; // Flag 写在 value4 之前，以避免自动布局将其分配到下一个单元格
    value4: Int as int256;
}
```

```tact
// _ value1:int256 value2:int256 value3:int256 ^[value4:int256 flag:bool] = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2: Int as int256;
    value3: Int as int256;
    value4: Int as int256;
    flag: Bool;
}
```

```tact
// _ value1:int256 value2:^TailString value3:int256 = SomeValue;
struct SomeValue {
    value1: Int as int256;
    value2：String;
    value3: Int as int256;
}
```

## 将收到的信息转换为 `op` 操作 {#convert-received-messages-to-op-operations}

Tact 会为每条接收到的键入信息生成一个唯一的 `op`，但它可以被覆盖。

下面是 FunC.NET 中的代码

```func
() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    ;; 传入消息代码...

    ;; 接收 MessageWithGeneratedOp 消息
    if (op == 1180414602) {
        ;; 代码...
    }

    ;; 接收 MessageWithOverwrittenOP 消息
    if (op == 291) {
        ;; 代码...
    }

}
```

在 Tact 中变成了这样：

```tact
message MessageWithGeneratedOp {
    amount: Int as uint32;
}

message(0x123) MessageWithOverwrittenOP {
    amount: Int as uint32;
}

contract Contract {
    // Contract Body...

    receive(msg: MessageWithGeneratedOp) {
        // code...
    }

    receive(msg: MessageWithOverwrittenOP) {
        // code...
    }

}

```

## Convert get-methods

你可以用与 FunC 的 `get` 方法兼容的 Tact 来表达除 `list-style-lists` 以外的所有内容。

### 基本返回类型

如果一个 `get` 方法在 FunC 中返回一个基元，那么在 Tact 中也可以用同样的方法实现它。

下面是 FunC 中的代码

```func
int seqno() method_id {
    return 0;
}
```

在 Tact 中变成了这样：

```tact
get fun seqno(): Int {
    return 0;
}
```

### 张量返回类型

在 FunC 中，张量类型 `(int, int){:func}` 和 `(int, (int)){:func}` 是有区别的，但对于 TVM 来说没有区别，它们都表示两个整数的堆栈。

要转换从 FunC `get` 方法返回的张量，需要定义一个 [Struct](/zh-cn/book/structs-and-messages#structs)，它与张量的字段类型相同，顺序也相同。

下面是 FunC 中的代码

```func
(int, slice, slice, cell) get_wallet_data() method_id {
    return ...;
}
```

在 Tact 中变成了这样：

```tact
struct JettonWalletData {
    balance: Int;
    owner: Address;
    master: Address;
    walletCode: Cell;
}

contract JettonWallet {
    get fun get_wallet_data(): JettonWalletData {
        return ...;
    }
}
```

### 元组返回类型

在 FunC 中，如果返回的是元组而不是张量，则需要遵循张量类型的流程，但要将 “get ”方法的返回类型定义为可选类型。

下面是 FunC 中的代码

```func
[int, int] get_contract_state() method_id {
    return ...;
}
```

在 Tact 中变成了这样：

```tact
struct ContractState {
    valueA: Int;
    valueB: Int;
}

contract StatefulContract {
    get fun get_contract_state(): ContractState? {
        return ...;
    }
}
```

### 混合元组和张量返回类型

如果某些张量是元组，则需要像前面的步骤一样定义结构体，而元组必须定义为单独的 [Struct]（/book/structs-and-messages#structs）。

下面是 FunC 中的代码

```func
(int, [int, int]) get_contract_state() method_id {
    return ...;
}
```

在 Tact 中变成了这样：

```tact
struct ContractStateInner {
    valueA: Int;
    valueB: Int;
}

struct ContractState {
    valueA: Int;
    valueB: ContractStateInner;
}

contract StatefulContract {
    get fun get_contract_state(): ContractState {
        return ...;
    }
}
```

### 参数 制图

获取 "方法参数的转换非常简单。每个参数都_原样_映射到 FunC one，每个元组都映射到 [结构](/zh-cn/book/structs-and-messages#structs)。

下面是 FunC 中的代码

```func
(int, [int, int]) get_contract_state(int arg1, [int,int] arg2) method_id {
    return ...;
}
```

在 Tact 中变成了这样：

```tact
struct ContractStateArg2 {
    valueA: Int;
    valueB: Int;
}

struct ContractStateInner {
    valueA: Int;
    valueB: Int;
}

struct ContractState {
    valueA: Int;
    valueB: ContractStateInner;
}

contract StatefulContract {
    get fun get_contract_state(arg1: Int, arg2: ContractStateArg2): ContractState {
        return ContractState{
            valueA: arg1,
            valueB: ContractStateInner{
                valueA: arg2.valueA,
                valueB: arg2.valueB, // trailing comma is allowed
            }, // trailing comma is allowed
        };
    }
}
```


## functions.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/functions.mdx)
---
title: 函数及其类型
---

import { Badge } from '@astrojs/starlight/components';

Tact 中的功能可以用不同的方式定义：

- 全局静态函数
- 扩展功能
- 可变函数
- 本地功能
- 接收器功能
- 获取器功能

除了 [接收器函数](#receiver-functions)，所有函数的定义（参数列表）和调用（参数列表）都可以使用逗号：

```tact
fun foo(
    a: Int, // 允许在参数列表中使用逗号拖尾
) {}

fun bar() {
    foo(
        5, // 也允许在参数列表中使用逗号拖尾！
    );
}
```

## 全局静态函数 {#global-static-functions}

您可以在程序的任何地方定义全局函数：

```tact
fun pow(a: Int, c: Int): Int {
  let res: Int = 1;
  repeat(c) {
    res = res * a;
  }
  return res;
}
```

## 虚拟和抽象函数 {#virtual-and-abstract-functions}

如果 [traits](/zh-cn/book/types#traits) 有 `virtual{:tact}` 关键字，则可以使用 `override{:tact}` 允许继承 [traits](/zh-cn/book/types#traits) 的合约修改内部函数。 函数也可以标记为 `抽象{:tact}`，在这种情况下，继承合约必须定义其实现：

```tact
trait FilterTrait with Ownable {
    // Virtual functions can be overridden by users of this trait
    virtual fun filterMessage(): Bool {
        return sender() != self.owner;
    }

    abstract fun specialFilter(): Bool;
}

contract Filter with FilterTrait {
    // Overriding default behavior of the FilterTrait
    override fun filterMessage(): Bool {
        return true;
    }

    override fun specialFilter(): Bool {
        return true;
    }
}
```

## 扩展功能 {#extension-function}

扩展函数允许你为任何可能的类型实现扩展。

> **警告**
> 第一个参数的名称必须名为 `self`，该参数的类型必须是你要扩展的类型。

```tact
extends fun customPow(self: Int, c: Int): Int {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    return res;
}
```

## 可变函数 {#mutation-functions}

可变函数是对数值进行变异，用执行结果代替数值。 要执行突变，函数必须改变 `self` 值。

```tact
extends mutates fun customPow(self: Int, c: Int) {
    let res: Int = 1;
    repeat(c) {
        res *= self;
    }
    self = res;
}
```

## 本地功能 {#native-functions}

本地函数是 FunC 函数的直接绑定：

> **注**
> 本地函数也可以是可变函数和扩展函数。

```tact
@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;
```

## Receiver functions {#receiver-functions}

接收器函数是负责在合约中接收信息的特殊函数，只能在合约或特质中定义。

```tact
contract Treasure {
    // This means that this contract can receive the comment "Increment" and this function would be called for such messages
    receive("Increment") {
        self.counter += 1;
    }
}
```

## 获取器函数 {#getter-functions}

获取器函数定义智能合约上的获取器，只能在合约或特征中定义。

```tact
contract Treasure {
    get fun counter(): Int {
        return self.counter;
    }
}
```
### 明确解决方法 ID 碰撞问题

<Badge text="Available since Tact 1.6" variant="tip" size="medium"/><p/>

与 TVM 合约中的其他函数一样，getters 也有其*独特*的相关函数选择器，即一些整数 ID（称为*方法 ID*）。
其中一些整数是为内部目的保留的，例如 -4, -3, -2, -1, 0 是保留 ID，而 
常规函数（合约内部函数，不可从外部调用）通常由从 1 开始的后续（小）整数编号。
默认情况下，获取器有相关的方法 ID，这些 ID 是使用 [CRC16](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) 算法从名称中导出的，具体如下：
`crc16(<function_name>) & 0xffff) | 0x10000`。
有时，这可能会使名称不同的获取器获得相同的方法 ID。
如果出现这种情况，您可以重命名合约中的某些获取器，或
以编译时表达式的形式手动指定获取器的方法 ID：

```tact
contract ManualMethodId {
    const methodId: Int = 16384 + 42;

    get(self.methodId) fun methodId1(): Int {
        return self.methodId;
    }

    get(crc32("crc32") + 42 & 0x3ffff | 0x4000)
    fun methodId2(): Int {
        return 0;
    }
}
```

请注意，*不能*使用 TVM 保留的方法 ID，也不能使用某些初始正整数，因为编译器会将其用作函数选择器。

用户指定的方法 ID 是 19 位有符号整数，因此可以使用从 $-2^{18}$ 到 $-5$ 以及从 $2^{14}$ 到 $2^{18}$ 的整数。- 1$.

此外，还有一些方法 ID 是为 Tact 编译器在编译过程中插入的获取器保留的，它们是 113617、115390 和 121275。


## import.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/import.mdx)
---
title: 导入代码
---

Tact 允许您导入 Tact 和 [FunC](https://docs.ton.org/develop/func/overview) 代码--任何给定的 `.tact` 或 `.fc`/`.func` 文件都可以使用 `import{:tact}` 关键字导入到您的项目中。

此外，Tact 编译器还拥有一套通用的标准库，这些标准库捆绑在 Tact 编译器中，但并不立即包含在 Tact 编译器中，请参阅 [标准库概述](/zh-cn/ref/standard-libraries)。

:::caution

 注意：所有导入的代码都会与您的代码合并在一起，因此必须避免名称冲突，并始终仔细检查源代码！

:::

## 导入 Tact 代码

使用 `import{:tact}` 语句并提供目标 `.tact` 文件的相对路径，可以导入任何 Tact 代码：

```tact
import "./relative/path/to/the/target/tact/file.tact";
```

也可以指定父目录 (`../`)：

```tact
import "../subfolder/imported/file.tact";
```

## 导入 FunC 代码

可以直接导入用 FunC 代码编写的代码，就像 Tact 代码导入一样：

```tact
// Relative import
import "./relative/path/to/the/target/func/file.fc";

// Specifying parent directories
import "../subfolder/imported/func/file.fc";
```

但要使用此类文件中的函数，必须先将它们声明为 "本地 "函数。 For example, when standard library [@stdlib/dns](/zh-cn/ref/stdlib-dns) uses a `dns.fc` FunC file, it maps FunC functions to Tact ones like so:

```tact
// FunC 代码位于当前 Tact 代码旁边的文件中：
import "./dns.fc";

// 从 FunC 到 Tact 的函数签名映射：
@name(dns_string_too_internal)
native dnsStringToInternal(str: String)：Slice?
```

## 标准图书馆

See [Standard libraries overview](/zh-cn/ref/standard-libraries).


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/index.mdx)
---
title: Overview
---

import { LinkCard, CardGrid, Steps } from '@astrojs/starlight/components';

欢迎阅读**Tact Book**部分（或简称**The Book**）--一本关于Tact语言的入门书籍。

Here are it's main contents:

<Steps>

1. #### Guides

   [Cheatsheets](/zh-cn/book/cs/from-func) 是关于 Tact 语法和习语的快速介绍，并与其他区块链语言（如 FunC（也在 TON 上）和 Solidity（以太坊区块链））进行了比较。 利用这些优势尽快过渡到战术。

   <CardGrid>
     <LinkCard
       title="Go to the first cheatsheet"
       href="/book/cs/from-func"
     />
   </CardGrid>

2. #### 图书

   [**Tact Book**](/zh-cn/book/types) 是一套连贯、精简的 Tact 教育资料。 一般来说，它假定您是按从前到后的顺序阅读的。 后面的部分以前面部分的概念为基础，前面的部分可能不会深入探讨某个特定主题的细节，但会在后面的部分重新讨论该主题。

   此外，文档的语言部分也有许多参考资料，其中对语言的许多基元进行了更详细的描述。 此外，只要 TON 主文档中对更广泛的 TON 概念已有解释，本书也会尽量参考。

   本书还假定你用另一种编程语言编写过代码，但并不假定是哪一种。 我们努力让来自不同编程背景的人都能广泛获取这些材料。 我们没有花很多时间来讨论编程是什么或如何思考编程。 如果你是编程新手，最好阅读专门介绍编程的书籍。

   <CardGrid>
     <LinkCard
       title="Proceed to the Book itself"
       href="/book/types"
     />
   </CardGrid>

</Steps>


## integers.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/integers.mdx)
---
title: 整数
---

TON 智能合约中的算术运算始终使用整数，从不使用浮点数，因为浮点数是[不可预测的](https://learn.microsoft.com/en-us/cpp/build/why-floating-point-numbers-may-lose-precision)。 因此，重点应放在整数及其处理上。

`Int{:tact}` 是一个 257 位的有符号整数类型。
它能够存储 $-2^{256}$ 和 $2^{256} - 1$ 之间的整数。

## 符号 {#notation}

Tact 支持以各种方式将 `Int{:tact}` 的基元值写成 [整数字面量](/zh-cn/book/expressions#integer-literals)。

大多数符号允许在数字之间添加下划线 (`_`)，但下列符号除外：

- 字符串表示法，如 [纳吨](#nanotoncoin) 案例所示。
- 带前导零的十进制数 $0$。一般不鼓励使用，参见 [下文](#decimal)。

此外，**不允许**在 $4\_\_2$ 中连续使用多个下划线，或在 $42\_$ 中使用尾部下划线。

### 十进制 {#decimal}

最常见、最常用的数字表示方法，使用[十进制数字系统](https://en.wikipedia.org/wiki/Decimal)： $123456789$。  
您可以使用下划线（`_`）来提高可读性： $123\_456\_789$ 等于 $123456789$。

:::caution
  或者，您也可以在数字前加上一个 $0$，这样就禁止使用下划线，只允许使用十进制数字：$0123 = 123.$
  注意，**强烈建议**使用这种带前导零的符号，因为可能会与 TypeScript 中的八进制整数字面混淆，而 TypeScript 通常与 Tact 一起用于开发和测试合约。
:::

### 十六进制 {#hexadecimal}

使用[十六进制数字系统](https://en.wikipedia.org/wiki/Hexadecimal)表示数字，用 $\mathrm{0x}$（或 $\mathrm{0X}$）前缀表示：$\mathrm{0xFFFFFFFFF}$。
使用下划线（`_`）提高可读性：$\mathrm{0xFFF\_FFFF\_FFF}$ 等于 $\mathrm{0xFFFFFFFFF}$。

### 八进制 {#octal}

使用[八进制数字系统](https://en.wikipedia.org/wiki/Octal)表示数字，用 $\mathrm{0o}$（或 $\mathrm{0O}$）前缀表示：$\mathrm{0o777777777}$。
使用下划线（`_`）提高可读性：$\mathrm{0o777\_777\_777}$ 等于 $\mathrm{0o777777777}$。

### 二进制 {#binary}

使用[二进制数字系统](https://en.wikipedia.org/wiki/Binary_number)表示数字，用 $\mathrm{0b}$（或 $\mathrm{0B}$）前缀表示：$\mathrm{0b111111111}$。
使用下划线（`_`）提高可读性：$\mathrm{0b111\_111\_111}$ 等于 $\mathrm{0b111111111}$。

### NanoToncoin {#nanotoncoin}

美元的算术运算需要在圆点后保留两位小数，这两位小数用于美分的计算。但是，如果我们只能用整数来表示数字 \$$1.25$，我们该如何表示呢？解决的办法是直接使用 _cents_。这样，\$$1.25$ 就变成了 $125$ 美分。我们只需记住最右边的两位数代表小数点后的数字。

同样，在使用 TON 区块链的主要货币 Toncoin 时，需要九位小数，而不是两位小数。可以说，纳米通币是通币的 $\frac{1}{10^{9}}$。

因此，$1.25$ Toncoin 的数量，可以用 Tact 表示为 [`ton("1.25"){:tact}`](/zh-cn/ref/core-comptime#ton)，实际上就是数字 $1250000000$。我们把这些数字称为 _纳米吨币_（或 _纳米吨_），而不是 _美分_。

## 序列化 {#serialization}

将 `Int{:tact}` 值编码为持久状态（[contracts](/zh-cn/book/contracts) 和 [traits](/zh-cn/book/types#traits) 的字段）时，通常最好使用比 $257$-bits 更小的表示形式，以降低[存储成本](https://docs.ton.org/develop/smart-contracts/fees#storage-fee)。 这些表示法的使用也被称为 "序列化"，因为它们代表了 TON 区块链运行的本地[TL-B][tlb]类型。

持久状态大小在状态变量的每个声明中都会在 `as{:tact}`关键字后指定：

```tact
contract SerializationExample {
    // 持久状态变量
    oneByte: Int as int8 = 0; // 范围从 -128 到 127（占用 8 位 = 1 字节）
    twoBytes：int as int16; // 范围从 -32,768 到 32,767 （占用 16 位 = 2 个字节）

    init() {
        // 需要在 init() 中初始化，因为它没有默认值
        self.twoBytes = 55*55;
    }
}
```

整数序列化也适用于 [Structs](/zh-cn/book/structs and-messages#structs) 和 [Messages](/zh-cn/book/structs and-messages#messages) 的字段，以及 [maps](/zh-cn/book/maps) 的键/值类型：

```tact
struct StSerialization {
    martin: Int as int8;
}

message MsgSerialization {
    seamus：Int as int8;
    mcFly: map<Int as int8, Int as int8>;
}
```

动机很简单：

- 在州[成本](https://docs.ton.org/develop/smart-contracts/fees#how-to-calculate-fees)中存储 $1000$ $257$- 位整数每年约需 $0.184$ ton 。
- 相比之下，存储 $1000$ $32$-bit 整数每年只需花费 $0.023$ ton 。

### 序列化类型 {#serialization-types}

|  名称              |         [TL-B][TLB]                        |      包容性范围                 |              占用空间              |
| :--------------: | :----------------------------------------: | :------------------------: | :----------------------------: |
| `uint8{:tact}`   |           [`uint8`][tlb-构建]                | $0$ 到 $2^{8} - 1$          |         $8$ 位 = $1$ 字节         |
| `uint16{:tact}`  |         [`uint16`][tlb-builtin]            | $0$ 到 $2^{16} - 1$         |         $16$ 位 = $2$ 字节        |
| `uint32{:tact}`  |         [`uint32`][tlb-builtin]            | $0$ 到 $2^{32} - 1$         |         $32$ 位 = $4$ 字节        |
| `uint64{:tact}`  |         [`uint64`][tlb-builtin]            | $0$ 到 $2^{64} - 1$         |         $64$ 位 = $8$ 字节        |
| `uint128{:tact}` |         [`uint128`][tlb-builtin]           | $0$ 到 $2^{128} - 1$        |        $128$ 位 = $16$ 字节       |
| `uint256{:tact}` |         [`uint256`][tlb-builtin]           | $0$ 到 $2^{256} - 1$        |        $256$ 位 = $32$ 字节       |
| `int8{:tact}`    |           [`int8`][tlb-构建]                 | $-2^{7}$ 至 $2^{7} - 1$     |         $8$ 位 = $1$ 字节         |
| `int16{:tact}`   |         [`int16`][tlb-builtin]             | $-2^{15}$ 至 $2^{15} - 1$   |         $16$ 位 = $2$ 字节        |
| `int32{:tact}`   |         [`int32`][tlb-builtin]             | $-2^{31}$ 至 $2^{31} - 1$   |         $32$ 位 = $4$ 字节        |
| `int64{:tact}`   |         [`int64`][tlb-builtin]             | $-2^{63}$ 至 $2^{63} - 1$   |         $64$ 位 = $8$ 字节        |
| `int128{:tact}`  |         [`int128`][tlb-builtin]            | $-2^{127}$ 至 $2^{127} - 1$ |        $128$ 位 = $16$ 字节       |
| `int256{:tact}`  | [`int256`][tlb-builtin]            | $-2^{255}$ 至 $2^{255} - 1$ | $256$ 位 = $32$ 字节       |
| `int257{:tact}`  | [`int257`][tlb-builtin]            | $-2^{256}$ 至 $2^{256} - 1$ | $257$ 位 = $32$ 字节 + $1$ 位   |
| `coins{:tact}`   | [`VarUInteger 16`][varuint]        | $0$ 到 $2^{120} - 1$        | $4$ 和 $124$ 位之间，[见下文](#serialization-coins) |

### 变量 `coins` 类型 {#serialization-coins}

在 Tact 中，`coins{:tact}` 是[TL-B][tlb]表示法中[`VarUInteger 16`][varuint]的别名，即根据存储给定整数所需的最佳字节数，它的位长是可变的，通常用于存储[nanoToncoin](/zh-cn/book/integers#nanotoncoin)金额。

这种序列化格式包括两个 [TL-B 字段](https://docs.ton.org/develop/data-formats/tl-b-language#field-definitions)：

- len"，一个 $4$位无符号大二进制整数，存储所提供值的字节长度
- value"，即所提供值的 8 \* len$ 位无符号大二进制表示法

也就是说，序列化为 `coins{:tact}` 的整数占用 $4$ 至 $124$ 位（`len`为$4$ 位，`value`为 $0$ 至 $15$ 字节），其值范围为 $0$ 至 $2^{120} - 1$ 之间。

例如

```tact
struct Scrooge {
    // len: 0000, 4 bits (always)
    // value: none!
    // in total: 4 bits
    a: Int as coins = 0; // 0000

    // len: 0001, 4 bits
    // value: 00000001, 8 bits
    // in total: 12 bits
    b: Int as coins = 1; // 0001 00000001

    // len: 0010, 4 bits
    // value: 00000001 00000010, 16 bits
    // in total: 20 bits
    c: Int as coins = 258; // 0010 00000001 00000010

    // len: 1111, 4 bits
    // value: hundred twenty 1's in binary
    // in total: 124 bits
    d: Int as coins = pow(2, 120) - 1; // hundred twenty 1's in binary
}
```

:::note

  点击此处阅读有关序列化的更多信息：[与 FunC 兼容](/zh-cn/book/func#convert-serialization)

:::

## 业务 {#operations}

所有数字的运行时计算都是在 257 位完成的，因此 [溢出](https://en.wikipedia.org/wiki/Integer_overflow) 非常罕见。 不过，如果任何数学运算出现溢出，就会抛出异常，事务也会失败。 可以说，Tact 的数学默认是安全的。

请注意，在同一计算中混合使用 [不同状态大小]（#序列化）的变量是没有问题的。 在运行时，无论如何，它们都是相同的类型 - $257$-比特签名，因此不会发生溢出。

不过，这仍可能导致在事务的[计算阶段](https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase)出现\*\*\*错误。 请看下面的例子：

```tact
import "@stdlib/deploy";

contract ComputeErrorsOhNo with Deployable {
    oneByte: Int as uint8; // persistent state variable, max value is 255

    init() {
        self.oneByte = 255; // initial value is 255, everything fits
    }

    receive("lets break it") {
        let tmp：int = self.oneByte * 256; // 没有运行时溢出
        self.oneByte = tmp; // 哎呀，tmp 值超出了 oneByte 的预期范围
    }
}
```

这里，"oneByte" 被序列化为 [`uint8`](#serialization-types)，只占用一个字节，范围从 $0$ 到 $2^8 - 1$，即 $255$。在运行时计算中使用时，不会发生溢出，所有计算结果都是 $257$ 位有符号整数。但是，就在我们决定将 `tmp` 的值存储回 `oneByte` 的那一刻，我们收到了一个错误，[退出代码 5](/zh-cn/book/exit-codes#5)，错误信息如下：整数超出预期范围。

:::caution
  因此，在使用序列化时，对数字要**非常**小心，并始终仔细检查计算结果。
:::

[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[tlb-builtin]: https://docs.ton.org/develop/data-formats/tl-b-language#built-in-types
[变量]: https://docs.ton.org/develop/data-formats/msg-tlb#varuinteger-n


## lifecycle.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/lifecycle.mdx)
---
title: 信息生命周期
---

合同对信息的处理有几个阶段，其中还有更多的阶段，但我们将集中讨论最重要的几个阶段：

## 接收阶段

该阶段结合了多个低级阶段。 

它首先会在合同余额**中添加一个**信息值。 输入报文的价值是合约为处理该报文的天然气所能支付的最高价格。 合同可以覆盖此限制，但不建议这样做，只有高级开发人员才适合这样做，因为这可能导致合同被耗尽。 1 million of gas is the maximum amount that a contract can spend in a single contract which equals 1 TON (currently). 如果信息值为零，则执行中止。

Then some (usually a small amount) of nanotons is subtracted from the contract balance for storage. 这意味着您无法完美预测平衡的变化，必须根据这种不稳定性调整代码。

然后，如果合同尚未部署，且信息中包含初始包，则会部署合同。 如果 init 软件包不存在，它将被忽略。

## 计算阶段

该阶段执行智能合约的代码，并产生一系列操作或异常。 目前只支持两种操作：**发送信息**和**保留**。

发送信息可以使用固定值或动态值，如**信息剩余值**--接收信息的剩余值。发送信息时可以使用 “SendIgnoreErrors”（发送忽略错误）标记，这样在发送信息时就会忽略错误，并继续下一个操作。如果有多个操作，这个标志就很有用。在发送带有某个值的信息时，首先会从收到的值中减去该值，然后才从合约余额中减去该值（在处理之前）。

## 行动阶段

操作是按顺序执行的，但请注意：
处理操作过程中的**异常不会还原事务**

例如，如果您从客户的余额中减去 1 ton ，然后发送一条无效信息，这可能会导致客户的余额被减去，但他不会收到。


## maps.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/maps.mdx)
---
title: 地图
---

import { Badge } from '@astrojs/starlight/components';

[复合类型](/zh-cn/book/types#composite-types) `map<K, V>{:tact}` 用于将 `K{:tact}` 类型的键与 `V{:tact}` 类型的相应值关联起来。

例如，`map<Int, Int>{:tact}` 的键和值使用 [`英特{:tact}`][英特] 类型：

```tact
struct IntToInt {
    counters: map<Int, Int>;
}
```

## 允许的类型 {#allowed-types}

允许的密钥类型

- [`Int{:tact}`][int]。
- [`地址{:tact}`][p]

允许的值类型：

- [`Int{:tact}`][int]。
- [`Bool{:tact}`](/zh-cn/book/types#booleans)
- [`单元格{:tact}`][单元格]
- [`地址{:tact}`][p]
- [结构](/zh-cn/book/structs-and-messages#structs)
- [消息](/zh-cn/book/structs-and-messages#messages)

## 业务

### 声明，`emptyMap()` {#emptymap}

作为[局部变量](/zh-cn/book/statements#let)，使用标准库的 `emptyMap(){:tact}` 函数：

```tact
let fizz: map<Int, Int> = emptyMap();
let fizz: map<Int, Int> = null; // 与前一行相同，但描述性较弱
```

作为 [持久状态变量](/zh-cn/book/contracts#variables)：

```tact
contract Example {
    fizz: map<Int, Int>; // Int keys to Int values
    init() {
        self.fizz = emptyMap(); // 冗余，可以删除！
    }
}
```

请注意，类型为 `map<K, V>{:tact}` 的 [持久状态变量](/zh-cn/book/contracts#variables) 默认为空，不需要默认值，也不需要在 [`init(){:tact}` 函数](/zh-cn/book/contracts#init-function)中进行初始化。

### 设置值，`.set()` {#set}

要设置或替换键下的值，请调用 `.set(){:tact}` [方法](/zh-cn/book/functions#extension-function)，所有地图都可以使用该方法。

```tact
// 空 map
let fizz: map<Int, Int> = emptyMap();

// 在不同的键下设置几个值
fizz.set(7, 7);
fizz.set(42, 42);

// 覆盖现有键值对中的一个
fizz.set(7, 68); // 键 7 现在指向值 68
```

### 获取值，`.get()` {#get}

通过调用 `.get(){:tact}` [方法](/zh-cn/book/functions#extension-function)，检查是否在地图中找到了键，所有地图都可以访问该方法。 如果键丢失，则返回 `null{:tact}`；如果键找到，则返回值。

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// Setting a value
fizz.set(68, 0);

// Getting the value by its key
let gotButUnsure: Int? = fizz.get(68); // returns Int or null, therefore the type is Int?
let mustHaveGotOrErrored：让 mustHaveGotOrErrored: Int = fizz.get(68)!!; // 明确断言值不能为空，
                                                // 如果值实际上为空，运行时可能会崩溃

// 或者，我们可以在 if 语句中检查关键字
if (gotButUnsure != null) {
    // 万岁，现在让我们毫无顾忌地使用 !! 并将 Int? 转换为 Int
    让 definitelyGotIt：Int = fizz.get(68)!!;
} else {
    // Do something else...
}
```

### 删除条目，`.del()` {#del}

要删除单个键值对（单个条目），请使用 `.del(){:tact}` [方法](/zh-cn/book/functions#extension-function)。 如果删除成功，则返回 `true{:tact}`，否则返回 `false{:tact}`。

```tact
// 空 map
let fizz: map<Int, Int> = emptyMap();

// 在不同的键下设置几个值
fizz.set(7, 123);
fizz.set(42, 321);

// 删除其中一个键
let deletionSuccess：Bool = fizz.del(7); // true，因为 map 包含了键 7 下的条目
fizz.del(7); // false，因为 map 不再有键 7 下的条目

// 注意，在使用 `.set()` 方法
// 等同于调用 `.del()`，不过这种方法的描述性要差得多
// 而且一般不推荐使用：
fizz.set(42, null); // 键 42 下的条目现在被删除了
```

要删除映射表中的所有条目，请使用 `emptyMap(){:tact}` 函数重新分配映射表：

```tact
// 空 map
let fizz: map<Int, Int> = emptyMap();

// 在不同的键下设置几个值
fizz.set(7, 123);
fizz.set(42, 321);

// 一次性删除所有条目
fizz = emptyMap();
fizz = null; // 与上一行相同，但描述性较弱
```

采用这种方法后，即使已将映射声明为持久状态变量，映射之前的所有条目也会从合约中完全删除。 因此，将地图分配给 `emptyMap(){:tact}` **不会**产生任何隐藏或突然的[存储费用](https://docs.ton.org/develop/smart-contracts/fees#storage-fee)。

### 检查条目是否存在, `.exists()` {#exists}

<Badge text="Available since Tact 1.5" variant="tip" size="medium"/><p/>

映射上的 `.exists(){:tact}` [方法](/zh-cn/book/functions#extension-function)，如果给定键下的值在映射中存在，则返回 `true{:tact}`，否则返回 `false{:tact}`。

```tact
let fizz: map<Int, Int> = emptyMap();
fizz.set(0, 0);

if (fizz.exists(2 + 2)) { // false
    dump("Something doesn't add up!");
}

if (fizz.exists(1 / 2)) { // true
    dump("I told a fraction joke once. It was half funny.");
}

if (fizz.get(1 / 2) != null) { // also true, but consumes more gas
    dump("Gotta pump more!");
}
```

:::note

  调用`m.exists(key){:tact}`比执行`m.get(key) != null{:tact}` 更省 gas，尽管两种方法产生的结果是一样的。

:::

### 检查是否为空，`.isEmpty()` {#isempty}

地图上的 `.isEmpty(){:tact}` [方法](/zh-cn/book/functions#extension-function) 如果地图为空，则返回 `true{:tact}`，否则返回 `false{:tact}`：

```tact
let fizz: map<Int, Int> = emptyMap();

if (fizz.isEmpty()) {
    dump("Empty maps are empty, duh!");
}

// 请注意，将地图与 "空 "进行比较的行为与".isEmpty() "方法相同，
// 尽管这种直接比较的描述性要差得多，一般不鼓励使用：
if (fizz == null) {
    dump("Empty maps are null, which isn't obvious");
}
```

### 转换为 `Cell`, `.asCell()` {#ascell}

在地图上使用 `.asCell(){:tact}` [方法](/zh-cn/book/functions#extension-function)，将其所有值转换为 [`单元格{:tact}`][单元格] 类型。 请注意，[`Cell{:tact}`][单元格] 类型最多只能存储 1023 位，因此将更大的映射转换为单元格会导致错误。

例如，这种方法适用于在回复正文中直接发送小地图：

```tact
contract Example {
    // Persistent state variables
    fizz: map<Int, Int>; // our map

    // Constructor (initialization) function of the contract
    init() {
        // Setting a bunch of values
        self.fizz.set(0, 3);
        self.fizz.set(1, 14);
        self.fizz.set(2, 15);
        self.fizz.set(3, 926);
        self.fizz.set(4, 5_358_979_323_846);
    }

    // Internal message receiver, which responds to empty messages
    receive() {
        // Here we're converting the map to a Cell and making a reply with it
        self.reply(self.fizz.asCell());
    }
}
```

### 遍历条目 {#traverse}

要遍历地图条目，有一个 [`foreach{:tact}`](/zh-cn/book/statements#foreach-loop)循环语句：

```tact
// Empty map
let fizz: map<Int, Int> = emptyMap();

// 在不同的键下设置几个值
fizz.set(42, 321);
fizz.set(7, 123);

// 按顺序迭代：从最小的键到最大的键
foreach (key, value in fizz) {
    dump(key); // 第一次迭代将转存 7，第二次迭代将转存 42
}
```

了解更多相关信息：[`foreach{:tact}` loop in Book→Statements](/zh-cn/book/statements#foreach-loop).

请注意，也可以将映射作为简单数组使用，只要定义一个 `map<Int, V>{:tact}`，键为 [`Int{:tact}`][int] 类型，值为任何允许的 `V{:tact}` 类型，并跟踪单独变量中的项数即可：

```tact
contract Iteration {
    // 持久状态变量
    counter：int as uint32; // 地图条目的计数器，序列化为 32 位无符号
    record: map<Int, Address>; // Int to Address map

    // 合约的构造函数（初始化）
    init() {
        self.counter = 0; // 设置 self.counter 为 0
    } // 内部消息接收器，用于响应字符串消息 "Add" receive("Add") { // 获取上下文结构体 let c.counter = 0.

    // 内部消息接收器，响应字符串消息 "Add"
    receive("Add") {
        // 获取上下文结构
        let ctx：Context = context();
        // 设置条目：counter Int 作为键，ctx.sender Address 作为值
        self.record.set(self.counter, ctx.sender);
        // 增加计数器
        self.counter += 1;
    }


    receive("Send") {
        // 循环，直到 self.counter 的值（遍历所有 self.record 条目）
        let i. Int = 0; // 声明通常的 i.counter = 1; // 增加计数器的值：Int = 0; // 为循环迭代声明通常的 i
        while (i < self.counter) {
           send(SendParameters{
                bounce: false, // do not bounce back this message
                to: self.record.get(i)!!, // set the sender address, knowing that key i exists in the map
                value: ton("0.0000001"), // 100 nanoToncoins (nano-tons)
                mode：SendIgnoreErrors, // 忽略交易中的错误（如果有的话）发送
                body："SENDING".asComment() // "SENDING "字符串转换为单元格作为消息正文
            });
            i += 1; // 不要忘记增加 i
        }
    }

    // 获取 self.record 值的获取函数
    get fun map(): map<Int, Address> {
        return self.record;
    }

    // 获取 self.counter 值的获取函数
    get fun counter()：Int {
        return self.counter;
    }
}
```

在此类地图上设置上限限制通常很有用，这样就不会[触及极限]（#limits-and-drawbacks）。

:::caution

  请注意，手动记录项目数或检查此类地图的长度非常容易出错，一般不建议使用。 相反，请尝试将您的地图封装到 [Struct](/zh-cn/book/structs-and-messages#structs) 中，并在其上定义 [extension functions](/zh-cn/book/functions#extension-function) 。 参见 Cookbook 中的示例：[如何使用包裹在 Struct 中的 map 来模拟数组](/zh-cn/cookbook/data-structures#array)。

:::

:::note

  本例改编自 [howardpen9/while-example-tact](https://github.com/howardpen9/while-example-tact/blob/de5807fcd20dba5f6a3748d112511477fb22bfcc/contracts/awesome.tact#L19C10-L19C10).

  查看 Cookbook 中有关 map 使用的其他示例：\
  [如何使用包裹在 Struct 中的 map 来模拟堆栈](/zh-cn/cookbook/data-structures#stack)\
  [如何使用包裹在 Struct 中的 map 来模拟循环缓冲区](/zh-cn/cookbook/data-structures#circular-buffer)

:::

## 序列化

可以对映射键、值或两者进行[整数序列化](/zh-cn/book/integers#serialization-types)，以[保留空间并降低存储成本](/zh-cn/book/integers#serialization)：

```tact
struct SerializedMapInside {
    // 这里的键和值都将序列化为 8 位无符号整数，
    // 从而节省空间并降低存储成本：
    countersButCompact: map<Int as uint8, Int as uint8>;
}
```

:::note

  了解其他序列化选项：[与 FunC 兼容](/zh-cn/book/func#convert-serialization)。

:::

## 局限性和缺点

虽然地图在小范围内使用起来很方便，但如果项目数量不受限制，地图的大小会大幅增加，就会产生很多问题：

- 由于智能合约状态大小的上限约为 [`Cell{:tact}`][cell] 类型的 $65,000$ 项，因此整个合约的映射存储上限约为 $30,000$ 键值对。

- 地图中的条目越多，[计算费](https://docs.ton.org/develop/howto/fees-low-level#computation-fees) 就越高。 因此，处理大型地图使得计算费用难以预测和管理。

- 在单个合同中使用大型地图无法分散工作量。 因此，与使用较小的地图和大量交互式智能合约相比，这可能会使整体性能大打折扣。

要解决此类问题，可以将地图上的上限限制设置为常数，并在每次为地图设置新值时对其进行检查：

```tact
contract Example {
    // 为我们的 map 声明一个编译时常数上限
    const MaxMapSize：Int = 42;

    // 持久状态变量
    arr: map<Int, Int>; // Int 值的 "数组 "作为 map
    arrLength：Int = 0; // "数组 "的长度，默认为 0

    // 将一个项目推到 "数组 "末尾的内部函数
    fun arrPush(item: Int) {
        if (self.arrLength >= self.MaxMapSize) {
            // 做一些事情，例如停止操作
        } else {
            // 继续添加新项
            self.arr.set(self.arrLength, item);
            self.arrLength += 1;
        }
    }
}
```

如果您仍然需要大地图或无约束（无限大）地图，最好按照[TON 区块链的异步和基于角色的模型](https://docs.ton.org/learn/overviews/ton-blockchain)来构建您的智能合约。 也就是说，使用合约分片，让整个区块链成为地图的一部分。

{/*
  TODO：添加对分片页面的引用，如： https://github.com/tact-lang/tact-docs/issues/155
*/}

[p]: /zh-cn/book/types#primitive-types
[int]: /zh-cn/book/integers
[电池]: /zh-cn/book/cells#cells


## masterchain.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/masterchain.mdx)
---
title: 主链
---

:::caution

  除非将[配置文件](/zh-cn/book/config)中的 "masterchain "选项设置为 `true{:json}`，否则主链地址将被视为无效。

:::

在 TON 区块链中，一条名为["主链"](https://docs.ton.org/learn/overviews/ton-blockchain#masterchain-blockchain-of-blockchains) 的特殊链用于同步消息路由和交易执行，因此网络中的节点可以固定多链状态中的某个特定点，并就该状态达成共识。

主链存储 [网络配置](/zh-cn/ref/core-advanced#getconfigparam) 和所有 [工作链] 的最终状态(https://docs.ton.org/learn/overviews/ton-blockchain#workchain-blockchain-with-your-own-rules)。 它承载着基本的协议信息，包括当前设置、活动验证器及其赌注列表、活动工作链以及相关的[分块链](https://docs.ton.org/develop/blockchain/shards)。 最重要的是，它为所有工作链和分块链维护最新的区块哈希值记录，从而在整个网络中达成共识。

## 主链如何保护合约

Tact 强制所有合约使用 [basechain](https://docs.ton.org/develop/blockchain/shards)，即 ID 为 $0$ 的默认工作链。这样做是为了防止在合约中使用主链地址。

在未[启用主链支持](#support)的情况下，任何指向主链或以其他方式与之交互的尝试都会产生异常，并显示[退出代码 137](/zh-cn/book/exit-codes#137)： 此合约未启用 “主链支持”。

也就是说，意外部署到主链、从主链账户接收消息、向此类账户发送消息以及使用主链地址或其链 ID ($-1$) 都是默认禁止的。

## 在编译选项中启用主链支持 {#support}

:::caution

大多数合约不需要部署在主链上，也不需要在主链上进行任何交互。这是因为主链主要用于投票或存储库。如果你不需要参与这些事情，就不需要启用主链支持。

:::

如果您确实需要主链支持，最简单也是最推荐的方法是修改项目根目录下的 [`tact.config.json`](/zh-cn/book/config) 文件（如果还不存在，则创建该文件），并 [将 `masterchain` 属性设置为 `true{:json}`](/zh-cn/book/config#options-masterchain)。

如果您正在开发基于 [Blueprint][bp] 的项目，可以在合约的编译配置中启用主链支持，这些配置位于名为 `wrappers/` 的目录中：

```typescript title="wrappers/YourContractName.compile.ts" {7}
import { CompilerConfig } from '@ton/blueprint';

export const compile：CompilerConfig = {
  lang: 'tact',
  target: 'contracts/your_contract_name.tact',
  options：{
    masterchain: true, // ← that's the stuff！
  }
};
```

不过，[蓝图][bp] 项目中仍可使用 [`tact.config.json`](/zh-cn/book/config)。 在这种情况下，除非在 `wrappers/` 中修改，否则 [`tact.config.json`](/zh-cn/book/config)中指定的值将作为默认值。

[bp]: https://github.com/ton-org/blueprint


## message-mode.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/message-mode.mdx)
---
title: Message `mode`
---

如前所述，信息是通过结构体 `SendParameters{:tact}` 的 `mode` 参数发送的。这是一个[`Int{:tact}`][int]值，由基本模式和可选标志（也是[`Int{:tact}`][int]值）组合而成。

您可以使用原始的 [`Int{:tact}`][int]值，并手动为 `mode` 提供这些值，但为了方便起见，您可以使用一组常量来轻松构建复合 `mode`。有关基本模式和可选标记的更多信息，请参阅下表。

## 基本模式 {#base-modes}

|        模式值 | 恒定名称                 | 说明                           |
| ---------: | :------------------- | ---------------------------- |
| $0$        | -                    | 普通信息（默认）。                    |
| $64$       | SendRemainingValue   | 除了新报文中最初显示的值外，还携带入站报文的所有剩余值。 |
| $128$      | SendRemainingBalance | 携带当前智能合约的所有余额，而不是信息中最初显示的值。  |

## 可选标记 {#optional-flags}

|        标志值 | 恒定名称                   | 说明                                                                                                                     |
| ---------: | :--------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| $+1$       | SendPayGasSeparately   | 将转发费用与信息价值分开支付。                                                                                                        |
| $+2$       | SendIgnoreErrors       | 忽略行动阶段处理该信息时出现的任何错误。                                                                                                   |
| $+16$      | SendBounceIfActionFail | 如果在操作阶段出现任何错误，则退回交易。 Has no effect if flag $+2$, SendIgnoreErrors is used.                                             |
| $+32$      | SendDestroyIfZero      | Current account must be destroyed if its resulting balance is zero (often used with mode $128$, SendRemainingBalance). |

## 将模式与标志相结合 {#combining-modes-with-flags}

要为 `SendParameters{:tact}` 的 `mode` 字段创建 [`Int{:tact}`][int] 值，只需通过 [bitwise OR](/zh-cn/book/operators#binary-bitwise-or) 运算将基本模式与可选标记结合起来。

例如，如果您想分别发送普通信息和支付转账费用，请使用模式 $0$（默认）和标志 $+1$，以获得 `mode` $= 1$，这等同于使用 `SendPayGasSeparately{:tact}` 常量。

或者，如果要发送全部合约余额并立即销毁，使用模式 $128$ 和标志 $+32$，得到 `mode` $= 160$，相当于 `SendRemainingBalance | SendDestroyIfZero{:tact}` 常量。

下面是后一个示例的代码：

```tact
let to: Address = ...;
let value: Int = ton("1");
send(SendParameters{
    to: to,
    value: value,
    mode: SendRemainingBalance | SendDestroyIfZero,
    body: "Hello, World!".asComment(),
});
```

:::caution

  请注意，虽然可以将（[`+{:tact}`](/zh-cn/book/operators#binary-add)）基本模式与可选标志一起添加，但由于可能会出现多余的值，因此不鼓励这样做。 请使用位wise OR ([`|{:tact}`](/zh-cn/book/operators#binary-bitwise-or))，因为它是为处理此类标志和对 `mode` 的位操作而设计的。

:::

:::note

  还要注意的是，[基本模式](#base-modes) 只能有一种，但[可选标记](#optional-flags) 的数量可以不同：可以全部使用，也可以不使用或只使用其中一些。

:::

[int]: /zh-cn/book/integers


## operators.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/operators.mdx)
---
title: 操作员
---

几乎所有合约都对数据进行操作：将某些值转换成另一个值。 范围可能各不相同，但运营商是此类修改的核心。

本页按照[优先级]（#precedence）的递减顺序列出了 Tact 中的所有运算符，并附有使用示例。

:::note

  需要注意的是，Tact 中没有隐式类型转换，因此运算符不能用来添加不同类型的值，或者在不明确转换为相同类型的情况下比较它们的相等性。 这是通过标准库中的某些函数实现的。 请参阅 [`Int.toString(){:tact}`](/zh-cn/ref/core-strings#inttostring)，了解此类函数的示例。

:::

## 操作员表 {#table}

下表列出了按 [优先级](#precedence)：从高到低递减的运算符。

| 简要说明           | 操作员                                                                                         |
| :------------- | :------------------------------------------------------------------------------------------ |
| 括号             | [`(){:tact}`][父母]                                                                           |
| 一元后缀           | [`!!{:tact}`][nna]                                                                          |
| 一元前缀           | [`+{:tact}`][正] &nbsp; [`-{:tact}`][负] &nbsp; [`!{:tact}`][负] &nbsp; [`~{:tact}`][b-not]。   |
| 乘法             | [`*{:tact}`][mul] &nbsp; [`/{:tact}`][div] &nbsp; [`%{:tact}`][mod]。                        |
| 添加剂            | [`+{:tact}`][加] &nbsp; [`-{:tact}`][分]                                                      |
| 轮班             | [`>>{:tact}`][shr] &nbsp; [`<<{:tact}`][shl]。                                               |
| 关系             | [`>{:tact}`][gt] &nbsp; [`>={:tact}`][ge] &nbsp; [`<{:tact}`][lt] &nbsp; [`<={:tact}`][le]。 |
| 平等             | [`=={:tact}`][eq] &nbsp; [`！={:tact}`][eq]。                                                 |
| 位与             | [`&{:tact}`][b-and]。                                                                        |
| 比特 XOR         | [`^{:tact}`][b-xor]。                                                                        |
| 位操作 OR         | [`\|{:tact}`][b-or]。                                                                        |
| 逻辑与            | [`&&{:tact}`][l-and]。                                                                       |
| 逻辑或            | [`\|\|{:tact}`][l-or]                                                                       |
| 三元             | [`？：{:tact}`][三元]                                                                           |
| 任务             | [`={:tact}`][赋值] 和 [所有增强赋值运算符](#augmented-assignment)                                       |

[父母]: #parentheses
[nna]: #unary-non-null-assert
[加号]: #unary-plus
[否]: #unary-negate
[请]: #unary-inverse
[不]: #unary-bitwise-not
[桑葚]: #binary-multiply
[分裂]: #binary-divide
[模式]: #binary-modulo
[增加]: #binary-add
[字幕]: #binary-subtract
[缩]: #binary-bitwise-shift-right
[shl]: #binary-bitwise-shift-left
[gt]: #binary-greater
[ge]: #binary-greater-equal
[lt]: #binary-less
[勒]: #binary-less-equal
[等式]: #二元平等
[b 和]: #binary-bitwise-and
[b-xor]: #binary-bitwise-xor
[或]: #binary-bitwise-or
[和]: #binary-logical-and
[或]: #binary-logical-or
[三元]: #ternary
[分配]: <# 分配>

## 优先级 {#precedence}

本页所有运算符的优先级从高到低依次递减。 优先级用于选择在特定情况下考虑哪个运算符。 每当出现模棱两可的情况时，Tact 会优先选择优先级较高的运算符，而不是优先级较低的运算符。

例如，减号 (`-{:tact}`) 可被视为减法运算符或否定运算符，它将表达式的正负符号颠倒过来，反之亦然。 由于在两者有歧义的情况下，后者的优先级高于前者，Tact 将首先把 `-{:tact}` 视为否定操作符。 如果这对给定表达式没有意义，它才会将其视为减法运算符。

请看下面的代码

```tact
5 + -5; // 在这里，减号将被视为否定运算符
5 -5; // 而在这里，尽管有格式限制，它仍将被视为减法运算符
```

尽管这个例子可能很简单，但忽略优先级规则往往会导致运算符出现混乱的情况。 由于括号在所有表达式和运算符中具有最高优先级，因此用[括号](#parentheses)封装每个操作可以确保正确的操作顺序。

## 括号，`()` {#parentheses}

括号（也可称为圆括号，`(){:tact}`）与其说是实际的运算符，不如说是一种标点符号，但其[优先级]（#优先级）高于任何其他运算符的优先级。 使用括号可覆盖运算顺序：

```tact
5 * 5 - 2; // 23
5 * (5 - 2); // 15
```

## 一元

这里的"一元"是指只应用于给定表达式的一个操作数。除了[非空断言](#unary-non-null-assert)，所有一元运算符都具有相同的[优先级](#precedence)。

一元运算符可以是两种类型之一：

- 前缀 - 放在表达式之前。
- 后缀（或后缀） - 放在表达式之后。

### 非空断言，`!!` {#unary-non-null-assert}

一元双叹号（_非空断言_）运算符 `!{:tact}`是一个后缀运算符，它强制执行非`null{:tact}`值，如果可选变量不是`null{:tact}`，则允许直接访问可选变量的值。 否则，如果编译器可以跟踪，则引发编译错误；如果不能跟踪，则抛出[退出代码 128](/zh-cn/book/exit-codes#128)异常：空引用异常"。 可应用于任何可选变量，无论其类型是`非空{:tact}`。

:::note

  点击此处了解更多有关可选变量和字段的信息：[可选变量](/zh-cn/book/optionals)

:::

### 加号，`+` {#unary-plus}

虽然 Tact 编译器的语法中指定了一元加号运算符 `+{:tact}`，但它只作为 [二元运算符]（#binary-add）存在。

### 否定，`-` {#unary-negate}

一元减号（_negation_）运算符 `-{:tact}` 是一个前缀运算符，用于反转表达式的符号。 只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let five：Int = 5;
five + -five; // 在这里，减号是一个否定运算符，而不是减法运算符
-(-1); // 双倍应用返回原始值，即 1
--1; // 1
```

### 逆，`!` {#unary-inverse}

一元感叹号（_inversion_）运算符 `!{:tact}` 是一个前缀运算符，用于反转表达式的布尔值——将 `true{:tact}` 变为 `false{:tact}`，反之亦然。只能应用于 [`Bool{:tact}`][bool] 类型的值：

```tact
let iLikeTact：Bool = true;
!iLikeTact; // false
!false; // true
!(!false); // false
!!false; // false
```

### 双向 NOT, `~` {#unary-bitwise-not}

单引号 tilde（_bitwise not_）运算符 `~{:tact}` 是一个前缀运算符，它将表达式二进制表示中的每一位反转或_flip_，即把 $1$ 改为 $0$，反之亦然。 只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let answer：Int = 42;
~answer; // -43
~(~answer); // 42
~(~0); // 0
~~0; // 0
```

## 二进制

二进制运算符按[优先级](#precedence)递减的顺序分成几个小节。 每个小节中的操作符与小节本身具有相同的 [优先级](#precedence)。

### 乘法 {#binary-multiplication}

乘、除或求余数。

#### 乘法，`*` {#binary-multiply}

二进制星号 (_multiplication_) 运算符 `*{:tact}` 用于两个值的乘法运算。 可能导致 [整数溢出](/zh-cn/book/integers#operations)。

只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two * two; // 4
0 * 1_000_000_000; // 0
-1 * 5; // -5

pow(2, 255) * pow(2, 255); // build error: integer overflow！
```

#### 除法，`/` {#binary-divide}

二进制斜线 (_division_) 运算符 `/{:tact}` 用于两个值的整除，如果结果为正，则向零截断，如果结果为负，则从零截断。这也叫[向下舍入](https://en.wikipedia.org/wiki/Rounding#Rounding_down)（或向 $-\infty$ 舍入）。

如果尝试除以零，则会出现[退出代码 4](/zh-cn/book/exit-codes#4)错误：整数溢出。

只能应用于 [`Int{:tact}`][int] 类型的值：

```tact
let two: Int = 2;
two / 2; // 1
two / 1; // 2
-1 / 5; // -1
-1 / -5; // 0
1 / -5; // -1
1 / 5; // 0
6 / 5; // 1，四舍五入
-6 / 5; // -2，四舍五入（向-∞方向）。
```

:::note

  请注意，对于 `Int{:tact}` 类型，除法运算符和模数运算符之间的以下关系始终成立：

```tact
a / b * b + a % b == a; // 对于 `a` 和 `b` 的任何 Int 值均为 true,
                        // 除了当 `b` 等于 0 且我们用 0 除以 `a` 时，
                        // 这是尝试除以 0，结果会出错。
```

:::

#### Modulo, `%` {#binary-modulo}

二进制百分号 (_modulo_) 运算符 `%{:tact}` 用于获取整数除法的模数，不能与获取余数混淆。 对于符号相同的两个值，模运算和余运算是等价的，但当操作数的符号不同时，模运算的结果总是与_除数_（右边的值）的符号相同，而余运算的结果与_除数_（左边的值）的符号相同，这可能使它们相差一个单位的_除数_。

只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two % 2; // 0
two % 1; // 1

1 % 5; // 1
-1 % 5; // 4
1 % -5; // -4
-1 % -5; // -1
```

避免两者混淆的最简单方法是通过 [`abs(x: Int){:tact}`](/zh-cn/ref/core-math#abs)优先使用正值：

```tact
abs(-1) % abs(-5); // 1
```

:::note

  你知道吗，在 JavaScript 中，`%{:tact}` 可以作为_remainder_运算符，但不能作为_modul_运算符（比如在 Tact 中）？
  [Remainder (%) - JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder#description)
  [Modulo - Wikipedia](https://en.wikipedia.org/wiki/Modulo)

:::

### 加法 {#binary-addition}

加法或减法。

#### 添加，`+` {#binary-add}

二进制加法运算符 `+{:tact}` 用于将数字相加。 超出 [`Int{:tact}`][int]的最大值将导致[退出代码 4](/zh-cn/book/exit-codes#4)错误：整数溢出"。

只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two + 2; // 4
-1 + 1; // 0

pow(2, 254) + pow(2, 254); // 2 * 2^254
pow(2, 255) + pow(2, 255); // 编译错误：整数溢出！
pow(2, 255) - 1 + pow(2, 255); // 2^256 - 1，Tact 中任何整数的最大值！
```

#### 减去，`-` {#binary-subtract}

二进制减号（_subtraction_）运算符 `-{:tact}` 用于将数字相减。 超出 [`Int{:tact}`][int]的最小值将导致[退出代码 4](/zh-cn/book/exit-codes#4)错误：整数溢出。

只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two - 2; // 0
-1 - 1; // -2

pow(2, 254) - pow(2, 254); // 0
pow(2, 255) - pow(2, 255); // 0
pow(2, 256) - pow(2, 256); // build error: integer overflow！
```

### 位移 {#binary-bitwise-shifts}

向左或向右移动位。

#### 右移，`>>` {#binary-bitwise-shift-right}

二进制双大于号（_位向右移动_）运算符 `>>{:tact}` 返回一个整数，其二进制表示为*左操作数*的值向右移动了*右操作数*的位数。向右移位的多余位被丢弃，最左边位的副本从左边移入。这种操作也称为"符号向右移动"或"算术向右移动"，因为结果数字的符号与左操作数的符号相同。这是一种更有效的方法，即用 $2^n$ 除以*左操作数*，其中 $n$ 等于*右操作数*。

只能应用于 [`Int{:tact}`][int] 类型的值：

```tact
let two: Int = 2;
two >> 1; // 1
4 >> 1; // 2
5 >> 1; // 2，由于整数值的下限

pow(2, 254) >> 254; // 1
```

:::note

  [Bit shifts - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts)
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

#### 左移，`<<` {#binary-bitwise-shift-left}

二进制双小于号（_bitwise shift left_）运算符 `<<{:tact}` 返回一个整数，其二进制表示为*左操作数*的值向左移动*右操作数*的位数。向左移位的多余比特被丢弃，零比特从右边移入。这是一种更有效的方法，可以将*左操作数*乘以 $2^n$，其中 $n$ 等于*右操作数*。超出 [`Int{:tact}`][int] 的最大值将导致[退出代码 4](/zh-cn/book/exit-codes#4)错误：整数溢出。

只能应用于 [`Int{:tact}`][int] 类型的值：

```tact
let two：Int = 2;
two << 1; // 4
1 << 5; // 1 * 2^5, 即 32
2 << 5; // 2 * 2^5, 即 64

pow(2, 254) == (1 << 254); // true
pow(2, 254) == 1 << 254；// true，由于 >> 优先于 ==
pow(2, 255) == 1 << 255; // true，但我们在这里非常接近溢出，所以不需要括号！
```

:::note

  [Bit shifts - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#Bit_shifts)
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### 关系 {#binary-relation}

查找更大、更小或相等的数值。

#### 大于，`>` {#binary-greater}

二进制_大于_运算符 `>{:tact}` 如果左操作数大于右操作数，则返回 `true{:tact}`，否则返回 `false{:tact}`。 只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two > 2; // false
-1 > -3; // true
```

#### 大于或等于，`>=` {#binary-greater-equal}

二进制_大于或等于_运算符 `>={:tact}` 如果左操作数大于或等于右操作数，则返回 `true{:tact}`，否则返回 `false{:tact}`。 只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two >= 2; // true
-1 >= -3; // true
```

#### 小于，`<` {#binary-less}

二进制 _less than_ 运算符 `<{:tact}` 如果左操作数小于右操作数，则返回 `true{:tact}`，否则返回 `false{:tact}`。 只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two < 2; // false
-1 < -3; // false
```

#### 小于或等于，`<=` {#binary-less-equal}

二进制_小于或等于_运算符 `<={:tact}` 如果左操作数小于或等于右操作数，则返回 `true{:tact}`，否则返回 `false{:tact}`。 只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two <= 2; // true
-1 <= -3; // false
```

### 平等与不平等，```===``！=``` {#binary-equality}

二进制相等（_equal_）运算符 `=={:tact}` 检查其两个操作数是否_equal_，返回结果类型 [`Bool{:tact}`][bool]。

二元不等式（_not equal_）运算符 `!={:tact}` 检查其两个操作数是否_not equal_，返回一个 [`Bool{:tact}`][bool] 类型的结果。

除了 [`Cell{:tact}`][cell]和 [`Slice{:tact}`][slice]类型会通过哈希值进行隐式比较外，这两种操作符都要求操作数为相同类型，并且都不执行隐式类型转换。

这两种运算符都可以应用于下列类型和值：

- [`Int{:tact}`][int]。
- [`Bool{:tact}`][bool]。
- [`地址{:tact}`][p]
- [`单元格{:tact}`][单元格]，通过`.hash(){:tact}`隐式比较
- [`片{:tact}`][片]，通过`.hash(){:tact}`隐式比较
- [`字符串{:tact}`][p]
- [`map<K, V>{:tact}`](/zh-cn/book/maps)，但前提是它们的键和值类型相同
- [选项和 `null{:tact}` 值](/zh-cn/book/optionals)

```tact
// Int:
2 == 3; // false
2 != 3; // true

// Bool:
true == true; // true
false != true; // true

// Address:
myAddress() == myAddress(); // true
myAddress() ！= myAddress(); // false

// Cell:
emptyCell() == emptyCell(); // true
emptyCell() != emptyCell(); // false

// Slice:
"A".asSlice() == "A".asSlice(); // true
"A".asSlice() != "A".asSlice(); // false

// String：
"A" == "A"; // true
"A" != "A"; // false

// map<K, V>:
let map1: map<Int, Int> = emptyMap();
let map2: map<Int, Int> = emptyMap();
map1 == map2; // true
map1 != map2; // false

// 可选项和空值本身
let nullable：Int? = null;
nullable == null; // true
null == null; // true
nullable != null; // false
null != null; // false

let anotherNullable：= 5;
nullable == anotherNullable; // false
nullable != anotherNullable; // true
```

### 比特 AND, `&` {#binary-bitwise-and}

二进制安培（_比特 AND_）运算符 `&{:tact}` 应用[比特 AND](https://en.wikipedia.org/wiki/Bitwise_operation#AND)，对操作数的每一对相应比特执行[逻辑 AND](#binary-bitwise-and)运算。 当我们要清除一个数字的选定位时，这一点非常有用，因为每个位都代表一个单独的标志或布尔状态，这使得每个整数可以 "存储 "多达 $257$ 个布尔值，因为 Tact 中的所有整数都是 $257$- 位有符号的。

只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two & 1; // 0
4 & 1; // 0
3 & 1; // 1
1 & 1; // 1

255 & 0b00001111; // 15
0b11111111 & 0b00001111; // 15
```

:::note

  [Bitwise AND - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#AND)
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### 比特 XOR, `^` {#binary-bitwise-xor}

二进制符串（_位向 XOR_）运算符 `^{:tact}` 应用 [位向 XOR](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)，对操作数的每一对相应位执行 [逻辑排他 OR](https://en.wikipedia.org/wiki/Exclusive_or)运算。 如果只有一个位是 $1$，则每个位置的结果都是 $1$ ，但如果两个位都是 $0$ 或两个位都是 $1$，则结果都是 $0$。 在这种情况下，它会对两个比特进行比较，如果两个比特不同，则给出 $1$ ；如果两个比特相同，则给出 $0$。

它适用于将操作数的选定位反转（也称为切换或翻转），因为任何位都可以通过与 $1$进行 "XOR "来切换。

只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two ^ 3; // 1
4 ^ 1; // 0
3 ^ 1; // 3
1 ^ 1; // 0

255 ^ 0b00001111; // 240
0b111111 11 ^ 0b00001111; // 240
```

:::note

  [Bitwise XOR - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#XOR)/
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### 位wise OR, `|` {#binary-bitwise-or}

二进制条形 (_bitwise OR_) 运算符 `|{:tact}` 应用 [bitwise OR](https://en.wikipedia.org/wiki/Bitwise_operation#OR)，对操作数的每一对相应位执行 [logical OR](#binary-logical-or) 运算。 当我们要应用特定的 [bitmask](https://en.wikipedia.org/wiki/Mask_(computing)) 时，这很有用。

例如，_bitwise OR_ 通常用于 Tact 中的[将基本模式与可选标记结合](/zh-cn/book/message-mode#combining-modes-with-flags)，方法是将特定位屏蔽到 $1$ ，以构建目标[信息`模式`](/zh-cn/book/message-mode)。

只能应用于 [`Int{:tact}`][int]类型的值：

```tact
let two: Int = 2;
two | 1; // 3
4 | 1; // 5
3 | 1; // 3
1 | 1; // 1

255 | 0b00001111; // 255
0b111111 | 0b00001111; // 255
```

:::note

  [Bitwise OR - Wikipedia](https://en.wikipedia.org/wiki/Bitwise_operation#OR)
  [Bit manipulation - Wikipedia](https://en.wikipedia.org/wiki/Bit_manipulation)

:::

### 逻辑 AND, `&&` {#binary-logical-and}

二进制逻辑 AND（[逻辑连接](https://en.wikipedia.org/wiki/Logical_conjunction)）运算符 `&&{:tact}` 如果两个操作数都是 `true{:tact}`，则返回 `true{:tact}`，否则返回 `false{:tact}`。 它是短路的，也就是说，如果左操作数是 `false{:tact}`，它会立即将整个表达式求值为 `false{:tact}`，而不求值右操作数。

只能应用于 [`Bool{:tact}`][bool]类型的值：

```tact
let iLikeTact：Bool = true;
iLikeTact && true; // true, evaluated both operands
iLikeTact && false; // false, evaluated both operands
false && iLikeTact; // false, didn't evaluate iLikeTact
```

### 逻辑 OR, `||` {#binary-logical-or}

二元逻辑 OR（[逻辑析取](https://en.wikipedia.org/wiki/Logical_disjunction)）运算符 `||{:tact}` 只有当两个操作数都是 `false{:tact}` 时，才返回 `false{:tact}`，否则返回 `true{:tact}`。 它是短路的，也就是说，如果左操作数是 `true{:tact}`，它会立即将整个表达式评估为 `true{:tact}`，而不评估右操作数。

只能应用于 [`Bool{:tact}`][bool]类型的值：

```tact
let iLikeSnails：Bool = false;
iLikeSnails || true; // true, evaluated both operands
iLikeSnails || false; // false, evaluated both operands
true || iLikeSnails; // true, didn't evaluate iLikeSnails
```

## 三元，`?:` {#ternary}

条件（_ternary_）运算符是唯一一个包含三个操作数的 Tact 运算符：一个条件，后面跟一个问号（`?{:tact}`），然后是如果条件被评估为`true{:tact}`时要执行的表达式，后面跟一个冒号（`:{:tact}`），最后是如果条件被评估为`false{:tact}`时要执行的表达式。 该运算符常用于替代 [`if...else{:tact}`](/zh-cn/book/statements#if-else) 语句。

条件必须解析为 [`布尔{:tact}`][布尔] 类型：

```tact
// condition
// ↓
true ?"incredibly so" ："absolutely not"; // "incredibly so"
// --------------- ----------------
// ↑ ↑
// | alternative, when condition is false
// |
// consequence, when condition is true

2 + 2 == 4 ? true : false; // true
```

三元运算符是除[赋值相关运算符]（#赋值）外唯一具有右关联性的运算符。 这意味着，在模棱两可的情况下，Tact 会优先选择最长的匹配序列。 简而言之，这使得三元运算符的无括号嵌套成为可能，但仅限于替代情况（冒号 `:{:tact}` 后面的部分）：

```tact
// 在其他情况下不需要额外的括号
false ?1 : (false ? 2 : 3); // 3
false ?1 : false ?2 : 3; // 也是 3
false ?1 : true ?2 : 3; // 2

// 后果情况需要额外的括号(介于 ? 和 : 之间的部分)
false ?(false ? 1 : 2) : 3; // 3
false ?1 : 2 : 3; // SYNTAX ERROR!
true ?(false ? 1 : 2) : 3; // 2
```

## 赋值，`=` {#assignment}

赋值操作符 `={:tact}` 用于为变量或 [Message](/zh-cn/book/structs-and-messages#messages) 或 [Struct](/zh-cn/book/structs-and-messages#structs) 的属性赋值。 赋值是一个语句，不返回值。

```tact
let someVar：Int = 5; // 这里使用了赋值运算符 =...
someVar = 4; // ... 这里
someVar = (someVar = 5); // SYNTAX ERROR！
```

### 增强赋值运算符 {#augmented-assignment}

增强（或复合）赋值运算符，如 `+={:tact}`，将操作与 [赋值]（#assignment）结合起来。 增强赋值是一个语句，不返回值。

扩充赋值在语义上等同于常规赋值，只是多了一个操作：

```tact
let value：Int = 5;

// this:
value += 5;
// 等同于 this:
value = value + 5；
```

增强赋值运算符列表：

- `+={:tact}`，使用 [加法运算符 `+{:tact}`](#binary-addition)。 只能应用于 [`Int{:tact}`][int]类型的值。
- `-={:tact}`，使用 [减法运算符 `-{:tact}`](#binary-subtract)。 只能应用于 [`Int{:tact}`][int]类型的值。
- `*={:tact}`，使用 [乘法运算符 `*{:tact}`](#binary-multiply)。 只能应用于 [`Int{:tact}`][int]类型的值。
- `/={:tact}`，使用 [除法运算符 `/{:tact}`](#binary-divide)。 只能应用于 [`Int{:tact}`][int]类型的值。
- `%={:tact}`，使用 [modulo 运算符 `%{:tact}`](#binary-modulo)。 只能应用于 [`Int{:tact}`][int]类型的值。
- `&={:tact}`，使用 [bitwise AND 运算符 `&{:tact}`](#binary-bitwise-and)。 只能应用于 [`Int{:tact}`][int]类型的值。
- `^={:tact}`，它使用 [bitwise XOR 运算符 `^{:tact}`](#binary-bitwise-xor)。 只能应用于 [`Int{:tact}`][int]类型的值。
- `|={:tact}`，它使用 [bitwise OR 运算符 `|{:tact}`](#binary-bitwise-or)。 只能应用于 [`Int{:tact}`][int]类型的值。

```tact
let value：Int = 5;

// +=
value + 5; // 加 5
value = value + 5; // 加 5 并返回结果
value += 5; // 也加 5 并返回结果

// -=
value - 5; // 减 5
value = value - 5; // 减 5 并返回结果
value -= 5; // 也减 5 并返回结果

// *=
value * 5；         // 乘以 5
value = value * 5; // 乘以 5 并返回结果
value *= 5; // 也乘以 5 并返回结果

// /=
value / 5; // 除以 5
value = value / 5; // 除以 5 并返回结果
value /= 5; // 也除以 5 并返回结果

// %=
value % 5；         // 得到 5 的模数
value = value % 5; // 得到 5 的模数并返回结果
value %= 5; // 也得到 5 的模数并返回结果

// &=
value & 5; // 位和 5
value = value & 5; // 位和 5 并返回结果
value &= 5; // 也位和 5 并返回结果

// ^=
value ^ 5；         // 位似 XOR 5
value = value ^ 5; // 位似 XOR 5 并返回结果
value ^= 5; // 也是位似 XOR 5 并返回结果

// |=
value | 5; // 位似 OR 5
value = value | 5; // 位似 OR 5 并返回结果
value |= 5; // 也是位似 OR 5 并返回结果
```

[p]: /zh-cn/book/types#primitive-types
[bool]: /zh-cn/book/types#booleans
[int]: /zh-cn/book/integers
[电池]: /zh-cn/book/cells#cells
[一片]: /zh-cn/book/cells#slices


## optionals.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/optionals.mdx)
---
title: 可选项
---

[类型系统概述](/zh-cn/book/types#optionals)中提到，所有[原始类型](/zh-cn/book/types#primitive-types)、[结构体](/zh-cn/book/structs-and-messages#structs)和[消息](/zh-cn/book/structs-and-messages#messages)都可以为空。也就是说，除了 `null{:tact}`（一种特殊值，表示故意没有任何其他值）之外，它们不一定持有任何值。

[变量](/zh-cn/book/statements#let)或[结构](/zh-cn/book/structs-and-messages#structs)和[消息](/zh-cn/book/structs-and-messages#messages)中可容纳 `null{:tact}` 的字段被称为"可选项"。当变量不一定被使用时，它们对减少状态大小很有用。

在变量或字段的类型声明后添加问号 (`?{:tact}`)，就可以将其设为可选变量或字段。唯一的例外是 [`map<K, V>{:tact}`](/zh-cn/book/maps)和 [`bounced<Msg>{:tact}`](/zh-cn/book/bounced)，你不能让它们、内部键/值类型（如果是 map）或内部[消息](/zh-cn/book/structs-and-messages#messages)（如果是 bounced）成为可选项。

未定义的可选变量或可选字段默认为 `null{:tact}` 值。如果不先检查 `null{:tact}`，就无法访问它们。但如果你确定它们在某一时刻不是 `null{:tact}`，可以使用[非空断言操作符 `!!{:tact}`](/zh-cn/book/operators#unary-non-null-assert)访问它们的值。

在未使用 [`!!{:tact}`](/zh-cn/book/operators#unary-non-null-assert)或未事先检查 `null{:tact}` 的情况下尝试访问可选变量或可选字段的值，如果编译器可以跟踪，则会导致编译错误；如果不能跟踪，则会导致[退出代码 128](/zh-cn/book/exit-codes#128)异常：空引用异常。

可选项举例：

```tact
struct StOpt {
    opt：Int?; // Int 或 null
}

message MsOpt {
    opt：StOpt?; // 注意，在此定义中如何使用 struct StOpt
}

contract Optionals {
    opt：Int?;
    address：Address?;

    init(opt: Int?) { // optionals as parameters
        self.opt = opt;
        self.address = null; // explicit null value
    }

    receive(msg: MsOpt) {
        let opt：= 12; // defining a new variable
        if (self.opt != null) { // explicit check
            self.opt = opt!!; // using !! as we know that opt value isn't null
        }
    }
}
```


## programmatic.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/programmatic.mdx)
---
title: 程序化 API
---

您可以在节点和浏览器环境中从代码中调用 Tact 编译器。

:::caution

  该应用程序接口尚未发布。 它将在 1.0.0 版本中发布。

:::

## 在浏览器中运行编译器

```ts
import { run } from "@tact-lang/compiler";

// Virtual FS
const fs = {
  ["main.tact"]：Buffer.from("...").toString("base64"),
};

const config = {
  projects：[
    {
      name: "Sample",
      path："main.tact",
      output："./output",
    },
  ],
};

// Run compiler
let successful = await run({ config, fs });

// NOTE: Output from is written to the same fs object.
```

## 合同核查

您可以使用 `verify` 函数验证编译后的软件包。

```ts
import { verify } from "@tact-lang/compiler";
const pkg: string = '...';
const res = await verify(pkg)；
```


## receive.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/receive.mdx)
---
title: 接收信息
---

TON 是一个分布式区块链，这意味着合约之间的通信是通过发送和接收信息完成的。 最常见的信息类型是内部信息--从一个合约（或钱包）发送到另一个合约（或钱包）的信息。

## 接收内部信息

要接收所需类型的信息，您需要声明一个接收函数，例如`receive(“increment”){:tact}`。这个符号表示声明一个接收函数，当向合约发送值为 `“increment”{:tact}`的文本时，该函数将被调用。函数体可以修改合约的状态，并向其他合约发送信息。不可能直接调用接收器。如果需要重用某些逻辑，可以声明一个函数，然后从接收器中调用。

有多个接收器函数。所有接收器函数的处理顺序如下：

* `receive(){:tact}` - 向合约发送空信息时调用。
* `receive("message"){:tact}` - 向合约发送带有特定注释的文本信息时调用。
* `receive(str: String){:tact}` - 向合约发送任意文本信息时调用。
* `receive(msg: MyMessage){:tact}`-当向合约发送 “MyMessage ”类型的二进制信息时调用。
* `receive(msg: Slice){:tact}` - 向合约发送未知类型的二进制信息时调用。

```tact

message MyMessage {
    value: Int;
}

contract MyContract {
    receive() {
        // ...
    }
    receive("message") {
        // ...
    }
    receive(str: String) {
        // ...
    }
    receive(msg: MyMessage) {
        // ...
    }
    receive(msg: Slice) {
        // ...
    }
}
```

用下划线`_{:tact}`命名接收函数的参数时，其值将被视为未使用的值并被丢弃。 当您不需要检查接收到的信息，而只想让它传达特定的操作码时，这就很有用了：

```tact
message(42) UniverseCalls {}

contract Example {
    receive(_: UniverseCalls) {
        // Got a Message with opcode 42
    }
}
```


## send.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/send.mdx)
---
title: 发送信息
---

TON 区块链是基于消息的--要与其他合约通信和部署新合约，您需要发送消息。

Tact 中的消息通常使用内置[Struct](/zh-cn/book/structs-and-messages#structs) `SendParameters{:tact}`组成，它由以下部分组成：

| 现场    | 类型                      | 说明                                                                                                                                                                      |
| :---- | :---------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 弹跳    | [`Bool{:tact}`][p]      | `bounce` - if set to `true` (default) then the message will be bounced back to the sender if the receiver contract doesn't exist or wasn't able to process the message. |
| 到     | [`地址{:tact}`][p]        | TON 区块链中的内部接收器 [`地址{:tact}`][p]。                                                                                                                                        |
| 值     | [`Int{:tact}`][int]。    | `value` in TON - the amount of TON you want to send with the message. This value is used to cover gas fees on the receiver side.                                        |
| 模式    | [`Int{:tact}`][int]。    | 一个 8 位值，用于配置发送信息的方式，默认值为 $0$。 参见：[消息`模式`](/zh-cn/book/message-mode)。                                                                                                          |
| 身体    | [`Cell?{:tact}`][单元格]   | [可选][选项]信息正文作为[`单元格{:tact}`][单元格]                                                                                                                                       |
| 代码    | [`Cell?{:tact}`][单元格]   | [可选][opt] 合同的初始代码（编译后的字节码）                                                                                                                                              |
| 数据    | [`Cell?{:tact}`][单元格]   | [可选][选项]合同的初始数据（合同的[`init(){:tact}`函数](/zh-cn/book/contracts#init-function)的参数）                                                                                               |

字段 `code` 和 `data` 被称为 [初始包](/zh-cn/book/expressions#initof)，用于部署新合约。

## 发送简单回复 {#send-simple-reply}

最简单的信息是对接收信息的回复，返回信息的所有多余值：

```tact
receive() {
    self.reply("Hello, World!".asComment()); // asComment converts a String to a Cell with a comment
}
```

## 发送信息 {#send-message}

如果需要更高级的逻辑，可以直接使用 `send(){:tact}` 函数和 `SendParameters{:tact}` [Struct](/zh-cn/book/structs-and-messages#structs) 。

事实上，前面使用 [`.reply(){:tact}`](#send-simple-reply)的示例可以通过调用下面的`send(){:tact}`函数来实现：

```tact
receive() {
    send(SendParameters{
        // bounce is set to true by default
        to: sender(), // sending message back to the sender
        value: 0, // don't add Toncoins to the message...
        mode: SendRemainingValue | SendIgnoreErrors, // ...except for ones received from the sender due to SendRemainingValue
        body: "Hello, World".asComment(), // asComment converts a String to a Cell with a comment
    });
}
```

另一个示例是向指定的 [`Address{:tact}`][p]发送一条信息，信息的`值`为 $1$ TON，`body`为带有 [`String{:tact}`][p] `"Hello, World!"{:tact}`的注释：

```tact
let recipient: Address = ...;
let value: Int = ton("1");
send(SendParameters{
    // bounce is set to true by default
    to: recipient,
    value: value,
    mode: SendIgnoreErrors, // will send the message despite any errors
    body: "Hello, World!".asComment(),
});
```

[可选标记](/zh-cn/book/message-mode#optional-flags) `SendIgnoreErrors{:tact}`表示即使在发送信息过程中发生错误，也会继续发送下一条信息。**发送阶段的任何错误都不会导致事务逆转**。

## 发送打字信息

要发送二进制键入信息，可以使用以下代码：

```tact
let recipient: Address = ...;
let value: Int = ton("1");
send(SendParameters{
    // bounce is set to true by default
    to: recipient,
    value: value,
    mode: SendIgnoreErrors, // don't stop in case of errors
    body: SomeMessage{arg1: 123, arg2: 1234}.toCell(),
});
```

## 部署合约

要部署一个合约，你需要用 [`initOf{:tact}`](/zh-cn/book/expressions#initof)计算它的地址和初始状态，然后在初始化信息中发送它们：

```tact
let init: StateInit = initOf SecondContract(arg1, arg2);
let address: Address = contractAddress(init);
let value: Int = ton("1");
send(SendParameters{
    // bounce is set to true by default
    to: address,
    value: value,
    mode: SendIgnoreErrors, // don't stop in case of errors
    code: init.code,
    data: init.data,
    body: "Hello, World!".asComment(), // not necessary, can be omitted
});
```

## 外发信息处理 {#outbound-message-processing}

TON 区块链上的每笔交易都由 [多个阶段][阶段] 组成。 出站报文在[计算阶段][计算]中进行评估，但\*\*\*不在该阶段发送。 在[计算阶段][compute]中列出的所有操作，如外向消息或[储备请求]（/ref/core-advanced#nativereserve），都会在[操作阶段][phases]中执行。

由于所有值都是在[计算阶段][compute]中计算的，所有费用都是在计算结束前计算的，而且在[操作阶段][phases]中出现异常时不会恢复交易，因此向外发送信息可能会因[操作费](https://docs.ton.org/develop/howto/fees-low-level#action-fee) 或[转发费][fwdfee]不足而失败，不会出现跳转。

请看下面的例子：

```tact
// This contract initially has 0 nanoToncoins on the balance
contract FailureIsNothingButAnotherStep {
    // And all the funds it gets are obtained from inbound internal messages
    receive() {
        // 1st outbound message evaluated and queued (but not sent yet)
        send(SendParameters{
            to: sender(),
            value: ton("0.042"), // plus forward fee due to SendPayGasSeparately
            mode: SendIgnoreErrors | SendPayGasSeparately,
        });

        // 2nd outbound message evaluated and queued (but not sent yet, and never will be!)
        send(SendParameters{
            to: sender(),
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
        });
    }
}
```

在那里，第二条信息实际上不会被发送：

- [计算阶段][计算]结束后，计算合约的剩余价值 $\mathrm{R}$。

- 在出站信息处理过程中，假设入站信息中提供了足够的价值，第一条信息会在余额上留下 $\mathrm{R} - (0.042 + \mathrm{forward\_fees})$ [nanoToncoins](/zh-cn/book/integers#nanotoncoin) 。

- 处理第二条信息时，合约会尝试发送 $\mathrm{R}$ [纳米通币](/zh-cn/book/integers#nanotoncoin)，但发送失败，因为剩余的金额已经较少。

:::note

  有关所有信息发送功能的更多信息，请参阅参考资料：

- [`send(){:tact}`](/zh-cn/ref/core-common#send)
- [`emit(){:tact}`](/zh-cn/ref/core-common#emit)
- [`self.notify(){:tact}`](/zh-cn/ref/core-base#self-notify)
- [`self.reply(){:tact}`](/zh-cn/ref/core-base#self-reply)
- [`self.forward(){:tact}`](/zh-cn/ref/core-base#self-forward)
- [`nativeSendMessage(){:tact}`](/zh-cn/ref/core-advanced#nativesendmessage)

:::

[p]: /zh-cn/book/types#primitive-types
[int]: /zh-cn/book/integers
[电池]: /zh-cn/book/cells#cells
[选择]: /zh-cn/book/optionals

[阶段]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases
[算]: https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase
[纳米]: /zh-cn/book/integers#nanotoncoin
[fwdfee]: https://docs.ton.org/develop/howto/fees-low-level#forward-fees


## statements.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/statements.mdx)
---
title: 发言
---

以下语句可出现在 [function](/zh-cn/book/functions) 主体的任何位置。

## `let`语句 {#let}

`let{:tact}` 语句允许声明局部变量和 [block](#block)-scoped 变量。

在 Tact 中，声明一个局部变量总是需要一个初始值。但是，也可以省略类型标注，Tact 会尝试从初始值推断类型：

```tact
let value：Int = 123; // 包含类型和值的完整声明
let vInferred = 123; // 推断类型 Int

let vExplicitCtx：Context = context(); // 显式类型 Context，内置结构
let vCtx = context(); // 推断类型 Context
```

请注意，`null{:tact}`的初始值既可以指具有任意 `K{:tact}`和 `V{:tact}`类型的空[`map<K, V>{:tact}`](/zh-cn/book/maps)，也可以指故意不为[optional](/zh-cn/book/optionals)类型设置任何其他值。 这就是为什么在声明 [optional](/zh-cn/book/optionals) 或 [`map<K, V>{:tact}`](/zh-cn/book/maps)时，需要明确指定类型，因为无法推断：

```tact
let vOptional: Int? = null; // explicit type Int or null
let vOptInt = 42; // implicit type Int
vOptInt = null; // CompILATION ERROR!

let vMap: map<Int, Int> = emptyMap(); // explicit type map<Int, Int>
let vMapWithSerialization: map<Int as uint8, Int as uint8> = emptyMap()；
```

用下划线 `_{:tact}` 命名局部变量时，其值将被视为未使用并丢弃。 当你不需要某个函数的返回值（有副作用），并想明确地将变量标记为未使用时，这种方法就很有用。 注意，不能访问通配符变量名 `_{:tact}`：

```tact
let _ = someFunctionWithSideEffects(); // with type inference
let _: map<Int, Int> = emptyMap(); // with explicit type

dump(_); // COMPILATION ERROR！无法访问 _
```

## `return` 语句 {#return}

`return{:tact}` 语句结束 [function](/zh-cn/book/functions) 的执行，并指定要返回给 [function](/zh-cn/book/functions) 调用者的值。

```tact
// Simple wrapper over stdlib function now()
fun getTimeFromNow(offset: Int): Int {
    return now() + offset;
}
```

## block

块语句用于组合零个或多个语句。 块由一对大括号（"大括号"、`{}{:tact}`）分隔，包含一个由零个或多个语句和声明组成的列表。

某些语句，如 [`let{:tact}`](#let) 或 [`return{:tact}`](#return)，必须以结束分号 `;{:tact}` 结束。 不过，语块中最后一条语句的分号是可选的，可以省略。

```tact
{ // <- 块的开始
    // 任意语句：
    let value：Int = 2 + 2;
    dump(value);
}// <- 程序块的结束

{ dump(2 + 2) }// 一个只有一条语句的代码块，
                // 省略了最后也是唯一的分号

{
    let nah = 3 * 3 * 3; // 一个有两条语句的代码块，
    let yay = nah + 42 // 但没有最后的分号
}
```

## 表达

表达式语句是一种表达式，用于预期需要语句的地方。 表达式被求值后，其结果将被丢弃--因此，它只适用于有副作用的表达式，如执行函数或更新变量。

```tact
dump(2 + 2); // stdlib 函数
```

## 任务

赋值语句使用 [赋值运算符](/zh-cn/book/operators#assignment) (`={:tact}`)或 [增强赋值运算符](/zh-cn/book/operators#augmented-assignment) (赋值与运算相结合)：

```tact
let value：Int; // 声明
value = 5; // 赋值
value += 5; // 增强赋值（众多赋值之一，见下文）
```

:::note

  有关赋值和增强赋值的更多信息，请参阅其专门章节：[赋值运算符](/zh-cn/book/operators#assignment)。

:::

## 分支机构

控制代码流

### `if...else` {#if-else}

:::caution

  需要使用大括号（代码块）！

:::

在执行 `if...else{:tact}` 语句时，首先会对指定条件进行评估。 如果结果值为 `true{:tact}`，则执行下面的语句块。 否则，如果条件评估结果为 `false{:tact}`，将执行可选的 `else{:tact}` 块。 如果缺少 `else{:tact}` 块，则什么也不会发生，执行仍将继续。

常规 `if{:tact}` 语句：

```tact
// condition
// ↓
if (true) { // consequence, when condition is true
    dump(2 + 2);
}
```

`else{:tact}` 块：

```tact
// condition
// ↓
if (2 + 2 == 4) {
    // consequence, when condition is true
    dump(true);
} else {
    // alternative, when condition is false
    dump(false);
}
```

使用嵌套的 `if...else{:tact}`：

```tact
// condition
// ↓
if (2 + 2 == 3) {
    // consequence, when condition is true
    dump("3?");
//        condition2
//        ↓
} else if (2 + 2 == 4) {
    // another consequence, when condition2 is true
    dump(true);
} else {
    // alternative, when both condition and condition2 are false
    dump(false);
}
```

:::note

  Tact 也有一个三元表达式 `?:{:tact}`，在本书前面已有介绍：[三元表达式](/zh-cn/book/operators#ternary)。

:::

### `try...catch` {#try-catch}

`try...catch{:tact}`语句由一个 `try{:tact}`块和一个可选的 `catch{:tact}`块组成，它接收一个 [`Int{:tact}`][int][退出代码](/zh-cn/book/exit-codes)作为唯一参数。 首先执行 `try{:tact}`块中的代码，如果失败，则执行`catch{:tact}`块中的代码，并尽可能回滚`try{:tact}` 块中的更改。

:::note

  请注意，某些 TVM 状态参数（如编码页和 gas 计数器）不会回滚。 也就是说，`try{:tact}`程序块中的所有 gas 使用量都将被考虑在内，而改变 gas 限值的操作码的效果也将被保留。

:::

常规 `try{:tact}` 语句：

```tact
fun braveAndTrue() {
    // 让我们尝试做一些错误的事情
    try {
        nativeThrow(42); // 抛出退出代码 42
    } // 下面的内容将被执行，因为上面的错误代码被封装在 try 块中 dump(42); }

    // 下面的代码将被执行，因为上面的错误代码被封装在一个 try 块中
    dump(42);
}
```

用 `catch (e){:tact}` 块：

```tact
fun niceCatch() {
    // 让我们尝试做一些错误的事情
    try {
        nativeThrow(42); // 抛出退出代码 42
    } catch (err) {
        dump(err); // 这将转储捕获的退出代码，即 42
    }
}
```

使用嵌套的 `try...catch{:tact}`：

```tact
try {
    // Preparing an x equal to 0, in such a way that Tact compiler won't realize it (yet!)
    let xs: Slice = beginCell().storeUint(0, 1).endCell().beginParse();
    let x: Int = xs.loadUint(1); // 0

    try {
        throw(101);     // 1. throws with exit code 101
    } catch (err) {     // 2. catches the error and captures its exit code (101) as err
        return err / x; // 3. divides err by x, which is zero, throwing with exit code 4
    }

} catch (err) {         // 4. catches the new error and captures its exit code (4) as err
    //   ^^^ this works without name collisions because the previous err
    //       has a different scope and is only visible inside the previous catch block

    dump(err);          // 5. dumps the last caught exit code (4)
}
```

请注意，与 [`let{:tact}` 语句](#let)类似，在 `catch (){:tact}` 子句中捕获的[退出代码](/zh-cn/book/exit-codes)可以通过指定下划线 `_{:tact}` 来丢弃：

```tact
try {
    throw(42);
} catch (_) {
    dump("I don't know the exit code anymore");
}
```

:::note

  在专用页面上阅读更多有关退出代码的信息：[图书中的出口代码](/zh-cn/book/exit-codes)。

:::

## 循环

有条件地多次重复某些代码块。

### `repeat` {#repeat-loop}

`repeat复{:tact}`循环执行指定次数的代码块。重复次数应该是一个正的 $32$ 位 [`Int{:tact}`][int]，范围从 $1$ 到 $2^{31} - 1$。如果数值大于这个范围，将出现 [exit code 5](/zh-cn/book/exit-codes#5)，“Integer out of the expected range ”的错误。

如果指定的重复次数等于 $0$ 或包含范围 $-2^{256}$ 至 $-1$ 中的任何负数，则忽略该值，不执行代码块。

```tact
let twoPow: Int = 1;

// Repeat exactly 10 times
repeat (10) {
    twoPow *= 2;
}

// Skipped
repeat (-1) {
    twoPow *= 3333;
}

twoPow; // 1024
```

### `while` {#while-loop}

只要给定条件为 `true{:tact}`，`while{:tact}` 循环就会继续执行代码块。

在下面的示例中，每次迭代时，`x` 的值都会递减 $1$，因此循环将运行 $10$ 次：

```tact
let x: Int = 10;
while(x > 0) {
  x = x - 1;
}
```

### `do...until` {#do-until-loop}

`do...until{:tact}`循环是一个后测试循环，它至少执行一次代码块，然后继续执行，直到给定条件变为 `true{:tact}`。

在下面的示例中，每次迭代时，`x` 的值都会递减 $1$，因此循环将运行 $10$ 次：

```tact
let x: Int = 10;
do {
  x = x - 1;  # do something no matter at least one time
} until (x <= 0);
```

### `foreach` {#foreach-loop}

`foreach{:tact}` 循环按顺序对 [`map<K, V>{:tact}`](/zh-cn/book/maps) 类型的键值对（条目）进行操作：从 map 的最小键到最大键。

该循环为给定映射中的每个条目执行一个代码块，每次迭代都会捕获键和值。 当您事先不知道地图中有多少个条目，或不想明确地使用地图的 [`.get(){:tact}`](/zh-cn/book/maps#get) [method](/zh-cn/book/functions#extension-function) 查找每个条目时，这将非常方便。

请注意，每次迭代时捕获的键和值对的名称是任意的，可以是任何有效的 Tact 标识符，只要它们是当前作用域的新标识符即可。 最常见的选项是k "和 "v"，或 "key "和 "value"。

在下面的示例中，地图 `cells` 有 $4$ 个条目，因此循环将运行 $4$ 次：

```tact
// 空地图
let cells: map<Int, Cell> = emptyMap();

// 设置四个条目
cells.set(1, beginCell().storeUint(100, 16).endCell());
cells.set(2, beginCell().storeUint(200, 16).endCell());
cells.set(3, beginCell().storeUint(300, 16).endCell());
cells.set(4, beginCell().storeUint(400, 16).endCell());

// 用于求数值总和的变量
let sum：Int = 0;

// 对于单元格映射中的每个键和值对，执行：
foreach (key, value in cells) { // or just k, v
    let s：Slice = value.beginParse(); // 将单元格转换为 Slice
    sum += s.loadUint(16); // Slice 值的总和
}
dump(sum); // 1000
```

还可以遍历合约存储中的映射，以及作为 [Struct](/zh-cn/book/structs-and-messages#structs) 或 [Message](/zh-cn/book/structs-and-messages#messages) 类型实例成员的映射：

```tact
import "@stdlib/deploy";

struct Fizz { oh_my: map<Int, Int> }
message Buzz { oh_my: map<Int, Int> }

contract Iterated {
    oh_my: map<Int, Int>;

    receive("call to iterate！") {
        let oh_my: map<Int, Int> = emptyMap();
        oh_my.set(0, 42);
        oh_my.set(1, 27);

        self.oh_my = oh_my; // 将本地 map 赋值给存储空间
        let fizz = Fizz{ oh_my }; // 字段双关语
        let buzz = Buzz{ oh_my }; // 字段双关语

        // 遍历合同存储空间中的 map
        foreach (key, value in self.oh_my) {
            // ...
        }

        // 遍历 Struct Fizz 实例的 map 成员
        foreach (key, value in fizz.oh_my) {
            // ...
        }

        // 遍历 Message Buzz 实例的 map 成员
        foreach (key, value in buzz.oh_my) {
            // ...
        }
    }
}
```

请注意，与 [`let{:tact}` 语句](#let)类似，可以通过指定下划线 `_{:tact}` 来丢弃捕获的键或值（或两者）：

```tact
// 空地图
let quartiles: map<Int, Int> = emptyMap();

// 设置一些条目
quartiles.set(1, 25);
quartiles.set(2, 50);
quartiles.set(3, 75);

// 丢弃捕获的键
// 不在地图本身中修改它们
foreach (_, value in quartiles) {}

// 丢弃捕获的值
// 不在映射本身中修改它们
foreach (key, _ in quartiles) {}

// 丢弃键和值
// 不在 map 本身中修改它们
foreach (_, _ in quartiles) {
    // 不能通过 _ 访问，但可以进行所需的操作
    // n 次，其中 n 是当前 map 的长度
}
```

:::caution

  请注意，目前 `foreach{:tact}` 只适用于明确提供的映射标识符和嵌套标识符结构，如 `foo.bar.targetMap{:tact}` 或 `self.baz.targetMap{:tact}`。 也就是说，从函数中返回一个映射并试图遍历其条目是行不通的：

```tact
foreach (k, v in emptyMap()) {
// ^ 这将给出以下错误信息：
// foreach 只允许在路径表达式（
// 即标识符）或直接合同/结构/消息访问序列（
// 如 "self.foo "或 "self.structure.field"）的映射上运行
}
```

  试图遍历函数返回的 [Struct](/zh-cn/book/structs-and-messages#structs)的 map 成员也是行不通的，因为函数调用是一种表达式，而不是标识符或嵌套标识符访问：

```tact
foreach (k, v in genCoolStruct().map) {
// ^ 这将给出以下错误信息：
// foreach 只允许在路径表达式（
// 即标识符）或直接合同/结构/消息访问序列（
// 如 "self.foo "或 "self.structure.field"）的映射上使用
}
```

:::

:::note

  有关其他循环示例，请参阅[循环示例](https://tact-by-example.org/04-loops)。

:::

[initOf]: /zh-cn/book/integers


## structs-and-messages.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/structs-and-messages.mdx)
---
title: 结构和信息
---

Tact 支持许多专为智能合约使用而定制的 [原始数据类型](/zh-cn/book/types#primitive-types)。 不过，使用单独的存储方式往往会变得繁琐，因此有 [Structs](#structs) 和 [Messages](#messages)可以将类型组合在一起。

:::caution

  **警告**：目前无法**循环**类型。 这意味着结构/消息 **A** 的字段不能与结构/消息 **B** 的字段相同。

  因此，以下代码**无法**编译：

  ```tact
  struct A {
      circularFieldA: B;
  }

  struct B {
      impossibleFieldB：A;
  }
  ```

:::

## 结构 {#structs}

结构体可以定义包含多个不同类型字段的复杂数据类型。 它们还可以嵌套。

```tact
struct Point {
    x：Int as int64;
    y：Int as int64;
}

struct Line {
    start：point;
    end：point;
}
```

结构体还可以包含默认字段和定义[可选类型]字段（/book/optionals）。 如果您有很多字段，但又不想一直在 [new instances]（#instantiate）中为它们指定通用值，那么这将非常有用。

```tact
struct Params {
    name: String = "Satoshi"; // default value

    age: Int?; // field with an optional type Int?
               // 默认值为空

    point：Point; // 嵌套结构
}
```

结构体还可用作获取器或其他内部函数的返回值。 它们有效地允许单个获取器返回多个返回值。

```tact
contract StructsShowcase {
    params：Params; // Struct 作为合约的持久状态变量

    init() {
        self.params = Params{
            point：Point{
                x: 4,
                y: 2,
            },
        };
    }

    get fun params()：Params {
        return self.params;
    }
}
```

请注意，结构声明中的最后一个分号 `;`是可选项，可以省略：

```tact
struct Mad { ness: Bool }

struct MoviesToWatch {
    wolverine：String;
    redFunnyGuy: String
}
```

字段的顺序很重要，因为它与[TL-B 模式](https://docs.ton.org/develop/data-formats/tl-b-language) 中的内存布局一致。 不过，与某些采用手动内存管理的语言不同，Tact 在字段之间没有任何填充。

## 信息 {#messages}

消息中可以包含 [结构体]（#structs）：

```tact
struct Point {
    x：Int;
    y：Int;
}

message Add {
    point：Point; // holds a struct Point
}
```

消息与 [结构体](#structs)几乎相同，唯一不同的是，消息在序列化时有一个 32 位整数头，包含唯一的数字 id，通常称为 _opcode_（操作码）。 这使得信息可以与 [接收者]（/book/receive）一起使用，因为合约可以根据这个 id 区分不同类型的信息。

Tact 会为每个接收到的信息自动生成这些唯一 ID（操作码），但也可以手动覆盖：

```tact
// 此消息用 0x7362d09c 覆盖其唯一 ID
message(0x7362d09c) TokenNotification {
    forwardPayload：Slice as remaining;
}
```

这对于要处理特定智能合约的某些操作码（如 [Jetton standard](https://github.com/ton-blockchain/TEPs/blob/master/text/0074-jettons-standard.md)）的情况非常有用。 该合约能够处理的操作码简表为[此处以 FunC 表示](https://github.com/ton-blockchain/token-contract/blob/main/ft/op-codes.fc)。 它们是智能合约的接口。

:::note

  更深入的信息请参见：
  [Convert received messages to `op` operations](/zh-cn/book/func#convert-received-messages-to-op-operations)\
  [Internal message body layout in TON Docs](https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#internal-message-body)\
  [Messages of the Jetton implementation in Tact](https://github.com/howardpen9/jetton-implementation-in-tact/blob/9eee917877a92af218002874a9f2bd3f9c619229/sources/messages.tact)\
  [Jetton Standard in Tact on Tact-by-Example](https://tact-by-example.org/07-jetton-standard)

:::

## 业务

### 实例化

创建 [Struct](#structs) 和 [Message](#messages) 实例类似于 [function calls](/zh-cn/book/expressions#static-function-call)，但需要用大括号 `{}{:tact}`（大括号）代替小括号 `(){:tact}`指定参数：

```tact
struct StA {
    field1：Int;
    field2: Int;
}

message MsgB {
    field1：String;
    field2: String;
}

fun example() {
    // Instance of a Struct StA
    StA{
        field1: 42,
        field2: 68 + 1, // trailing comma is allowed
    };

    // Instance of a Message MsgB
    MsgB{
        field1："May the 4th",
        field2: "be with you!", // trailing comma is allowed
    };
}
```

当分配给字段的变量或常量的名称与该字段的名称重合时，Tact 提供了一种方便的语法快捷方式，有时称为字段双关。 有了它，你就不必输入多余的内容：

```tact
struct PopQuiz {
    vogonsCount：Int;
    nicestNumber: Int;
}

fun example() {
    // 让我们引入几个变量
    let vogonsCount：Int = 42;
    let nicestNumber: Int = 68 + 1;

    // 你可以像往常一样实例化 Struct 并将变量赋值给字段，
    // 但这样做有时会有点重复和乏味
    PopQuiz{ vogonsCount: vogonsCount, nicestNumber: nicestNumber };

    // 让我们使用字段双关语并减少键入，
    // 因为我们的变量名恰好与字段名相同
    PopQuiz{
        vogonsCount,
        nicestNumber, // 这里也允许使用尾部逗号！
    };
}
```

:::note

  因为实例化是 Tact 中的一个表达式，所以在相关页面中也有描述：[实例化表达式](/zh-cn/book/expressions#instantiation)。

:::

### 转换为 `Cell`, `.toCell()` {#tocell}

通过使用 `.toCell(){:tact}` [扩展函数](/zh-cn/book/functions#extension-function)，可以将任意 [Struct](#structs) 或 [Message](#messages) 转换为 [`单元格{:tact}`][单元格] 类型：

```tact
struct Big {
    f1: Int;
    f2: Int;
    f3: Int;
    f4：Int;
    f5: Int;
    f6: Int;
}

fun conversionFun() {
    dump(Big{
        f1: 10000000000, f2: 10000000000, f3: 10000000000,
        f4: 10000000000, f5: 10000000000, f6: 10000000000,
    }.toCell()); // x{...cell with references...}
}
```

:::note

  参见参考资料中的扩展函数：
  [`Struct.toCell(){:tact}`](/zh-cn/ref/core-cells#structtocell)/
  [`Message.toCell(){:tact}`](/zh-cn/ref/core-cells#messagetocell)。

:::

### 从 `Cell` 或 `Slice` 获取，`.fromCell()` 和 `.fromSlice()` {#fromcellslice}

无需通过一系列相关的 `.loadSomething(){:tact}` 函数调用来手动解析 [`Cell{:tact}`][cell] 或 [`Slice{:tact}`][slice]，而是可以使用 `.fromCell(){:tact}` 和 `.fromSlice(){:tact}` [扩展函数](/zh-cn/book/functions#extension-function)。这些扩展函数将所提供的 [`Cell{:tact}`][cell] 或 [`Slice{:tact}`][slice] 转换为所需的 [Struct](#structs) 或 [Message](#messages)。

这些扩展函数仅尝试根据 [Struct](#structs) 或 [Message](#messages) 的结构解析 [`Cell{:tact}`][cell] 或 [`Slice{:tact}`][slice]。如果布局不匹配，可能会抛出各种异常——确保用 [`try...catch{:tact}`](/zh-cn/book/statements#try-catch) 块封装代码，以防止意外结果。

```tact
struct Fizz { foo: Int }
message(100) Buzz { bar: Int }

fun constructThenParse() {
    let fizzCell = Fizz{foo: 42}.toCell();
    let buzzCell = Buzz{bar: 27}.toCell();

    let parsedFizz：Fizz = Fizz.fromCell(fizzCell);
    let parsedBuzz: Buzz = Buzz.fromCell(buzzCell);
}
```

:::note

  参见参考资料中的扩展函数：
  [`Struct.fromCell(){:tact}`][st-fc]/
  [`Struct.fromSlice(){:tact}`][st-fs]/
  [`Message.fromCell(){:tact}`][msg-fc]/
  [`Message.fromSlice(){:tact}`][msg-fs]/ 。

:::

### 转换法

只要通过 `.toCell(){:tact}` 和 `.fromCell(){:tact}` 函数在 [`单元格{:tact}`][单元格]/[`切片{:tact}`][切片] 和 [结构体](#structs)/[消息](#messages) 之间进行转换，以下规律就会成立：

- 对于任何 [Struct](#structs)/[Message](#messages)类型的实例，调用`.toCell(){:tact}`，然后对结果应用`Struct.fromCell(){:tact}`（或`Message.fromCell(){:tact}`），就会得到原始实例的副本：

```tact {8-9,13-14}
struct ArbitraryStruct {}
message(0x2A) ArbitraryMessage {}

fun lawOne() {
    let structInst = ArbitraryStruct{};
    let messageInst = ArbitraryMessage{};

    ArbitraryStruct.fromCell(structInst.toCell()); // = structInst
    ArbitraryMessage.fromCell(messageInst.toCell()); // = messageInst.toCell()); // = messageInst

    // 切片也一样，有 .toCell().asSlice() 和 .fromSlice()

    ArbitraryStruct.fromSlice(structInst.toCell().asSlice()); // = structInst
    ArbitraryMessage.fromSlice(messageInst.toCell().asSlice()); // = messageInst
}
```

- 对于任何与给定 [Struct](#structs)/[Message](#messages) 具有相同 [TL-B](https://docs.ton.org/develop/data-formats/tl-b-language) 布局的 [`单元格{:tact}`][单元格]，调用 `Struct.fromCell(){:tact}`（或 `Message.fromCell(){:tact}`），然后通过 `.toCell(){:tact}` 将结果转换为 [`Cell{:tact}`][单元格]，就会得到原始 [`单元格{:tact}`][单元格] 的副本：

```tact {9-10,15-16}
struct ArbitraryStruct { val: Int as uint32 }
message(0x2A) ArbitraryMessage {}

fun lawTwo() {
    // 使用 32 位来存储 42，这样这个 cellInst 就可以
    // 在处理 ArbitraryStruct 和 ArbitraryMessage 时重复使用
    let cellInst = beginCell().storeUint(42, 32).endCell();

    ArbitraryStruct.fromCell(cellInst).toCell(); // = cellInst
    ArbitraryMessage.fromCell(cellInst).toCell(); // = cellInst

    // Slices 也是如此，使用 .fromSlice() 和 .toCell().asSlice()
    let sliceInst = cellInst.asSlice();

    ArbitraryStruct.fromSlice(sliceInst).toCell().asSlice(); // = sliceInst
    ArbitraryMessage.fromSlice(sliceInst).toCell().asSlice(); // = sliceInst
}
```

[st-fc]: /zh-cn/ref/core-cells#structfromcell
[st-fs]: /zh-cn/ref/core-cells#structfromslice
[msg-fc]: /zh-cn/ref/core-cells#messagefromcell
[msg-fs]: /zh-cn/ref/core-cells#messagefromslice
[p]: /zh-cn/book/types#primitive-types
[电池]: /zh-cn/book/cells#cells
[一片]: /zh-cn/book/cells#slices


## types.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/types.mdx)
---
title: 类型系统概述
---

Tact 程序中的每个变量、项目和值都有一个类型。 它们可以是

- [原始类型](#primitive-types) 之一
- 或 [复合类型](#composite-types)

Additionally, many of those types [can be made nullable](#optionals).

## 原始类型 {#primitive-types}

Tact 支持许多专为智能合约定制的原始数据类型：

- `Int{:tact}` — Tact 中的所有数字都是 257 位有符号整数，但可以使用[较小的表示方法](/zh-cn/book/integers#serialization)来减少存储成本。
- `Bool{:tact}` — 经典布尔类型，具有 `true{:tact}` 和 `false{:tact}` 值。
- `Address{:tact}` — TON 区块链中的标准[智能合约地址](https://docs.ton.org/learn/overviews/addresses#address-of-smart-contract)。
- [`Cell{:tact}`](/zh-cn/book/cells#cells)、[`Builder{:tact}`](/zh-cn/book/cells#builders)、[`Slice{:tact}`](/zh-cn/book/cells#slices) — [TVM][tvm] 的底层基元。
- `String{:tact}` — 不可变的文本字符串。
- `StringBuilder{:tact}` — 辅助类型，允许以节省 gas 的方式连接字符串。

[tvm]: https://docs.ton.org/learn/tvm-instructions/tvm-overview

### 布尔 {#booleans}

原始类型 `Bool{:tact}` 是经典的布尔类型，只能容纳两个值：`true{:tact}` 和 `false{:tact}`。它便于布尔和逻辑运算，也便于存储标志。

Tact 中没有隐式类型转换，因此两个布尔值的加法（[`+{:tact}`](/zh-cn/book/operators#binary-add)）是不可能的。这里有许多比较[运算符](/zh-cn/book/operators)，例如：

- `&&{:tact}` 为 [logical AND](/zh-cn/book/operators#binary-logical-and)
- `||{:tact}` 为 [logical OR](/zh-cn/book/operators#binary-logical-or)
- `!{:tact}` 为 [logical inversion](/zh-cn/book/operators#unary-inverse)
- `=={:tact}` 和 `!={:tact}` 用于检查[相等](/zh-cn/book/operators#binary-equality)
- `!{:tact}` 表示[非空断言](/zh-cn/book/optionals)

将 bools 持久化为状态非常节省空间，因为它们只占用 1 位。 每年在州[花费](https://ton.org/docs/develop/smart-contracts/fees#how-to-calculate-fees)存储 1000 个布尔约需 $0.00072$ ton 。

## 复合类型 {#composite-types}

使用单独的存储手段往往会变得繁琐，因此有办法将多个[原始类型](#primitive-types)组合在一起，创建复合类型：

- [Maps](#maps) - 键与值的关联。
- 复合类型，如[结构体和消息](#structs-and-messages)
- [可选项](#optionals) - [结构体和消息](#structs-and-messages)变量或字段的`null{:tact}`值。

除上述复合类型外，Tact 还提供了一种特殊的类型构造函数[`bounced<T>{:tact}`](/zh-cn/book/bounced)，它只能在[弹回消息接收器](/zh-cn/book/bounced)中指定。

请注意，虽然[合约](#contracts)和[特质](#traits)也被视为Tact类型系统的一部分，但我们不能像[结构体和消息](#structs-and-messages)那样传递它们。相反，我们可以使用[`initOf{:tact}`](/zh-cn/book/expressions#initof)表达式来获取给定合约的初始状态。

### 映射 {#maps}

类型`map<k, v>{:tact}`用于将数据与相应的键关联起来。

```tact
let mapExample: map<Int, Int> = emptyMap(); // 带有 Int 键和值的空地图
```

在专门页面了解更多信息：[地图][地图]。

[[Maps](#maps)]: /zh-cn/book/maps

### 结构和信息 {#structs-and-messages}

Possible key types:

[Structs][structs] and [Messages][messages] are two main ways of combining multiple [primitive types](#primitive-types) into a composite one.

Example of a [Struct][structs]:

```tact
struct Point {
    x：Int;
    y：Int;
}
```

Example of a [Message][messages]:

```tact
// Custom numeric id of the Message
message(0x11111111) SetValue {
    key: Int;
    value: Int?; // Optional
    coins: Int as coins; // Serialization into TL-B types
}
```

有关它们的更多信息，请访问专门页面：[结构和信息][s-n-m]。

[s-n-m]: /zh-cn/book/structs-and-messages
[structs]: /zh-cn/book/structs-and-messages#structs
[messages]: /zh-cn/book/structs-and-messages#messages

### 可选项 {#optionals}

所有[原始类型](#primitive-types)以及[结构体和消息](#structs-and-messages)都可以为空，并持有一个特殊的 `null{:tact}`值。

[可选项][可选项]示例：

```tact
let opt: Int? = null; // Int or null, with explicitly assigned null
```

Learn more about them on a dedicated page: [Optionals][optionals].

[选修课]: /zh-cn/book/optionals

### 合同 {#contracts}

Contracts are the main entry of a smart contract on the TON blockchain. It holds all functions, getters, and receivers of a TON contract.

[合同示例](/zh-cn/book/contracts)：

```tact
contract HelloWorld {
    // Persistent state variable
    counter: Int;

    // Constructor function init(), where all the variables are initialized
    init() {
        self.counter = 0;
    }

    // Internal message receiver, which responds to a string message "increment"
    receive("increment") {
        self.counter += 1;
    }

    // Getter function with return type Int
    get fun counter(): Int {
        return self.counter;
    }
}
```

or [Contracts](#contracts) and [Traits](#traits)

### 特质 {#traits}

Tact 不支持经典的类继承，而是引入了**特质**（traits）的概念。它们的结构与[合约](#contracts)相同，但不能[初始化持久状态变量](/zh-cn/book/contracts#init-function)。

特质还可以让继承它的契约重写其[函数](/zh-cn/book/functions#virtual-and-abstract-functions)的行为和[常量](/zh-cn/book/constants#virtual-and-abstract-constants)的值。

来自 [`@stdlib/ownable`](/zh-cn/ref/stdlib-ownable) 的 trait [`Ownable`](/zh-cn/ref/stdlib-ownable#ownable) 示例：

```tact
trait Ownable {
    // Persistent state variable, which cannot be initialized in the trait
    owner: Address;

    // Internal function
    fun requireOwner() {
        nativeThrowUnless(132, context().sender == self.owner);
    }

    // Getter function with return type Address
    get fun owner(): Address {
        return self.owner;
    }
}
```

而 [contract](#contracts) 使用了 trait [`Ownable{:tact}`](/zh-cn/ref/stdlib-ownable#ownable)：

```tact
contract Treasure with Ownable {
    // Persistent state variable, which MUST be defined in the contract
    owner: Address;

    // Constructor function init(), where all the variables are initialized
    init(owner: Address) {
        self.owner = owner;
    }
}
```


## upgrades.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/upgrades.mdx)
---
title: 合同升级
---

Tact 目前不允许合同升级，因为 Tact 合同比 `func` 中的合同更复杂。理论上是可行的，但所需的工具并不在这里。


## from-func.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/cs/from-func.mdx)
---
title: 来自 FunC
description: "从 FunC 快速过渡到 Tact 的小窍门"
sidebar:
  order: 1
---

:::danger[Not implemented]

此页面等待编写 [#54](https://github.com/tact-lang/tact-docs/issues/54)

:::


## from-solidity.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/book/cs/from-solidity.mdx)
---
title: 来自 Solidity
description: "从 Solidity 快速过渡到 Tact 以及从以太坊快速过渡到 TON 区块链的小抄"
sidebar:
  order: 2
---

:::danger[Not implemented]

此页面等待编写 [#67](https://github.com/tact-lang/tact-docs/issues/67)

:::


## access.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/access.mdx)
---
title: 门禁控制
---

本页列出了使用权限、所有权和访问控制的常见示例。

## 如何使用 Ownable 特质检查发件人权限

```tact
// 为了方便起见，必须从 stdlib 导入 Ownable 以及 Deployable：
import "@stdlib/ownable";
import "@stdlib/deploy";

message FooBarMsg {
    newVal: Int as uint32;
}

// Ownable 特性可以限制某些操作只能由所有者执行
Deployable, Ownable 的 SenderChecker 合约 {
    // 持久状态变量
    owner: Address; // Ownable 特性要求你添加这个确切的状态变量
    val: Int as uint32; // 一些值

    init() {
        // 我们可以将所有者初始化为我们想要的任何值，在本例中就是部署者：
        self.owner = sender();
        self.val = 0;
    }

    receive("inc") {
        self.requireOwner(); // throws exit code 132 if the sender isn't an owner
        self.val += 1;
    }

    receive(msg: FooBarMsg) {
        self.requireOwner(); // throws exit code 132 if the sender isn't an owner
        self.val = msg.newVal;
    }
}
```

:::note[Useful links:]

  [核心库中的 `trait Ownable{:tact}`](/zh-cn/ref/stdlib-ownable#ownable)

:::

:::tip[Hey there!]

  没有找到您最喜欢的访问控制范例？ 您有很酷的实施方案吗？ [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## algo.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/algo.mdx)
---
title: 算法
---

算法是严格指令的有限序列，通常用于解决一类特定问题或进行计算。

:::danger[Not implemented]

  本页为残页。 [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## data-structures.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/data-structures.mdx)
---
title: 数据结构
---

数据结构是数据组织、管理和存储格式，通常是为了高效访问数据而选择的。 更确切地说，数据结构是数据值、数据间关系以及可用于数据的函数或操作的集合。

本页列出了一系列在 Tact 中实现的数据结构，方便您满足日常及其他需求。

这里列出的所有数据结构都是使用内置的 [`map<K, V>{:tact}`][map]类型制作的。 有关地图的描述和基本用法，请参阅[本书专页][地图]。

## Array

[数组](https://en.wikipedia.org/wiki/Array_(data_structure)) 是一种数据结构，由连续的内存块组成，代表相同内存大小的元素集合，每个元素至少由一个数组键或_index_标识。

下面的示例使用[结构](/zh-cn/book/structs-and-messages#structs)包装的[`map<Int, V>{:tact}`][map]模拟数组，其中`V{:tact}`可以是 map 的任何[允许值类型](/zh-cn/book/maps#allowed-types)：

```tact
import "@stdlib/deploy"; // for Deployable trait

struct Array {
    m: map<Int as uint16, Int>; // 数组的 Int 值作为 Ints 到 Ints 的映射，
                                // 将其键序列化为 uint16 以节省空间
    length：Int = 0; // 数组的长度，默认为 0
} // 数组的编译时常数上界。

//
const MaxArraySize：Int = 5_000; // 5,000 entries max, to stay reasonable far from limits

// Extension mutation function for adding new entries to the end of the array
extends mutates fun append(self: Array, item: Int) {
    require(self.length + 1 <= MaxArraySize, "数组中没有空间留给新条目了！");

    self.map.set(self.length, item); // 设置条目（键值对）
    self.length += 1; // 增加长度字段
}

// 扩展突变函数，用于在给定索引处插入新条目
extends mutates fun insert(self: Array, item: Int, idx: Int) {
    require(self.length + 1 <= MaxArraySize, "数组中没有空间留给新条目！");
    require(idx >= 0, "Index of the item cannot be negative!");
    require(idx < self.length, "Index is out of array bounds!");

    // Move all items from idx to the right
    let i. Int = self.length; // not not：Int = self.length; // 不是错别字，因为我们需要从不曾存在的地方开始
    while (i > idx) {
        // 注意，我们使用了 !! 操作符，因为我们知道值肯定会在那里
        self.map.set(i, self.map.get(i - 1)!!);
        i -= 1;
    }

    // 并将新条目放入
    self.map.set(idx, item); // 设置条目（键值对）
    self.length += 1; // 增加长度字段
}

// Extension function for getting the value at the given index
extends fun getIdx(self: Array, idx: Int)：Int {
    require(self.length > 0, "No items in the array!");
    require(idx >= 0, "Index of the item cannot be negative!");
    require(idx < self.length, "Index is out of array bounds!");

    // 注意，我们使用 !! 操作符，因为我们知道值肯定会在那里
    return self.map.get(idx)!!;
} // 返回最后一个值的扩展函数。

// 返回最后一个值的扩展函数
extends fun getLast(self: Array)：Int {
    require(self.length > 0, "No items in the array!");

    // 注意，我们使用 !! 运算符是因为我们确定值会在那里
    return self.map.get(self.length - 1)!!;
}

// 扩展突变函数，用于删除给定索引中的条目并返回其值
extends mutates fun deleteIdx(self: Array, idx: Int)：Int {
    require(self.length > 0, "No items in the array to delete!");
    require(idx >= 0, "Index of the item cannot be negative!");
    require(idx < self.length, "Index is out of array bounds!");

    // Remember the value, which is going to be deleted
    let memorized：Int = self.map.get(idx)!!;

    // 将所有从 idx 开始（包括 idx）的项目移到左边
    let i：Int = idx;
    while (i + 1 < self.length) {
        // 注意，我们使用了！！操作符，因为我们知道该值肯定会存在
        self.map.set(i, self.map.get(i + 1)!!);
        i += 1;
    }

    self.map.set(self.length - 1, null); // 删除最后一个条目
    self.length -= 1; // 减少长度字段

    return memorized;
}

// 用于删除最后一个条目并返回其值的扩展突变函数
extends fun deleteLast(self: Array)：Int {
    require(self.length > 0, "No items in the array!");

    // 注意，我们使用了！！操作符，因为我们知道值肯定会存在
    let lastItem: Int = self.map.get(self.length - 1)!!;
    self.map.set(self.length - 1, null); // 删除条目
    self.length -= 1; // 减少长度字段

    return lastItem;
} // 删除数组中最后一个条目的扩展函数。

// 用于删除数组中所有项的扩展函数
extends mutates fun deleteAll(self: Array) {
    self.map = emptyMap();
    self.length = 0;
}

// 用于创建空数组的全局静态函数
fun emptyArray()：Array {
    return Array{m: emptyMap(), length: 0}; // length 默认为 0
}

// 契约，使用 map 仿真数组
contract MapAsArray with Deployable {
    // 持久状态变量
    array：Array;

    // 合约的构造函数（初始化）函数
    init() {
        self.array = emptyArray();
    }

    // 内部消息接收器，响应字符串消息 "append"
    receive("append") {
        // 添加一个新项目
        self.array.append(42);
    }

    // 内部消息接收器，响应字符串消息 "delete_5h"
    receive("delete_5th") {
        // 删除第 5 个项目（如果存在），并回复其值，否则引发错误
        self.reply(self.array.deleteIdx(4).toCoinsString().asComment()); // 索引偏移 0 + 4 给出第 5 个项目
    }

    // 内部消息接收器，对字符串消息 "del_last "做出响应
    receive("del_last") {
        // 删除最后一项，并回复其值，否则引发错误
        self.reply(self.array.deleteLast().toCoinsString().asComment());
    }

    // 内部消息接收器，用于响应字符串消息 "get_last"
    receive("get_last") {
        // 如果数组中存在最新项目，则回复该项目，否则引发错误
        self.reply(self.array.getLast().toCoinsString().asComment());
    }

    // 内部消息接收器，用于响应字符串消息 "delete_all"
    receive("delete_all") {
        self.array.deleteAll();
    }
}
```

## Stack

[堆栈](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) 是一种由元素集合组成的数据结构，主要有两种操作：

- 推送，将一个元素添加到集合的末尾
- 弹出，移除最近添加的元素

下面的示例使用[结构](/zh-cn/book/structs-and-messages#structs)包装的[`map<Int, V>{:tact}`][map]模拟堆栈，其中 `V{:tact}`可以是 map 的任何[允许值类型](/zh-cn/book/maps#allowed-types)：

```tact
import "@stdlib/deploy"; // for Deployable trait

struct Stack {
    m: map<Int as uint16, Int>; // 堆栈中的 Int 值是 Ints 到 Ints 的映射，
                                // 将其键序列化为 uint16 以节省空间
    length：Int = 0; // 堆栈的长度，默认为 0
} // 编译时常数上限值。

//
const MaxStackSize：Int = 5_000; // 最大 5,000 个条目，以合理地远离限制

// 扩展突变函数，用于向堆栈末尾添加新条目
extends mutates fun push(self: Stack, item: Int) {
    require(self.length + 1 <= MaxStackSize, "No space left in the stack for new items!");

    self.map.set(self.length, item); // set the entry (key-value pair)
    self.length += 1; // increase the length field
} // Extension mutation function for deleted the item.

// 用于删除最后一个条目并返回其值的扩展突变函数
extends mutates fun pop(self: Stack)：Int {
    require(self.length > 0, "No items in the stack to delete!");

    // 注意，我们使用了！！操作符，因为我们知道值肯定在那里
    let lastItem: Int = self.map.get(self.length - 1)!!;
    self.map.set(self.length - 1, null); // 删除条目
    self.length -= 1; // 减少长度字段

    return lastItem;
}

// 返回最后一个值的扩展函数
extends fun peek(self: Stack)：Int {
    require(self.length > 0, "No items in the stack!");

    // 注意，我们使用 !! 运算符是因为我们知道值肯定会在那里
    return self.map.get(self.length - 1)!!;
}

// 用于删除堆栈中所有项目的扩展函数
extends mutates fun deleteAll(self: Stack) {
    self.map = emptyMap();
    self.length = 0;
}

// 用于创建空 Stack 的全局静态函数
fun emptyStack()：Stack {
    return Stack{m: emptyMap(), length: 0}; // length 默认为 0
}

contract MapAsStack with Deployable {
    // Persistent state variables
    stack：Stack; // 我们的栈，它使用 map

    // 合约的构造函数（初始化）函数
    init() {
        self.stack = emptyStack();
    }

    // 内部消息接收器，响应字符串消息 "push"
    receive("push") {
        // 添加一个新项目
        self.stack.push(42);
    }

    // 内部信息接收器，响应字符串信息 "pop"
    receive("pop") {
        // 删除最后一个项目并回复
        self.reply(self.stack.pop().toCoinsString().asComment());
    }

    // 内部消息接收器，对字符串消息 "peek "做出响应
    receive("peek") {
        // 如果地图中存在最新条目，则回复该条目，否则引发错误
        self.reply(self.stack.peek().toCoinsString().asComment());
    }

    // 内部消息接收器，响应字符串消息 "delete_all"
    receive("delete_all") {
        self.stack.deleteAll();
    }

    // 获取堆栈的获取函数
    get fun map(): map<Int, Int> {
        return self.stack.map;
    }

    // 获取堆栈当前长度的 Getter 函数
    get fun length()：Int {
        return self.stack.length;
    }
}
```

## Circular buffer

[循环缓冲区](https://en.wikipedia.org/wiki/Circular_buffer)（循环队列、循环缓冲区或环形缓冲区）是一种数据结构，它使用单个固定大小的[缓冲区](https://en.wikipedia.org/wiki/Data_buffer)，就像端对端连接一样。

下面的示例使用包裹在 [Struct](/zh-cn/book/structs-and-messages#structs) 中的 [`map<Int, V>{:tact}`][map]模拟循环缓冲区，其中 `V{:tact}` 可以是 map 的任何 [允许值类型](/zh-cn/book/maps#allowed-types)：

```tact
import "@stdlib/deploy"; // for Deployable trait

struct CircularBuffer {
    m: map<Int as uint8, Int>; // Int 值的循环缓冲区作为 Ints 到 Ints 的映射，
                               // 将其键序列化为 uint8 以节省空间
    length：Int = 0; // 循环缓冲区的长度，默认为 0
    start：Int = 0; // 循环缓冲区的当前索引，默认为 0
}

//
const MaxCircularBufferSize：Int = 5;

// 扩展突变函数，用于将新项目放入循环缓冲区
extends mutates fun put(self: CircularBuffer, item: Int) {
    if (self.length < MaxCircularBufferSize) {
        self.map.set(self.length, item); // 存储项目
        self.map.set(self.length, item); // 将新项目放入循环缓冲区。length += 1; // 增加长度字段
    } else {
        self.map.set(self.start, item); // 存储项目，覆盖前一个条目
        self.start = (self.start + 1) % MaxCircularBufferSize; // 更新起始位置
    }
}

// 从循环缓冲区获取项目的扩展突变函数
extends mutates fun getIdx(self: CircularBuffer, idx: Int)：Int {
    require(self.length > 0, "No items in the circular buffer!");
    require(idx >= 0, "Index of the item cannot be negative!");

    if (self.length < MaxCircularBufferSize) {
        // 注意，我们使用了！！运算符，因为我们知道值肯定会在那里
        return self.map.get(idx % self.length)!!;
    } // 返回围绕圆形缓冲区旋转的值。

    // 返回围绕圆形缓冲区旋转的值，也保证在那里
    return self.map.get((self.start + idx) % MaxCircularBufferSize)!!;
}

// 用于遍历循环缓冲区中的所有项目并将其转储到控制台的扩展函数
extends fun printAll(self: CircularBuffer) {
    let i. Int = self.start; repeat i. Int = self.start; repeat i. Int = self.start; repeat i. Int = self.start：Int = self.start;
    repeat (self.length) {
        dump(self.map.get(i)!!); // !! tells the compiler this can't be null
        i = (i + 1) % MaxCircularBufferSize;
    }
}

// 用于删除 CircularBuffer 中所有项的扩展函数
extends mutates fun deleteAll(self: CircularBuffer) {
    self.map = emptyMap();
    self.length = 0;
    self.start = 0;
}

// 用于创建空 CircularBuffer 的全局静态函数
fun emptyCircularBuffer()：CircularBuffer {
    return CircularBuffer{m: emptyMap(), length: 0, start：0}; // length 和 start 默认为 0
}

// 此合约记录了接收到 "timer "消息的最后 5 个时间戳
合约 MapAsCircularBuffer with Deployable {
    // 持久状态变量
    cBuf: CircularBuffer; // 我们的循环缓冲区，使用 map

    // 合约的构造函数（初始化）
    init() {
        self.cBuf = emptyCircularBuffer();
    } // 内部消息接收器。

    // 内部消息接收器，用于响应字符串消息 "timer"
    // 并记录接收到该消息时的时间戳
    receive("timer") {
        let timestamp：Int = now();
        self.cBuf.put(timestamp);
    }

    // 内部消息接收器，响应字符串消息 "get_first"
    // 并以循环缓冲区的第一个项目作为回复
    receive("get_first") {
        self.reply(self.cBuf.getIdx(0).toCoinsString().asComment());
    }

    // 内部消息接收器，对字符串消息 "print_all "做出响应
    receive("print_all") {
        self.cBuf.printAll();
    }

    // 响应字符串消息 "delete_all "的内部消息接收器
    receive("delete_all") {
        self.cBuf.deleteAll();
    }
}
```

:::note

  本例改编自[Tact-By-Example 中的 Arrays 页面](https://tact-by-example.org/04-arrays)。

:::

:::tip[Hey there!]

  没有找到您最喜欢的使用数据结构的示例？ 您有很酷的实施方案吗？ [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::

[地图]: /zh-cn/book/maps


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/index.mdx)
---
title: 食谱概览
---

import { LinkCard, Card, CardGrid, Steps } from '@astrojs/starlight/components';

制作 Tact Cookbook 的主要目的是将 Tact 开发人员的所有经验汇集到一个地方，以便未来的开发人员可以使用。 这部分文档更侧重于每个 Tact 开发人员在开发智能合约过程中需要解决的日常任务。

将其作为在 TON 区块链上制作令人愉悦的智能合约的食谱，而无需在此过程中重新发明轮子。

<Steps>

1. #### 单一合同 {#single-contract}

   以下页面以单个合同实例为重点，涵盖了广泛的主题：

   <CardGrid>
    <LinkCard
      title=" 1️⃣ Single-contract communication"
      href="/cookbook/single-communication"
    />
    <LinkCard
      title="⚙️ Type conversion"
      href="/cookbook/type-conversion"
    />
    <LinkCard
      title="📦 Data structures"
      href="/cookbook/data-structures"
    />
    <LinkCard
      title="🤖算法"
      href="/cookbook/algo"
    />
    <LinkCard
      title="📆时间和日期"
      href="/cookbook/time"
    />
    <LinkCard
      title="⚠️访问控制"
      href="/cookbook/access"
    />
    <LinkCard
      title="✨ 随机性"
      href="/cookbook/random"
    />
    <LinkCard
      title="🤔 杂项"
      href="/cookbook/misc"
    />
   </CardGrid>

2. #### 多重合同 {#multiple-contracts}

   下文将重点介绍多合约示例，探讨 TON 区块链的可扩展性：

   <CardGrid>
     <LinkCard
       title="🧮多合约通信"
       href="/cookbook/multi-communication"
     />
     <LinkCard
       title="💎 Fungible Tokens (Jettons)"
       href="/cookbook/jettons"
     />
     <LinkCard
       title="🖼️ Non-Fungible Tokens (NFTs)"
       href="/cookbook/nfts"
     />
   </CardGrid>

   此外，还有与流行的 TON DEX（去中心化交易所）合作的例子，这些交易所通常需要许多合约和复杂的逻辑：

   <CardGrid>
     <LinkCard
       title="DeDust.io"
       href="/cookbook/dexes/dedust"
     />
     <LinkCard
       title="STON.fi"
       href="/cookbook/dexes/stonfi"
     />
   </CardGrid>

</Steps>


## jettons.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/jettons.mdx)
---
title: 可变型代币（Jettons）
---

本页列出了使用 [jettons](https://docs.ton.org/develop/dapps/asset-processing/jettons)的常见示例。

## 接受 jetton 转移

转账通知信息的结构如下

```tact
message(0x7362d09c) JettonTransferNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    sender: Address;
    forwardPayload: Slice as remaining;
}
```

使用 [receiver](/zh-cn/book/receive) 功能接受令牌通知信息。

:::caution

  必须验证转账通知的发送方！

:::

可使用 jetton 钱包状态初始值和计算 jetton 地址进行验证。
请注意，通知来自您的合约的 jetton 钱包，因此所有者地址栏应使用 [`myAddress()`](/zh-cn/ref/core-common#myaddress)。
钱包的初始数据布局如下所示，但有时会有所不同。
请注意，"myJettonWalletAddress "也可以存储在合约存储中，以便在每次交易中减少 gas 使用量。

```tact
struct JettonWalletData {
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
    jettonWalletCode: Cell;
}

fun calculateJettonWalletAddress(ownerAddress: Address, jettonMasterAddress: Address, jettonWalletCode: Cell): Address {
    let initData = JettonWalletData{
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
        jettonWalletCode,
    };

    return contractAddress(StateInit{code: jettonWalletCode, data: initData.toCell()});
}

contract Sample {
    jettonWalletCode: Cell;
    jettonMasterAddress: Address;

    init(jettonWalletCode: Cell, jettonMasterAddress: Address) {
        self.jettonWalletCode = jettonWalletCode;
        self.jettonMasterAddress = jettonMasterAddress;
    }

    receive(msg: JettonTransferNotification) {
        let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
        require(sender() == myJettonWalletAddress, "Notification not from your jetton wallet!");

        // your logic of processing token notification
    }
}
```

## 发送 jetton 转送

要发送 jetton 传输，请使用 [`send(){:tact}`](/zh-cn/book/send)函数。
请注意，"myJettonWalletAddress" 也可以存储在合约存储中，以便在每次交易中减少 gas 使用量。

```tact
message(0xf8a7ea5) JettonTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    responseDestination: Address?;
    customPayload: Cell? = null;
    forwardTonAmount: Int as coins;
    forwardPayload: Slice as remaining;
}

receive("send") {
    let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
    send(SendParameters{
        to: myJettonWalletAddress,
        value: ton("0.05"),
        body: JettonTransfer{
            queryId: 42,
            amount: jettonAmount, // jetton amount you want to transfer
            destination: msg.userAddress, // address you want to transfer jettons. Note that this is address of jetton wallet owner, not jetton wallet itself
            responseDestination: msg.userAddress, //  address where to send a response with confirmation of a successful transfer and the rest of the incoming message Toncoins
            customPayload: null, // in most cases will be null and can be omitted. Needed for custom logic on Jetton Wallets itself
            forwardTonAmount: 1, // amount that will be transferred with JettonTransferNotification. Needed for custom logic execution like in example below. If the amount is 0 notification won't be sent
            forwardPayload: rawSlice("F") // precomputed beginCell().storeUint(0xF, 4).endCell().beginParse(). This works for simple transfer, if needed any struct can be used as `forwardPayload`
        }.toCell(),
    });
}
```

## 销毁 jetton

```tact
message(0x595f07bc) JettonBurn {
    queryId: Int as uint64;
    amount: Int as coins;
    responseDestination: Address?;
    customPayload: Cell? = null;
}

receive("burn") {
    let myJettonWalletAddress = calculateJettonWalletAddress(myAddress(), self.jettonMasterAddress, self.jettonWalletCode);
    send(SendParameters{
        to: myJettonWalletAddress,
        body: JettonBurn{
            queryId: 42,
            amount: jettonAmount, // jetton amount you want to burn
            responseDestination: someAddress, // address where to send a response with confirmation of a successful burn and the rest of the incoming message coins
            customPayload: null, // in most cases will be null and can be omitted. Needed for custom logic on jettons itself
        }.toCell(),
    });
}
```

## USDT jetton 业务

除了 `JettonWalletData` 将采用以下结构外，USDT（在 TON 上）的操作保持不变：

```tact
struct JettonWalletData {
    status: Ins as uint4;
    balance: Int as coins;
    ownerAddress: Address;
    jettonMasterAddress: Address;
}
```

计算钱包地址的函数如下所示：

```tact
fun calculateJettonWalletAddress(ownerAddress: Address, jettonMasterAddress: Address, jettonWalletCode: Cell): Address {
    let initData = JettonWalletData{
        status: 0,
        balance: 0,
        ownerAddress,
        jettonMasterAddress,
    };

    return contractAddress(StateInit{code: jettonWalletCode, data: initData.toCell()});
}
```

:::tip[Hey there!]

  没有找到您最喜欢的 jetton 使用范例？ 您有很酷的实施方案吗？ [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## misc.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/misc.mdx)
---
title: 杂项
---

各种利基范例，这些范例还没有专门的页面，但非常有用和有趣。

## 如何抛出错误

当我们不知道要多久执行一次特定操作时，合约中的 `throw(){:tact}` 函数就非常有用。

它允许有意的异常或错误处理，从而导致当前事务的终止，并恢复该事务中的任何状态更改。

```tact
let number: Int = 198;

// 无论如何都会触发错误
throw(36);

// 只有当数字大于 50 时才会触发错误
nativeThrowIf(35, number > 50);

// 只有当数字不等于 198 时才会触发错误
nativeThrowUnless(39, number == 198)；
```

:::note[Useful links:]

  [核心库中的 `throw(){:tact}`](/zh-cn/ref/core-debug#throw)/
  [Tact-By-Example中的错误](https://tact-by-example.org/03-errors)

:::

:::tip[Hey there!]

  没有找到您最喜欢的利基工作范例？ 您有很酷的实施方案吗？ [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## multi-communication.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/multi-communication.mdx)
---
title: 多合同通信
---

:::danger[Not 已实施]

  本页为残页。 [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## nfts.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/nfts.mdx)
---
title: 不可封代币（NFT）
---

:::danger[Not 已实施]

  本页为残页。 [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## random.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/random.mdx)
---
title: 随机性
---

本页列出了使用随机数、不确定性和随机性的示例。

## 如何生成随机数

```tact
// 声明一个变量来存储随机数
let number: Int;

// 生成一个新的随机数，它是一个无符号的 256 位整数
number = randomInt();

// 生成一个介于 1 和 12 之间的随机数
number = random(1, 12)；
```

:::note[Useful links:]

  [`randomInt(){:tact}` in Core library](/zh-cn/ref/core-random#randomint)\
  [`random(){:tact}` in Core library](/zh-cn/ref/core-random#random)

:::

:::tip[Hey there!]

  没有找到你最喜欢的使用随机性的例子？ 您有很酷的实施方案吗？ [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## single-communication.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/single-communication.mdx)
---
title: 单项合同通信
---

本页列出了单个已部署合约与区块链上其他合约进行通信的示例。

有关多个已部署合同之间的通信示例，请参阅：[多合约通信](/zh-cn/cookbook/multi-communication)。

## 如何进行基本回复 {#how-to-make-a-basic-reply}

```tact
receive() {
    self.reply("Hello, World!".asComment()); // asComment 将字符串转换为带注释的单元格
}
```

## 如何发送简单信息

```tact
send(SendParameters{
    bounce: true, // default
    to: destinationAddress,
    value: ton("0.01"), // attached amount of Tons to send
    body："Hello from Tact!".asComment(), // comment (optional)
})；
```

## 如何发送包含全部余额的信息

如果我们需要发送智能合约的全部余额，则应使用 `SendRemainingBalance{:tact}` 发送模式。 或者，我们也可以使用 `mode：128{:tact}`，其含义相同。

```tact
send(SendParameters{
    // bounce = true by default
    to: sender(), // send the message back to the original sender
    value: 0,
    mode：SendRemainingBalance, // or mode：128
    body："Hello from Tact!".asComment(), // comment (optional)
})；
```

## 如何发送带有余值的信息

如果我们要向同一发件人发送回复，可以使用 `SendRemainingValue{:tact}`模式（即 `mode: 64{:tact}`），除了新信息中最初显示的值外，它还会携带入站信息的所有剩余值。

```tact
send(SendParameters{
    // bounce = true by default
    to: sender(), // send the message back to the original sender
    value: 0,
    mode：SendRemainingValue,
    body："Hello from Tact!".asComment(), // comment (optional)
})；
```

通常还需要添加 `SendIgnoreErrors{:tact}`标记，以便忽略在操作阶段处理该消息时出现的任何错误L

```tact
send(SendParameters{
    // bounce = true by default
    to: sender(), // send the message back to the original sender
    value: 0,
    mode：SendRemainingValue | SendIgnoreErrors, // 更喜欢使用 | 而不是 + 来表示模式
    body："Hello from Tact!".asComment(), // comment (optional)
})；
```

后一个示例与使用 [`.reply(){:tact}` 函数](#how-to-make-a-basic-reply)相同。

## 如何发送带有长文本注释的信息

如果我们需要发送一条带有冗长文本注释的信息，我们应该创建一个 [`String{:tact}`](/zh-cn/book/types#primitive-types)，由超过 $127$ 个字符组成。 为此，我们可以利用 [`StringBuilder{:tact}`](/zh-cn/book/types#primitive-types)原始类型及其名为 `beginComment(){:tact}` 和 `append(){:tact}` 的方法。 在发送之前，我们应该使用 `toCell(){:tact}` 方法将字符串转换为单元格。

```tact
let comment: StringBuilder = beginComment();
let longString = "..."; // Some string with more than 127 characters.
comment.append(longString);

send(SendParameters{
    // bounce = true by default
    to: sender(),
    value: 0,
    mode: SendIgnoreErrors,
    body: comment.toCell(),
});
```

:::note[Useful links:]

  ["Sending messages" in the Book](/zh-cn/book/send#send-message)\
  ["Message `mode`" in the Book](/zh-cn/book/message-mode)
  [`StringBuilder{:tact}` in the Book](/zh-cn/book/types#primitive-types)
  [`Cell{:tact}` in Core library](/zh-cn/ref/core-cells)

:::

:::tip[Hey there!]

  没有找到您最喜欢的单一合同通信案例？ 您有很酷的实施方案吗？ [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## time.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/time.mdx)
---
title: 时间和日期
---

## 如何获取当前时间

使用 `now(){:tact}` 方法获取当前标准[Unix 时间](https://en.wikipedia.org/wiki/Unix_time)。

如果需要在状态中存储时间或在信息中编码时间，请使用下面的 [serialization](/zh-cn/book/integers#serialization)：`Int as uint32{:tact}`。

```tact
let currentTime: Int = now();

if (currentTime > 1672080143) {
    // do something
}
```

:::note[Useful links:]

  [核心库中的 `now(){:tact}`](/zh-cn/ref/core-common#now)/
  [Tact-By-Example中的 "当前时间"](https://tact-by-example.org/04-current-time)

:::

:::tip[Hey there!]

  没有找到您最喜欢的使用时间和日期的例子？ 您有很酷的实施方案吗？ [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::


## type-conversion.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/type-conversion.mdx)
---
title: 类型转换
---

本页展示了在[原始类型][p]之间进行转换以及从[复合类型](/zh-cn/book/types#composite-types)中获取这些类型的示例。

## `Int` ↔ `String` {#int-string}

### 如何将 "字符串 "转换为 "整数 {#how-to-convert-a-string-to-an-int}

```tact
// 为 String 类型定义一个新的扩展函数，返回 Int 类型的值
// 注意：当 String 包含非数字字符时，会产生意想不到的结果！
extends fun toInt(self: String)：Int {
    // 将 String 转换为 Slice 用于解析
    let string：Slice = self.asSlice();

    // 一个用于存储累积数字的变量
    let acc: Int = 0;

    // 循环直到 String 为空
    while (!string.empty()) {
        let char：Int = string.loadUint(8); // 从 Slice 中加载 8 位（1 个字节）
        acc = (acc * 10) + (char - 48); // 使用 ASCII 表获取数值
        // 注意，当起始字符串包含非数字字符时，这种方法会产生意想不到的结果
        // 如果起始字符串包含非数字字符时，这种方法会产生意想不到的结果！
    }

    // 产生结果数字
    return acc;
}

fun runMe() {
    let string：String = "26052021";
    dump(string.toInt());
}
```

### 如何将 `Int` 转换为 `String` 字符

```tact
let number: Int = 261119911;

// 将 [number] 转换为字符串
let numberString：String = number.toString();

// 将 [number] 转换为浮点字符串,
// 其中传递的参数 3 是结果浮点字符串的指数 10^(-3),
// 它可以是 0 到 76 之间的任何整数，包括两端
let floatString：String = number.toFloatString(3);

// 将作为硬币的[数字]转换为人类可读的字符串
let coinsString：String = number.toCoinsString();

dump(numberString); // "261119911"
dump(floatString); // "261119.911"
dump(coinsString); // "0.261119911"
```

:::note[Useful links:]

  [`Int.toString(){:tact}` 在核心库中](/zh-cn/ref/core-strings#inttostring)/
  [`Int.toFloatString(){:tact}` 在核心库中](/zh-cn/ref/core-strings#inttofloatstring)/
  [`Int.toCoinsString(){:tact}` 在核心库中](/zh-cn/ref/core-strings#inttocoinsstring)

:::

## `Struct` 或 `Message` ↔ `Cell` 或 `Slice` {#structmessage-cellslice}

### 如何将任意 "结构 "或 "消息 "转换为 "单元 "或 "片"？

```tact {19-20, 22-23}
struct Profit {
    big：String?;
    dict: map<Int, Int as uint64>;
    energy: Int;
}

message(0x45) Nice {
    maybeStr：String?;
}

fun convert() {
    let st = Profit{
        big: null,
        dict: null,
        energy: 42,
    };
    let msg = Nice{ maybeStr："今天的消息！"};

    st.toCell();
    msg.toCell();

    st.toCell().asSlice();
    msg.toCell().asSlice();
}
```

:::note[Useful links:]

  [`Struct.toCell(){:tact}` 在核心库中](/zh-cn/ref/core-cells#structtocell)/
  [`Message.toCell(){:tact}` 在核心库中](/zh-cn/ref/core-cells#messagetocell)

:::

### 如何将 "单元格 "或 "切片 "转换为任意的 "结构 "或 "消息"？

```tact {19-20, 22-23}
struct Profit {
    big：String?;
    dict: map<Int, Int as uint64>;
    energy: Int;
}

message(0x45) Nice {
    maybeStr：String?;
}

fun convert() {
    let stCell = Profit{
        big: null,
        dict: null,
        energy: 42,
    }.toCell();
    let msgCell = Nice{ maybeStr："今日消息！"}.toCell();

    Profit.fromCell(stCell);
    Nice.fromCell(msgCell);

    Profit.fromSlice(stCell.asSlice());
    Nice.fromSlice(msgCell.asSlice());
}
```

:::note[Useful links:]

  [`Struct.fromCell(){:tact}` in Core library](/zh-cn/ref/core-cells#structfromcell)\
  [`Struct.fromSlice(){:tact}` in Core library](/zh-cn/ref/core-cells#structfromslice)\
  [`Message.fromCell(){:tact}` 在核心库中](/zh-cn/ref/core-cells#messagefromcell)/
  [`Message.fromSlice(){:tact}` 在核心库中](/zh-cn/ref/core-cells#messagefromslice)

:::

:::tip[Hey there!]

  没有找到您最喜欢的类型转换示例？ 您有很酷的实施方案吗？ [欢迎投稿！](https://github.com/tact-lang/tact/issues)

:::

[p]: /zh-cn/book/types#primitive-types


## dedust.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/dexes/dedust.mdx)
---
title: DeDust.io
sidebar:
  order: 1
---

[DeDust](https://dedust.io)是基于[TON Blockchain](https://ton.org)和[DeDust Protocol 2.0](https://docs.dedust.io/reference/tlb-schemes)的去中心化交易所（DEX）和自动做市商（AMM）。 DeDust 的设计非常注重用户体验（UX）、 gas 效率和可扩展性。

:::danger[Not implemented]

  在 [#146](https://github.com/tact-lang/tact-docs/issues/146) 获得新内容之前，本页只是一个存根。

:::


## stonfi.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/cookbook/dexes/stonfi.mdx)
---
title: STON.fi
sidebar:
  order: 2
---

[STON.fi](https://ston.fi)是一个建立在[TON 区块链](https://ton.org)上的去中心化自动做市商（AMM），提供几乎零费用、低滑点、极其简单的界面以及与 TON 钱包的直接集成。

:::danger[Not implemented]

  在 [#149](https://github.com/tact-lang/tact-docs/issues/149) 获得新内容之前，本页只是一个存根。

:::


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ecosystem/index.mdx)
---
title: 生态系统概述
---

import { CardGrid, LinkCard, Steps } from '@astrojs/starlight/components';

欢迎来到**生态系统**版块--鸟瞰 Tact 生态系统、工具以及您可以开始为之做出贡献的方法！

以下是其主要内容：

<Steps>

1. #### 工具

   工具是官方和社区专门为 Tact 制作的工具列表，或与 Tact 语言和其他工具配合使用的工具列表。 每个工具都有简短的使用细节和附加信息，这些信息有时在相关文档中缺失，或者只是战术文档中的方便摘要。

   <CardGrid>
    <LinkCard
      title="TypeScript"
      href="/ecosystem/typescript"
    />
    <LinkCard
      title="VS Code Extension"
      href="/ecosystem/vscode"
    />
    <LinkCard
      title="JetBrains IDEs Plugin"
      href="/ecosystem/jetbrains"
    />
    <LinkCard
      title="Misti Static Analyzer"
      href="/ecosystem/misti"
    />
   </CardGrid>

</Steps>


## jetbrains.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ecosystem/jetbrains.mdx)
---
title: TON Development Plugin for JetBrains IDEs
---

支持在 **2023.** 及更高版本的 JetBrains 集成开发环境中突出显示 Tact 的语法。请注意，除支持 Tact 外，该插件还支持 TON 区块链的 FunC 和 Fift 语言以及 TL-B 架构。

JetBrains Marketplace 上的插件： [TON 开发插件](https://plugins.jetbrains.com/plugin/23382-ton)

## 安装手册

1. 打开 JetBrains IDE（IntelliJ IDEA、PyCharm、WebStorm 等）。
2. 选择 "文件">"设置/首选项">"插件"，导航至 "**插件市场**"。
3. 在插件市场的搜索栏中输入 "TON Development"。 You will see a dropdown with the extension provided by `ton-blockchain`.
4. 点击插件名称旁边的**安装**按钮。 等待安装完成。
5. 插件安装完成后，系统会提示您重新启动 JetBrains IDE。 单击 ** 重新启动** 按钮应用更改。
6. 重新启动后，TON 开发插件应已成功安装到 JetBrains IDE 中。

## 故障排除

如果在安装过程中遇到问题，请查阅 [插件的 GitHub 代码库](https://github.com/ton-blockchain/intellij-ton) 以获取解决方案和更多信息。

## 参考资料和资源

- [TON Development on GitHub](https://github.com/ton-blockchain/intellij-ton)
- [TON Development Plugin on JetBrains Marketplace](https://plugins.jetbrains.com/plugin/18541-ton)


## misti.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ecosystem/misti.mdx)
---
title: Misti 静态分析仪
---

[Misti](https://nowarp.github.io/tools/misti/)是一款支持 Tact 的静态程序分析工具。

## 米斯蒂是什么？

- **静态程序分析**：Misti 在不执行代码的情况下对代码进行分析，通过检查结构和语法来扫描[漏洞和安全缺陷](https://nowarp.github.io/tools/misti/docs/detectors)。 这种方法可以及早发现问题，防止问题影响生产。

- **自定义探测器**：创建 [自定义探测器](https://nowarp.github.io/tools/misti/docs/hacking/custom-detector)，根据您的特定需求定制 Misti。 这有助于识别通用工具可能会遗漏的漏洞，确保对代码进行彻底审查。

- **CI/CD 集成**：[集成](https://nowarp.github.io/tools/misti/docs/tutorial/ci-cd) Misti 到您的 CI/CD 管道中，以确保持续的代码质量检查，在问题进入生产之前将其捕获。

## 资源

- [Github](https://github.com/nowarp/misti)
- [电报社区](https://t.me/misti_dev)
- [Misti文档](https://nowarp.github.io/docs/misti/)
- [Misti应用程序接口参考](https://nowarp.github.io/docs/misti/api)


## typescript.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ecosystem/typescript.mdx)
---
title: Typescript 库
---

Tact 语言内置了对 `ton` 和 `ton-core` 类型脚本库的支持。编译器会自动为这些库生成代码，您可以使用 [@tact-lang/emulator](https://github.com/tact-lang/tact-emulator), [@ton-community/sandbox](https://github.com/ton-community/sandbox) 等库。

## Typescript 中的契约

编译器会为项目中的每个合约生成名为 `{project}_{contract}.ts` 的文件，其中包含随时可用的强类型封装器，以便在任何环境下使用合约：测试、部署等。

## vscode.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ecosystem/vscode.mdx)
---
title: VS Code Extension
---

在 Visual Studio 代码中为 Tact 语言提供广泛支持：

- 语法高亮
- 高亮显示错误
- 片段
- 悬停信息
- 所有变量、函数、全局参数和 Tact 独特类型的代码自动完成
- 对当前文件中的所有合约/库以及所有引用的导入进行代码补全
- 格式化

VS Code Marketplace 上的扩展： [支持 TON 区块链的 Tact 语言](https://marketplace.visualstudio.com/items?itemName=KonVik.tact-lang-vscode)

## 安装手册

1. Open Visual Studio Code.

2. 单击窗口侧面活动栏中的 "扩展 "图标，导航至 "扩展 "视图。 它看起来就像一个正方形中的正方形。

3. In the Extensions view input box, type "TACT Language". You should see a dropdown with the extension "TACT Language" provided by KonVik. Probably, you would see the same extension provided by TON Community but this one is deprecated and we should use KonVik’s instead

4. 点击扩展名称旁边的安装按钮。 等待安装完成。

5. 安装扩展后，您可能需要重新加载 VS Code。 如有必要，扩展名旁边会有一个重新加载按钮。 如果出现该按钮，请单击该按钮。

6. 现在，Tact 语言扩展应该已安装到您的 VS 代码中。

## 启用 "保存时格式化" {#format-on-save}

本指南将说明如何在 VS 代码中使用 “命令调板 ”和编辑 JSON 设置文件为 Tact 语言扩展启用 “保存时格式 ”功能。

1. 在命令调板中输入 "首选项：在命令调板中输入 "首选项：打开设置 (JSON)"。 这将打开你的 `settings.json` 文件。

2. 编辑 JSON 设置

   - 您将看到一个 JSON 对象。 We're going to add some properties to this object to enable format on save for the TACT Language extension.

   - 在 JSON 对象中添加以下几行：

     ```json
     {
     	"[tact]"：{
     		"editor.formatOnSave": true,
     		"editor.defaultFormatter"："KonVik.tact-lang-vscode"
     	}
     }
     ```

   - 这将启用保存时的格式化（`“editor.formatOnSave”: true`），并将 Tact 文件的默认格式化（`“[tact]”: {“editor.defaultFormatter”: “KonVik.tact-lang-vscode”}` ）设置为 Tact 语言扩展名。

3. 保存和关闭设置
   - 添加完这些行后，保存您的 `settings.json` 文件（可按 `Ctrl+S` 保存）。
   - 关闭 `settings.json` 选项卡或按 `Ctrl+W`。

现在，当您保存文件时，您的 Tact Language VS Code 扩展程序会自动格式化您的文件。如果您没有看到这些更改立即生效，您可能需要重新加载 VS Code。

## 参考资料和资源

- Enabling Format on Save for the TACT Language Extension
- [TACT Language VS Code Extension](https://marketplace.visualstudio.com/items?itemName=KonVik.tact-lang-vscode)


## core-advanced.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-advanced.mdx)
---
title: 高级
---

各种小众、危险或不稳定的功能，可能会产生意想不到的结果，仅供更有经验的用户使用。

:::caution

  谨慎行事。

:::

## Context.readForwardFee

```tact
extends fun readForwardFee(self: Context)：Int
```

[`Context{:tact}`](/zh-cn/ref/core-common#context) 的扩展函数。

读取 [forward fee](https://docs.ton.org/develop/smart-contracts/guidelines/processing)，并以 [`Int{:tact}`][int] 的形式返回 [nanoToncoins](/zh-cn/book/integers#nanotoncoin) 的金额。

使用示例

```tact
let fwdFee: Int = context().readForwardFee()；
```

## getConfigParam

```tact
fun getConfigParam(id: Int)：Cell?
```

通过 "id "号加载 TON 区块链的[配置参数](https://docs.ton.org/develop/howto/blockchain-configs)。

使用示例

```tact
// 参数 0，存储区块链配置的特殊智能合约的地址
let configAddrAsCell: Cell = getConfigParam(0)!!;

// 参数 18，用于确定数据存储价格的配置
let dataStorageFeeConfig: Cell = getConfigParam(18)!!;
```

:::note

  标准库 [`@stdlib/config`](/zh-cn/ref/stdlib-config) 提供了两个相关的辅助函数：\
  [`getConfigAddress(){:tact}`](/zh-cn/ref/stdlib-config#getconfigaddress)，用于获取配置 [`Address{:tact}`][p]/
  [`getElectorAddress(){:tact}`](/zh-cn/ref/stdlib-config#getconfigaddress)，用于获取选区 [`地址{:tact}`][p]。

  了解有关其他参数的更多信息：[TON 文档中的配置参数](https://docs.ton.org/develop/howto/blockchain-configs)。

:::

## acceptMessage

```tact
fun acceptMessage()；
```

同意购买一些汽油来完成当前交易。 处理外部信息时需要这一操作，因为外部信息本身没有价值（因此没有 gas ）。

使用示例

```tact {10}
contract Timeout {
    timeout：Int;

    init() {
        self.timeout = now() + 5 * 60; // 5 minutes from now
    }

    external("timeout") {
        if (now() > self.timeout) {
            acceptMessage(); // 超时后开始接受外部信息
        }
    }
}
```

:::note

  更多详情，请参阅[TON 文档中的接受信息效果](https://docs.ton.org/develop/smart-contracts/guidelines/accept)。

:::

## commit

```tact
fun commit()；
```

提交 [寄存器](https://docs.ton.org/learn/tvm-instructions/tvm-overview#control-registers)`c4`（"持久化数据"）和`c5`（"操作"）的当前状态，这样，即使随后在计算阶段出现异常，当前执行也会因保存的值而被视为 "成功"。

使用示例

```tact {1}
commit(); // 现在，事务被视为 "成功"
throw(42); // 这样就不会失败了
```

## nativePrepareRandom {#nativepreparerandom}

```tact
fun nativePrepareRandom()；
```

使用 [`nativeRandomizeLt(){:tact}`](#nativerandomizelt)准备随机数生成器。 由 [`randomInt(){:tact}`](/zh-cn/ref/core-random#randomint) 和 [`random(){:tact}`](/zh-cn/ref/core-random#random) 函数自动调用。

使用示例

```tact
nativePrepareRandom(); // prepare the RNG
// ... do your random things ...
```

## nativeRandomize

```tact
fun nativeRandomize(x: Int)；
```

使用指定的种子 `x` 随机化伪随机数生成器。

使用示例

```tact
nativeRandomize(); // 现在，随机数的可预测性降低了
let idk：Int = randomInt(); // ????, it's random！
```

## nativeRandomizeLt

```tact
fun nativeRandomizeLt()；
```

使用当前 [逻辑时间](https://docs.ton.org/develop/smart-contracts/guidelines/message-delivery-guarantees#what-is-a-logical-time) 随机化随机数发生器。

使用示例

```tact
nativeRandomizeLt(); // 现在，随机数对用户来说是不可预测的，
                            // 但仍可能受到验证器或校对器的影响
                            // 因为它们决定了当前代码块的种子。
let idk：Int = randomInt(); // ???，它是随机的！
```

## nativeRandom

```tact
fun nativeRandom()：Int；
```

生成并返回 $256$-bit 随机数，就像 [`randomInt(){:tact}`](/zh-cn/ref/core-random#randomint)，但不会事先用 [`nativePrepareRandom(){:tact}`](#nativepreparerandom)初始化随机生成器。

:::note

  不要直接使用该函数，而应使用 [`randomInt(){:tact}`](/zh-cn/ref/core-random#randomint)。

:::

## nativeRandomInterval

```tact
fun nativeRandomInterval(max: Int)：Int；
```

生成并返回 $256$-bit 的随机数，范围从 $0$ 到 `max`，类似于 [`random(){:tact}`](/zh-cn/ref/core-random#random)，但不会事先用 [`nativePrepareRandom(){:tact}`](#nativepreparerandom)初始化随机生成器。

:::note

  不要直接使用该函数，而应使用 [`random(){:tact}`](/zh-cn/ref/core-random#random)。

:::

## nativeSendMessage

```tact
fun nativeSendMessage(cell: Cell, mode: Int)；
```

通过指定完整的 "单元格 "和[信息 "模式"](/zh-cn/book/message-mode)，[排队发送信息](/zh-cn/book/send#outbound-message-processing)。

:::note

  除非您有无法以其他方式表达的复杂逻辑，否则请优先使用更常见、更方便用户使用的 [`send(){:tact}`](/zh-cn/ref/core-common#send)函数。

:::

## nativeReserve

```tact
fun nativeReserve(amount: Int, mode: Int)；
```

以指定的金额和模式调用本地 `raw_reserve` 函数。 raw_reserve "是一个函数，用于创建输出操作，从账户余额中储备特定数量的[nanoToncoins](/zh-cn/book/integers#nanotoncoin)。

它在 FunC 中的签名如下

```func
raw_reserve(int amount, int mode) impure asm "RAWRESERVE"；
```

该函数有两个参数：

- 金额：要储备的 [nanoToncoins](/zh-cn/book/integers#nanotoncoin)的数量。
- 模式决定预订行为。

函数 "raw_reserve "大致等同于创建一个向外发送的消息，将指定的 "金额"[nanoToncoins](/zh-cn/book/integers#nanotoncoin)（或 "b " $-$ "金额"[nanoToncoins](/zh-cn/book/integers#nanotoncoin)，其中 "b "为余额）发送给自己。 这就确保了后续产出行动所花费的资金不会超过剩余资金。

您可以使用原始的 [`Int{:tact}`][int]值，并手动为 `mode` 提供这些值，但为了方便起见，您可以使用一组常量来轻松构建复合 `mode`。 有关基本模式和可选标记的更多信息，请参阅下表。

:::caution

  目前，"金额 "必须是非负整数，"模式 "的范围必须是 $0..31$（含）。

:::

### 基本模式 {#nativereserve-base-modes}

由此产生的 `mode` 值可以有以下基本模式：

|        模式值 | 恒定名称                          | 说明                                                                                   |
| ---------: | :---------------------------- | ------------------------------------------------------------------------------------ |
| $0$        | `ReserveExact{:tact}`         | 精确保留指定数量的 [纳顿币](/zh-cn/book/integers#nanotoncoin)。                                         |
| $1$        | `ReserveAllExcept{:tact}`     | 保留所有 [纳米通币]（/book/integers#nanotoncoin），但保留指定数量的 [纳米通币]（/book/integers#nanotoncoin）。 |
| $2$        | `ReserveAtMost{:tact}`        | 最多保留指定 "数量 "的 [纳顿币](/zh-cn/book/integers#nanotoncoin)。                                     |

### 可选标记 {#nativereserve-optional-flags}

此外，生成的 `mode` 还可以添加以下可选标记：

|        标志值 | 恒定名称                               | 说明                                  |
| ---------: | :--------------------------------- | ----------------------------------- |
| $+4$       | `ReserveAddOriginalBalance{:tact}` | 用经常账户的原始余额（计算阶段之前）增加 "金额"，包括所有额外货币。 |
| $+8$       | `ReserveInvertSign{:tact}`         | 在执行保留之前否定 `amount` 值。               |
| $+16$      | `ReserveBounceIfActionFail{:tact}` | 如果预订失败，则退回交易。                       |

### 使用标志组合模式 {#nativereserve-combining-modes-with-flags}

要为 `mode` 参数创建 [`Int{:tact}`][int]值，只需通过 [bitwise OR](/zh-cn/book/operators#binary-bitwise-or)操作将基本模式与可选标志结合起来：

```tact
nativeReserve(ton("0.1"), ReserveExact | ReserveBounceIfActionFail);
// ---------- ----------------------------------------
// ↑ ↑
// | 模式，如果精确预订失败，将反弹交易
// 要预订的纳吨币数量
```

[p]: /zh-cn/book/types#primitive-types
[bool]: /zh-cn/book/types#booleans
[int]: /zh-cn/book/integers


## core-base.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-base.mdx)
---
title: 基本特质
---

Tact 中的每个 [contract](/zh-cn/book/contracts) 和 [trait](/zh-cn/book/types#traits) 都隐式 [继承](/zh-cn/book/contracts#traits) `BaseTrait{:tact}` trait，该 trait 包含大量对任何类型的 contract 最有用的 [internal functions](/zh-cn/book/contracts#internal-functions) 以及一个针对 Tact 高级用户的常量 `self.storageReserve{:tact}`。

## 常数

### self.storageReserve {#self-storagereserve}

```tact
virtual const storageReserve：Int = 0；
```

使用示例

```tact
contract AllYourStorageBelongsToUs {
    // 这将改变 self.forward() 函数的行为，
    // 使其在
    // 使用 SendRemainingBalance 模式转发消息之前，尝试保留此数量的纳吨币
    override const storageReserve：Int = ton("0.1");
}
```

## 功能

### self.reply {#self-reply}

```tact
virtual fun reply(body: Cell?)；
```

使用以下参数调用 [`self.forward(){:tact}`](#self-forward)函数的别名：

```tact
self.forward(sender(), body, true, null);
//           ↑         ↑     ↑     ↑
//           |         |     |     init: StateInit?
//           |         |     bounce: Bool
//           |         body: Cell?
//           to: Address
```

使用示例

```tact
// 这条信息会反弹给我们！
self.reply("Beware, this is my reply to you!".asComment())；
```

### self.notify {#self-notify}

```tact
virtual fun notify(body: Cell?)；
```

使用以下参数调用 [`self.forward(){:tact}`](#self-forward)函数的别名：

```tact
self.forward(sender(), body, false, null);
//           ↑         ↑     ↑      ↑
//           |         |     |      init: StateInit?
//           |         |     bounce: Bool
//           |         body: Cell?
//           to: Address
```

使用示例

```tact
// 此消息不会跳转！
self.notify("Beware, this is my reply to you!".asComment());
```

### self.forward {#self-forward}

```tact
virtual fun forward(to: Address, body: Cell?, bounce: Bool, init: StateInit?)；
```

[将信息](/zh-cn/book/send#outbound-message-processing)（可跳转或不可跳转）发送到指定地址 `to`。 您可以选择提供信息的 "body "和[`init`包](/zh-cn/book/expressions#initof)。

当[`self.storageReserve{:tact}`](#self-storagereserve)常量被覆盖为$> 0$时，在发送信息之前，它也会尝试从剩余余额中预留`self.storageReserve{:tact}`的[nanoToncoins][nano]金额，然后再以[`SendRemainingBalance{:tact}`](https://docs.tact-lang.org/book/message-mode#base-modes)($128$) 模式发送信息。

如果预订尝试失败，或在默认情况下没有尝试，则会以[`SendRemainingValue{:tact}`](https://docs.tact-lang.org/book/message-mode#base-modes)（$64$）模式发送信息。

:::note

  请注意，`self.forward(){:tact}` 不会在余额上可用的[nanoToncoins][nano]之外发送额外的[nanoToncoins][nano]。
  要想用一条信息发送更多的[nanoToncoins][nano]，请使用[`send(){:tact}`](/zh-cn/ref/core-common#send)函数。

:::

使用示例

```tact
import "@stdlib/ownable";

message PayoutOk {
    address：Address;
    value：Int as coins;
}

用 Ownable 签订 Payout 合同 {
    completed：Bool;
    owner: Address;

    init(owner: Address) {
        self.owner = owner;
        self.completed = false;
    }

    // ......一些操作 ...

    // 被退回的接收函数，当指定的发送信息被退回时被调用
    bounced(msg: bounced<PayoutOk>) {
        // 如果我们的信息被退回，则重置完成标志
        self.completed = false;

        // 使用处理此发送的剩余资金发送支付失败的通知
        self.forward(self.owner, "Payout failed".asComment(), false, null);
    } // 如果我们的信息被退回，则重置完成标志。
}
```

[nano]: /zh-cn/book/integers#nanotoncoin


## core-cells.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-cells.mdx)
---
title: 细胞、建造者和切片
---

[`Cell{:tact}`][cell]是 TON 区块链中表示数据的低级[基元][p]。 单元由 $1023$ 位数据组成，最多可 $4$ 引用另一个单元。 它们是只读的、不可变的，并且不能循环引用。

[`Builder{:tact}`][builder]是一个不可变的[基元][p]，用于构建单元格；[`Slice{:tact}`][slice]是一个可变的[基元][p]，用于解析单元格。

:::note

  在手动构建和解析单元格时要非常小心，并始终确保记录其所需的布局：用于序列化和反序列化的值和类型的严格顺序。

  为此，建议高级用户使用[类型语言 - 二进制（TL-B）模式][tlb]。

  建议每位用户使用 [Structs][struct] 及其 [方法](/zh-cn/book/functions#extension-function)，如 [`Struct.toCell(){:tact}`](#structtocell) 和 [`Struct.fromCell(){:tact}`](#structfromcell)，而不是手动构建和解析单元格，因为 [Structs][struct] 和 [Messages][message] 最接近于[您的合约的活 TL-B 架构](/zh-cn/book/cells#cnp-structs)。

:::

## beginCell

```tact
fun beginCell()：生成器
```

创建一个新的空[`Builder{:tact}`][builder]。

使用示例

```tact
让 fizz：Builder = beginCell()；
```

## emptyCell

```tact
fun emptyCell()：单元格；
```

创建并返回空 [`单元格{:tact}`][单元格]（不含数据和引用）。 别名为 `beginCell().endCell(){:tact}`。

使用示例

```tact
让 fizz：Cell = emptyCell();
let buzz：Cell = beginCell().endCell();

fizz == buzz; // true
```

## emptySlice

```tact
fun emptySlice()：Slice；
```

创建并返回空 [`片{:tact}`][片]（不含数据和引用）。 与 `emptyCell().asSlice(){:tact}` 同名。

使用示例

```tact
让 fizz：Slice = emptySlice();
let buzz：Slice = emptyCell().asSlice();

fizz == buzz; // true
```

## Cell.beginParse

```tact
extends fun beginParse(self: Cell)：Slice；
```

[`单元格{:tact}`][单元格]的扩展函数。

打开[`单元格{:tact}`][单元格]进行解析，并以[`切片{:tact}`][切片]的形式返回。

使用示例

```tact
让 c：Cell = emptyCell();
let fizz：Slice = c.beginParse()；
```

## Cell.hash

```tact
extends fun hash(self: Cell)：Int；
```

[`单元格{:tact}`][单元格]的扩展函数。

计算并返回给定[`单元格{:tact}`][单元格]的[标准`单元格{:tact}`表示][st-repr]的[SHA-256][sha-2]哈希值的[`Int{:tact}`][int]值。

使用示例

```tact
让 c：Cell = emptyCell();
let fizz：Int = c.hash()；
```

## Cell.asSlice

```tact
extends fun asSlice(self: Cell)：Slice；
```

[`单元格{:tact}`][单元格]的扩展函数。

将单元格转换为[`Slice{:tact}`][slice]并返回。 `self.beginParse(){:tact}`的别名。

使用示例

```tact
让 c：Cell = emptyCell();
let fizz：Slice = c.asSlice()；
```

## Builder.endCell

```tact
extends fun endCell(self: Builder)：Cell；
```

[`生成器{:tact}`][生成器]的扩展函数。

将 [`构造器{:tact}`][构造器] 转换为普通的 [`单元格{:tact}`][单元格]。

使用示例

```tact
let b: Builder = beginCell();
let fizz：单元格 = b.endCell()；
```

## Builder.storeUint

```tact
extends fun storeUint(self: Builder, value: Int, bits: Int)：Builder；
```

[`生成器{:tact}`][生成器]的扩展函数。

将 $0 \leq \text{bits} \leq 256$ 的无符号 `bits` 位 `value` 存储到 [`Builder{:tact}`][builder] 的副本中。返回该副本。

试图存储负 `value` 或提供不足或超界 `bits` 数时，会出现 [退出代码 5](/zh-cn/book/exit-codes#5) 异常："整数超出预期范围"。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Builder = b.storeUint(42, 6)；
```

## Builder.storeInt

```tact
extends fun storeInt(self: Builder, value: Int, bits: Int)：Builder；
```

[`生成器{:tact}`][生成器]的扩展函数。

将$0 ≤$ `bits` $≤ 257$的有符号`bits`-位`值`存储到[`builder{:tact}`][builder]的副本中。 返回该副本。

试图提供一个不足或超出范围的`比特`数时，会出现[退出代码5](/zh-cn/book/exit-codes#5)的异常：整数超出预期范围"。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Builder = b.storeUint(42, 7)；
```

## Builder.storeBool

```tact
extends fun storeBool(self: Builder, value: Bool)：Builder；
```

[`生成器{:tact}`][生成器]的扩展函数。

将[`Bool{:tact}`][bool]`value`存储到[`Builder{:tact}`][builder]的副本中。 如果 `value` 是 `true{:tact}`，则写入 $1$ 作为单个位，否则写入 $0$。 返回 [`生成器{:tact}`][生成器] 的副本。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Builder = b.storeBool(true); // writes 1
let buzz：Builder = b.storeBool(false); // writes 0
```

## Builder.storeSlice

```tact
extends fun storeSlice(self: Builder, cell: Slice)：Builder；
```

[`生成器{:tact}`][生成器]的扩展函数。

将[`slice{:tact}`][slice]`cell`存储到[`builder{:tact}`][builder]的副本中。 返回该副本。

使用示例

```tact
let b: Builder = beginCell();
let s：Slice = emptyCell().asSlice();
let fizz：Builder = b.storeSlice(s)；
```

## Builder.storeCoins

```tact
extends fun storeCoins(self: Builder, value: Int)：Builder；
```

[`生成器{:tact}`][生成器]的扩展函数。

存储（序列化）一个范围为 $0 \ldots 2^{120} - 1$ 的无符号 [`Int{:tact}`][int] `value` 到 [`Builder{:tact}`][builder] 的副本中。`value` 的序列化由 $4$ 位无符号大端整数 $l$ 组成，它是最小的整数 $l \geq 0$，使得 $\text{value} < 2^{8l}$，然后是 `value` 的 $8l$ 位无符号大端表示。返回 [`Builder{:tact}`][builder] 的副本。

试图存储一个超出范围的`值`时，会出现[退出代码5](/zh-cn/book/exit-codes#5)的异常：超出预期范围的`整数`。

这是最常见的[纳米通币]存储方式（/book/integers#nanotoncoin）。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Builder = b.storeCoins(42)；
```

:::note[Useful links:]

  [特殊的 "硬币 "序列化类型](/zh-cn/book/integers#serialization-coins)

:::

## Builder.storeAddress

```tact
extends fun storeAddress(self: Builder, address: Address)：Builder；
```

[`生成器{:tact}`][生成器]的扩展函数。

将地址存储在 [`生成器{:tact}`][生成器] 的副本中。 返回该副本。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Builder = b.storeAddress(myAddress())；
```

## Builder.storeRef

```tact
extends fun storeRef(self: Builder, cell: Cell)：Builder；
```

[`生成器{:tact}`][生成器]的扩展函数。

将引用 `cell` 存储到[`Builder{:tact}`][builder]的副本中。 返回该副本。

由于单个 [`单元格{:tact}`][单元格] 最多可存储 $4$ 引用，如果尝试存储更多引用，则会出现[退出代码 8](/zh-cn/book/exit-codes#8)异常：单元格溢出"。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Builder = b.storeRef(emptyCell())；
```

## Builder.refs

```tact
extends fun refs(self: Builder)：Int；
```

[`生成器{:tact}`][生成器]的扩展函数。

以 [`Int{:tact}`][int]形式返回已存储在 [`构造器{:tact}`][构造器] 中的单元格引用的数目。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Int = b.refs(); // 0
```

## Builder.bits

```tact
extends fun bits(self: Builder)：Int；
```

[`生成器{:tact}`][生成器]的扩展函数。

以[`Int{:tact}`][int]形式返回已存储在[`builder{:tact}`][builder]中的数据位数。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Int = b.bits(); // 0
```

## Builder.asSlice

```tact
extends fun asSlice(self: Builder)：Slice；
```

[`生成器{:tact}`][生成器]的扩展函数。

将[`builder{:tact}`][builder]转换为[`slice{:tact}`][slice]并返回。 别名为 `self.endCell().beginParse(){:tact}`。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Slice = b.asSlice()；
```

## Builder.asCell

```tact
extends fun asCell(self: Builder)：Cell；
```

[`生成器{:tact}`][生成器]的扩展函数。

将[`Builder{:tact}`][builder]转换为[`Cell{:tact}`][cell]并返回。 别名为 `self.endCell(){:tact}`。

使用示例

```tact
let b: Builder = beginCell();
let fizz：Cell = b.asCell()；
```

## Slice.loadUint

```tact
extends mutates fun loadUint(self: Slice, l: Int)：Int；
```

[`切片{:tact}`][切片]的扩展突变函数。

从 [`Slice{:tact}`][slice]中加载并返回一个无符号的 `l` 位 [`Int{:tact}`][int]，条件是 $0 ≤$ `l` $≤ 256$。

试图指定一个超出范围的 `l` 值时，会出现 [exit code 5](/zh-cn/book/exit-codes#5)异常：超出预期范围的整数。

尝试加载的数据超过 [`片{:tact}`][片] 包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9) 异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeUint(42, 7).asSlice();
let fizz：Int = s.loadUint(7)；
```

## Slice.preloadUint

```tact
extends fun preloadUint(self: Slice, l: Int)：Int；
```

[`切片{:tact}`][切片]的扩展函数。

为 $0 ≤$ `l` $≤ 256$ 从 [`Slice{:tact}`][slice]中预载并返回一个无符号的 `l` 位 [`Int{:tact}`][int]。 不会修改 [`切片{:tact}`][切片]。

试图指定一个超出范围的 `l` 值时，会出现 [exit code 5](/zh-cn/book/exit-codes#5)异常：超出预期范围的整数。

尝试预载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9)异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeUint(42, 7).asSlice();
let fizz：Int = s.preloadUint(7)；
```

## Slice.loadInt

```tact
extends mutates fun loadInt(self: Slice, l: Int)：Int；
```

[`切片{:tact}`][切片]的扩展突变函数。

从 [`Slice{:tact}`][slice]中加载并返回一个有符号的 `l` 位 [`Int{:tact}`][int]，值为 $0 ≤$ `l` $≤ 257$。

试图指定一个超出范围的 `l` 值时，会出现 [exit code 5](/zh-cn/book/exit-codes#5)异常：超出预期范围的整数。

尝试加载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9) 异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeInt(42, 7).asSlice();
let fizz：Int = s.loadInt(7)；
```

## Slice.preloadInt

```tact
extends fun preloadInt(self: Slice, l: Int)：Int；
```

[`切片{:tact}`][切片]的扩展函数。

为 $0 ≤$ `l` $≤ 257$ 从 [`Slice{:tact}`][slice]中预载并返回一个有符号的 `l` 位 [`Int{:tact}`][int]。 不会修改 [`切片{:tact}`][切片]。

试图指定一个超出范围的 `l` 值时，会出现 [exit code 5](/zh-cn/book/exit-codes#5)异常：超出预期范围的整数。

尝试预载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9)异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeInt(42, 7).asSlice();
let fizz：Int = s.preloadInt(7)；
```

## Slice.loadBits

```tact
extends mutates fun loadBits(self: Slice, l: Int)：Slice；
```

[`切片{:tact}`][切片]的扩展突变函数。

从 [`片{:tact}`][片] 中加载 $0 ≤$ `l` $≤ 1023$ 位，并作为单独的 [`片{:tact}`][片] 返回。

试图指定一个超出范围的 `l` 值时，会出现 [exit code 5](/zh-cn/book/exit-codes#5)异常：超出预期范围的整数。

尝试加载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9) 异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeInt(42, 7).asSlice();
let fizz：Slice = s.loadBits(7)；
```

## Slice.preloadBits

```tact
extends fun preloadBits(self: Slice, l: Int)：Slice；
```

[`切片{:tact}`][切片]的扩展函数。

从 [`片{:tact}`][片] 中预载 $0 ≤$ `l` $≤ 1023$ 位，并将其作为单独的 [`片{:tact}`][片] 返回。 不修改原始 [`切片{:tact}`][切片]。

试图指定一个超出范围的 `l` 值时，会出现 [exit code 5](/zh-cn/book/exit-codes#5)异常：超出预期范围的整数。

尝试预载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9)异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeInt(42, 7).asSlice();
let fizz：Slice = s.preloadBits(7)；
```

## Slice.skipBits

```tact
extends mutates fun skipBits(self: Slice, l: Int)；
```

[`片{:tact}`][片]的扩展突变函数。

从 [`片{:tact}`][片] 中加载除第一个 0 ≤$ `l` $≤ 1023$ 位以外的所有位。

试图指定一个超出范围的 `l` 值时，会出现 [exit code 5](/zh-cn/book/exit-codes#5)异常：超出预期范围的整数。

尝试加载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9) 异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeInt(42, 7).asSlice();
s.skipBits(5); // 除了前 5 位之外的所有位
let fizz：Slice = s.loadBits(1); // 只加载 1 位
```

## Slice.loadBool

```tact
extends mutates fun loadBool(self: Slice)：Bool；
```

[`片{:tact}`][片]的扩展突变函数。

从[`Slice{:tact}`][slice]加载单个位并返回[`Bool{:tact}`][bool]值。 如果加载的位等于 $1$，则读取 `true{:tact}`，否则读取 `false{:tact}`。

当 [`Bool{:tact}`][bool][`slice{:tact}`][slice]不包含它时，尝试加载此类 [`Bool `][bool]会产生异常，[退出代码 8](/zh-cn/book/exit-codes#8)：单元格溢出"。

尝试加载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9) 异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeBool(true).asSlice();
let fizz：Bool = s.loadBool(); // true
```

## Slice.loadCoins

```tact
extends mutates fun loadCoins(self: Slice)：Int；
```

[`切片{:tact}`][切片]的扩展突变函数。

加载并返回[序列化](#builderstorecoins)的一个范围为 $0 ... 2^{120} - 1$ 的无符号 [`Int{:tact}`][int]值，来自 [`片{:tact}`][片]。该值通常代表以[纳吨币](/zh-cn/book/integers#nanotoncoin)为单位的金额。

当 [`Slice{:tact}`][slice]中不包含[`Int{:tact}`][int]时，尝试加载此类[`Int`][int]会产生异常，[退出代码为 8](/zh-cn/book/exit-codes#8)："单元格溢出"。

尝试加载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9) 异常："单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeCoins(42).asSlice();
let fizz：Int = s.loadCoins()；
```

:::note[Useful links:]

  [特殊的 "硬币 "序列化类型](/zh-cn/book/integers#serialization-coins)

:::

## Slice.loadAddress

```tact
extends mutates fun loadAddress(self: Slice)：地址；
```

[`Slice{:tact}`][slice]的扩展突变函数。

从[`Slice{:tact}`][slice]加载并返回一个[`Address{:tact}`][address]。

当[`Slice{:tact}`][slice]不包含该地址时，尝试加载该[`Address{:tact}`][address]会产生异常，[退出代码 8](/zh-cn/book/exit-codes#8)："单元格溢出"。

尝试加载的数据超过 [`Slice{:tact}`][slice] 所包含的数据时，会出现 [退出代码 9](/zh-cn/book/exit-codes#9) 异常："单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeAddress(myAddress()).asSlice();
let fizz：地址 = s.loadAddress()；
```

## Slice.loadRef

```tact
extends mutates fun loadRef(self: Slice)：Cell；
```

[`切片{:tact}`][切片]的扩展突变函数。

从 [`切片{:tact}`][切片] 中加载下一个引用作为 [`单元格{:tact}`][单元格]。

当 [`切片{:tact}`][切片]不包含该引用时，尝试加载该引用会产生异常，[退出代码 8](/zh-cn/book/exit-codes#8)："单元格溢出"。

尝试加载的数据超过 [`片{:tact}`][片] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9) 异常：单元格下溢"。

使用示例

```tact
让 s：Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz：Cell = s.loadRef();

let s：Slice = beginCell()
    .storeRef(emptyCell())
    .storeRef(emptyCell())
    .asSlice();
let ref1: Cell = s.loadRef();
let ref2: Cell = s.loadRef()；
```

## Slice.refs

```tact
extends fun refs(self: Slice)：Int；
```

[`切片{:tact}`][切片]的扩展函数。

以 [`Int{:tact}`][int]形式返回 [`片{:tact}`][片] 中引用的个数。

使用示例

```tact
让 s：Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz：Int = s.refs().asSlice(); let fizz: Int = s.refs().asSlice()
```

## Slice.bits

```tact
extends fun bits(self: Slice)：Int；
```

[`切片{:tact}`][切片]的扩展函数。

以 [`Int{:tact}`][int]形式返回 [`片{:tact}`][片] 中的数据位数。

使用示例

```tact
让 s：Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz：Int = s.bits()；
```

## Slice.empty

```tact
extends fun empty(self: Slice)：Bool；
```

[`切片{:tact}`][切片]的扩展函数。

检查 [`片{:tact}`][片] 是否为空（即不包含数据位和单元格引用）。 如果为空，则返回 `true{:tact}`，否则返回 `false{:tact}`。

使用示例

```tact
让 s：Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz：Bool = s.empty(); // false
let buzz：Bool = beginCell().asSlice().empty(); // true
```

:::note

  与 [`Slice.endParse(){:tact}`](#sliceendparse)不同，即使 [`Slice{:tact}`][slice]为空，该函数也不会抛出任何异常。

:::

## Slice.dataEmpty

```tact
extends fun dataEmpty(slice: Slice)：Bool；
```

[`切片{:tact}`][切片]的扩展函数。

检查 [`片{:tact}`][片] 是否没有数据位。 如果没有数据，则返回 `true{:tact}`，否则返回 `false{:tact}`。

使用示例

```tact
让 s：Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz：Bool = s.dataEmpty(); // true

let s2：Slice = beginCell().storeInt(42, 7).asSlice();
let buzz：Bool = s2.dataEmpty(); // false
```

## Slice.refsEmpty

```tact
extends fun refsEmpty(slice: Slice)：Bool；
```

[`切片{:tact}`][切片]的扩展函数。

检查 [`Slice{:tact}`][slice]是否没有引用。 如果没有引用，则返回 `true{:tact}`，否则返回 `false{:tact}`。

使用示例

```tact
让 s：Slice = beginCell().storeRef(emptyCell()).asSlice();
let fizz：Bool = s.refsEmpty(); // false
let buzz：Bool = beginCell().asSlice().refsEmpty(); // true
```

## Slice.endParse

```tact
extends fun endParse(self: Slice)；
```

[`切片{:tact}`][切片]的扩展函数。

检查 [`片{:tact}`][片] 是否为空（即不包含数据位和单元格引用）。 如果不是，则抛出异常[退出代码 9](/zh-cn/book/exit-codes#9)：单元格下溢。

使用示例

```tact {2,6}
let emptyOne: Slice = emptySlice();
emptyOne.endParse(); // nothing, as it's empty

let paul: Slice = "Fear is the mind-killer".asSlice();
try {
    paul.endParse(); // throws exit code 9
}
```

## Slice.hash

```tact
extends fun hash(self: Slice)：Int；
```

[`切片{:tact}`][切片]的扩展函数。

计算并返回给定[`Slice{:tact}`][slice]的[标准`Cell{:tact}`表示][st-repr]的[SHA-256][sha-2]哈希值的[`Int{:tact}`][int]值。

使用示例

```tact
让 s：Slice = beginCell().asSlice();
let fizz：Int = s.hash()；
```

## Slice.asCell

```tact
extends fun asCell(self: Slice)：Cell；
```

[`切片{:tact}`][切片]的扩展函数。

将 [`Slice{:tact}`][slice]转换为 [`Cell{:tact}`][cell]并返回。 别名为 `beginCell().storeSlice(self).endCell(){:tact}`。

使用示例

```tact
让 s：Slice = beginCell().asSlice();
let fizz：Cell = s.asCell();
let buzz：Cell = beginCell().storeSlice(s).endCell();

fizz == buzz; // true
```

## Address.asSlice

```tact
extends fun asSlice(self: Address)：Slice；
```

[`地址{:tact}`][p]的扩展函数。

将[`地址{:tact}`][p]转换为[`片{:tact}`][片]并返回。 别名为 `beginCell().storeAddress(self).asSlice(){:tact}`。

使用示例

```tact
让 a：Address = myAddress();
let fizz：Slice = a.asSlice();
let buzz：Slice = beginCell().storeAddress(a).asSlice();

fizz == buzz; // true
```

## Struct.toCell

```tact
extends fun toCell(self: Struct)：Cell；
```

任何结构类型 [Struct][struct]的扩展函数。

将 [Struct][struct] 转换为 [`单元格{:tact}`][单元格]并返回。

使用示例

```tact
struct GuessCoin {
    probably：
    nothing: Int as coins;
}

fun coinCell()：Cell {
    let s：GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz：Cell = s.toCell();

    return fizz; // "x{12A11B}"
}
```

## Struct.fromCell

```tact
extends fun fromCell(self: Struct, cell: Cell)：Struct；
```

任何结构类型 [Struct][struct]的扩展函数。

将 [`单元格{:tact}`][单元格] 转换为指定的 [结构体][struct]，并返回该 [结构体][struct]。

试图传递布局与指定 [Struct][struct] 不同的 [`单元格{:tact}`][单元格]，或加载的数据超过 [`单元格{:tact}`][单元格] 所包含的数据时，会出现 [exit code 9](/zh-cn/book/exit-codes#9)异常：单元格下溢"。

使用示例

```tact
struct GuessCoin {
    probably：
    nothing: Int as coins;
}

fun directParse(payload: Cell)：GuessCoin {
    return GuessCoin.fromCell(payload);
}

fun cautiousParse(payload: Cell)：GuessCoin?{
    let coin: GuessCoin?= null;
    try {
        coin = GuessCoin.fromCell(payload);
    } catch (e) {
        dump("Cell payload doesn't match GuessCoin Struct!");
    }
    return coin;
}
```

## Struct.fromSlice

```tact
extends fun fromSlice(self: Struct, cell: Slice)：Struct；
```

任何结构类型 [Struct][struct]的扩展函数。

将 [`片{:tact}`][slice]转换为指定的 [Struct][struct]，并返回该 [Struct][struct]。

尝试传递布局与指定 [结构][struct]不同的 [`片{:tact}`][片]，或加载比 [`片{:tact}`][片] 包含的数据更多的数据时，会出现[退出代码 9](/zh-cn/book/exit-codes#9)异常：单元下溢"。

使用示例

```tact
struct GuessCoin {
    probably：
    nothing: Int as coins;
}

fun directParse(payload: Slice)：GuessCoin {
    return GuessCoin.fromSlice(payload);
}

fun cautiousParse(payload: Slice)：GuessCoin?{
    let coin: GuessCoin?= null;
    try {
        coin = GuessCoin.fromSlice(payload);
    } catch (e) {
        dump("Slice payload doesn't match GuessCoin Struct!");
    }
    return coin;
}
```

## Message.toCell

```tact
extends fun toCell(self: Message)：Cell；
```

任何报文类型 [报文][信息] 的扩展函数。

将[信息][message]转换为[`单元格{:tact}`][单元格]并返回。

使用示例

```tact
message GuessCoin {
    probably：
    nothing: Int as coins;
}

fun coinCell()：Cell {
    let s：GuessCoin = GuessCoin{ probably: 42, nothing: 27 };
    let fizz：Cell = s.toCell();

    return fizz; // "x{AB37107712A11B}"
}
```

## Message.fromCell

```tact
extends fun fromCell(self: Message, cell: Cell)：消息；
```

任何报文类型 [报文][信息] 的扩展函数。

将 [`单元格{:tact}`][单元格] 转换为指定的 [信息][消息]，并返回该 [信息][消息]。

尝试传递布局与指定[信息][message]不同的[`单元格{:tact}`][单元格]，或加载的数据超过[`单元格{:tact}`][单元格]所包含的数据时，会出现[退出代码 9](/zh-cn/book/exit-codes#9)的异常：单元格下溢"。

使用示例

```tact
message(0x777) TripleAxe {
    prize：Int as uint32;
}

fun directParse(payload: Cell)：TripleAxe {
    return TripleAxe.fromCell(payload);
}

fun cautiousParse(payload: Cell)：TripleAxe?{
    let coin: TripleAxe? = null;
    try {
        coin = TripleAxe.fromCell(payload);
    } catch (e) {
        dump("Cell payload doesn't match TripleAxe Message!");
    }
    return coin;
}
```

## Message.fromSlice

```tact
extends fun fromSlice(self: Message, cell: Slice)：消息；
```

任何报文类型 [报文][信息] 的扩展函数。

将 [`片{:tact}`][片] 转换为指定的 [信息][消息]，并返回该 [信息][消息]。

试图传递布局不同于指定[信息][消息]的[`片{:tact}`][片]，或加载的数据多于[`片{:tact}`][片]所包含的数据时，会出现[退出代码 9](/zh-cn/book/exit-codes#9)的异常：单元下溢"。

使用示例

```tact
message(0x777) TripleAxe {
    prize：Int as uint32;
}

fun directParse(payload: Slice)：TripleAxe {
    return TripleAxe.fromSlice(payload);
}

fun cautiousParse(payload: Slice)：TripleAxe?{
    let coin: TripleAxe? = null;
    try {
        coin = TripleAxe.fromSlice(payload);
    } catch (e) {
        dump("Slice payload doesn't match TripleAxe Message!");
    }
    return coin;
}
```

[p]: /zh-cn/book/types#primitive-types
[bool]: /zh-cn/book/types#booleans
[int]: /zh-cn/book/integers
[cell]: /zh-cn/book/cells#cells
[builder]: /zh-cn/book/cells#builders
[slice]: /zh-cn/book/cells#slices
[map]: /zh-cn/book/maps
[struct]: /zh-cn/book/structs-and-messages#structs
[message]: /zh-cn/book/structs-and-messages#messages

[std-repr]: /zh-cn/book/cells#cells-representation

[tlb]: https://docs.ton.org/develop/data-formats/tl-b-language
[sha-2]: https://en.wikipedia.org/wiki/SHA-2#Hash_standard


## core-common.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-common.mdx)
---
title: 常见问题
---

最常用的内置 [全局静态函数] 列表(/book/functions#global-static-functions)。

## 语境

### now

```tact
fun now()：Int
```

返回当前 [Unix 时间](https://en.wikipedia.org/wiki/Unix_time)。

使用示例

```tact
let timeOffset：Int = now() + 1000; // 距离 now() 千秒
```

### myBalance

```tact
fun myBalance()：Int；
```

返回当前交易的 [计算阶段](https://docs.ton.org/learn/tvm-instructions/tvm-overview#compute-phase) 开始时智能合约的 [纳米通币](/zh-cn/book/integers#nanotoncoin) 余额。

使用示例

```tact
让 iNeedADolla：Int = myBalance()；
```

:::caution

  请注意，Tact 的 [所有信息发送函数](/zh-cn/book/send) 可以更改_实际_合约的余额，但不会_更新此函数返回的值。

:::

### myAddress

```tact
fun myAddress()：地址；
```

以[`地址{:tact}`][p]的形式返回当前智能合约的地址。

使用示例

```tact
let meMyselfAndI: Address = myAddress()；
```

### sender

```tact
fun sender()：地址；
```

返回当前信息发件人的 [`地址{:tact}`][p]。

使用示例

```tact
receive() {
    let whoSentMeMessage：Address = sender();
}
```

:::caution

  对于 [getter 函数](/zh-cn/book/contracts#getter-functions)，行为是未定义的，因为它们不能有发送者，也不能发送信息。

:::

:::note

  为了减少 gas 用量，当您只需要知道消息的发件人时，请使用此函数而不是调用 [`context().sender{:tact}`](#context)。

:::

### context

```tact
fun context()：Context；
```

Returns `Context{:tact}` [Struct](/zh-cn/book/structs-and-messages#structs), that consists of：

| 现场     | 类型                     | 说明                                                                                                                                                                                                                                    |
| :----- | :--------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 宣布     | [`Bool{:tact}`][bool]。 | [退信](https://ton.org/docs/learn/overviews/addresses#bounceable-vs-non-bounceable-addresses) 标志。                                                                                                                                       |
| 发件人    | [`地址{:tact}`][p]       | 发送方在 TON 区块链上的内部地址。                                                                                                                                                                                                                   |
| 值      | [`Int{:tact}`][int]。   | 信息中 [nanoToncoins](/zh-cn/book/integers#nanotoncoin) 的数量。                                                                                                                                                                                   |
| 生      | [`切片{:tact}`][切片]      | 信息的其余部分作为 [`片{:tact}`][片]。 它遵循 TON 的[内部报文布局](https://docs.ton.org/develop/smart-contracts/messages#message-layout)，从目的地[`地址{:tact}`][p]（[TL-B 符号](https://docs.ton.org/develop/data-formats/tl-b-language) 中的`dest:MsgAddressInt`）开始。 |

使用示例

```tact
让 ctx：Context = context();
require(ctx.value != 68 + 1, "Invalid amount of nanoToncoins, bye!")；
```

:::note

  请注意，如果您只需要知道谁发送了信息，请使用 [`sender(){:tact}`](#sender) 函数，因为它耗油量较少。

:::

## 地址

### newAddress

```tact
fun newAddress(chain: Int, hash: Int)：地址；
```

根据[`链`id](https://ton-blockchain.github.io/docs/#/overviews/TON_blockchain_overview)和[SHA-256](/zh-cn/ref/core-math#sha256)编码的[`哈希`值](https://docs.ton.org/learn/overviews/addresses#account-id)创建一个新的[`地址{:tact}`][p]。

该函数尽可能在[编译时](/zh-cn/ref/core-comptime)解析常量值。

使用示例

```tact
let oldTonFoundationAddr: Address =
    newAddress(0, 0x83dfd552e63729b472fcbcc8c45ebcc6691702558b68ec7527e1ba403a0f31a8);
    // ↑ ------------------------------------------------------------------
    | // ↑
    // | 合约初始包（StateInit）的 sha-256 哈希值
    // 链 id：0 代表工作链，-1 代表主链。
```

:::caution

  如果 `chain` 无效，该方法会抛出错误[退出代码 136](/zh-cn/book/exit-codes#136)；如果 `chain` 指向主链 ($-1$) 且未启用[主链支持](/zh-cn/book/masterchain)，该方法会抛出错误[退出代码 137](/zh-cn/book/exit-codes#137)。

:::

:::note[Useful links:]

  [TON文档中的`chain`（工作链ID）](https://docs.ton.org/learn/overviews/addresses#workchain-id)\
  [TON文档中的`hash`（账户ID）](https://docs.ton.org/learn/overviews/addresses#account-id)\
  [合约的初始包（`StateInit{:tact}`）](/zh-cn/book/expressions#initof)

:::

### contractAddress

```tact
fun contractAddress(s: StateInit)：地址；
```

根据智能合约的 [`StateInit{:tact}`](/zh-cn/book/expressions#initof)，计算智能合约在工作链 $0$ 中的 [`地址{:tact}`][p]。

使用示例

```tact
让 foundMeSome：Address = contractAddress(initOf SomeContract())；
```

### contractAddressExt

```tact
fun contractAddressExt(chain: Int, code: Cell, data: Cell)：地址；
```

根据 "链 "id、合约 "代码 "和合约初始状态 "数据 "计算智能合约的[`地址{:tact}`][p]。 使用 [`initOf{:tact}`](/zh-cn/book/expressions#initof)表达式获取给定合约的初始 `code` 和初始 `data` 。

使用示例

```tact
让 initPkg：StateInit = initOf SomeContract();
let hereBeDragons：Address = contractAddressExt(0, initPkg.code, initPkg.data)；
```

:::caution

  如果 `chain` 无效，该方法会抛出错误[退出代码 136](/zh-cn/book/exit-codes#136)；如果 `chain` 指向主链 ($-1$) 且未启用[主链支持](/zh-cn/book/masterchain)，该方法会抛出错误[退出代码 137](/zh-cn/book/exit-codes#137)。

:::

:::note

  要使用该功能，必须在 [configuration file](/zh-cn/book/config).
  中为当前项目将编译器选项 `debug` 设置为 `true{:tact}`：[调试](/zh-cn/book/debug)。

:::

## 交流 

### send

```tact
fun send(params: SendParameters)；
```

使用 [`发送参数{:tact}`](/zh-cn/book/send)[结构](/zh-cn/book/structs-and-messages#structs)发送[队列信息](/zh-cn/book/send#outbound-message-processing)。

使用示例

```tact
send(SendParameters{
    to: sender(), // back to the sender,
    value: ton("1"), // with 1 Toncoin (1_000_000_000 nanoToncoin),
                     // and no message body
})；
```

:::note[Useful links:]

  [Sending messages in the Book](/zh-cn/book/send)/
  [Message`mode` in the Book](/zh-cn/book/message-mode)/
  [Single-contract communication in the Cookbook](/zh-cn/cookbook/single-communication)

:::

### emit

```tact
fun emit(body: Cell)；
```

将[信息排队](/zh-cn/book/send#outbound-message-processing) `body` 发送到外部世界，以便在链外进行记录和分析。 该信息没有收件人，与使用 Tact 的其他信息发送功能相比更省油。

使用示例

```tact
emit("Catch me if you can, Mr. Holmes".asComment()); // asComment() 将字符串转换为单元格
```

:::note

  要分析 `emit(){:tact}` 调用，必须查看合约产生的 [外部信息](/zh-cn/book/external)。

  了解更多信息：[通过 `emit(){:tact}`记录日志](/zh-cn/book/debug#logging)。

:::

[p]: /zh-cn/book/types#primitive-types
[bool]: /zh-cn/book/types#booleans
[int]: /zh-cn/book/integers
[一片]: /zh-cn/book/cells#slices


## core-comptime.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-comptime.mdx)
---
title: 编译时
---

本页列出了所有内置 [全局静态函数](/zh-cn/book/functions#global-static-functions)，这些函数在构建 Tact 项目时进行评估，无法处理非恒定的运行时数据。 这些函数通常被称为 "编译时函数"。

## 地址

```tact
fun address(s: String)：地址；
```

编译时函数，用于将带有地址的 [`字符串{:tact}`][p]转换为 [`地址{:tact}`][p]类型。

使用示例

```tact
contract Example {
    // Persistent state variables
    addr: Address =
        address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N"); // works at compile-time！
}
```

## 电池

```tact
fun cell(bocBase64: String)：单元格；
```

编译时函数，将 base64 编码的 [BoC](https://docs.ton.org/develop/data-formats/cell-boc#bag-of-cells)`bocBase64`作为 [`单元格{:tact}`][单元格] 嵌入到合约中。

使用示例

```tact
contract Example {
    // 持久状态变量
    storedCell：Cell =
        // 钱包 V3R1 的初始包为 base64-编码的 BoC
        cell("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=")；// 编译时有效！
}
```

:::note[Useful links:]

  [TON文档中的细胞袋](https://docs.ton.org/develop/data-formats/cell-boc#bag-of-cells)

:::

## ton 

```tact
fun ton(value: String)：Int；
```

编译时函数，将给定的通币`值`从人类可读格式[`String{:tact}`][p]转换为[nanoToncoin](/zh-cn/book/integers#nanotoncoin)[`Int{:tact}`][int]格式。

使用示例

```tact
contract Example {
    // 持久状态变量
    one：Int = ton("1"); // 10^9 枚纳米通币，等于 1 枚通币
    pointOne: Int = ton("0.1"); // 10^8 枚纳米通币，等于 0.1 枚通币
    nano: Int = ton("0.000000001"); // 1 枚纳米通币，等于 10^9 枚通币
                                    // 在编译时有效！
}
```

[p]: /zh-cn/book/types#primitive-types
[bool]: /zh-cn/book/types#booleans
[int]: /zh-cn/book/integers
[电池]: /zh-cn/book/cells#cells


## core-debug.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-debug.mdx)
---
title: 调试
---

Tact 中调试智能合约常用的函数列表。

:::note

  有关调试的更多信息，请访问专用页面：[调试](/zh-cn/book/debug)。

:::

## require

```tact
fun require(condition: Bool, error: String)；
```

检查 `condition` 并抛出错误，如果 `condition` 为 `false{:tact}`，则从 `error` 消息中生成 [exit code](/zh-cn/book/exit-codes)。 除此之外，别无其他作用。

生成退出代码的算法如下：

- 首先，获取`错误`报文[`字符串{:tact}`][p]的[SHA-256](https://en.wikipedia.org/wiki/SHA-2#Hash_standard) 哈希值。
- 然后，按此顺序将其值读作一个 32 位 [big-endian](https://en.wikipedia.org/wiki/Endianness) 数字 modulo $63000$ 加 $1000$。
- 最后，它将被放入 `.md` 编译报告文件，该文件与其他编译工件一起存放在项目的 `outputs/` 或 `build/` 目录中。

保证生成的退出代码不在为 TVM 和 Tact 合同错误保留的常用 $0 - 255$ 范围内，这样就可以将退出代码与 `require(){:tact}` 和任何其他 [标准退出代码](/zh-cn/book/exit-codes) 区分开来。

使用示例

```tact
// now() 必须返回一个大于 1000 的值，否则将抛出错误信息
require(now() > 1000, "We're in the first 1000 seconds of January 1970!");

try {
    // 下面的内容永远不会为真，所以这个 require 将总是抛出
    require(now() < -1, "Time is an illusion.午餐时间更是如此。");
} catch (e) {
    // e 将超出 0-255 范围
    dump(e);
}
```

## dump

```tact
fun dump(arg)；
```

将参数 `arg` 打印到合约的调试控制台。 仅当[配置文件](/zh-cn/book/config) 中的 "debug "选项设置为 `true{:json}`时才进行评估，否则不执行任何操作。

可应用于下列类型和值：

- [`Int{:tact}`][int]。
- [`Bool{:tact}`][bool]。
- [`地址{:tact}`][p]
- [`单元格{:tact}`][单元格]、[`构建器{:tact}`][构建器]或[`切片{:tact}`][切片]
- [`String{:tact}`][p] 或 [`StringBuilder{:tact}`][p]
- [`map<K, V>{:tact}`](/zh-cn/book/maps)
- [选项和 `null{:tact}` 值](/zh-cn/book/optionals)
- void"，当函数没有定义返回值时隐式返回

使用示例

```tact
// Int
dump(42);

// Bool
dump(true);
dump(false);

// Address
dump(myAddress());

// Cell, Builder or Slice
dump(emptyCell())；  // Cell
dump(beginCell()); // Builder
dump(emptySlice()); // Slice

// String or StringBuilder
dump("Hello, my name is..."); // String
dump(beginTailString()); // StringBuilder

// Maps
let m: map<Int, Int> = emptyMap();
m.set(2 + 2, 4);
dump(m);

// 特殊值
dump(null);
dump(emit("msg".asComment())); // 由于 emit() 函数不返回值，dump() 将打印 #DEBUG#: void.
```

:::note[Useful links:]

  [使用 `dump(){:tact}` 调试](/zh-cn/book/debug#tests-dump)

:::

## dumpStack

```tact
fun dumpStack()；
```

将 [持久状态变量](/zh-cn/book/contracts#variables)的所有值打印到合约的调试控制台。 仅当[配置文件](/zh-cn/book/config) 中的 "debug "选项设置为 `true{:json}`时才进行评估，否则不执行任何操作。

使用示例

```tact {6}
contract DumpsterFire {
    var1: Int = 0;
    var2: Int = 5;

    receive() {
        dumpStack(); // would print 0 5
    }
}
```

:::note[Useful links:]

  [使用 `dump(){:tact}` 调试](/zh-cn/book/debug#tests-dump)

:::

## throw

```tact
fun throw(code: Int)；
```

是 [`nativeThrow(){:tact}`](#nativethrow)的别名。

## nativeThrow

```tact
fun nativeThrow(code: Int)；
```

抛出错误代码等于 `code` 的异常。 当前上下文的执行将停止（"nativeThrow "后的语句将不会执行），控制权将传递给调用栈中的第一个[`try...catch{:tact}`块](/zh-cn/book/statements#try-catch)。 如果调用者函数中不存在 `try{:tact}`或 `try...catch{:tact}`块，[TVM](https://docs.ton.org/learn/tvm-instructions/tvm-overview)将终止事务。

试图在 $0 - 65535$ 范围之外指定 `code` 时，会出现 [exit code 5](/zh-cn/book/exit-codes#5)异常：整数超出预期范围"。

使用示例

```tact {2,7}
fun thisWillTerminate() {
    nativeThrow(42); // 抛出退出代码 42
}

fun butThisDoesNot() {
    try {
        nativeThrow(42); // 抛出退出代码 42
    }

    // ... 后续逻辑 ...
}
```

## nativeThrowIf

```tact
fun nativeThrowIf(code: Int, condition: Bool)；
```

类似于 [`nativeThrow(){:tact}`](#nativethrow)，但会在 `condition` 等于 `true{:tact}` 时有条件地抛出异常。 否则不会扔。

试图在 $0 - 65535$ 范围之外指定 `code` 时，会出现 [exit code 5](/zh-cn/book/exit-codes#5) 异常：整数超出预期范围"。

使用示例

```tact {2,7}
fun thisWillTerminate() {
    nativeThrowIf(42, true); // 抛出退出代码 42
}

fun butThisDoesNot() {
    try {
        nativeThrowIf(42, true); // 抛出退出代码 42
    }
    // ... 后续逻辑 ...
}
```

## nativeThrowUnless

```tact
fun nativeThrowUnless(code: Int, condition: Bool)；
```

类似于 [`nativeThrow(){:tact}`](#nativethrow)，但会在 `condition` 等于 `false{:tact}` 时有条件地抛出异常。 否则不会扔。

试图在 $0 - 65535$ 范围之外指定 `code` 时，会出现 [exit code 5](/zh-cn/book/exit-codes#5) 异常：整数超出预期范围"。

使用示例

```tact {2,7}
fun thisWillTerminate() {
    nativeThrowUnless(42, false); // 抛出退出代码 42
}

fun butThisDoesNot() {
    try {
        nativeThrowUnless(42, false); // 抛出退出代码 42
    }
    // ... 后续逻辑 ...
}
```

[p]: /zh-cn/book/types#primitive-types
[bool]: /zh-cn/book/types#booleans
[int]: /zh-cn/book/integers
[电池]: /zh-cn/book/cells#cells
[建筑工人]: /zh-cn/book/cells#builders
[一片]: /zh-cn/book/cells#slices


## core-math.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-math.mdx)
---
title: 数学
---

各种数学辅助功能

## min

```tact
fun min(x: Int, y: Int)：Int；
```

计算并返回两个 [`Int{:tact}`][int]值 `x` 和 `y` 的 [最小值](https://en.wikipedia.org/wiki/Maximum_and_minimum)。

使用示例

```tact
min(1, 2); // 1
min(2, 2); // 2
min(007, 3); // 3
min(0x45, 3_0_0); // 69, nice
// ↑ ↑
// 69 300
```

## max

```tact
fun max(x: Int, y: Int)：Int；
```

计算并返回两个 [`Int{:tact}`][int]值 `x` 和 `y` 的 [最大值](https://en.wikipedia.org/wiki/Maximum_and_minimum)。

使用示例

```tact
max(1, 2); // 2
max(2, 2); // 2
max(007, 3); // 7
max(0x45, 3_0_0); // 300
// ↑ ↑
// 69 300
```

## abs

```tact
fun abs(x: Int)：Int
```

计算并返回[`Int{:tact}`][int]值 `x` 的[绝对值](https://en.wikipedia.org/wiki/Absolute_value)。

使用示例

```tact
abs(42); // 42
abs(-42); // 42
abs(-(-(-42))); // 42
```

## log

```tact
fun log(num: Int, base: Int)：Int；
```

计算并返回数字 `num` $> 0$ 以 `base` $≥1$ 为底的 [logarithm](https://en.wikipedia.org/wiki/Logarithm) 值。 结果[四舍五入](https://en.wikipedia.org/wiki/Rounding#Rounding_down)。 传入一个非正数`num`值或`base`小于 $1$ 会产生错误[退出代码 5](/zh-cn/book/exit-codes#5)：整数超出预期范围"。

使用示例

```tact
log(1000, 10); // 3, 因为 10^3 是 1000
// ↑ ↑ ↑
// num base base num

log(1001, 10); // 3
log(999, 10); // 2
try {
  log(-1000, 10)；// 抛出退出代码 5，因为数值不是正数
}
log(1024, 2); // 10
try {
  log(1024, -2); // 抛出退出代码 5，因为基数小于 1
}
```

:::note

  请注意，如果只需要获取以 $2$为底的对数，请使用 [`log2(){:tact}`](#log2)函数，因为它更省油。

:::

## log2

```tact
fun log2(num: Int)：Int；
```

类似于 [`log(){:tact}`](#log)，但将 `base` 设为 $2$。

使用示例

```tact
log2(1024); // 10，因为 2^10 是 1024
// ↑ ↑
// num base₂ num
```

:::note

  为了减少 gas 用量，当您只需要获取以 $2$为底的对数时，最好使用该函数，而不是调用 [`log(){:tact}`](#log)。

:::

## pow

```tact
fun pow(base: Int, exp: Int)：Int；
```

计算并返回涉及两个数的 [幂级数](https://en.wikipedia.org/wiki/Exponentiation)："基数 "和指数（或_幂_）"exp"。 指数 `exp` 必须是非负数，否则将产生[退出代码 5](/zh-cn/book/exit-codes#5)错误：`整数超出预期范围`。

请注意，该函数在运行时和［编译时］（/ref/core-comptime）均有效。

使用示例

```tact
contract Example {
    // 持久状态变量
    p23: Int = pow(2, 3); // 将 2 提升到三次幂，即 8
    one：Int = pow(5, 0); // 将 5 提升到 0 的幂次，总是产生 1
                          // 在编译时工作！

    // 内部消息接收器，接受消息 ExtMsg
    receive() {
        pow(self.p23, self.one + 1); // 64，运行时也有效！
        pow(0, -1); // ERROR！退出代码 5：整数超出预期范围
    }
}
```

:::note

  注意，如果只需要获取 $2$的幂，请使用 [`pow2(){:tact}`](#pow2)函数，因为它更省油。

:::

:::note

  仅在编译时有效的函数列表：[API 编译时间](/zh-cn/ref/core-comptime)。

:::

## pow2

```tact
fun pow2(exp: Int)：Int；
```

与 [`pow(){:tact}`](#pow) 类似，但将 `base` 设为 $2$。 在运行时和［编译时］（/ref/core-comptime）均可使用。

使用示例

```tact
contract Example {
    // 持久状态变量
    p23: Int = pow2(3); // 将 2 提升到三次幂，即 8
    one：Int = pow2(0); // 将 2 提升到 0 的幂，总是产生 1
                        // 在编译时工作！

    // 内部消息接收器，接受消息 ExtMsg
    receive() {
        pow2(self.one + 1); // 4，运行时也有效！
        pow2(-1); // ERROR！退出代码 5：整数超出预期范围
    }
}
```

:::note

  为了减少 gas 用量，当您只需要获取 $2$的幂时，最好使用该函数，而不是调用 [`pow(){:tact}`](#pow) 。

:::

:::note

  仅在编译时有效的函数列表：[API 编译时间](/zh-cn/ref/core-comptime)。

:::

## checkSignature

```tact
fun checkSignature(hash: Int, signature: Slice, public_key: Int)：Bool；
```

使用由 $256$-bit unsigned [`Int{:tact}`][int]表示的 "公钥 "检查 $256$-bit unsigned [`Int{:tact}`][int]"哈希 "的[Ed25519][ed]"签名"。 签名必须包含至少 $512$ 位数据，但只使用前 $512$ 位。

如果签名有效，则返回 `true{:tact}`，否则返回 `false{:tact}`。

使用示例

```tact {19-24}
message ExtMsg {
    signature：Slice;
    data：Cell;
}

contract Showcase {
    // Persistent state variables
    pub：Int as uint256; // 公钥为 256 位无符号 Int

    // 构造函数 init()，初始化所有变量
    init(pub: Int) {
        self.pub = pub; // 契约初始化时存储公钥
    } // 外部消息接收器接受消息 ExtMsg

    // 外部消息接收器，接受消息 ExtMsg
    external(msg: ExtMsg) {
        let hash：Int = beginCell().storeRef(msg.data).endCell().hash();
        let check：Bool = checkSignature(hash, msg.signature, self.pub);
        // ---- ------------- --------
        // ↑ ↑
        // | | public_key，存储在我们的合约中
        // | signature，从接收到的消息中获取
        // hash，使用接收到的消息中的数据计算
        // ... 后续逻辑...
    }
}
```

## checkDataSignature

```tact
fun checkDataSignature(data: Slice, signature: Slice, public_key: Int)：Bool；
```

使用 "公钥 "检查 "数据 "的[Ed25519][ed]"签名"，类似于[`checkSignature(){:tact}`](#checksignature)。 如果 `data` 的位长不能被 $8$整除，该函数将产生错误[退出代码 9](/zh-cn/book/exit-codes#9)：单元格下溢。 验证本身是间接进行的：根据 "数据 "的[SHA-256][sha-2] 哈希值进行验证。

如果签名有效，则返回 `true{:tact}`，否则返回 `false{:tact}`。

使用示例

```tact
让 data：Slice = ...;
let signature：Slice = ...;
let publicKey：Int = ...;

let check：Bool = checkSignature(data, signature, publicKey)；
```

## sha256

```tact
fun sha256(data: Slice)：
fun sha256(data: String)：Int；
```

从传递的 [`片{:tact}`][片] 或 [`字符串{:tact}`][p]`数据`计算[SHA-256][sha-2] 哈希值，并以 $256$-bit 无符号 [`Int{:tact}`][int]的形式返回。

如果 `data` 是一个 [`字符串{:tact}`][p]，它的位数应能被 $8$除，如果它是一个 [`片{:tact}`][片]，它也必须\*\*\*没有引用（即总共最多只有 1023 位数据）。

该函数尽可能在 [编译时](/zh-cn/ref/core-comptime) 解析常量字符串值。

使用示例

```tact
sha256(beginCell().asSlice());
sha256("Hello, world!"); // 将在编译时解析
sha256(someVariableElsewhere); // 将尝试在编译时解析，
                               // 并回退到运行时评估
```

[p]: /zh-cn/book/types#primitive-types
[bool]: /zh-cn/book/types#booleans
[int]: /zh-cn/book/integers
[一片]: /zh-cn/book/cells#slices
[编辑]: https://en.wikipedia.org/wiki/EdDSA#Ed25519
[屏蔽-2]: https://en.wikipedia.org/wiki/SHA-2#Hash_standard


## core-random.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-random.mdx)
---
title: 随机数生成
---

为 Tact 智能合约生成随机数。

## random

```tact
fun random(min: Int, max: Int)：Int；
```

在提供的半封闭区间内生成并返回一个新的伪随机无符号 [`Int{:tact}`][int]值 `x`: `min` $≤$ `x` $<$ `max` or `min` $≥$ `x` $>$ `max`, 如果 `min` 和 `max` 都是负值。 注意，"最大 "值从不包含在区间内。

使用示例

```tact
random(42, 43); // 42, always
random(0, 42); // 0-41, but never a 42
```

## randomInt

```tact
fun randomInt()：Int；
```

生成并返回一个新的伪随机无符号 $256$-bit [`Int{:tact}`][int]值 `x`。

该算法的工作原理如下：如果 `r` 是被视为 $32$-字节数组（通过构建无符号 $256$-位 [`Int{:tact}`][int]的 big-endian 表示）的随机种子的旧值，则计算其 `sha512(r){:tact}`。 哈希值的前 $32$ 字节作为随机种子的新值 `r'` 存储，其余 $32$ 字节作为下一个随机值 `x` 返回。

使用示例

```tact
let allYourRandomBelongsToUs：Int = randomInt(); // ????, it's random :)
```

:::caution

  用于处理随机数的高级函数列在一个专门页面上：[高级应用程序接口](/zh-cn/ref/core-advanced)。

:::

[int]: /zh-cn/book/integers


## core-strings.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/core-strings.mdx)
---
title: 字符串和字符串构造器
---

字符串是不可更改的字符序列，这意味着 [`字符串{:tact}`][p]一旦创建，就不能更改。 字符串可用于存储文本，因此可将其转换为[`单元格{:tact}`][单元格]类型，用作信息体。

要以省 gas 的方式连接字符串，请使用 [`字符串生成器{:tact}`][p]。

要直接使用 [`字符串{:tact}`][p]字面量，请参阅：[字符串字面量](/zh-cn/book/expressions#string-literals)。

## beginString

```tact
fun beginString()：StringBuilder；
```

创建并返回空 [`StringBuilder{:tact}`][p]。

使用示例

```tact
让 fizz：StringBuilder = beginString()；
```

## 开始评论

```tact
fun beginComment()：StringBuilder；
```

创建并返回一个空的 [`字符串生成器{:tact}`][p]，用于生成注释字符串，并在生成的 [`字符串{:tact}`][p]前加上四个空字节。 这种格式用于传递文本注释作为报文正文。

使用示例

```tact
让 fizz：StringBuilder = beginComment()；
```

## beginTailString

```tact
fun beginTailString()：StringBuilder；
```

创建并返回一个空的 [`字符串生成器{:tact}`][p]，用于生成尾字符串，并在生成的 [`字符串{:tact}`][p]前加上一个空字节。 这种格式在 NFT 或 Jetton 等各种标准中都有使用。

使用示例

```tact
让 fizz：StringBuilder = beginTailString()；
```

## beginStringFromBuilder

```tact
fun beginStringFromBuilder(b: StringBuilder)：StringBuilder；
```

从现有的 [`字符串生成器{:tact}`][p] `b` 创建并返回一个新的 [`字符串生成器{:tact}`][p]。 当您需要将现有的 [`字符串{:tact}`][p]序列化为 [`单元格{:tact}`][单元格]，并加上一些其他数据时非常有用。

使用示例

```tact
让 fizz：StringBuilder = beginStringFromBuilder(beginString())；
```

## StringBuilder.append

```tact
extends mutates fun append(self: StringBuilder, s: String)；
```

用于 [`StringBuilder{:tact}`][p]的扩展突变函数。

将 [`String{:tact}`][p] `s` 追加到 [`StringBuilder{:tact}`][p]。

使用示例

```tact
让 fizz：StringBuilder = beginString();
fizz.append("oh");
fizz.append("my");
fizz.append("Tact!")；
```

## StringBuilder.concat

```tact
extends fun concat(self: StringBuilder, s: String)：StringBuilder；
```

[`字符串生成器{:tact}`][p]的扩展函数。

与 [`字符串{:tact}`][p] `s` 连接后，返回一个新的 [`字符串构造器{:tact}`][p]。 与 [`StringBuilder.append(){:tact}`](#stringbuilderappend)不同，可以进行链式操作。

使用示例

```tact
让 fizz：StringBuilder = beginString()
    .concat("oh")
    .concat("my")
    .concat("Tact!")；
```

## StringBuilder.toString

```tact
extends fun toString(self: StringBuilder)：String；
```

[`字符串生成器{:tact}`][p]的扩展函数。

返回从 [`字符串生成器{:tact}`][p]构建的 [`字符串{:tact}`][p]。

使用示例

```tact
让 fizz：StringBuilder = beginString();
let buzz：String = fizz.toString()；
```

## StringBuilder.toCell

```tact
extends fun toCell(self: StringBuilder)：Cell；
```

[`字符串生成器{:tact}`][p]的扩展函数。

返回由 [`字符串生成器{:tact}`][p]组装的 [`单元格{:tact}`][单元格]。

使用示例

```tact
让 fizz：StringBuilder = beginString();
let buzz：Cell = fizz.toCell()；
```

## StringBuilder.toSlice

```tact
extends fun toSlice(self: StringBuilder)：Slice；
```

[`字符串生成器{:tact}`][p]的扩展函数。

从 [`StringBuilder{:tact}`][p]返回一个组装好的 [`单元格{:tact}`][单元格] 作为 [`片{:tact}`][片]。 别名为 [`self.toCell().asSlice(){:tact}`](/zh-cn/ref/core-cells#cellasslice)。

使用示例

```tact
让 s：StringBuilder = beginString();
let fizz：Slice = s.toSlice();
let buzz：Slice = s.toCell().asSlice();

fizz == buzz; // true
```

## String.asSlice

```tact
extends fun asSlice(self: String)：Slice；
```

[`字符串{:tact}`][p]的扩展函数。

从[`字符串{:tact}`][p]返回一个[`片{:tact}`][slice]，方法是尝试将其所有位打包到一个连续的[单元格][p]列表中，每个单元格引用下一个单元格，并为将来的解析打开所有单元格。

请注意，[`片{:tact}`][片]中没有说明特定字符可能占用多少字节，也没有说明引用列表的深度，因此只有在知道自己在做什么的情况下才能使用该函数。

使用示例

```tact
让 s：String = "It's alive！It's alive!!!";
let fizz：Slice = s.asSlice();
let buzz：Slice = s.asSlice().asString().asSlice();

fizz == buzz; // true, 但要小心，因为并非总是如此。
```

:::note

  查看 `String.asSlice{:tact}` 函数如何实际使用：[如何将 `String` 转换为 `Int`](/zh-cn/cookbook/type-conversion#how-to-convert-a-string-to-an-int).

:::

## String.asComment

```tact
extends fun asComment(self: String)：Cell；
```

[`字符串{:tact}`][p]的扩展函数。

从[`字符串{:tact}`][p]返回一个[`单元格{:tact}`][单元格]，在后者的前缀加上四个空字节。 这种格式用于传递文本注释作为报文正文。

使用示例

```tact
让 s：String = "When life gives you lemons, call them 'yellow oranges' and sell them for double the price.";
let fizz：Cell = s.asComment();

let b: StringBuilder = beginComment();
b.append(s);
let buzz：Cell = b.toCell();

fizz == buzz; // true
```

## String.fromBase64

```tact
extends fun fromBase64(self: String)：Slice；
```

[`字符串{:tact}`][p]的扩展函数。

从解码后的 [Base64](https://en.wikipedia.org/wiki/Base64) [`String{:tact}`][p] 中返回 [`片{:tact}`][片]。别名为 `self.asSlice().fromBase64(){:tact}`。

请注意，该函数是有限制的，只能从给定的 [`字符串{:tact}`][p] 中获取前 $1023$ 位数据，当 [`字符串{:tact}`][p] 较大（即包含超过 $1023$ 位数据）时，不会抛出异常。

如果给定的 [`String{:tact}`][p] 包含不属于 Base64 集的字符，则会出现[退出代码 134](/zh-cn/book/exit-codes#134)异常："无效参数"。

使用示例

```tact
让 s：String = "SGVyZSdzIEpvaG5ueSE=";
let fizz：Slice = s.fromBase64();
let buzz：Slice = s.asSlice().fromBase64();

fizz == buzz; // true
```

## Slice.asString

```tact
extends fun asString(self: Slice)：String；
```

[`切片{:tact}`][切片]的扩展函数。

从 [`字符串{:tact}`][p]返回一个[`字符串{:tact}`][片]，方法是尝试加载它的所有位，而不查找它的引用（如果有的话）。

请注意，该函数根本不查看引用，而且会将输出截断到 $1023$ 位，因此只有在知道自己在做什么的情况下才使用它。

使用示例

```tact
让 s：String = "Keep your Slices close, but your Strings closer.";
let fizz：String = s;
let buzz：String = s.asSlice().asString();

fizz == buzz; // true，但要小心，因为并非总是如此。
```

## Slice.fromBase64

```tact
extends fun fromBase64(self: Slice)：Slice；
```

[`切片{:tact}`][切片]的扩展函数。

从解码后的 [Base64](https://en.wikipedia.org/wiki/Base64) [`Slice{:tact}`][slice]返回一个新的 [`片{:tact}`][片]。

请注意，该函数是有限制的，只能从给定的 [`片{:tact}`][片] 中获取前 $1023$ 位数据，如果 [`片{:tact}`][片] 有更多数据（即有任何引用），则不会抛出异常。

如果给定的 [`Slice{:tact}`][p]包含不属于 Base64 集的字符，将产生[退出代码 134](/zh-cn/book/exit-codes#134)异常："无效参数"。

使用示例

```tact
让 s：Slice = "SSBhbSBHcm9vdC4=".asSlice();
let fizz：Slice = s.fromBase64()；
```

## Int.toString

```tact
extends fun toString(self: Int)：String；
```

[`Int{:tact}`][int]的扩展函数。

从 [`Int{:tact}`][int]值返回 [`String{:tact}`][p]。

使用示例

```tact
让 fizz：String = (84 - 42).toString()；
```

## Int.toFloatString

```tact
extends fun toFloatString(self: Int, digits: Int)：String；
```

[`Int{:tact}`][int]的扩展函数。

使用小数的[定点表示](https://en.wikipedia.org/wiki/Fixed-point_arithmetic)从[`Int{:tact}`][int]值返回[`String{:tact}`][p]，其中`self`是数字的有效部分，`digits`是小数部分的位数。

更确切地说，"digits "是 $10^{-\mathrm{digits}}$ 表达式的指数化参数，它给出了实际 [`Int{:tact}`][int]值乘以后所代表的小数。 参数 `digits` 必须在封闭区间内：$0 <$ `digits` $< 78$，否则会出现 [exit code 134](/zh-cn/book/exit-codes#134)异常："无效参数"。

使用示例

```tact
let fizz：String = (42).toFloatString(9); // "0.000000042"
```

## Int.toCoinsString

```tact
extends fun toCoinsString(self: Int)：String；
```

[`Int{:tact}`][int]的扩展函数。

使用小数的[定点表示法](https://en.wikipedia.org/wiki/Fixed-point_arithmetic)从[`Int{:tact}`][int]值返回[`String{:tact}`][p]。 别名为 `self.toFloatString(9){:tact}`。

用于用字符串表示 [纳米通币](/zh-cn/book/integers#nanotoncoin) [`Int{:tact}`][int]值。

使用示例

```tact
let nanotons：Int = 42;
let fizz：String = nanotons.toCoinsString();
let buzz：String = nanotons.toFloatString(9);

fizz == buzz; // true, 两者都存储 "0.000000042"。
```

## 地址

```tact
extends fun toString(self: Address)：String；
```

[`地址{:tact}`][p]的扩展函数。

从 [`地址{:tact}`][p]返回 [`字符串{:tact}`][p]。

使用示例

```tact
让 community：Address = address("UQDpXLZKrkHsOuE_C1aS69C697wE568vTnqSeRfBXZfvmVOo");
let fizz：String = community.toString()；
```

[p]: /zh-cn/book/types#primitive-types
[bool]: /zh-cn/book/types#booleans
[int]: /zh-cn/book/integers
[电池]: /zh-cn/book/cells#cells
[一片]: /zh-cn/book/cells#slices


## index.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/index.mdx)
---
title: 参考资料概览
---

import { LinkCard, CardGrid, Steps } from '@astrojs/starlight/components';

欢迎来到 Tact 文档的**参考资料**部分，这里是了解 Tact 标准库、语法规范和演变过程的地方。

以下是其主要内容：

<Steps>

1. #### 核心图书馆

   [核心库](/zh-cn/ref/core-base)提供了自动包含的函数、特质和其他结构体的完整列表及其使用示例。

   <CardGrid>
     <LinkCard
       title="转到核心库"
       href="/ref/core-base"
     />
   </CardGrid>

2. #### 标准图书馆

   [标准库](/zh-cn/ref/standard-libraries) 子章节解释了如何使用捆绑的库，列出了所有库的内容及其使用示例。

   <CardGrid>
     <LinkCard
       title="转到标准库"
       href="/ref/standard-libraries"
     />
   </CardGrid>

3. #### 规格

   [规范](/zh-cn/ref/spec) 页面提供了用欧姆语言编写的完整 Tact 语法，该语法用于 Tact 的编译器。 面向更有经验的程序员，但通常仍能非常方便地快速掌握该语言的所有可能语法。

   <CardGrid>
     <LinkCard
       title="转到规范"
       href="/ref/spec"
     />
   </CardGrid>

4. #### 演变

   最后，[Evolution](/zh-cn/ref/evolution/overview) 子章节介绍了有关语言语义的重要决定、Tact 的未来以及 Tact 更新日志的链接。

   <CardGrid>
     <LinkCard
       title="Go to the Evolution"
       href="/ref/evolution/overview"
     />
   </CardGrid>

</Steps>


## spec.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/spec.mdx)
---
title: Tact 规格
pagefind: false
---

:::danger[Not 已实施]
  在 [#76](https://github.com/tact-lang/tact-docs/issues/76) 实现之前，本页主要是一个存根。
:::

其编译器中使用的战术语法是用[欧姆语言](https://ohmjs.org)编写的，该语言基于[解析表达式语法](http://en.wikipedia.org/wiki/Parsing_expression_grammar) (PEG)，是一种描述语法的形式化方法，类似于正则表达式和无上下文语法。

{/*
    这是一条注释，在页面上是隐藏的。

    Shiki 通过 TextMate 语法对 Ohm 的高亮处理效果不佳，尽管在 VSCode 中表现良好。我认为原因可能是 Shiki 逐行高亮或使用了不同的正则表达式引擎。我不确定具体问题在哪里，所以在修复之前，最好使用 tree-sitter-ohm 并通过其 `highlight` 命令生成 ANSI 序列。然后由 Shiki 完成剩余的工作：
*/}

```ansi
[38;5;23mTact[0m [38;5;239m{[0m

    [3;38;5;245m// Starting point of the program[0m
    [38;5;26mProgram[0m [1;38;5;239m=[0m [38;5;26mProgramItem[0m[1;38;5;239m*[0m
    [38;5;26mProgramItem[0m [1;38;5;239m=[0m [38;5;26mStruct[0m
                [1;38;5;239m|[0m [38;5;26mContract[0m
                [1;38;5;239m|[0m [38;5;26mPrimitive[0m
                [1;38;5;239m|[0m [38;5;26mStaticFunction[0m
                [1;38;5;239m|[0m [38;5;26mNativeFunction[0m
                [1;38;5;239m|[0m [38;5;26mProgramImport[0m
                [1;38;5;239m|[0m [38;5;26mTrait[0m
                [1;38;5;239m|[0m [38;5;26mConstant[0m
    [38;5;26mProgramImport[0m [1;38;5;239m=[0m [38;5;26mimport[0m [38;5;26mstringLiteral[0m [38;5;28m";"[0m

    [3;38;5;245m// Built-in declarations[0m
    [38;5;26mPrimitive[0m [1;38;5;239m=[0m [38;5;28m"primitive"[0m [38;5;26mType[0m [38;5;28m";"[0m

    [3;38;5;245m// Static function[0m
    [38;5;26mStaticFunction[0m [1;38;5;239m=[0m [38;5;26mFunction[0m
    [38;5;26mNativeFunction[0m [1;38;5;239m=[0m [38;5;26mnameAttribute[0m [38;5;28m"("[0m [38;5;26mfuncId[0m [38;5;28m")"[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mnative[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m";"[0m [3;38;5;124m--withVoid[0m
                   [1;38;5;239m|[0m [38;5;26mnameAttribute[0m [38;5;28m"("[0m [38;5;26mfuncId[0m [38;5;28m")"[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mnative[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m";"[0m [3;38;5;124m--withType[0m

    [3;38;5;245m// Field declarations[0m
    [38;5;26mType[0m [1;38;5;239m=[0m [38;5;26mtypeLiteral[0m [38;5;28m"?"[0m [3;38;5;124m--optional[0m
         [1;38;5;239m|[0m [38;5;26mtypeLiteral[0m [3;38;5;124m--required[0m
         [1;38;5;239m|[0m [38;5;28m"map"[0m [38;5;28m"<"[0m [38;5;26mtypeLiteral[0m [38;5;239m([0m[38;5;26mas[0m [38;5;26mid[0m[38;5;239m)[0m[1;38;5;239m?[0m [38;5;28m","[0m [38;5;26mtypeLiteral[0m [38;5;239m([0m[38;5;26mas[0m [38;5;26mid[0m[38;5;239m)[0m[1;38;5;239m?[0m [38;5;28m">"[0m [3;38;5;124m--map[0m
         [1;38;5;239m|[0m [38;5;28m"bounced"[0m [38;5;28m"<"[0m [38;5;26mtypeLiteral[0m [38;5;28m">"[0m [3;38;5;124m--bounced[0m
    [38;5;26mField[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m";"[0m [3;38;5;124m--default[0m
          [1;38;5;239m|[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m [3;38;5;124m--defaultWithInit[0m
          [1;38;5;239m|[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;26mas[0m [38;5;26mid[0m [38;5;28m";"[0m [3;38;5;124m--withSerialization[0m
          [1;38;5;239m|[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;26mas[0m [38;5;26mid[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m [3;38;5;124m--withSerializationAndInit[0m

    [3;38;5;245m// Constant[0m
    [38;5;26mConstantAttribute[0m [1;38;5;239m=[0m [38;5;26mvirtual[0m    [3;38;5;124m--virtual[0m
                      [1;38;5;239m|[0m [38;5;26moverride[0m   [3;38;5;124m--override[0m
                      [1;38;5;239m|[0m [38;5;26mabstract[0m   [3;38;5;124m--abstract[0m
    [38;5;26mConstant[0m [1;38;5;239m=[0m [38;5;26mConstantAttribute[0m[1;38;5;239m*[0m [1;38;5;239m~[0m[38;5;26mfun[0m [38;5;26mconst[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m [3;38;5;124m--withValue[0m
             [1;38;5;239m|[0m [38;5;26mConstantAttribute[0m[1;38;5;239m*[0m [1;38;5;239m~[0m[38;5;26mfun[0m [38;5;26mconst[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m";"[0m                [3;38;5;124m--withEmpty[0m

    [3;38;5;245m// Struct[0m
    [38;5;26mStruct[0m [1;38;5;239m=[0m [38;5;28m"struct"[0m [38;5;26mtypeLiteral[0m [38;5;28m"{"[0m [38;5;26mStructBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--originary[0m
           [1;38;5;239m|[0m [38;5;28m"message"[0m [38;5;26mtypeLiteral[0m [38;5;28m"{"[0m [38;5;26mStructBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--message[0m
           [1;38;5;239m|[0m [38;5;28m"message"[0m [38;5;28m"("[0m [38;5;26mintegerLiteral[0m [38;5;28m")"[0m [38;5;26mtypeLiteral[0m [38;5;28m"{"[0m [38;5;26mStructBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--messageWithId[0m
    [38;5;26mStructBody[0m [1;38;5;239m=[0m [38;5;26mField[0m

    [3;38;5;245m// Contract[0m
    [38;5;26mContract[0m [1;38;5;239m=[0m [38;5;26mContractAttribute[0m[1;38;5;239m*[0m [38;5;26mcontract[0m [38;5;26mid[0m [38;5;28m"{"[0m [38;5;26mContractBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--simple[0m
             [1;38;5;239m|[0m [38;5;26mContractAttribute[0m[1;38;5;239m*[0m [38;5;26mcontract[0m [38;5;26mid[0m [38;5;26mwith[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mid[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m"{"[0m [38;5;26mContractBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withTraits[0m
    [38;5;26mContractInit[0m [1;38;5;239m=[0m [38;5;28m"init"[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m
    [38;5;26mContractBody[0m [1;38;5;239m=[0m [38;5;26mField[0m
                 [1;38;5;239m|[0m [38;5;26mContractInit[0m
                 [1;38;5;239m|[0m [38;5;26mReceiveFunction[0m
                 [1;38;5;239m|[0m [38;5;26mFunction[0m
                 [1;38;5;239m|[0m [38;5;26mConstant[0m

    [3;38;5;245m// Trait[0m
    [38;5;26mTrait[0m [1;38;5;239m=[0m [38;5;26mContractAttribute[0m[1;38;5;239m*[0m [38;5;26mtrait[0m [38;5;26mid[0m [38;5;28m"{"[0m [38;5;26mTraitBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--originary[0m
          [1;38;5;239m|[0m [38;5;26mContractAttribute[0m[1;38;5;239m*[0m [38;5;26mtrait[0m [38;5;26mid[0m [38;5;26mwith[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mid[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m"{"[0m [38;5;26mTraitBody[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withTraits[0m
    [38;5;26mTraitBody[0m [1;38;5;239m=[0m [38;5;26mField[0m
              [1;38;5;239m|[0m [38;5;26mReceiveFunction[0m
              [1;38;5;239m|[0m [38;5;26mFunction[0m
              [1;38;5;239m|[0m [38;5;26mConstant[0m

    [3;38;5;245m// Contract attributes[0m
    [38;5;26mContractAttribute[0m [1;38;5;239m=[0m [38;5;28m"@interface"[0m [38;5;28m"("[0m [38;5;26mstringLiteral[0m [38;5;28m")"[0m [3;38;5;124m--interface[0m

    [3;38;5;245m// Function[0m
    [38;5;26mFunctionAttribute[0m [1;38;5;239m=[0m [38;5;28m"get"[0m     [3;38;5;124m--getter[0m
                      [1;38;5;239m|[0m [38;5;26mmutates[0m   [3;38;5;124m--mutates[0m
                      [1;38;5;239m|[0m [38;5;26mextends[0m   [3;38;5;124m--extends[0m
                      [1;38;5;239m|[0m [38;5;26mvirtual[0m   [3;38;5;124m--virtual[0m
                      [1;38;5;239m|[0m [38;5;26moverride[0m  [3;38;5;124m--override[0m
                      [1;38;5;239m|[0m [38;5;26minline[0m    [3;38;5;124m--inline[0m
                      [1;38;5;239m|[0m [38;5;26mabstract[0m  [3;38;5;124m--abstract[0m
    [38;5;26mFunction[0m [1;38;5;239m=[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mfun[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withVoid[0m
             [1;38;5;239m|[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mfun[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withType[0m
             [1;38;5;239m|[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mfun[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m";"[0m [3;38;5;124m--abstractVoid[0m
             [1;38;5;239m|[0m [38;5;26mFunctionAttribute[0m[1;38;5;239m*[0m [38;5;26mfun[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mFunctionArg[0m[38;5;239m,[0m[38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m";"[0m [3;38;5;124m--abstractType[0m
    [38;5;26mFunctionArg[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m

    [38;5;26mReceiveFunction[0m [1;38;5;239m=[0m [38;5;28m"receive"[0m [38;5;28m"("[0m [38;5;26mFunctionArg[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--simple[0m
                    [1;38;5;239m|[0m [38;5;28m"receive"[0m [38;5;28m"("[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--empty[0m
                    [1;38;5;239m|[0m [38;5;28m"receive"[0m [38;5;28m"("[0m [38;5;26mstringLiteral[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--comment[0m
                    [1;38;5;239m|[0m [38;5;28m"bounced"[0m [38;5;28m"("[0m [38;5;26mFunctionArg[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--bounced[0m
                    [1;38;5;239m|[0m [38;5;28m"external"[0m [38;5;28m"("[0m [38;5;26mFunctionArg[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--externalSimple[0m
                    [1;38;5;239m|[0m [38;5;28m"external"[0m [38;5;28m"("[0m [38;5;26mstringLiteral[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--externalComment[0m
                    [1;38;5;239m|[0m [38;5;28m"external"[0m [38;5;28m"("[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--externalEmpty[0m

    [3;38;5;245m// Statements[0m
    [38;5;26mStatement[0m [1;38;5;239m=[0m [38;5;26mStatementLet[0m
              [1;38;5;239m|[0m [38;5;26mStatementBlock[0m
              [1;38;5;239m|[0m [38;5;26mStatementReturn[0m
              [1;38;5;239m|[0m [38;5;26mStatementExpression[0m
              [1;38;5;239m|[0m [38;5;26mStatementAssign[0m
              [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssign[0m
              [1;38;5;239m|[0m [38;5;26mStatementCondition[0m
              [1;38;5;239m|[0m [38;5;26mStatementWhile[0m
              [1;38;5;239m|[0m [38;5;26mStatementRepeat[0m
              [1;38;5;239m|[0m [38;5;26mStatementUntil[0m
    [38;5;26mStatementBlock[0m [1;38;5;239m=[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m
    [38;5;26mStatementLet[0m [1;38;5;239m=[0m [38;5;26mlet[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mType[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementReturn[0m [1;38;5;239m=[0m [38;5;26mreturn[0m [38;5;26mExpression[0m [38;5;28m";"[0m [3;38;5;124m--withExpression[0m
                    [1;38;5;239m|[0m [38;5;26mreturn[0m [38;5;28m";"[0m [3;38;5;124m--withoutExpression    [0m
    [38;5;26mStatementExpression[0m [1;38;5;239m=[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAssign[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssign[0m [1;38;5;239m=[0m [38;5;26mStatementAugmentedAssignAdd[0m
                             [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssignSub[0m
                             [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssignMul[0m
                             [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssignDiv[0m
                             [1;38;5;239m|[0m [38;5;26mStatementAugmentedAssignRem[0m
    [38;5;26mStatementAugmentedAssignAdd[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"+="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssignSub[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"-="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssignMul[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"*="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssignDiv[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"/="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementAugmentedAssignRem[0m [1;38;5;239m=[0m [38;5;26mLValue[0m [38;5;28m"%="[0m [38;5;26mExpression[0m [38;5;28m";"[0m
    [38;5;26mStatementCondition[0m [1;38;5;239m=[0m [38;5;26mif[0m [38;5;26mExpression[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [1;38;5;239m~[0m[38;5;26melse[0m [3;38;5;124m--simple[0m
                       [1;38;5;239m|[0m [38;5;26mif[0m [38;5;26mExpression[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [38;5;26melse[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [3;38;5;124m--withElse[0m
                       [1;38;5;239m|[0m [38;5;26mif[0m [38;5;26mExpression[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [38;5;26melse[0m [38;5;26mStatementCondition[0m [3;38;5;124m--withElseIf[0m
    [38;5;26mStatementWhile[0m [1;38;5;239m=[0m [38;5;26mwhile[0m [38;5;28m"("[0m [38;5;26mExpression[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m
    [38;5;26mStatementRepeat[0m [1;38;5;239m=[0m [38;5;26mrepeat[0m [38;5;28m"("[0m [38;5;26mExpression[0m [38;5;28m")"[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m
    [38;5;26mStatementUntil[0m [1;38;5;239m=[0m [38;5;26mdo[0m [38;5;28m"{"[0m [38;5;26mStatement[0m[1;38;5;239m*[0m [38;5;28m"}"[0m [38;5;26muntil[0m [38;5;28m"("[0m [38;5;26mExpression[0m [38;5;28m")"[0m [38;5;28m";"[0m

    [3;38;5;245m// L-value[0m
    [38;5;26mLValue[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m"."[0m [38;5;26mLValue[0m [3;38;5;124m--more[0m
           [1;38;5;239m|[0m [38;5;26mid[0m [3;38;5;124m--single[0m

    [3;38;5;245m// Expressions[0m
    [38;5;26mExpression[0m [1;38;5;239m=[0m [38;5;26mExpressionConditional[0m
    [38;5;26mExpressionConditional[0m [1;38;5;239m=[0m [38;5;26mExpressionOr[0m [38;5;28m"?"[0m [38;5;26mExpressionOr[0m [38;5;28m":"[0m [38;5;26mExpressionConditional[0m [3;38;5;124m--ternary[0m
                          [1;38;5;239m|[0m [38;5;26mExpressionOr[0m
    [38;5;26mExpressionOr[0m [1;38;5;239m=[0m [38;5;26mExpressionOr[0m [38;5;28m"||"[0m [38;5;26mExpressionAnd[0m [3;38;5;124m--or[0m
                 [1;38;5;239m|[0m [38;5;26mExpressionAnd[0m
    [38;5;26mExpressionAnd[0m [1;38;5;239m=[0m [38;5;26mExpressionAnd[0m [38;5;28m"&&"[0m [38;5;26mExpressionCompare[0m [3;38;5;124m--and[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m
    [38;5;26mExpressionCompare[0m [1;38;5;239m=[0m [38;5;26mExpressionCompare[0m [38;5;28m"!="[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--not[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m"=="[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--eq[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m">"[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--gt[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m">="[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--gte[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m"<"[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--lt[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionCompare[0m [38;5;28m"<="[0m [38;5;26mExpressionBinary[0m [3;38;5;124m--lte[0m
                      [1;38;5;239m|[0m [38;5;26mExpressionBinary[0m
    [38;5;26mExpressionBinary[0m [1;38;5;239m=[0m [38;5;26mExpressionBinary[0m [38;5;28m">>"[0m [38;5;26mExpressionAdd[0m [3;38;5;124m--shr[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionBinary[0m [38;5;28m"<<"[0m [38;5;26mExpressionAdd[0m [3;38;5;124m--shl[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionBinary[0m [38;5;28m"&"[0m [38;5;26mExpressionAdd[0m [3;38;5;124m--bin_and[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionBinary[0m [38;5;28m"|"[0m [38;5;26mExpressionAdd[0m [3;38;5;124m--bin_or[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionAdd[0m
    [38;5;26mExpressionAdd[0m [1;38;5;239m=[0m [38;5;26mExpressionAdd[0m [38;5;28m"+"[0m [1;38;5;239m~[0m[38;5;28m"+"[0m [38;5;26mExpressionMul[0m [3;38;5;124m--add[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionAdd[0m [38;5;28m"-"[0m [1;38;5;239m~[0m[38;5;28m"-"[0m [38;5;26mExpressionMul[0m [3;38;5;124m--sub[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionMul[0m
    [38;5;26mExpressionMul[0m [1;38;5;239m=[0m [38;5;26mExpressionMul[0m [38;5;28m"*"[0m [38;5;26mExpressionUnary[0m [3;38;5;124m--mul[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionMul[0m [38;5;28m"/"[0m [38;5;26mExpressionUnary[0m [3;38;5;124m--div[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionMul[0m [38;5;28m"%"[0m [38;5;26mExpressionUnary[0m [3;38;5;124m--rem[0m
                  [1;38;5;239m|[0m [38;5;26mExpressionUnary[0m
    [38;5;26mExpressionUnary[0m [1;38;5;239m=[0m [38;5;28m"-"[0m [38;5;26mExpressionUnarySuffix[0m [3;38;5;124m--neg[0m
                    [1;38;5;239m|[0m [38;5;28m"+"[0m [38;5;26mExpressionUnarySuffix[0m [3;38;5;124m--add[0m
                    [1;38;5;239m|[0m [38;5;28m"!"[0m [38;5;26mExpressionUnarySuffix[0m [3;38;5;124m--not[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionUnarySuffix[0m
    [38;5;26mExpressionUnarySuffix[0m [1;38;5;239m=[0m [38;5;26mExpressionValue[0m [38;5;28m"!!"[0m [3;38;5;124m--notNull[0m
                          [1;38;5;239m|[0m [38;5;26mExpressionValue[0m
    [38;5;26mExpressionBracket[0m [1;38;5;239m=[0m [38;5;28m"("[0m [38;5;26mExpression[0m [38;5;28m")"[0m

    [3;38;5;245m// Order is important[0m
    [38;5;26mExpressionValue[0m [1;38;5;239m=[0m [38;5;26mExpressionCall[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionField[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionStaticCall[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionBracket[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionNew[0m
                    [1;38;5;239m|[0m [38;5;26mintegerLiteral[0m
                    [1;38;5;239m|[0m [38;5;26mboolLiteral[0m
                    [1;38;5;239m|[0m [38;5;26mid[0m
                    [1;38;5;239m|[0m [38;5;26mnull[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionInitOf[0m
                    [1;38;5;239m|[0m [38;5;26mExpressionString[0m
    [38;5;26mExpressionString[0m [1;38;5;239m=[0m [38;5;26mstringLiteral[0m
    [38;5;26mExpressionField[0m [1;38;5;239m=[0m [38;5;26mExpressionValue[0m [38;5;28m"."[0m [38;5;26mid[0m [1;38;5;239m~[0m[38;5;28m"("[0m
    [38;5;26mExpressionCall[0m [1;38;5;239m=[0m [38;5;26mExpressionValue[0m [38;5;28m"."[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mExpression[0m[38;5;239m,[0m [38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m
    [38;5;26mExpressionNew[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m"{"[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mNewParameter[0m[38;5;239m,[0m [38;5;28m","[0m[38;5;239m>[0m [38;5;28m"}"[0m
    [38;5;26mNewParameter[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m":"[0m [38;5;26mExpression[0m
    [38;5;26mExpressionStaticCall[0m [1;38;5;239m=[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mExpression[0m[38;5;239m,[0m [38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m
    [38;5;26mExpressionInitOf[0m [1;38;5;239m=[0m [38;5;26minitOf[0m [38;5;26mid[0m [38;5;28m"("[0m [1;38;5;26mListOf[0m[38;5;239m<[0m[38;5;26mExpression[0m[38;5;239m,[0m [38;5;28m","[0m[38;5;239m>[0m [38;5;28m")"[0m

    [3;38;5;245m// Type Literal[0m
    [38;5;26mtypeLiteral[0m [1;38;5;239m=[0m [38;5;26mletterAsciiUC[0m [38;5;26mtypeLiteralPart[0m[1;38;5;239m*[0m
    [38;5;26mtypeLiteralPart[0m [1;38;5;239m=[0m [38;5;26mletterAscii[0m [1;38;5;239m|[0m [1;38;5;26mdigit[0m [1;38;5;239m|[0m [38;5;28m"_"[0m

    [3;38;5;245m// Integer Literal[0m
    [3;38;5;245m// hexDigit defined in Ohm's built-in rules (otherwise: hexDigit = "0".."9" | "a".."f" | "A".."F")[0m
    [3;38;5;245m// digit defined in Ohm's built-in rules (otherwise: digit = "0".."9")[0m
    [38;5;26mintegerLiteral[0m [1;38;5;239m=[0m [38;5;26mintegerLiteralHex[0m [1;38;5;239m|[0m [38;5;26mintegerLiteralBin[0m [1;38;5;239m|[0m [38;5;26mintegerLiteralOct[0m [1;38;5;239m|[0m [38;5;26mintegerLiteralDec[0m [3;38;5;245m// Order is important[0m
    [38;5;26mintegerLiteralDec[0m [1;38;5;239m=[0m [38;5;26mnonZeroDigit[0m [38;5;239m([0m[38;5;28m"_"[0m[1;38;5;239m?[0m [1;38;5;26mdigit[0m[38;5;239m)[0m[1;38;5;239m*[0m  [3;38;5;124m--nonZeroIntegerLiteralDec[0m
                      [1;38;5;239m|[0m [38;5;28m"0"[0m [1;38;5;26mdigit[0m[1;38;5;239m*[0m                  [3;38;5;124m--integerLiteralWithLeadingZero[0m
    [38;5;26mintegerLiteralHex[0m [1;38;5;239m=[0m [38;5;239m([0m[38;5;28m"0x"[0m [1;38;5;239m|[0m [38;5;28m"0X"[0m[38;5;239m)[0m [1;38;5;26mhexDigit[0m [38;5;239m([0m[38;5;28m"_"[0m[1;38;5;239m?[0m [1;38;5;26mhexDigit[0m[38;5;239m)[0m[1;38;5;239m*[0m
    [38;5;26mintegerLiteralBin[0m [1;38;5;239m=[0m [38;5;239m([0m[38;5;28m"0b"[0m [1;38;5;239m|[0m [38;5;28m"0B"[0m[38;5;239m)[0m [38;5;26mbinDigit[0m [38;5;239m([0m[38;5;28m"_"[0m[1;38;5;239m?[0m [38;5;26mbinDigit[0m[38;5;239m)[0m[1;38;5;239m*[0m
    [38;5;26mintegerLiteralOct[0m [1;38;5;239m=[0m [38;5;239m([0m[38;5;28m"0o"[0m [1;38;5;239m|[0m [38;5;28m"0O"[0m[38;5;239m)[0m [38;5;26moctDigit[0m [38;5;239m([0m[38;5;28m"_"[0m[1;38;5;239m?[0m [38;5;26moctDigit[0m[38;5;239m)[0m[1;38;5;239m*[0m
    [38;5;26mbinDigit[0m [1;38;5;239m=[0m [38;5;28m"0"[0m [1;38;5;239m|[0m [38;5;28m"1"[0m
    [38;5;26moctDigit[0m [1;38;5;239m=[0m [38;5;28m"0"[0m[1;38;5;239m..[0m[38;5;28m"7"[0m
    [38;5;26mnonZeroDigit[0m [1;38;5;239m=[0m [38;5;28m"1"[0m[1;38;5;239m..[0m[38;5;28m"9"[0m

    [3;38;5;245m// Letters[0m
    [38;5;26mletterAsciiLC[0m [1;38;5;239m=[0m [38;5;28m"a"[0m[1;38;5;239m..[0m[38;5;28m"z"[0m
    [38;5;26mletterAsciiUC[0m [1;38;5;239m=[0m [38;5;28m"A"[0m[1;38;5;239m..[0m[38;5;28m"Z"[0m
    [38;5;26mletterAscii[0m [1;38;5;239m=[0m [38;5;26mletterAsciiLC[0m [1;38;5;239m|[0m [38;5;26mletterAsciiUC[0m
    [38;5;26mletterComment[0m [1;38;5;239m=[0m [38;5;26mletterAsciiLC[0m [1;38;5;239m|[0m [38;5;26mletterAsciiUC[0m [1;38;5;239m|[0m [1;38;5;26mdigit[0m [1;38;5;239m|[0m [38;5;28m"_"[0m

    [3;38;5;245m// ID Literal[0m
    [38;5;26midStart[0m [1;38;5;239m=[0m [38;5;26mletterAscii[0m [1;38;5;239m|[0m [38;5;28m"_"[0m
    [38;5;26midPart[0m [1;38;5;239m=[0m [38;5;26mletterAscii[0m [1;38;5;239m|[0m [1;38;5;26mdigit[0m [1;38;5;239m|[0m [38;5;28m"_"[0m
    [38;5;26mid[0m [1;38;5;239m=[0m [1;38;5;239m~[0m[38;5;26mreservedWord[0m [1;38;5;239m#[0m[38;5;26midStart[0m [1;38;5;239m#[0m[38;5;239m([0m[38;5;26midPart[0m[1;38;5;239m*[0m[38;5;239m)[0m

    [3;38;5;245m// FunC id[0m
    [38;5;26mfuncLetter[0m [1;38;5;239m=[0m [38;5;26mletterAscii[0m [1;38;5;239m|[0m [38;5;28m"_"[0m [1;38;5;239m|[0m [38;5;28m"'"[0m [1;38;5;239m|[0m [38;5;28m"?"[0m [1;38;5;239m|[0m [38;5;28m"!"[0m [1;38;5;239m|[0m [38;5;28m"::"[0m [1;38;5;239m|[0m [38;5;28m"&"[0m
    [38;5;26mfuncId[0m [1;38;5;239m=[0m [38;5;26mfuncLetter[0m [1;38;5;239m#[0m[38;5;239m([0m[38;5;26mfuncLetter[0m [1;38;5;239m|[0m [1;38;5;26mdigit[0m[38;5;239m)[0m[1;38;5;239m*[0m

    [3;38;5;245m// Bool Literal[0m
    [38;5;26mboolLiteral[0m [1;38;5;239m=[0m [38;5;239m([0m[38;5;28m"true"[0m [1;38;5;239m|[0m [38;5;28m"false"[0m[38;5;239m)[0m [1;38;5;239m~[0m[38;5;26midPart[0m

    [3;38;5;245m// String literal[0m
    [38;5;26mstringLiteralCharacter[0m [1;38;5;239m=[0m [1;38;5;239m~[0m[38;5;239m([0m[38;5;28m"[0m[38;5;30m\"[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;28m"[0m[38;5;30m\\[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;26mlineTerminator[0m[38;5;239m)[0m [1;38;5;26many[0m
    [38;5;26mstringLiteral[0m [1;38;5;239m=[0m [38;5;28m"[0m[38;5;30m\"[0m[38;5;28m"[0m [38;5;26mstringLiteralCharacter[0m[1;38;5;239m*[0m [38;5;28m"[0m[38;5;30m\"[0m[38;5;28m"[0m

    [3;38;5;245m// Keywords[0m
    [3;38;5;245m// NOTE Order is important[0m
    [38;5;26mkeyword[0m [1;38;5;239m=[0m [38;5;26mfun[0m
            [1;38;5;239m|[0m [38;5;26mlet[0m
            [1;38;5;239m|[0m [38;5;26mreturn[0m
            [1;38;5;239m|[0m [38;5;26mextend[0m
            [1;38;5;239m|[0m [38;5;26mnative[0m
            [1;38;5;239m|[0m [38;5;26mpublic[0m
            [1;38;5;239m|[0m [38;5;26mnull[0m
            [1;38;5;239m|[0m [38;5;26mif[0m
            [1;38;5;239m|[0m [38;5;26melse[0m
            [1;38;5;239m|[0m [38;5;26mwhile[0m
            [1;38;5;239m|[0m [38;5;26mrepeat[0m
            [1;38;5;239m|[0m [38;5;26mdo[0m
            [1;38;5;239m|[0m [38;5;26muntil[0m
            [1;38;5;239m|[0m [38;5;26mas[0m
            [1;38;5;239m|[0m [38;5;26mmutates[0m
            [1;38;5;239m|[0m [38;5;26mextends[0m
            [1;38;5;239m|[0m [38;5;26mimport[0m
            [1;38;5;239m|[0m [38;5;26mwith[0m
            [1;38;5;239m|[0m [38;5;26mtrait[0m
            [1;38;5;239m|[0m [38;5;26minitOf[0m
            [1;38;5;239m|[0m [38;5;26moverride[0m
            [1;38;5;239m|[0m [38;5;26mabstract[0m
            [1;38;5;239m|[0m [38;5;26mvirtual[0m
            [1;38;5;239m|[0m [38;5;26minline[0m
            [1;38;5;239m|[0m [38;5;26mconst[0m
    [38;5;26mcontract[0m [1;38;5;239m=[0m [38;5;28m"contract"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mlet[0m [1;38;5;239m=[0m [38;5;28m"let"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mfun[0m [1;38;5;239m=[0m [38;5;28m"fun"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mreturn[0m [1;38;5;239m=[0m [38;5;28m"return"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mextend[0m [1;38;5;239m=[0m [38;5;28m"extend"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mnative[0m [1;38;5;239m=[0m [38;5;28m"native"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mpublic[0m [1;38;5;239m=[0m [38;5;28m"public"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mnull[0m [1;38;5;239m=[0m [38;5;28m"null"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mif[0m [1;38;5;239m=[0m [38;5;28m"if"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26melse[0m [1;38;5;239m=[0m [38;5;28m"else"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mwhile[0m [1;38;5;239m=[0m [38;5;28m"while"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mrepeat[0m [1;38;5;239m=[0m [38;5;28m"repeat"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mdo[0m [1;38;5;239m=[0m [38;5;28m"do"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26muntil[0m [1;38;5;239m=[0m [38;5;28m"until"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mas[0m [1;38;5;239m=[0m [38;5;28m"as"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mmutates[0m [1;38;5;239m=[0m [38;5;28m"mutates"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mextends[0m [1;38;5;239m=[0m [38;5;28m"extends"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mimport[0m [1;38;5;239m=[0m [38;5;28m"import"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mwith[0m [1;38;5;239m=[0m [38;5;28m"with"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mtrait[0m [1;38;5;239m=[0m [38;5;28m"trait"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26minitOf[0m [1;38;5;239m=[0m [38;5;28m"initOf"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mvirtual[0m [1;38;5;239m=[0m [38;5;28m"virtual"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26moverride[0m [1;38;5;239m=[0m [38;5;28m"override"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26minline[0m [1;38;5;239m=[0m [38;5;28m"inline"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mconst[0m [1;38;5;239m=[0m [38;5;28m"const"[0m [1;38;5;239m~[0m[38;5;26midPart[0m
    [38;5;26mabstract[0m [1;38;5;239m=[0m [38;5;28m"abstract"[0m [1;38;5;239m~[0m[38;5;26midPart[0m

    [3;38;5;245m// Attributes[0m
    [38;5;26mnameAttribute[0m [1;38;5;239m=[0m [38;5;28m"@name"[0m

    [3;38;5;245m// Reserved[0m
    [38;5;26mreservedWord[0m [1;38;5;239m=[0m [38;5;26mkeyword[0m

    [3;38;5;245m// Comments[0m
    [38;5;26mspace[0m [1;38;5;239m+=[0m [38;5;26mcomment[0m [1;38;5;239m|[0m [38;5;26mlineTerminator[0m
    [38;5;26mcomment[0m [1;38;5;239m=[0m [38;5;26mmultiLineComment[0m [1;38;5;239m|[0m [38;5;26msingleLineComment[0m
    [38;5;26mlineTerminator[0m [1;38;5;239m=[0m [38;5;28m"[0m[38;5;30m\n[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;28m"[0m[38;5;30m\r[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;28m"[0m[38;5;30m\u2028[0m[38;5;28m"[0m [1;38;5;239m|[0m [38;5;28m"[0m[38;5;30m\u2029[0m[38;5;28m"[0m
    [38;5;26mmultiLineComment[0m [1;38;5;239m=[0m [38;5;28m"/*"[0m [38;5;239m([0m[1;38;5;239m~[0m[38;5;28m"*/"[0m [1;38;5;26many[0m[38;5;239m)[0m[1;38;5;239m*[0m [38;5;28m"*/"[0m
    [38;5;26msingleLineComment[0m [1;38;5;239m=[0m [38;5;28m"//"[0m [38;5;239m([0m[1;38;5;239m~[0m[38;5;26mlineTerminator[0m [1;38;5;26many[0m[38;5;239m)[0m[1;38;5;239m*[0m
[38;5;239m}[0m
```


## standard-libraries.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/standard-libraries.mdx)
---
title: 标准图书馆概述
---

有些库（也称为标准库或 stdlibs）与 Tact 编译器捆绑在一起，但不会自动包含到项目中，除非明确指定。

要导入任何标准库，请使用[`import{:tact}`关键字](/zh-cn/book/import)，然后在[字符串][p]中输入该库的名称，像这样：

```tact
// 这将把 @stdlib/deploy 中的所有内容纳入代码库：
import "@stdlib/deploy"；
```

## 标准图书馆列表： {#list}

| 图书馆                      | 说明                                                      | 常用的应用程序接口                                                               |
| :----------------------- | :------------------------------------------------------ | :---------------------------------------------------------------------- |
| [`@stdlib/config`][1]    | 配置和选民地址检索。                                              | [`getConfigAddress(){:tact}`][gca]，[`getElectorAddress(){:tact}`][gea]。 |
| [`@stdlib/content`][2]   | 将链外链接[字符串][p]编码为[`单元格{:tact}`][单元格]。                    | [`createOffchainContent(){:tact}`][coff]。                               |
| [`@stdlib/deploy`][3]    | 统一的部署机制。                                                | [`可部署{:tact}`][dep]，[`可部署工厂{:tact}`][fcd]。                              |
| [`@stdlib/dns`][4]       | 解析 [DNS][dns] 名称。                                       | [`DNSResolver{:tact}`][dnsr]，[`dnsInternalVerify(){:tact}`][dnsi]。      |
| [`@stdlib/ownable`][5]   | 所有权管理的特质。                                               | [`可拥有{:tact}`][拥有]，[`可拥有可转让{:tact}`][拥有]                                |
| [`@stdlib/stoppable`][6] | 允许合同停止的特征。 需要 [@stdlib/ownable][5]。                     | [`Stoppable{:tact}`][stp]，[`Resumable{:tact}`][res]。                    |

[1]: /zh-cn/ref/stdlib-config
[gca]: /zh-cn/ref/stdlib-config#getconfigaddress
[gea]: /zh-cn/ref/stdlib-config#getelectoraddress
[2]: /zh-cn/ref/stdlib-content
[库克]: /zh-cn/ref/stdlib-content#createoffchaincontent
[3]: /zh-cn/ref/stdlib-deploy
[描写]: /zh-cn/ref/stdlib-deploy#deployable
[fcd]: /zh-cn/ref/stdlib-deploy#factorydeployable
[4]: /zh-cn/ref/stdlib-dns
[dnsr]: /zh-cn/ref/stdlib-dns#dnsresolver
[dnsi]: /zh-cn/ref/stdlib-dns#dnsinternalverify
[5]: /zh-cn/ref/stdlib-ownable
[拥有]: /zh-cn/ref/stdlib-ownable#ownable
[拥有]: /zh-cn/ref/stdlib-ownable#ownabletransferable
[6]: /zh-cn/ref/stdlib-stoppable
[stp]: /zh-cn/ref/stdlib-stoppable#stoppable
[重新]: /zh-cn/ref/stdlib-stoppable#resumable
[p]: /zh-cn/book/types#primitive-types
[电池]: /zh-cn/book/cells#cells
[dns]: https://docs.ton.org/participate/web3/dns


## stdlib-config.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/stdlib-config.mdx)
---
title: "@stdlib/config"
---

提供配置和选民地址检索功能。

要使用该库，请导入 `@stdlib/config`：

```tact
import "@stdlib/config";
```

## 功能

### getConfigAddress

```tact
fun getConfigAddress(): Address;
```

读取配置参数 $0$ 作为 [`地址{:tact}`][p]。

源代码

```tact
fun getConfigAddress()：Address {
    let cell：Cell = getConfigParam(0)!!;
    let sc：Slice = cell.beginParse();
    return newAddress(-1, sc.loadUint(256));
}
```

### getElectorAddress

```tact
fun getElectorAddress(): Address;
```

读取配置参数 $1$ 作为 [`地址{:tact}`][p]。

源代码

```tact
fun getElectorAddress(): Address {
    let cell: Cell = getConfigParam(1)!!;
    let sc: Slice = cell.beginParse();
    return newAddress(-1, sc.loadUint(256));
}
```

## 资料来源

- [config.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/config.tact)

[p]: /zh-cn/book/types#primitive-types


## stdlib-content.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/stdlib-content.mdx)
---
title: "@stdlib/content"
---

提供一个函数，用于编码从 [`字符串{:tact}`][p]到 [`单元格{:tact}`][单元格] 的链外链接。

要使用该库，请导入 `@stdlib/content`：

```tact
import "@stdlib/content";
```

## 功能

### 创建区块链内容

```tact
fun createOffchainContent(link: String)：Cell；
```

编码从[`字符串{:tact}`][p]到[`单元{:tact}`][单元格]的链外`链接`。

源代码

```tact
fun createOffchainContent(link: String)：Cell {
    let builder：StringBuilder = beginStringFromBuilder(beginCell().storeUint(0x01, 8));
    builder.append(link);
    return builder.toCell();
}
```

## 资料来源

- [content.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/content.tact)

[p]: /zh-cn/book/types#primitive-types
[电池]: /zh-cn/book/cells#cells


## stdlib-deploy.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/stdlib-deploy.mdx)
---
title: "@stdlib/deploy"
---

提供统一的部署机制。

要使用该库，请导入 `@stdlib/deploy`：

```tact
import "@stdlib/deploy";
```

## 信息

### Deploy

```tact
message Deploy {
    queryId：Int as uint64;
}
```

### DeployOk

```tact
message DeployOk {
    queryId：Int as uint64;
}
```

### 工厂部署

```tact
message FactoryDeploy {
    queryId：Int as uint64;
    cashback：Address;
}
```

## 特质

### Deployable

最简单的特质 `可部署{:tact}`，通过为[Deploy](#deploy)消息实现一个简单的接收器，为部署提供了一个方便的统一机制。

所有合同都是通过发送信息来部署的。 虽然任何信息都可用于此目的，但最佳做法是使用特殊的 [部署](#deploy) 信息。

该信息只有一个字段 `queryId` ，由部署者提供（通常设置为零）。 如果部署成功，合约将回复一条 [DeployOk](#deployok) 消息，并在回复中呼应相同的 `queryId` 。

源代码

```tact
trait Deployable {
    receive(deploy: Deploy) {
        self.notify(DeployOk{queryId: deploy.queryId}.toCell());
    }
}
```

使用示例

```tact /Deployable/
import "@stdlib/deploy";

contract ExampleContract with Deployable {
    // Now, this contract has a receiver for Deploy message
}
```

### FactoryDeployable

Trait `FactoryDeployable{:tact}` 为连锁部署提供了方便的统一机制。

源代码

```tact
trait FactoryDeployable {
    receive(deploy: FactoryDeploy) {
        self.forward(deploy.cashback, DeployOk{queryId: deploy.queryId}.toCell(), false, null);
    }
}
```

使用示例

```tact /FactoryDeployable/
import "@stdlib/deploy";

contract ExampleContract with FactoryDeployable {
    // Now, this contract has a receiver for FactoryDeploy message
}
```

## 资料来源

- [deploy.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/deploy.tact)


## stdlib-dns.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/stdlib-dns.mdx)
---
title: "@stdlib/dns"
---

提供[DNS](https://docs.ton.org/participate/web3/dns)名称的解析手段。

要使用该库，请导入 `@stdlib/dns`：

```tact
import "@stdlib/dns";
```

## 结构

### DNSResolveResult

```tact
struct DNSResolveResult {
    prefix：Int;
    record：Cell?;
}
```

## 功能

### dnsStringToInternal

```tact
@name(dns_string_to_internal)
native dnsStringToInternal(str: String)：Slice?
```

将 DNS 字符串转换为[`slice{:tact}`][slice]或[`null{:tact}`](/zh-cn/book/optionals)，如果不可能的话。

源代码 (FunC)：[dns.fc#L1](https://github.com/tact-lang/tact/blob/e69c7fc99dc9be3fa5ff984456c03ffe8fed3677/stdlib/libs/dns.fc#L1)

### dnsInternalNormalize

```tact
@name(dns_internal_normalize)
native dnsInternalNormalize(src: Slice)：Slice；
```

将 [`Slice{:tact}`][片] 的内部 DNS 表示规范化。 传递的 [`Slice{:tact}`][slice]必须没有任何引用，否则将产生[退出代码 134](/zh-cn/book/exit-codes#134)异常："无效参数"。

源代码 (FunC)：[dns.fc#L125](https://github.com/tact-lang/tact/blob/e69c7fc99dc9be3fa5ff984456c03ffe8fed3677/stdlib/libs/dns.fc#L125)

### dnsInternalVerify

```tact
@name(dns_internal_verify)
native dnsInternalVerify(subdomain: Slice)：Bool；
```

验证子域 [`Slice{:tact}`][片] 的内部 DNS 表示。

源代码 (FunC)：[dns.fc#L81](https://github.com/tact-lang/tact/blob/e69c7fc99dc9be3fa5ff984456c03ffe8fed3677/stdlib/libs/dns.fc#L81)

### dnsExtractTopDomainLength

```tact
fun dnsExtractTopDomainLength(subdomain: Slice)：Int；
```

计算顶域在 "子域"[`片{:tact}`][片]中的长度。

源代码

```tact
fun dnsExtractTopDomainLength(subdomain: Slice)：Int {
    let i：Int = 0;
    let needBreak：Bool = false;
    do {
        let char：Int = subdomain.loadUint(8); // 我们不检查 domain.length，因为它必须包含 0 个字符
        needBreak = char == 0;
        if (!needBreak) {
            i += 8;
        }
    } until (needBreak);
    require(i != 0, "Invalid DNS name");
    return i;
}
```

### dnsExtractTopDomain

```tact
fun dnsExtractTopDomain(subdomain: Slice)：Slice；
```

从 "子域 "中提取顶域 [`片{:tact}`][片]。

源代码

```tact
fun dnsExtractTopDomain(subdomain: Slice)：Slice {
    let len: Int = dnsExtractTopDomainLength(subdomain);
    return subdomain.loadBits(len);
}
```

### dnsResolveNext

```tact
fun dnsResolveNext(address: Address)：Cell；
```

将`地址`[`地址{:tact}`][p]解析为[`单元格{:tact}`][单元格]。

源代码

```tact
fun dnsResolveNext(address: Address)：Cell {
    return beginCell()
        .storeUint(0xba93, 16)
        .storeAddress(address)
        .endCell();
}
```

### dnsResolveWallet

```tact
fun dnsResolveWallet(address: Address)：Cell；
```

将钱包 `address`[`Address{:tact}`][p]解析为[`Cell{:tact}`][cell]。

源代码

```tact
fun dnsResolveWallet(address: Address)：Cell {
    return beginCell()
        .storeUint(0x9fd3, 16)
        .storeAddress(address)
        .storeUint(0, 8)
        .endCell();
}
```

## 特质

### DNSResolver

Trait `DNSResolver` 为 DNS 解析提供了两个辅助函数：

1. [getter函数](/zh-cn/book/functions#getter-functions) `dnsresolve(){:tact}`，对应于其[FunC变体](https://docs.ton.org/develop/howto/subresolvers#dnsresolve-code)。
2. 虚拟函数 `doResolveDNS(){:tact}`，由子域 [`片{:tact}`][片] 位创建结构 [DNSResolveResult](#dnsresolveresult)。

源代码

```tact
trait DNSResolver {
    get fun dnsresolve(subdomain: Slice, category: Int)：DNSResolveResult {
        // Normalize
        let delta: Int = 0;
        if (subdomain.preloadUint(8) == 0) {
            subdomain.loadUint(8); // Skip first byte
            delta += 8;
        } // Check correctity

        // 检查正确性
        require(dnsInternalVerify(subdomain), "Invalid DNS name");

        // 解析
        let res：DNSResolveResult = self.doResolveDNS(subdomain, category);
        return DNSResolveResult{prefix: res.prefix + delta, record: res.record};
    }
    virtual fun doResolveDNS(subdomain: Slice, category: Int)：DNSResolveResult {
        return DNSResolveResult{prefix: subdomain.bits(), record: null};
    }
}
```

使用示例

```tact
import "@stdlib/dns";

contract ExampleContract with DNSResolver {
    // Now, this contract has a:
    // 1. dnsresolve getter function
    // 2. doResolveDNS virtual function
}
```

## 资料来源

- [dns.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/dns.tact)
- [dns.fc](https://github.com/tact-lang/tact/blob/e69c7fc99dc9be3fa5ff984456c03ffe8fed3677/stdlib/libs/dns.fc)

[p]: /zh-cn/book/types#primitive-types
[电池]: /zh-cn/book/cells#cells
[一片]: /zh-cn/book/cells#slices


## stdlib-ownable.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/stdlib-ownable.mdx)
---
title: "@stdlib/ownable"
---

为可拥有的合约提供 [traits]（/book/types#composite-types）。 这是最常用的性状，大多数其他性状都需要它。

要使用该库，请导入 `@stdlib/ownable`：

```tact
import "@stdlib/ownable";
```

## 信息

### ChangeOwner

```tact
message ChangeOwner {
    queryId：Int as uint64;
    newOwner: Address;
}
```

### ChangeOwnerOk

```tact
message ChangeOwnerOk {
    queryId：Int as uint64;
    newOwner: Address;
}
```

## 特质

### Ownable

[Trait](/zh-cn/book/types#composite-types) `Ownable{:tact}` 声明了 [contract](/zh-cn/book/contracts) 的所有者（不可编辑），并提供了一个辅助函数 `requireOwner(){:tact}` 来检查消息是否由所有者发送。

此 [trait](/zh-cn/book/types#composite-types) 要求声明一个字段 `owner: Address{:tact}`，并公开一个 [getter 函数](/zh-cn/book/functions#getter-functions) `owner(){:tact}`，该函数从 [contract](/zh-cn/book/contracts) 中读取。

源代码

```tact
@interface("org.ton.ownable")
trait Ownable {
    owner: Address;

    fun requireOwner() {
        nativeThrowUnless(132, sender() == self.owner);
    }

    get fun owner()：Address {
        return self.owner;
    }
}
```

使用示例

```tact /Ownable/
import "@stdlib/ownable";

contract ExampleContract with Ownable {
    owner: Address;

    init(owner: Address) {
        self.owner = owner;
    }
}
```

### OwnableTransferable

`OwnableTransferable{:tact}` 是 [`Ownable{:tact}`](#ownable) 的扩展，允许将合同的所有权转移到另一个地址。它提供了一个安全的句柄 [Message](/zh-cn/book/structs-and-messages#messages) [`ChangeOwner{:tact}`](#changeowner)，可供所有者调用以转移所有权。

如果所有者转移请求成功，合约将回复一条 [`ChangeOwnerOk{:tact}`](#changeownerok) [信息](/zh-cn/book/structs-and-messages#messages)。

源代码

```tact
@interface("org.ton.ownable.transferable.v2")
trait OwnableTransferable with Ownable {
    owner: Address;

    receive(msg: ChangeOwner) {
        // Check if the sender is the owner
        self.requireOwner();

        // 更新所有者
        self.owner = msg.newOwner;

        // 回复结果
        self.reply(ChangeOwnerOk{ queryId: msg.queryId, newOwner: msg.newOwner }.toCell());
    }
}
```

使用示例

```tact /OwnableTransferable/
import "@stdlib/ownable";

contract ExampleContract with OwnableTransferable {
    owner: Address;

    init(owner: Address) {
        self.owner = owner;
    }
}
```

## 资料来源

- [ownable.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/ownable.tact)


## stdlib-stoppable.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/stdlib-stoppable.mdx)
---
title: "@stdlib/stoppable"
---

提供[traits](/zh-cn/book/types#composite-types)，允许停止[contract](/zh-cn/book/contracts)。 适用于应急或维护模式。 需要来自 [`@stdlib/ownable`](/zh-cn/ref/stdlib-ownable) 的 [`Ownable{:tact}`](/zh-cn/ref/stdlib-ownable#ownable)特质。 该特质只管理合约中的一个标记 "stopped"，处理停止状态必须在合约本身中完成。

要使用该库，请导入 `@stdlib/stoppable`：

```tact
import "@stdlib/stoppable"; // 这也将自动导入 @stdlib/ownable！
```

## 特质

### Stoppable

[Trait](/zh-cn/book/types#composite-types) `Stoppable{:tact}` 实现可由所有者发送的 [Message](/zh-cn/book/structs-and-messages#messages) [string](/zh-cn/book/types#primitive-types) "Stop" 的接收器、实现了 `stopped(){:tact}` [getter 函数](/zh-cn/book/functions#getter-functions)，如果合约已停止，则返回 `true{:tact}`（否则返回 `false{:tact}`），并提供了私有（非getter）函数 `requireNotStopped(){:tact}` 和 `requireStopped(){:tact}`。

源代码

```tact
@interface("org.ton.stoppable")
trait Stoppable with Ownable {
    stopped：Bool;
    owner: Address;

    fun requireNotStopped() {
        require(!self.stopped, "Contract stopped");
    }

    fun requireStopped() {
        require(self. stopped, "Contract not stopped"); } receive("Stop") { self.stopped, "Contract not stopped");
    }

    receive("Stop") {
        self.requireOwner();
        self.requireNotStopped();
        self.stopped = true;
        self.reply("Stopped".asComment());
    }

    get fun stopped()：Bool {
        return self.stopped;
    }
}
```

使用示例

```tact /Stoppable/
import "@stdlib/ownable";
import "@stdlib/stoppable";

contract MyContract with Stoppable {
    owner: Address;
    stopped: Bool;

    init(owner: Address) {
        self.owner = owner;
        self.stopped = false;
    }
}
```

### Resumable

`Resumable{:tact}` [trait](/zh-cn/book/types#composite-types) 扩展了 [`Stoppable{:tact}`](#stoppable) trait，允许恢复 [contract](/zh-cn/book/contracts) 的执行。

源代码

```tact
@interface("org.ton.resumable")
trait Resumable with Stoppable {
    stopped：Bool;
    owner: Address;

    receive("Resume") {
        self.requireOwner();
        self.requireStopped();
        self.stopped = false;
        self.reply("Resumed".asComment());
    }
}
```

使用示例

```tact /Resumable/
import "@stdlib/ownable";
import "@stdlib/stoppable";

contract MyContract with Resumable {
    owner: Address;
    stopped: Bool;

    init(owner: Address) {
        self.owner = owner;
        self.stopped = false;
    }
}
```

## 资料来源

- [stoppable.tact](https://github.com/tact-lang/tact/blob/61541b7783098e1af669faccd7d2334c10981c72/stdlib/libs/stoppable.tact)


## otp-001.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/evolution/otp-001.mdx)
---
title: OTP-001：支持的接口
sidebar:
  order: 1
---

本建议书推荐了一种自省智能合约并找出它们支持哪些接口的方法。

## 动机

现在，我们无法猜测用户想用合同做什么，也无法弄清交易的内容，因为没有明确的方法找到合同的内容。 在大多数情况下，人类需要记住或猜测这是怎么回事。

## 指南

当人类试图签署一项交易时，他们需要清楚地了解自己在做什么：铸币、代币转移、盯盘、DAO 投票。 虽然以太坊钱包支持签署任意结构，但仍不清楚您签署的是什么以及这样做的影响。 同样，探险家也无法以漂亮的形式展示正在发生的事情。

与具体合同打交道的开始就是进行反省--弄清合同对自身的声明是什么。 当应用程序知道这份合同的内容时，它就可以建立一个良好的用户界面，显示交易历史，并验证人类试图签署的内容。

该提案描述了一种报告合同支持哪些接口的方法。

接口是以自由格式的规范定义的。 与其他大多数方法不同的是，本提案不仅将接口定义为合约的技术接口（获取方法、内部信息等），还将其定义为合约行为的描述。 附加合同技术接口的散列表示可能会导致不同标准之间的冲突，因此该提案对接口的定义比较松散。 此外，它还能使接口更加流畅，例如，无法传输的令牌可以只是一个合约，它必须获得返回 "false "的方法 "can_transfer"，这将意味着该令牌根本不支持传输，而无需实现该方法。

接口 ID 是反向域名的哈希值（就像 Java 中的软件包），这样可以避免不同团队之间的名称冲突，如果他们只想为自己构建一些东西的话。

## 规格

为了支持自省，合约必须实现 supports_interface GET 方法：

`(int...) supported_interfaces()`
返回支持的接口代码列表。 第一个值必须是 `hash("org.ton.introspection.v0")` = `123515602279859691144772641439386770278`。
如果第一个值不正确，应用程序必须停止尝试反省合同。
示例

```func
_ supported_interfaces() method_id {
    return (123515602279859691144772641439386770278);
}
```

接口的哈希值定义为截断为 128 位的 SHA256。

## 缺点

这项建议并不能保证合约对接口的正确执行，也不能保证避免不同接口之间的名称冲突。 这不是本提案的目标。

这项建议与特定的技术接口无关。 这可能导致多个接口做同样的事情，但 ID 不同。 这不是本提案的目标，因为集中式注册表对现有接口非常有用，而自定义注册表则主要在内部使用。

## 理由和替代方案

- 为什么是 128 位？ 我们需要在不发生冲突的情况下保留一个全局命名空间，我们不能使用小得多的命名空间，因为发生冲突的可能性会高得多。 我们正在研究类似 UUID 的熵，它正好是 128 位，并且经过时间验证。 超过 128 太浪费了。
- 为什么是自由形式？ 如前所述，定义一些 ID 更容易尽早开始工作，然后最终建立一个标准。 此外，接口（如 ERC20）通常不仅仅是一个技术接口，还包括一些如何使用它的规则。
- 为什么不通过反编译找出合同支持什么？ 在开放世界场景中，明示总比暗示好。 我们不能依靠自己的 "拆解 "能力来进行反省，即使是很小的错误也可能是致命的。
- 为什么不是散列代表？ 目前还没有编译器支持这一点，而且这项建议是面向未来的。 如果有人想构建更自动化的东西，他们可以很容易地按照自己的规则构建自己的哈希值，对外部观察者而言，一切保持不变。

## 现有技术

[以太坊接口检测](https://eips.ethereum.org/EIPS/eip-165)


## otp-002.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/evolution/otp-002.mdx)
---
title: OTP-002：合同 ABI
sidebar:
  order: 2
---

ABI 定义了如何与智能合约通信。 它包含有关合同接收器、数据结构等的信息。

## 动机

ABI 是一种重要工具，允许开发人员生成方便的绑定和用户界面等。 最好的消费用途之一就是使用 DAO，并能在签署交易之前确认它到底要做什么。

## 指南

本 OTP 基于 TLB+ 中定义的类型，建议在阅读本 OTP 之前先了解这些类型。

## 规格

ABI 是一个 JSON 文件：

```json
{
  "name": "MyContract",
  "types": [
    {
      "name": "MyRequest",
      "header": 12315123,
      "fields": [
        {
          "name": "queryId",
          "type": {
            "kind": "simple",
            "type": "int",
            "optional": false,
            "format": "uint256"
          }
        }
      ]
    }
  ],
  "receivers": [
    { "type": "binary", "kind": "internal", "name": "MyRequest" },
    { "type": "binary", "kind": "internal" },
    { "type": "comment", "kind": "internal", "comment": "Vote!" },
    { "type": "comment", "kind": "internal" },
    { "type": "empty", "kind": "internal" }
  ],
  "getters": [
    { "name": "getOwner", "type": "address", "args": [] },
    {
      "name": "getBalance",
      "type": "coins",
      "args": [
        {
          "name": "invested",
          "type": {
            "kind": "simple",
            "type": "uint",
            "format": "coins"
          }
        }
      ]
    }
  ],
  "errors": {
    "123": "Error description",
    "124": "Division by zero"
  }
}
```

## 缺点

- ABI 的二进制和紧凑表示法可能会更好，但目前并不重要。

## 现有技术

- OTP-001，是对本 OTP 的补充。


## otp-003.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/evolution/otp-003.mdx)
---
title: OTP-003：自我评估报告
sidebar:
  order: 3
---

本建议定义了如何使用 IPFS 链接报告合同的 ABI。

## 动机

通常，ABI 是通过第三方服务或 GitHub 上的某个存储库单独提供的。 本提案建议增加一项新的合同 ABI 自我报告，使用 IPFS 链接。 这将使我们避免任何第三方依赖，并允许任何人构建依赖于 ABI 的工具，如探索器、钱包等。

## 规格

为支持这一提议，合同应实施 OTP-001，并报告一个接口 "org.ton.abi.ipfs.v0"。 然后实现一个获取方法 `get_abi_ipfs`，该方法会返回一个字符串，其中包含指向 ABI 文件的 IPFS 链接。 链接格式应为 `ipfs://<hash>`。

## 缺点

- 不更新合同就无法升级 ABI。 这个缺点只存在于硬编码链接中。


## otp-004.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/evolution/otp-004.mdx)
---
title: OTP-004：自动编码器
sidebar:
  order: 4
---

该提案定义了一种为给定结构自动构建序列化布局的方法。

## 动机

在 TLB 中设计序列化布局是一项非常冒险的任务。 开发人员必须注意单元格的大小限制，并记住每个字段使用的位数。 这是一项非常容易出错的工作，而且很容易出错。 本建议旨在解决这一问题，它提供了一种为给定结构自动构建序列化布局的方法。

## 规格

我们将自动编码器定义为一种为给定结构构建序列化布局的急迫算法。 算法定义如下

```text
将当前单元格 
   中的可用引用和位分别定义为 `available_references` 和 `available_bits`。
   注意：必须至少为序列化尾部保留一个引用，为可选标记保留一个 
         位。根据上下文，可能会保留更多的引用或位。 

对于 A 中的每个字段：
    (size_bits, size_ref) = get_field_max_size(field)；
    if (available_bits >= size_bits && available_references >= size_ref) {
        Push field to a current cell
    } else {
        available_references = (1023 - 1)；
        available_bits = (4 - 1)；
        分配一个新的尾部并从当前字段继续
}
```

## 缺点

- 这是一种隐式算法。 目前还不清楚是否需要检查该分配器的结果，以便进行兼容的序列化。


## otp-005.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/evolution/otp-005.mdx)
---
title: OTP-005：参数可寻址合同
sidebar:
  order: 5
---

该提案定义了一种通过参数而非初始数据来处理合同的方法。

## 动机

初始数据可能与论据大相径庭。 这样，我们就能避免在当前合约的上下文中执行来自另一个合约的不受信任的代码，或在链外执行 TVM 代码进行部署，而这在某些情况下可能会有风险。

## 规格

本规范定义了一种将参数写入初始化数据单元的方法，以便在部署过程中由合约代码读取。

### 前缀

前缀由智能合约自行定义，但默认情况下假定为 "单个零位"。 合同代码使用前缀来区分已部署和未部署状态。

### 参数 编码

参数使用 [Auto Encoder]（/ref/evolution/otp-004）编码。

### 合同要求

- 合约必须暴露 `lazy_deployment_completed` 获取方法，如果合约已部署，则返回 `true`，否则返回 `false`。
- 合同必须暴露 `org.ton.deploy.lazy.v0` 接口。

## 缺点

- 合同可能处于半部署状态
- 有多种写参数的方法，最终会产生不同的初始数据和不同的地址
- 您可以部署一个预初始化的合约，它将有一个不同的地址，但功能完整
- 部署时无法预测的天然气用量。 部署费用通常很高，但这项建议使费用更加高昂。


## otp-006.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/evolution/otp-006.mdx)
---
title: OTP-006：合同包
sidebar:
  order: 6
---

该提案定义了一种将编译合同、其依赖关系和所有相关元数据打包成一个文件的方法。

## 动机

需要一种统一的软件包格式，以简化使用各种工具部署和升级合同的过程，而无需对其进行配置。

## 规格

软件包文件的扩展名为".pkg"，是一个 JSON 文件：

```json
{
  "name": "My Contract",
  "code": "... boc of code ...",
  "abi": "ABI string to be uploaded as is to IPFS or Ton Storage",
  "init": {
    "kind": "direct", // Means that this contract can be deployed as is
    "args": {
      // ... Arguments in ABI format
    },
    "prefix": {
      // Optional prefix for contract init state
      "bits": 0, // Number of bits in prefix
      "value": 0 // Value of prefix
    },
    "deployment": {
      "kind": "system-cell", // Means that this contract can be deployed as is
      "system": "... boc of system cell ..."
    }
  },
  "sources": {
    "file.ton": "... base64 encoded source file ..."
  },
  "compiler": {
    "name": "func",
    "version": "0.4.1",
    "parameters": "..." // Optional string parameters
  }
}
```

## 缺点

无

## 参考资料

- 细胞袋 (BoC): https://docs.ton.org/develop/data-formats/cell-boc#packing-a-bag-of-cells


## overview.mdx (https://github.com/tact-lang/tact/blob/main/tact-main/docs/src/content/docs/zh-cn/ref/evolution/overview.mdx)
---
title: 演变概述
sidebar:
  label: 概述
  order: 0
---

import { LinkCard, CardGrid } from '@astrojs/starlight/components';

本小节包含 Tact 基金会定义的所有标准，这些标准用于 Tact 和 TON 生态系统的演进过程。
此外，它还提供 TEP（TON 增强建议）和 Tact 更新的最新变更日志。

## 公开招标（OTP）

<CardGrid>
  <LinkCard
    title="OTP-001"
    href="/ref/evolution/otp-001"
  />
  <LinkCard
    title="OTP-002"
    href="/ref/evolution/otp-002"
  />
  <LinkCard
    title="OTP-003"
    href="/ref/evolution/otp-003"
  />
  <LinkCard
    title="OTP-004"
    href="/ref/evolution/otp-004"
  />
  <LinkCard
    title="OTP-005"
    href="/ref/evolution/otp-005"
  />
  <LinkCard
    title="OTP-006"
    href="/ref/evolution/otp-006"
  />
</CardGrid>

## 加强统一部落协议（TEP）

TON Enhancement Proposals 的主要目标是提供一种方便、正式的方式来提议对 TON 区块链进行修改，并规范生态系统不同部分之间的交互方式。提案管理通过 GitHub 拉取请求完成，流程在 [TEP-1](https://github.com/ton-blockchain/TEPs/blob/master/text/0001-tep-lifecycle.md) 中有正式描述。

[合并的技术专家小组名单](https://github.com/ton-blockchain/TEPs#merged-teps)。

## 更新日志

主 Tact 代码库的所有显著变更都记录在 [CHANGELOG.md](https://github.com/tact-lang/tact/blob/main/CHANGELOG.md) 中。


## echo.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/echo.tact)
message EchoMessage {}

contract Echo {

    init(a: Int) {
        
    }

    receive(msg: EchoMessage) {
        self.reply(msg.toCell());
    }
    
    receive(msg: String) {
        self.reply(msg.asComment());
    }
    
    receive(msg: Slice) {
        self.reply(msg.asCell());
    }

    get fun hello(src: String): String {
        let builder: StringBuilder = beginString();
        builder.append("Hello, ");
        builder.append(src);
        return builder.toString();
    }

    get fun hello2(src: Int): Int {
        return src << 10 & 32;
    }
}

## external.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/external.tact)
import "@stdlib/deploy";
import "@stdlib/ownable";

message Increment {
    value: Int;
}

contract External with Deployable, Ownable {
    owner: Address;
    timeout: Int;

    init(owner: Address) {
        self.owner = owner;
        self.timeout = now() + 5 * 60; // 5 minutes
    }

    receive("Topup") {
        // Do nothing
    }

    external("Timeout") {
        if (now() > self.timeout) {
            acceptMessage();
        }
    }

    external(msg: Increment) {
        if (msg.value == now()) {
            acceptMessage();
        }
    }
}

## increment.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/examples/increment.spec.ts)
import { IncrementContract } from "./output/increment_IncrementContract";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { toNano } from "@ton/core";
import "@ton/test-utils";

describe("increment", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<IncrementContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");
        contract = blockchain.openContract(await IncrementContract.fromInit());

        const result = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(result.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should deploy", async () => {});

    it("should increment", async () => {
        await contract.send(
            treasure.getSender(),
            {
                value: toNano("10"),
            },
            {
                $$type: "Increment",
                key: 0n,
                value: -1232n,
            },
        );

        const counters = await contract.getCounters();
        expect(counters.size).toEqual(1);
        expect(counters.get(0n)).toEqual(-1232n);
    });
});


## increment.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/increment.tact)
import "@stdlib/deploy";

message Increment {
    key: Int;
    value: Int;
}

message Toggle {
    key: Int;
}

message Persist {
    key: Int;
    content: Cell?;
}

message Reset {
    key: Int;
}

struct Something {
    value: Int;
}

contract IncrementContract with Deployable {
    counters: map<Int, Int>;
    counters2: map<Int, Bool>;
    counters3: map<Int, Cell>;
    counters4: map<Address, Int>;
    counters5: map<Int, Something>;

    init() {
        // Nothing to do
    }

    receive(msg: Increment) {
        self.counters.set(msg.key, msg.value);
        self.counters4.set(sender(), msg.value);
    }

    receive(msg: Toggle) {
        let ex: Bool? = self.counters2.get(msg.key);
        if (ex == null) {
            self.counters2.set(msg.key, true);
        } else {
            self.counters2.set(msg.key, !(ex!!));
        }
    }

    receive(msg: Persist) {
        require(self.counters3.get(msg.key) == null, "Empty counter");
        self.counters3.set(msg.key, msg.content);
    }

    receive(msg: Reset) {
        self.counters.set(msg.key, null);
        self.counters2.set(msg.key, null);
        self.counters3.set(msg.key, null);
        self.counters4.set(sender(), null);
        self.counters5.set(msg.key, null);
    }

    get fun counters(): map<Int, Int> {
        return self.counters;
    }

    get fun counters2(): map<Address, Int> {
        return self.counters4;
    }
}

## inheritance.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/inheritance.tact)
trait VirtualTrait {

    const b: Int = 20;

    virtual const b2: Int = 40;

    virtual fun execute(): Int {
        return 0;
    }
}

trait AbstractTrait {

    const c: Int = 30;

    abstract const c2: Int;

    abstract fun executeAbs(): Int;

    fun loadC2(): Int {
        return self.c2;
    }
}

contract Contract with VirtualTrait, AbstractTrait {

    const a: Int = 10;

    override const c2: Int = 50;

    init() {}
    
    override fun executeAbs(): Int {
        return 1000;
    }

    override fun execute(): Int {
        return 2;
    }

    get fun ex(): Int {
        return self.execute();
    }

    get fun ex2(): Int {
        return self.executeAbs();
    }

    get fun const1(): Int {
        return self.a;
    }

    get fun const2(): Int {
        return self.b;
    }

    get fun const3(): Int {
        return self.c;
    }

    get fun const4(): Int {
        return self.b2;
    }

    get fun const5(): Int {
        return self.loadC2();
    }
}

## large.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/large.tact)
contract Large {
    cell1: Cell = cell("te6ccsECFQEACB4AAAAAYwDGASkBjAHvAlICtQMYA3sD3gRBBKQFBwVqBc0GMAaTBvYHWQe8AcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABpxB7D");
    cell2: Cell = cell("te6ccsECFQEACB4AAAAAYwDGASkBjAHvAlICtQMYA3sD3gRBBKQFBwVqBc0GMAaTBvYHWQe8AcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAoYS");
    cell3: Cell = cell("te6ccsECFQEACB4AAAAAYwDGASkBjAHvAlICtQMYA3sD3gRBBKQFBwVqBc0GMAaTBvYHWQe8AcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiq7e6");
    cell4: Cell = cell("te6ccsECFQEACB4AAAAAYwDGASkBjAHvAlICtQMYA3sD3gRBBKQFBwVqBc0GMAaTBvYHWQe8AcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACDwZXC");

    init() {
        
    }
}

## maps.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/maps.tact)
message SetIntMap1 {
    key: Int;
    value: Int?;
}

message SetIntMap2 {
    key: Int;
    value: Bool?;
}

message SetIntMap3 {
    key: Int;
    value: Cell?;
}

message SetIntMap4 {
    key: Int;
    value: SomeStruct?;
}

message SetAddrMap1 {
    key: Address;
    value: Int?;
}

message SetAddrMap2 {
    key: Address;
    value: Bool?;
}

message SetAddrMap3 {
    key: Address;
    value: Cell?;
}

message SetAddrMap4 {
    key: Address;
    value: SomeStruct?;
}

struct SomeStruct {
    value: Int;
}

struct SomeStruct2 {
    value: Int;
    intMap1: map<Int as uint8, Int as uint8>;
}

contract MapTestContract {
    init() {
        // Nothing to do
    }
    //
    // Int Maps
    //

    intMap1: map<Int as uint8, Int as uint8>;
    intMap2: map<Int, Bool>;
    intMap3: map<Int, Cell>;
    intMap4: map<Int, SomeStruct>;

    receive(msg: SetIntMap1) {
        self.intMap1.set(msg.key, msg.value);
    }

    receive(msg: SetIntMap2) {
        self.intMap2.set(msg.key, msg.value);
    }

    receive(msg: SetIntMap3) {
        self.intMap3.set(msg.key, msg.value);
    }

    receive(msg: SetIntMap4) {
        self.intMap4.set(msg.key, msg.value);
    }

    get fun intMap1(): map<Int as uint8, Int as uint8> {
        return self.intMap1;
    }

    get fun intMap1Value(key: Int): Int? {
        return self.intMap1.get(key);
    }

    get fun intMap2(): map<Int, Bool> {
        return self.intMap2;
    }

    get fun intMap2Value(key: Int): Bool? {
        return self.intMap2.get(key);
    }

    get fun intMap3(): map<Int, Cell> {
        return self.intMap3;
    }

    get fun intMap3Value(key: Int): Cell? {
        return self.intMap3.get(key);
    }

    get fun intMap4(): map<Int, SomeStruct> {
        return self.intMap4;
    }

    get fun intMap4Value(key: Int): SomeStruct? {
        return self.intMap4.get(key);
    }

    //
    // Address Keys
    //

    addrMap1: map<Address, Int>;
    addrMap2: map<Address, Bool>;
    addrMap3: map<Address, Cell>;
    addrMap4: map<Address, SomeStruct>;

    receive(msg: SetAddrMap1) {
        self.addrMap1.set(msg.key, msg.value);
    }

    receive(msg: SetAddrMap2) {
        self.addrMap2.set(msg.key, msg.value);
    }

    receive(msg: SetAddrMap3) {
        self.addrMap3.set(msg.key, msg.value);
    }

    receive(msg: SetAddrMap4) {
        self.addrMap4.set(msg.key, msg.value);
    }

    get fun addrMap1(): map<Address, Int> {
        return self.addrMap1;
    }
    
    get fun addrMap1Value(key: Address): Int? {
        return self.addrMap1.get(key);
    }

    get fun addrMap2(): map<Address, Bool> {
        return self.addrMap2;
    }

    get fun addrMap2Value(key: Address): Bool? {
        return self.addrMap2.get(key);
    }

    get fun addrMap3(): map<Address, Cell> {
        return self.addrMap3;
    }

    get fun addrMap3Value(key: Address): Cell? {
        return self.addrMap3.get(key);
    }

    get fun addrMap4(): map<Address, SomeStruct> {
        return self.addrMap4;
    }

    get fun addrMap4Value(key: Address): SomeStruct? {
        return self.addrMap4.get(key);
    }
}


## multisig-3.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/examples/multisig-3.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { MultisigContract } from "./output/multisig-3_MultisigContract";
import "@ton/test-utils";

describe("multisig-3", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<MultisigContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        const key1 = 1n;
        const key2 = 1n;
        const key3 = 1n;

        contract = blockchain.openContract(
            await MultisigContract.fromInit(key1, key2, key3),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "Deploy",
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Check keys
        expect(await contract.getKey1()).toBe(key1);
        expect(await contract.getKey2()).toBe(key2);
        expect(await contract.getKey3()).toBe(key3);
    });

    it("should deploy and verify keys", async () => {
        // Keys verification is already done in beforeEach
    });
});


## multisig-3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/multisig-3.tact)
struct Operation {
    seqno: Int as uint32;
    amount: Int as coins;
    target: Address;
}

message Execute {
    operation: Operation;
    signature1: Slice; 
    signature2: Slice; 
    signature3: Slice;
}

message Executed {
    seqno: Int as uint32;
}

contract MultisigContract {
    seqno: Int as uint32 = 0;
    user1_key: Int as uint256;
    user2_key: Int as uint256;
    user3_key: Int as uint256;

    init(key1: Int, key2: Int, key3: Int) {
        self.user1_key = key1;
        self.user2_key = key2;
        self.user3_key = key3;
    }

    receive("Deploy") {
        // Do nothing
    }

    receive(msg: Execute) {

        // Check all signatures
        let op_hash: Int = msg.operation.toCell().hash();
        let ok1: Bool = checkSignature(op_hash, msg.signature1, self.user1_key);
        let ok2: Bool = checkSignature(op_hash, msg.signature2, self.user2_key);
        let ok3: Bool = checkSignature(op_hash, msg.signature3, self.user3_key);
        require(msg.operation.seqno == self.seqno, "Invalid seqno");
        require(ok1 && ok2 && ok3, "Invalid signature");

        // Send messages
        self.execute(msg.operation);
    }

    fun execute(op: Operation) {
        send(SendParameters{ to: op.target, value: op.amount });
    }

    get fun key1(): Int {
        return self.user1_key;
    }

    get fun key2(): Int {
        return self.user2_key;
    }

    get fun key3(): Int {
        return self.user3_key;
    }

    get fun seqno(): Int {
        return self.seqno;
    }
}

## multisig.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/multisig.tact)
message Request {
    requested: Address;
    to: Address;
    value: Int as coins;
    timeout: Int as uint32;
    bounce: Bool;
    mode: Int as uint8;
    body: Cell?;
}

message Signed {
    request: Request;
}

contract MultisigSigner {

    master: Address;

    // Voting state
    members: map<Address, Int>;
    weight: Int = 0;
    requiredWeight: Int;
    completed: Bool;
    
    // Request
    request: Request;

    init(master: Address, members: map<Address, Int>, requiredWeight: Int, request: Request) {
        self.master = master;
        self.members = members;
        self.requiredWeight = requiredWeight;
        self.completed = false;
        self.request = request;
    }

    receive() {
        // Do nothing
    }

    receive("YES") {

        // Checks
        require(self.request.timeout > now(), "Timeout");
        require(!self.completed, "Completed");

        // Load weight
        let sender: Address = sender();
        let weight: Int = self.members.get(sender)!!;
        self.members.set(sender, null);

        // Update weight
        self.weight = self.weight + weight;
        if (self.weight >= self.requiredWeight) {
            self.completed = true;
            send(SendParameters{
                value: 0, 
                to: self.master, 
                mode: SendRemainingBalance | SendIgnoreErrors,
                bounce: false, 
                body: Signed{ request: self.request }.toCell()
            });
        }
    }

    get fun request(): Request {
        return self.request;
    }
}

contract Multisig {
    seqno: Int;
    members: map<Address, Int>;
    totalWeight: Int;
    requiredWeight: Int;

    init(members: map<Address, Int>, totalWeight: Int, requiredWeight: Int) {
        self.members = members;
        self.requiredWeight = requiredWeight;
        self.totalWeight = totalWeight;
        self.totalWeight = 0;
        self.seqno = 0;
    }

    // Request new pending transaction
    receive(msg: Request) {

        // Check sender
        let sender: Address = sender();
        let weight: Int = self.members.get(sender)!!;
        require(weight > 0, "Not a member");

        // Create message
        let opInit: StateInit = initOf MultisigSigner(myAddress(), self.members, self.requiredWeight, msg);
        let opAddress: Address = contractAddress(opInit);
        send(SendParameters{
            value: 0, 
            to: opAddress, 
            mode: SendRemainingValue | SendIgnoreErrors,
            bounce: true,
            code: opInit.code,
            data: opInit.data
        });
    }

    receive(msg: Signed) {

        // Check parameters
        // NOTE: this will check members, required weight, master address
        let sender: Address = sender();
        let opInit: StateInit = initOf MultisigSigner(myAddress(), self.members, self.requiredWeight, msg.request);
        let opAddress: Address = contractAddress(opInit);
        require(opAddress == sender, "Invalid sender");
        require(msg.request.timeout > now(), "Timeout");

        // Send operation
        send(SendParameters{
            to: msg.request.to, 
            value: msg.request.value, 
            mode: msg.request.mode, 
            bounce: msg.request.bounce, 
            body: msg.request.body
        });
    }

    get fun member(address: Address): Int? {
        return self.members.get(address);
    }

    get fun members(): map<Address, Int> {
        return self.members;
    }
}

## native.fc (https://github.com/tact-lang/tact/blob/main/tact-main/examples/native.fc)
int hello_world() {
    return 1000;
}

## native.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/native.tact)
import "./native.fc";

@name(hello_world)
native helloWorld(): Int;

contract Native {
    
    value: Int;

    init() {
        self.value = 0;
    }

    receive("Increment") {
        self.value = self.value + helloWorld();
    }
}

## payouts.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/payouts.tact)
import "@stdlib/ownable";

message CanPayout {
    amount: Int;
}

message CanPayoutResponse {
    amount: Int;
    address: Address;
    ok: Bool;
}

contract Beacon with Ownable {

    master: Address;
    owner: Address;
    completed: Bool;

    init(master: Address, owner: Address) {
        self.master = master;
        self.owner = owner;
        self.completed = false;
    }

    receive(msg: CanPayout) {

        // Check context
        let ctx: Context = context();
        require(ctx.sender == self.master, "Invalid sender");

        // Reserve funds
        nativeReserve(ton("0.1"), ReserveExact);

        // Send response
        if (self.completed) {
            self.completed = true;    
            self.reply(CanPayoutResponse{ok: true, amount: msg.amount, address: self.owner}.toCell());
        } else {
            self.reply(CanPayoutResponse{ok: false, amount: msg.amount, address: self.owner}.toCell());
        }        
    }

    bounced(msg: Slice) {
        // Reset completed flag is our message bounced
        self.completed = false;
    }
}

contract Payouts with OwnableTransferable {
    owner: Address;
    publicKey: Int;

    init(owner: Address, publicKey: Int) {
        self.owner = owner;
        self.publicKey = publicKey;
    }

    receive(msg: String) {

        // Check context
        let ctx: Context = context();
        require(ctx.value >= ton("1"), "Invalid value");

        // Parse message
        let data: Slice = msg.fromBase64();
        let amount: Int = data.loadCoins();
        let signature: Slice = data.loadBits(512);
        
        // Verify signature
        let dataToSign: Builder = beginCell();
        dataToSign = dataToSign.storeAddress(ctx.sender);
        dataToSign = dataToSign.storeCoins(amount);
        let hash: Int = dataToSign.asCell().hash();
        require(checkSignature(hash, signature, self.publicKey), "Invalid signature");

        // Request funds transfer
        let init: StateInit = initOf Beacon(myAddress(), ctx.sender);
        let address: Address = contractAddress(init);
        send(SendParameters{
            to: address, 
            value: 0, 
            mode: SendRemainingValue | SendIgnoreErrors,
            bounce: true, 
            body: CanPayout{amount: amount}.toCell()
        });
    }

    receive(msg: CanPayoutResponse) {

        // Check context
        let ctx: Context = context();
        let init: StateInit = initOf Beacon(myAddress(), msg.address);
        let address: Address = contractAddress(init);
        require(ctx.sender == address, "Invalid sender");

        if (msg.ok) {
            
            // Check that we have enough funds
            require(myBalance() - ctx.value - ton("1") - msg.amount > 0, "Invalid balance");

            // Send response
            send(SendParameters{
                to: msg.address, 
                value: msg.amount, 
                mode: SendRemainingValue | SendIgnoreErrors,
                bounce: false, 
                body: "Success".asComment()
            });
        } else {
            send(SendParameters{
                to: msg.address, 
                value: 0, 
                mode: SendRemainingValue | SendIgnoreErrors,
                bounce: false, 
                body: "Already paid".asComment()
            });
        }
    }
}

## rugpull.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/rugpull.tact)
import "@stdlib/stoppable";

struct RugParams {
    investment: Int;
    returns: Int;
    fee: Int;
}

contract RugPull with OwnableTransferable, Stoppable {

    // Parameters
    owner: Address;
    investment: Int;
    returns: Int;
    fee: Int;
    balance: Int;
    rugpulled: Bool;
    stopped: Bool;

    // Queue
    queueStart: Int;
    queueEnd: Int;
    queue: map<Int, Address>;
    
    init(owner: Address, investment: Int, returns: Int, fee: Int) {
        self.owner = owner;
        self.rugpulled = false;
        self.queueStart = 0;
        self.queueEnd = 0;
        self.balance = 0;
        self.investment = investment;
        self.returns = returns;
        self.fee = fee;
        self.stopped = false;
    }

    receive() {

        // Must not be stopped stop
        self.requireNotStopped();

        // Forward everything to owner if rugpulled
        if (self.rugpulled) {
            send(SendParameters{value: 0, to: self.owner, mode: SendRemainingBalance });
            return;
        }

        // Check if value ok
        let ctx: Context = context();
        require(ctx.value >= (self.investment + self.fee), "Invalid value");

        // Add to queue
        self.queue.set(self.queueEnd, ctx.sender);
        self.queueEnd = self.queueEnd + 1;
        self.balance = self.balance + self.investment;

        // Perform payouts
        while((self.balance > self.returns) && (self.queueEnd - self.queueStart > 0)) {
            let investor: Address = self.queue.get(self.queueStart)!!;
            self.balance = self.balance - self.returns;
            self.queueStart = self.queueStart + 1;
            self.sendPayout(investor, self.returns);
        }
    }

    receive("withdraw") {
        self.requireOwner();
        if (!self.rugpulled) {
            nativeReserve(self.balance, ReserveExact);
        }
        send(SendParameters{value: 0, to: self.owner, mode: SendRemainingBalance });
    }

    receive("rugpull") {
        self.rugpulled = true;
        send(SendParameters{value: 0, to: self.owner, mode: SendRemainingBalance });
    } 

    fun sendPayout(to: Address, value: Int) {
        send(SendParameters{value: value, to: to, mode: SendIgnoreErrors });
    }

    get fun params(): RugParams {
        return RugParams{investment: self.investment, returns: self.returns, fee: self.fee};
    }
}

## treasure.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/treasure.tact)
import "@stdlib/ownable";

message Withdraw {
    amount: Int as coins;
    mode: Int as uint8;
}

contract Treasure with OwnableTransferable {
    owner: Address;
    
    init(owner: Address) {
        self.owner = owner;
    }

    fun doWithdraw(amount: Int, mode: Int) {
        
        // Only owner can withdraw
        self.requireOwner();

        // Perform withdraw
        send(SendParameters{value: amount, to: self.owner, mode: mode, body: beginCell().endCell()});
    }

    receive(msg: Withdraw) {
        self.doWithdraw(msg.amount, msg.mode);
    }

    receive("Destroy") {
        self.doWithdraw(0, 32 + 128);
    }
}

## wallet-opt.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/wallet-opt.tact)
message TransferMessage {
    signature: Slice as bytes64;
    transfer: Slice as remaining;
}

contract Wallet {
    
    seqno: Int as uint32 = 0;
    key: Int as uint256;
    walletId: Int as uint64;
    
    init(key: Int, walletId: Int) {
        self.key = key;
        self.walletId = walletId;
    }

    receive(msg: TransferMessage) {

        // Check Signature
        let op_hash: Int = msg.transfer.hash();
        require(checkSignature(op_hash, msg.signature, self.key), "Invalid signature");

        // Check parameters
        let pkg: Slice = msg.transfer;
        let seqno: Int = pkg.loadInt(32);
        let mode: Int = pkg.loadInt(8);
        let body: Cell = pkg.loadRef();
        require(seqno == self.seqno, "Invalid seqno");

        // Increment seqno
        self.seqno = (self.seqno + 1) % 65536;

        // Send message
        nativeSendMessage(body, mode);
    }

    get fun publicKey(): Int {
        return self.key;
    }

    get fun walletId(): Int {
        return self.walletId;
    }

    get fun seqno(): Int {
        return self.seqno;
    }
}

## wallet.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/examples/wallet.spec.ts)
import { storeTransfer, Transfer, Wallet } from "./output/wallet_Wallet";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { beginCell, toNano } from "@ton/core";
import { sign } from "@ton/crypto";
import { testKey } from "../src/utils/testKey";
import "@ton/test-utils";

describe("wallet", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Wallet>;
    let key: { publicKey: Buffer; secretKey: Buffer };

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        key = testKey("wallet-key");
        const publicKey = beginCell()
            .storeBuffer(key.publicKey)
            .endCell()
            .beginParse()
            .loadUintBig(256);

        contract = blockchain.openContract(
            await Wallet.fromInit(publicKey, 0n),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "Deploy",
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Initial state checks
        expect(await contract.getPublicKey()).toBe(publicKey);
        expect(await contract.getWalletId()).toBe(0n);
        expect(await contract.getSeqno()).toBe(0n);
    });

    it("should deploy and handle transactions correctly", async () => {
        // Send transfer and check seqno
        const transfer: Transfer = {
            $$type: "Transfer",
            seqno: 0n,
            mode: 1n,
            amount: toNano(10),
            to: treasure.address,
            body: null,
        };
        const signature = sign(
            beginCell().store(storeTransfer(transfer)).endCell().hash(),
            key.secretKey,
        );

        const transferResult = await contract.send(
            treasure.getSender(),
            { value: toNano(1) },
            {
                $$type: "TransferMessage",
                transfer,
                signature: beginCell()
                    .storeBuffer(signature)
                    .endCell()
                    .asSlice(),
            },
        );
        expect(transferResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        // Verify that the contract sent the requested transfer message
        expect(transferResult.transactions).toHaveTransaction({
            from: contract.address,
            to: treasure.address,
            success: true,
            value: toNano(10),
            // Add any other specific details you want to check
        });

        expect(await contract.getSeqno()).toBe(1n);

        // Send empty message and check seqno
        const notifyResult = await contract.send(
            treasure.getSender(),
            { value: toNano(1) },
            "notify",
        );
        expect(notifyResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        expect(await contract.getSeqno()).toBe(2n);

        // Send comment message and check seqno
        const commentResult = await contract.send(
            treasure.getSender(),
            { value: toNano(1) },
            null,
        );
        expect(commentResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        expect(await contract.getSeqno()).toBe(3n);
    });
});


## wallet.tact (https://github.com/tact-lang/tact/blob/main/tact-main/examples/wallet.tact)
struct Transfer {
    seqno: Int as uint32;
    mode: Int as uint8;
    to: Address;
    amount: Int as coins;
    body: Cell?;
}

message(123) TransferMessage {
    signature: Slice;
    transfer: Transfer;
}

contract Wallet {

    seqno: Int as uint32 = 0;
    key: Int as uint256;
    walletId: Int as uint64;

    init(key: Int, walletId: Int) {
        self.key = key;
        self.walletId = walletId;
    }

    receive("Deploy") {
        // Do nothing
    }

    receive(msg: TransferMessage) {

        // Check Signature
        let op_hash: Int = msg.transfer.toCell().hash();
        require(checkSignature(op_hash, msg.signature, self.key), "Invalid signature");
        require(msg.transfer.seqno == self.seqno, "Invalid seqno");

        // Increment seqno
        self.seqno = self.seqno + 1;

        // Send message
        send(SendParameters{value: msg.transfer.amount, to: msg.transfer.to, mode: msg.transfer.mode, body: msg.transfer.body});
    }

    receive(msg: Slice) {
        self.seqno = self.seqno + 1;
    }

    receive() {
        self.seqno = self.seqno + 1;
    }

    receive("notify") {
        self.seqno = self.seqno + 1;
    }

    receive("你好ж") {
        self.seqno = self.seqno + 1;
    }

    receive("duplicate") {
        // Create new wallet
        let walletInit: StateInit = initOf Wallet(self.key, self.walletId + 1);
    }

    bounced(msg: Slice) {
        // TODO: Handle
    }

    get fun publicKey(): Int {
        return self.key;
    }

    get fun walletId(): Int {
        return self.walletId;
    }

    get fun seqno(): Int {
        return self.seqno;
    }
}

## add_slice.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/add_slice.fc)
tuple begin_string_builder(int comment) {
    builder b = begin_cell();
    if (comment) {
        b = store_uint(b, 0, 32);
    }
    return tpush(tpush(empty_tuple(), begin_cell()), null());
}

(tuple, ()) ~add_slice(tuple builders, slice sc) {
    (builder b, tuple tail) = uncons(builders);
    int remBytes = 127 - (builder_bits(b) / 8);
    int exBytes = slice_bits(sc) / 8;
    
    ;; Append bits
    int amount = min(remBytes, exBytes);
    if (amount > 0) {
        slice read = sc~load_bits(amount * 8);
        b = b.store_slice(read);
    }

    ;; Update builders
    builders = cons(b, tail);

    ;; Check if we need to add a new cell
    if (slice_bits(sc) > 0) {
        var bb = begin_cell();
        builders = cons(bb, builders);
        builders~add_slice(sc);
        return ((builders),());
    }

    ;; Check if we have refs
    int refs = slice_refs(sc);
    throw_if(1000, (refs != 0) & (refs != 1));
    if (refs == 0) {
        return ((builders),());
    } else {
        builders~add_slice(sc~load_ref().begin_parse());
        return ((builders),());
    }
}

(tuple, ()) ~add_slice_fast(tuple builders, slice sc) {

    int sliceRefs = slice_refs(sc);
    int sliceBits = slice_bits(sc);

    while((sliceBits > 0) | (sliceRefs > 0)) {

        ;; Load the current builder
        (builder b, tuple tail) = uncons(builders);
        int remBytes = 127 - (builder_bits(b) / 8);
        int exBytes = sliceBits / 8;

        ;; Append bits
        int amount = min(remBytes, exBytes);
        if (amount > 0) {
            slice read = sc~load_bits(amount * 8);
            b = b.store_slice(read);
        }

        ;; Update builders
        builders = cons(b, tail);

        ;; Check if we need to add a new cell and continue
        if (exBytes - amount > 0) {
            var bb = begin_cell();
            builders = cons(bb, builders);
            sliceBits = (exBytes - amount) * 8;
        } elseif (sliceRefs > 0) {
            sc = sc~load_ref().begin_parse();
            sliceRefs = slice_refs(sc);
            sliceBits = slice_bits(sc);
        } else {
            sliceBits = 0;
            sliceRefs = 0;
        }
    }
    return ((builders),());
}

cell __unwrap(tuple builders) {
    (builder b, tuple tail) = uncons(builders);
    cell c = b.end_cell();
    while(~ null?(tail)) {
        (builder b, tuple tail) = uncons(tail);
        c = b.store_ref(c).end_cell();
    }
    return c;
}

slice formatNumber(int src) {
    builder b = begin_cell();
    if (src < 0) {
        b = b.store_uint(45, 8);
        src = - src;   
    }

    tuple t = empty_tuple();
    int len = 0;
    while(src > 0) {
        int digit = src % 10;
        t~tpush(digit);
        len = len + 1;
        src = src / 10;
    }

    int c = 0;
    repeat(len) {
        int v = t.at(c);
        b = b.store_uint(v, 8);
        c = c + 1;
    }

    return b.end_cell().begin_parse();
}

slice formatFloat(int src, int digits) {
    throw_if(134, (digits <= 0) | (digits > 77));

    builder b = begin_cell();
    if (src < 0) {
        b = b.store_uint(45, 8);
        src = - src;   
    }

    ;; Process rem part
    int skip = true;
    int len = 0;
    int rem = 0;
    tuple t = empty_tuple();
    repeat(digits) {
        (src, rem) = src.divmod(10);
        if (~(skip & (rem == 0))) {
            skip = false;
            t~tpush(rem + 48);
            len = len + 1;
        }
    }

    ;; Process dot
    if (~ skip) {
        t~tpush(46);
        len = len + 1;
    }

    ;; Assemble
    int c = 0;
    repeat(len) {
        int v = t.at(c);
        b = b.store_uint(v, 8);
        c = c + 1;
    }

    ;; Result
    return b.end_cell().begin_parse();
}

_ main() impure {
}

## composition.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/composition.fc)
(int, int) do_something(int a) impure {
    return (a, a);
}

(int) do_another(int a, int b) impure {
    return a + b;
}

(int) get_first(int a, int b) inline {
    return a;
}

(int) get_second(int a, int b) inline {
    return b;
}

(int) get_value(int a) inline {
    return a;
}

(int, int) do_mutate(int a, int b, int c) impure {
    return (a + b, a + c);
}

_ main() impure {
    (int, int) x = do_something(get_value(1));
}

## empty_func.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/empty_func.fc)
builder __gen_write_Wallet(builder build_0, int v'seqno, int v'key, int v'walletId) inline {
    build_0 = store_uint(build_0, v'seqno, 32);
    build_0 = store_uint(build_0, v'key, 256);
    build_0 = store_uint(build_0, v'walletId, 64);
    return build_0;
}

cell __gen_writecell_Wallet(int v'seqno,int v'key,int v'walletId) inline {
    return __gen_write_Wallet(begin_cell(), v'seqno, v'key, v'walletId).end_cell();
}

(slice, (int, int, int)) __gen_read_Wallet(slice sc) inline {
    var seqno = sc~load_uint(32);
    var key = sc~load_uint(256);
    var walletId = sc~load_uint(64);
    return (sc, (seqno, key, walletId));
}

(int, int, int) __gen_load_Wallet() inline {
    slice sc = get_data().begin_parse();
    return sc~__gen_read_Wallet();
}

() __gen_store_Wallet(int v'seqno, int v'key, int v'walletId) impure inline {
    builder b = begin_cell();
    b = __gen_write_Wallet(b, v'seqno,v'key,v'walletId);
    set_data(b.end_cell());
}

;; NOTE: REMOVE impure inline to make it work
((int, int, int), ()) __gen_Wallet_receive((int, int, int) self) {
    var (self'seqno, self'key, self'walletId) = self;
    return ((self'seqno, self'key, self'walletId), ());
}

() recv_internal(cell in_msg_cell, slice in_msg) impure {
    
    ;; Parse incoming message
    int op = 0;
    if (slice_bits(in_msg) >= 32) {
        op = in_msg.preload_uint(32);
    }
    
    ;; Receivers
    var (int self'seqno, int self'key, int self'walletId) = __gen_load_Wallet();
    (self'seqno, self'key, self'walletId)~__gen_Wallet_receive();
    __gen_store_Wallet(self'seqno, self'key, self'walletId);    
    
    throw(100);
}

## global.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/global.fc)
global (int, int) ctx;

(int, int) do_something(int a) impure {
    return (a, a);
}

(int) do_another(int a, int b) impure {
    return a + b;
}

(int) get_first(int a, int b) inline {
    return a;
}

(int) get_second(int a, int b) inline {
    return b;
}

(int, int) do_mutate(int a, int b, int c) impure {
    return (a + b, a + c);
}

_ main() impure {
    (int, int) x = do_something(1);
    ctx = x;
}

## tuple_destructive.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/tuple_destructive.fc)
_ fn([int, int, int, int, int, [int, int]] b) impure {
    var [a, b, c, d, e, f] = b;
    return a + b + c + d + e;
}

_ main() impure {
    fn([1, 2, 3, 4, 5, [6, 7]]);
}

## echo_Echo.code.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/bug_0_4_3/echo_Echo.code.fc)
#include "echo_Echo.headers.fc";
#include "echo_Echo.stdlib.fc";
#include "echo_Echo.constants.fc";
#include "echo_Echo.storage.fc";

;;
;; Contract Echo functions
;;

tuple $Echo$_contract_init(int $a) impure inline_ref {
    tuple $self = null();
    return $self;
}

(tuple, slice) $Echo$_fun_hello(tuple $self, slice $src) impure inline_ref {
    var ($self) = $self;
    tuple $builder = __tact_string_builder_start_string();
    $builder~__tact_string_builder_append(__gen_slice_string_f370faf8638967dd9ace3fe077417700dc2370082f3795482bcb6285b962df24());
    $builder~__tact_string_builder_append($src);
    return ($self, __tact_string_builder_end_slice($builder));
}

;;
;; Receivers of a Contract Echo
;;

((tuple), ()) $Echo$_internal_binary_EchoMessage(tuple $self, tuple $msg) impure inline {
    var $self = $self;
    var $msg = $msg;
    $self~$Echo$_fun_reply($EchoMessage$_store_cell($msg));
    return ($self, ());
}

(tuple, ()) $Echo$_internal_any_text(tuple $self, slice $msg) impure inline {
    var $self = $self;
    $self~$Echo$_fun_reply($String$_fun_asComment($msg));
    return ($self, ());
}

(tuple, ()) $Echo$_internal_any(tuple $self, slice $msg) impure inline {
    var $self = $self;
    $self~$Echo$_fun_reply($Slice$_fun_asCell($msg));
    return ($self, ());
}

;;
;; Get methods of a Contract Echo
;;

_ %hello(slice $$src) method_id(115554) {
    slice $src = $$src;
    var self = $Echo$_contract_load();
    var res = self~$Echo$_fun_hello($src);
    return res;
}

_ supported_interfaces() method_id {
    return (
        "org.ton.introspection.v0"H >> 128,
        "org.ton.abi.ipfs.v0"H >> 128,
        "org.ton.deploy.lazy.v0"H >> 128,
        "org.ton.chain.workchain.v0"H >> 128
    );
}

_ get_abi_ipfs() method_id {
    return "ipfs://QmXa2PZRMKJz3A9tGDdANBWoKAAeiyhrVE4CRz2aitkj1z";
}

_ lazy_deployment_completed() method_id {
    return get_data().begin_parse().load_int(1);
}

;;
;; Routing of a Contract Echo
;;

(tuple, int) $Echo$_contract_router_internal(tuple self, int msg_bounced, slice in_msg) impure inline_ref {
    ;; Handle bounced messages
    if (msg_bounced) {
        return (self, true);
    }
    
    ;; Parse incoming message
    int op = 0;
    if (slice_bits(in_msg) >= 32) {
        op = in_msg.preload_uint(32);
    }
    
    
    ;; Receive EchoMessage message
    if (op == 2074217921) {
        var msg = in_msg~$EchoMessage$_load();
        self~$Echo$_internal_binary_EchoMessage(msg);
        return (self, true);
    }
    
    ;; Text Receivers
    if (op == 0) {
        if (slice_bits(in_msg) >= 32) {
            self~$Echo$_internal_any_text(in_msg.skip_bits(32));
            return (self, true);
        }
    }
    
    ;; Receiver fallback
    self~$Echo$_internal_any(in_msg);
    return (self, true);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    
    ;; Context
    var cs = in_msg_cell.begin_parse();
    var msg_flags = cs~load_uint(4);
    var msg_bounced = -(msg_flags & 1);
    slice msg_sender_addr = __tact_verify_address(cs~load_msg_addr());
    __tact_context = (msg_bounced, msg_sender_addr, msg_value, cs);
    __tact_context_sender = msg_sender_addr;
    
    ;; Load contract data
    var self = $Echo$_contract_load();
    
    ;; Handle operation
    int handled = self~$Echo$_contract_router_internal(msg_bounced, in_msg);
    
    ;; Throw if not handled
    throw_unless(130, handled);
    
    ;; Persist state
    $Echo$_contract_store(self);
}


## echo_Echo.constants.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/bug_0_4_3/echo_Echo.constants.fc)
;; String "Hello, "
slice __gen_slice_string_f370faf8638967dd9ace3fe077417700dc2370082f3795482bcb6285b962df24() asm "B{b5ee9c7241010101000900000e48656c6c6f2c20e8d197d2} B>boc <s PUSHSLICE";

## echo_Echo.headers.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/bug_0_4_3/echo_Echo.headers.fc)
#pragma version =0.4.3;
#pragma allow-post-modification;
#pragma compute-asm-ltr;

;;
;; Header files for Echo
;; NOTE: declarations are sorted for optimal order
;;

;; __tact_verify_address
slice __tact_verify_address(slice address) inline;

;; __tact_store_address
builder __tact_store_address(builder b, slice address) inline;

;; __tact_my_balance
int __tact_my_balance() inline;

;; __tact_not_null
forall X -> X __tact_not_null(X x) inline;

;; __tact_context_get
(int, slice, int, slice) __tact_context_get() inline;

;; __tact_context_get_sender
slice __tact_context_get_sender() inline;

;; __tact_store_bool
builder __tact_store_bool(builder b, int v) inline;

;; __tact_string_builder_start
tuple __tact_string_builder_start(builder b) inline;

;; __tact_string_builder_start_comment
tuple __tact_string_builder_start_comment() inline;

;; __tact_string_builder_start_string
tuple __tact_string_builder_start_string() inline;

;; __tact_string_builder_end
cell __tact_string_builder_end(tuple builders) inline;

;; __tact_string_builder_end_slice
slice __tact_string_builder_end_slice(tuple builders) inline;

;; __tact_string_builder_append
((tuple), ()) __tact_string_builder_append(tuple builders, slice sc) inline_ref;

;; $EchoMessage$_store
builder $EchoMessage$_store(builder build_0, tuple v) inline;

;; $EchoMessage$_store_cell
cell $EchoMessage$_store_cell(tuple v) inline;

;; $EchoMessage$_load
(slice, (tuple)) $EchoMessage$_load(slice sc_0) inline;

;; $StateInit$_not_null
((cell, cell)) $StateInit$_not_null(tuple v) inline;

;; $Echo$init$_load
(slice, ((int))) $Echo$init$_load(slice sc_0) inline;

;; $Echo$_contract_init
tuple $Echo$_contract_init(int $a) impure inline_ref;

;; $Echo$_contract_load
tuple $Echo$_contract_load() impure inline_ref;

;; $Echo$_contract_store
() $Echo$_contract_store(tuple v) impure inline;

;; $global_send
() $global_send((int, slice, int, int, cell, cell, cell) $params) impure inline_ref;

;; $Slice$_fun_asCell
cell $Slice$_fun_asCell(slice $self) impure inline;

;; $String$_fun_asComment
cell $String$_fun_asComment(slice $self) impure inline_ref;

;; $Echo$_fun_hello
(tuple, slice) $Echo$_fun_hello(tuple $self, slice $src) impure inline_ref;

;; $SendParameters$_constructor_bounce_to_value_mode_body_code_data
((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_bounce_to_value_mode_body_code_data(int bounce, slice to, int value, int mode, cell body, cell code, cell data) inline;

;; $Echo$_fun_forward
(tuple, ()) $Echo$_fun_forward(tuple $self, slice $to, cell $body, int $bounce, tuple $init) impure inline_ref;

;; $Echo$_fun_reply
(tuple, ()) $Echo$_fun_reply(tuple $self, cell $body) impure inline;


## echo_Echo.stdlib.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/bug_0_4_3/echo_Echo.stdlib.fc)
global (int, slice, int, slice) __tact_context;
global slice __tact_context_sender;
global cell __tact_context_sys;
global int __tact_randomized;

slice __tact_verify_address(slice address) inline {
    throw_unless(136, address.slice_bits() == 267);
    var h = address.preload_uint(11);
    throw_if(137, h == 1279);
    throw_unless(136, h == 1024);
    return address;
}

builder __tact_store_address(builder b, slice address) inline {
    return b.store_slice(__tact_verify_address(address));
}

int __tact_my_balance() inline {
    return pair_first(get_balance());
}

forall X -> X __tact_not_null(X x) inline {
    throw_if(128, null?(x)); return x;
}

(int, slice, int, slice) __tact_context_get() inline {
    return __tact_context;
}

slice __tact_context_get_sender() inline {
    return __tact_context_sender;
}

builder __tact_store_bool(builder b, int v) inline {
    return b.store_int(v, 1);
}

forall X0, X1 -> (X0, X1) __tact_tuple_destroy_2(tuple v) asm "2 UNTUPLE";

tuple __tact_string_builder_start(builder b) inline {
    return tpush(tpush(empty_tuple(), b), null());
}

tuple __tact_string_builder_start_comment() inline {
    return __tact_string_builder_start(begin_cell().store_uint(0, 32));
}

tuple __tact_string_builder_start_string() inline {
    return __tact_string_builder_start(begin_cell());
}

cell __tact_string_builder_end(tuple builders) inline {
    (builder b, tuple tail) = uncons(builders);
    cell c = b.end_cell();
    while(~ null?(tail)) {
        (b, tail) = uncons(tail);
        c = b.store_ref(c).end_cell();
    }
    return c;
}

slice __tact_string_builder_end_slice(tuple builders) inline {
    return __tact_string_builder_end(builders).begin_parse();
}

((tuple), ()) __tact_string_builder_append(tuple builders, slice sc) inline_ref {
    int sliceRefs = slice_refs(sc);
    int sliceBits = slice_bits(sc);
    
    while((sliceBits > 0) | (sliceRefs > 0)) {
    
        ;; Load the current builder
        (builder b, tuple tail) = uncons(builders);
        int remBytes = 127 - (builder_bits(b) / 8);
        int exBytes = sliceBits / 8;
    
        ;; Append bits
        int amount = min(remBytes, exBytes);
        if (amount > 0) {
            slice read = sc~load_bits(amount * 8);
            b = b.store_slice(read);
        }
    
        ;; Update builders
        builders = cons(b, tail);
    
        ;; Check if we need to add a new cell and continue
        if (exBytes - amount > 0) {
            var bb = begin_cell();
            builders = cons(bb, builders);
            sliceBits = (exBytes - amount) * 8;
        } elseif (sliceRefs > 0) {
            sc = sc~load_ref().begin_parse();
            sliceRefs = slice_refs(sc);
            sliceBits = slice_bits(sc);
        } else {
            sliceBits = 0;
            sliceRefs = 0;
        }
    }
    
    return ((builders), ());
}

() $global_send((int, slice, int, int, cell, cell, cell) $params) impure inline_ref {
    var (($params'bounce, $params'to, $params'value, $params'mode, $params'body, $params'code, $params'data)) = $params;
    builder $b = begin_cell();
    $b = store_int($b, 1, 2);
    $b = __tact_store_bool($b, $params'bounce);
    $b = store_int($b, 0, 3);
    $b = __tact_store_address($b, $params'to);
    $b = store_coins($b, $params'value);
    $b = store_int($b, 0, ((((1 + 4) + 4) + 64) + 32));
    if (( ((~ null?($params'code))) ? (true) : ((~ null?($params'data))) )) {
        $b = __tact_store_bool($b, true);
        builder $bc = begin_cell();
        $bc = __tact_store_bool($bc, false);
        $bc = __tact_store_bool($bc, false);
        if ((~ null?($params'code))) {
            $bc = __tact_store_bool($bc, true);
            $bc = store_ref($bc, __tact_not_null($params'code));
        } else {
            $bc = __tact_store_bool($bc, false);
        }
        if ((~ null?($params'data))) {
            $bc = __tact_store_bool($bc, true);
            $bc = store_ref($bc, __tact_not_null($params'data));
        } else {
            $bc = __tact_store_bool($bc, false);
        }
        $bc = __tact_store_bool($bc, false);
        $b = __tact_store_bool($b, true);
        $b = store_ref($b, end_cell($bc));
    } else {
        $b = __tact_store_bool($b, false);
    }
    cell $body = $params'body;
    if ((~ null?($body))) {
        $b = __tact_store_bool($b, true);
        $b = store_ref($b, __tact_not_null($body));
    } else {
        $b = __tact_store_bool($b, false);
    }
    cell $c = end_cell($b);
    send_raw_message($c, $params'mode);
}

cell $Slice$_fun_asCell(slice $self) impure inline {
    var ($self) = $self;
    return end_cell(store_slice(begin_cell(), $self));
}

cell $String$_fun_asComment(slice $self) impure inline_ref {
    var ($self) = $self;
    tuple $b = __tact_string_builder_start_comment();
    $b~__tact_string_builder_append($self);
    return __tact_string_builder_end($b);
}

(tuple, ()) $Echo$_fun_forward(tuple $self, slice $to, cell $body, int $bounce, tuple $init) impure inline_ref {
    var ($self) = $self;
    var ($init) = $init;
    cell $code = null();
    cell $data = null();
    if ((~ null?($init))) {
        var ($init2'code, $init2'data) = $StateInit$_not_null($init);
        $code = $init2'code;
        $data = $init2'data;
    }
    if ((0 > 0)) {
        var ($ctx'bounced, $ctx'sender, $ctx'value, $ctx'raw) = __tact_context_get();
        int $balance = __tact_my_balance();
        int $balanceBeforeMessage = ($balance - $ctx'value);
        if (($balanceBeforeMessage < 0)) {
            raw_reserve(0, 0);
            $global_send($SendParameters$_constructor_bounce_to_value_mode_body_code_data($bounce, $to, 0, (128 + 2), $body, $code, $data));
            return ($self, ());
        }
    }
    $global_send($SendParameters$_constructor_bounce_to_value_mode_body_code_data($bounce, $to, 0, (64 + 2), $body, $code, $data));
    return ($self, ());
}

(tuple, ()) $Echo$_fun_reply(tuple $self, cell $body) impure inline {
    var ($self) = $self;
    $self~$Echo$_fun_forward(__tact_context_get_sender(), $body, true, null());
    return ($self, ());
}

## echo_Echo.storage.fc (https://github.com/tact-lang/tact/blob/main/tact-main/func/bug_0_4_3/echo_Echo.storage.fc)
;;
;; Type: StateInit
;; TLB: _ code:^cell data:^cell = StateInit
;;

((cell, cell)) $StateInit$_not_null(tuple v) inline {
    throw_if(128, null?(v));
    var (cell vvv'code, cell vvv'data) = __tact_tuple_destroy_2(v);
    return (vvv'code, vvv'data);
}

;;
;; Type: SendParameters
;; TLB: _ bounce:bool to:address value:int257 mode:int257 body:Maybe ^cell code:Maybe ^cell data:Maybe ^cell = SendParameters
;;

((int, slice, int, int, cell, cell, cell)) $SendParameters$_constructor_bounce_to_value_mode_body_code_data(int bounce, slice to, int value, int mode, cell body, cell code, cell data) inline {
    return (bounce, to, value, mode, body, code, data);
}

;;
;; Type: EchoMessage
;; Header: 0x7ba20dc1
;; TLB: echo_message#7ba20dc1  = EchoMessage
;;

builder $EchoMessage$_store(builder build_0, tuple v) inline {
    build_0 = store_uint(build_0, 2074217921, 32);
    return build_0;
}

cell $EchoMessage$_store_cell(tuple v) inline {
    return $EchoMessage$_store(begin_cell(), v).end_cell();
}

(slice, (tuple)) $EchoMessage$_load(slice sc_0) inline {
    throw_unless(129, sc_0~load_uint(32) == 2074217921);
    return (sc_0, null());
}

;;
;; Type: Echo
;;

(slice, ((int))) $Echo$init$_load(slice sc_0) inline {
    var v'a = sc_0~load_int(257);
    return (sc_0, (v'a));
}

tuple $Echo$_contract_load() impure inline_ref {
    slice $sc = get_data().begin_parse();
    __tact_context_sys = $sc~load_ref();
    int $loaded = $sc~load_int(1);
    if ($loaded) {
        return null();
    } else {
        ;; Allow only workchain deployments
        throw_unless(137, my_address().preload_uint(11) == 1024);
        (int a) = $sc~$Echo$init$_load();
        $sc.end_parse();
        return $Echo$_contract_init(a);
    }
}

() $Echo$_contract_store(tuple v) impure inline {
    builder b = begin_cell();
    b = b.store_ref(__tact_context_sys);
    b = b.store_int(true, 1);
    set_data(b.end_cell());
}

## configSchema.json (https://github.com/tact-lang/tact/blob/main/tact-main/schemas/configSchema.json)
{
  "$schema": "http://json-schema.org/schema#",
  "$id": "http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json",
  "title": "Tact configuration schema",
  "description": "JSON Schema for tact.config.json",
  "type": "object",
  "required": ["projects"],
  "properties": {
    "projects": {
      "type": "array",
      "description": "List of Tact projects with respective compilation options. Each .tact file represents its own Tact project.",
      "items": {
        "type": "object",
        "required": ["name", "path", "output"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Name of the project. All generated files are prefixed with it.\n\nIn Blueprint, `name` refers to the name of the contract itself."
          },
          "path": {
            "type": "string",
            "description": "Path to the project's Tact file. You can only specify one Tact file per project.\n\nIn Blueprint, `path` is superseded by the `target` field in `wrappers/ContractName.compile.ts` by default, or in `compilables/ContractName.compile.ts` if you have `separateCompilables` the option set in the `blueprint.config.ts`.",
            "examples": ["./path/to/contract.tact"]
          },
          "output": {
            "type": "string",
            "description": "Path to the directory where all generated files will be placed.\n\nIn Blueprint, `output` is not used and all generated files are always placed in `build/ProjectName/`.",
            "examples": ["./path/to/output/directory"]
          },
          "options": {
            "type": "object",
            "description": "Compilation options for the project.\n\nIn Blueprint, they act as default unless modified in `wrappers/ContractName.compile.ts` by default, or in `compilables/ContractName.compile.ts` if you have `separateCompilables` the option set in the `blueprint.config.ts`.",
            "properties": {
              "debug": {
                "type": "boolean",
                "default": false,
                "description": "False by default. If set to true, enables debug output of a contract and allows usage of `dump()` function, which is useful for debugging purposes. With this option enabled, the contract will report that it was compiled in debug mode using the supported_interfaces method.\n\nRead more on debugging Tact code: https://docs.tact-lang.org/book/debug."
              },
              "external": {
                "type": "boolean",
                "default": false,
                "description": "False by default. If set to true, enables support of external message receivers.\n\nRead more about external message receivers: https://docs.tact-lang.org/book/external."
              },
              "ipfsAbiGetter": {
                "type": "boolean",
                "default": false,
                "description": "False by default. If set to true, enables generation of a getter with IPFS links describing the contract's ABI.\n\nRead more about IPFS ABI links: https://docs.tact-lang.org/ref/evolution/OTP-003."
              },
              "interfacesGetter": {
                "type": "boolean",
                "default": false,
                "description": "False by default. If set to true, enables generation of a getter the information on the interfaces provided by the contract.\n\nRead more about supported interfaces: https://docs.tact-lang.org/ref/evolution/OTP-001."
              },
              "experimental": {
                "type": "object",
                "description": "Experimental options that might be removed in the future. Use with caution!",
                "properties": {
                  "inline": {
                    "type": "boolean",
                    "default": false,
                    "description": "False by default. If set to true, enables inlining of all functions in contracts. This can reduce gas usage at the cost of bigger contracts."
                  }
                }
              }
            }
          },
          "mode": {
            "type": "string",
            "default": "full",
            "enum": ["fullWithDecompilation", "full", "funcOnly", "checkOnly"],
            "title": "Compilation mode of the project. In Blueprint, it's always set to `full` and cannot be overwritten.",
            "description": "Set to `full` by default, which runs the whole pipeline of the compilation and emits FunC code, BoC, and various utility files, including wrappers for TypeScript.\nIf set to `fullWithDecompilation`, does full compilation and also decompiles produced binary code in the BoC format.\nIf set to `funcOnly`, only outputs intermediate FunC code, preventing further compilation.\nIf set to `checkOnly`, only performs syntax and type checking, preventing further compilation."
          }
        }
      }
    }
  }
}


## copy-files.ts (https://github.com/tact-lang/tact/blob/main/tact-main/scripts/copy-files.ts)
import * as fs from "node:fs/promises";
import * as path from "node:path";
import * as glob from "glob";

const cp = async (fromGlob: string, toPath: string) => {
    const files = glob.sync(fromGlob);
    for (const file of files) {
        await fs.copyFile(file, path.join(toPath, path.basename(file)));
    }
};

const main = async () => {
    try {
        await cp("./src/grammar/grammar.ohm*", "./dist/grammar/");
        await cp("./src/func/funcfiftlib.*", "./dist/func/");
    } catch (e) {
        console.error(e);
        process.exit(1);
    }
};

void main();


## pack.ts (https://github.com/tact-lang/tact/blob/main/tact-main/scripts/pack.ts)
import fs from "fs";
import path from "path";
import glob from "glob";
import { posixNormalize } from "../src/utils/filePath";

// Pack func
const wasmBase64 = fs
    .readFileSync(
        path.resolve(__dirname, "..", "src", "func", "funcfiftlib.wasm"),
    )
    .toString("base64");
const wasmBase64js = `module.exports = { FuncFiftLibWasm: '${wasmBase64}' };`;
fs.writeFileSync(
    path.resolve(__dirname, "..", "src", "func", "funcfiftlib.wasm.js"),
    wasmBase64js,
);

// Pack stdlib
const stdlibFiles = glob.sync(
    path.resolve(__dirname, "..", "stdlib", "**", "*.@(tact|fc)"),
    { windowsPathsNoEscape: true },
);
const dirPrefixToRemove =
    posixNormalize(path.resolve(__dirname, "..", "stdlib")) + "/"; // Remove also the leading slash
let output: string = "";
output = "const files: Record<string, string> = {};\n";
for (const f of stdlibFiles) {
    let code = fs.readFileSync(f).toString("base64");
    const name = f.replace(dirPrefixToRemove, "");
    output += `files['${name}'] =\n`;
    let first = true;
    while (code.length > 0) {
        if (first) {
            first = false;
        } else {
            output += " +\n";
        }
        output += `    '${code.slice(0, 128)}'`;
        code = code.slice(128);
    }
    output += `;\n`;
}
output += "export default files;";
fs.writeFileSync(
    path.resolve(__dirname, "..", "src", "imports", "stdlib.ts"),
    output,
);


## prepare.ts (https://github.com/tact-lang/tact/blob/main/tact-main/scripts/prepare.ts)
import fs from "fs";
import { decompileAll } from "@tact-lang/opcode";
import { run } from "../src/node";
import { FuncCompilationResult, funcCompile } from "../src/func/funcCompile";
import path from "path";
import { glob } from "glob";
import { verify } from "../src/verify";
import { Logger } from "../src/logger";
import { __DANGER__disableVersionNumber } from "../src/pipeline/version";

// Read cases
void (async () => {
    // Disable version number in packages
    __DANGER__disableVersionNumber();

    const logger = new Logger();

    try {
        // Compile projects
        const compileResult = await run({
            configPath: path.join(__dirname, "..", "tact.config.json"),
        });
        if (!compileResult.ok) {
            throw new Error("Tact projects compilation failed");
        }

        // Verify projects
        for (const pkgPath of glob.sync(
            path.normalize(
                path.resolve(__dirname, "..", "examples", "output", "*.pkg"),
            ),
        )) {
            const res = await verify({
                pkg: fs.readFileSync(pkgPath, "utf-8"),
            });
            if (!res.ok) {
                throw new Error(`Failed to verify ${pkgPath}: ${res.error}`);
            }
        }

        // Compile func files
        for (const p of [{ path: path.join(__dirname, "..", "func") }]) {
            const files = fs.readdirSync(p.path);
            for (const file of files) {
                if (!file.endsWith(".fc")) {
                    continue;
                }

                // Precompile
                const funcFileFullPath = path.join(p.path, file);
                logger.info(`Processing ${funcFileFullPath}`);
                let c: FuncCompilationResult;
                try {
                    const stdlibPath = path.resolve(
                        __dirname,
                        "..",
                        "stdlib",
                        "stdlib.fc",
                    );
                    const stdlib = fs.readFileSync(stdlibPath, "utf-8");
                    const code = fs.readFileSync(funcFileFullPath, "utf-8");
                    c = await funcCompile({
                        entries: [stdlibPath, funcFileFullPath],
                        sources: [
                            {
                                path: stdlibPath,
                                content: stdlib,
                            },
                            {
                                path: funcFileFullPath,
                                content: code,
                            },
                        ],
                        logger,
                    });
                    if (!c.ok) {
                        logger.error(c.log);
                        throw new Error(
                            `FunC compilation failed for ${funcFileFullPath}`,
                        );
                    }
                } catch (e) {
                    logger.error(e as Error);
                    logger.error(`Failed for ${funcFileFullPath}`);
                    throw e;
                }
                fs.writeFileSync(funcFileFullPath + ".fift", c.fift!);
                fs.writeFileSync(funcFileFullPath + ".cell", c.output!);

                // Cell -> Fift decompiler
                const source = decompileAll({ src: c.output! });
                fs.writeFileSync(funcFileFullPath + ".rev.fift", source);
            }
        }
    } catch (error) {
        logger.error(error as Error);
        process.exit(1);
    }
})();


## set-next-version.sh (https://github.com/tact-lang/tact/blob/main/tact-main/scripts/set-next-version.sh)
#!/usr/bin/env sh

# Call the script with a new dev version as its argument.
# If the argument is not provided a new version will be
# automatically generated from package.json and current date,
# plus a gitHead field with the current Git commit hash
# will be added to package.json.
# 
# The version format should be as follows:
# <MAJOR>.<MINOR>.<PATCH>-dev.<ISO-8601-DATE-WITHOUT-DELIMITERS>
# e.g. something like 1.4.0-dev.20240711

FILE=package.json
COMMIT=$(git rev-parse HEAD)

if [ ! -f "$FILE" ]; then
    echo "Error: $FILE not found!"
    exit 1
fi

VERSION=$1
if [ -z "$VERSION" ]; then
    VERSION=$(jq -r '.version' $FILE)-dev.$(date +"%Y%m%d")
fi

TMP=$(mktemp)
jq ".version = \"$VERSION\" | .gitHead = \"$COMMIT\"" "$FILE" > "$TMP"
mv "$TMP" "$FILE"
rm "$TMP"
yarn prettier -w "$FILE"



## tsconfig.json (https://github.com/tact-lang/tact/blob/main/tact-main/scripts/tsconfig.json)
{
  "extends": "../tsconfig.base.json"
}


## browser.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/browser.ts)
import { Config, verifyConfig } from "./config/parseConfig";
import { ILogger } from "./logger";
import { build } from "./pipeline/build";
import { createVirtualFileSystem } from "./vfs/createVirtualFileSystem";

export async function run(args: {
    config: Config;
    files: Record<string, string>;
    logger?: ILogger;
}) {
    // Verify config
    const config = verifyConfig(args.config);

    // Create project's writable fs
    const project = createVirtualFileSystem("/", args.files, false);

    // Create stdlib path
    const stdlib = "@stdlib";

    // Compile
    let success = true;
    let errorCollection: Error[] = [];
    for (const p of config.projects) {
        const built = await build({
            config: p,
            project,
            stdlib,
            logger: args.logger,
        });
        success = success && built.ok;
        if (!built.ok) {
            errorCollection = { ...errorCollection, ...built.error };
        }
    }
    return { ok: success, error: errorCollection };
}


## check.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/check.ts)
import { featureEnable } from "./config/features";
import { CompilerContext } from "./context";
import { getAstFactory } from "./grammar/ast";
import { getParser } from "./grammar";
import files from "./imports/stdlib";
import { createVirtualFileSystem, TactError, VirtualFileSystem } from "./main";
import { precompile } from "./pipeline/precompile";

export type CheckResultItem = {
    type: "error" | "warning";
    message: string;
    location?: {
        file: string;
        line: number;
        column: number;
        length: number;
    };
};

export type CheckResult =
    | {
          ok: true;
      }
    | {
          ok: false;
          messages: CheckResultItem[];
      };

export function check(args: {
    project: VirtualFileSystem;
    entrypoint: string;
}): CheckResult {
    // Create context
    const stdlib = createVirtualFileSystem("@stdlib/", files);
    let ctx: CompilerContext = new CompilerContext();
    ctx = featureEnable(ctx, "debug"); // Enable debug flag (does not affect type checking in practice)
    ctx = featureEnable(ctx, "external"); // Enable external messages flag to avoid external-specific errors

    const ast = getAstFactory();
    const parser = getParser(ast);

    // Execute check
    const items: CheckResultItem[] = [];
    try {
        precompile(ctx, args.project, stdlib, args.entrypoint, parser, ast);
    } catch (e) {
        if (e instanceof TactError) {
            items.push({
                type: "error",
                message: e.message,
                location:
                    e.loc === undefined
                        ? undefined
                        : e.loc.file
                          ? {
                                file: e.loc.file,
                                line: e.loc.interval.getLineAndColumn().lineNum,
                                column: e.loc.interval.getLineAndColumn()
                                    .colNum,
                                length:
                                    e.loc.interval.endIdx -
                                    e.loc.interval.startIdx,
                            }
                          : {
                                file: args.entrypoint,
                                line: 0,
                                column: 0,
                                length: 0,
                            },
            });
        } else {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const msg = (e as any).message;
            if (typeof msg === "string") {
                items.push({
                    type: "error",
                    message: msg,
                    location: {
                        file: args.entrypoint,
                        line: 0,
                        column: 0,
                        length: 0,
                    },
                });
            } else {
                items.push({
                    type: "error",
                    message: "Unknown internal message",
                    location: {
                        file: args.entrypoint,
                        line: 0,
                        column: 0,
                        length: 0,
                    },
                });
            }
        }
    }

    if (items.length > 0) {
        return {
            ok: false,
            messages: items,
        };
    }
    return {
        ok: true,
    };
}


## constEval.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/constEval.ts)
import { CompilerContext } from "./context";
import {
    AstBinaryOperation,
    AstExpression,
    AstUnaryOperation,
    AstValue,
    isValue,
} from "./grammar/ast";
import { TactConstEvalError } from "./errors";
import { Value } from "./types/types";
import { AstUtil, extractValue } from "./optimizer/util";
import { ExpressionTransformer } from "./optimizer/types";
import { StandardOptimizer } from "./optimizer/standardOptimizer";
import {
    Interpreter,
    InterpreterConfig,
    ensureInt,
    evalBinaryOp,
    evalUnaryOp,
    throwNonFatalErrorConstEval,
} from "./interpreter";
import { SrcInfo } from "./grammar";

// Utility Exception class to interrupt the execution
// of functions that cannot evaluate a tree fully into a value.
class PartiallyEvaluatedTree extends Error {
    public tree: AstExpression;

    constructor(tree: AstExpression) {
        super();
        this.tree = tree;
    }
}

export const getOptimizer = (util: AstUtil) => {
    // The optimizer that applies the rewriting rules during partial evaluation.
    // For the moment we use an optimizer that respects overflows.
    const optimizer: ExpressionTransformer = new StandardOptimizer(util);

    function partiallyEvalUnaryOp(
        op: AstUnaryOperation,
        operand: AstExpression,
        source: SrcInfo,
        ctx: CompilerContext,
    ): AstExpression {
        if (operand.kind === "number" && op === "-") {
            // emulating negative integer literals
            return util.makeValueExpression(ensureInt(-operand.value, source));
        }

        const simplOperand = partiallyEvalExpression(operand, ctx);

        if (isValue(simplOperand)) {
            const valueOperand = extractValue(simplOperand as AstValue);
            const result = evalUnaryOp(
                op,
                valueOperand,
                simplOperand.loc,
                source,
            );
            // Wrap the value into a Tree to continue simplifications
            return util.makeValueExpression(result);
        } else {
            const newAst = util.makeUnaryExpression(op, simplOperand);
            return optimizer.applyRules(newAst);
        }
    }

    function partiallyEvalBinaryOp(
        op: AstBinaryOperation,
        left: AstExpression,
        right: AstExpression,
        source: SrcInfo,
        ctx: CompilerContext,
    ): AstExpression {
        const leftOperand = partiallyEvalExpression(left, ctx);

        if (isValue(leftOperand)) {
            // Because of short-circuiting, we must delay evaluation of the right operand
            const valueLeftOperand = extractValue(leftOperand as AstValue);

            try {
                const result = evalBinaryOp(
                    op,
                    valueLeftOperand,
                    // We delay the evaluation of the right operand inside a continuation
                    () => {
                        const rightOperand = partiallyEvalExpression(
                            right,
                            ctx,
                        );
                        if (isValue(rightOperand)) {
                            // If the right operand reduces to a value, then we can let the function
                            // evalBinaryOp finish its normal execution by returning the value
                            // in the right operand.
                            return extractValue(rightOperand as AstValue);
                        } else {
                            // If the right operand does not reduce to a value,
                            // we interrupt the execution of the evalBinaryOp function
                            // by returning an exception with the partially evaluated right operand.
                            // The simplification rules will handle the partially evaluated tree in the catch
                            // of the try surrounding the evalBinaryOp function.
                            throw new PartiallyEvaluatedTree(rightOperand);
                        }
                    },
                    leftOperand.loc,
                    right.loc,
                    source,
                );

                return util.makeValueExpression(result);
            } catch (e) {
                if (e instanceof PartiallyEvaluatedTree) {
                    // The right operand did not evaluate to a value. Hence,
                    // time to symbolically simplify the full tree.
                    const newAst = util.makeBinaryExpression(
                        op,
                        leftOperand,
                        e.tree,
                    );
                    return optimizer.applyRules(newAst);
                } else {
                    throw e;
                }
            }
        } else {
            // Since the left operand does not reduce to a value, no immediate short-circuiting will occur.
            // Hence, we can partially evaluate the right operand and let the rules
            // simplify the tree.
            const rightOperand = partiallyEvalExpression(right, ctx);
            const newAst = util.makeBinaryExpression(
                op,
                leftOperand,
                rightOperand,
            );
            return optimizer.applyRules(newAst);
        }
    }

    function partiallyEvalExpression(
        ast: AstExpression,
        ctx: CompilerContext,
        interpreterConfig?: InterpreterConfig,
    ): AstExpression {
        const interpreter = new Interpreter(ctx, interpreterConfig);
        switch (ast.kind) {
            case "id":
                try {
                    return util.makeValueExpression(
                        interpreter.interpretName(ast),
                    );
                } catch (e) {
                    if (e instanceof TactConstEvalError) {
                        if (!e.fatal) {
                            // If a non-fatal error occurs during lookup, just return the symbol
                            return ast;
                        }
                    }
                    throw e;
                }
            case "method_call":
                // Does not partially evaluate at the moment. Will attempt to fully evaluate
                return util.makeValueExpression(
                    interpreter.interpretMethodCall(ast),
                );
            case "init_of":
                throwNonFatalErrorConstEval(
                    "initOf is not supported at this moment",
                    ast.loc,
                );
                break;
            case "null":
                return ast;
            case "boolean":
                return ast;
            case "number":
                return util.makeValueExpression(
                    interpreter.interpretNumber(ast),
                );
            case "string":
                return util.makeValueExpression(
                    interpreter.interpretString(ast),
                );
            case "op_unary":
                return partiallyEvalUnaryOp(ast.op, ast.operand, ast.loc, ctx);
            case "op_binary":
                return partiallyEvalBinaryOp(
                    ast.op,
                    ast.left,
                    ast.right,
                    ast.loc,
                    ctx,
                );
            case "conditional":
                // Does not partially evaluate at the moment. Will attempt to fully evaluate
                return util.makeValueExpression(
                    interpreter.interpretConditional(ast),
                );
            case "struct_instance":
                // Does not partially evaluate at the moment. Will attempt to fully evaluate
                return util.makeValueExpression(
                    interpreter.interpretStructInstance(ast),
                );
            case "field_access":
                // Does not partially evaluate at the moment. Will attempt to fully evaluate
                return util.makeValueExpression(
                    interpreter.interpretFieldAccess(ast),
                );
            case "static_call":
                // Does not partially evaluate at the moment. Will attempt to fully evaluate
                return util.makeValueExpression(
                    interpreter.interpretStaticCall(ast),
                );
        }
    }

    return {
        partiallyEvalUnaryOp,
        partiallyEvalBinaryOp,
        partiallyEvalExpression,
    };
};

export function evalConstantExpression(
    ast: AstExpression,
    ctx: CompilerContext,
    interpreterConfig?: InterpreterConfig,
): Value {
    const interpreter = new Interpreter(ctx, interpreterConfig);
    const result = interpreter.interpretExpression(ast);
    return result;
}


## context.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/context.ts)
type Key = string | number;
export type Store<T> = Map<Key, T>;

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type Stores = Map<symbol, Store<any> | undefined>;

export class CompilerContext {
    readonly stores: Stores = new Map();

    constructor(
        args: { stores: Stores } = {
            stores: new Map(),
        },
    ) {
        this.stores = args.stores;
        Object.freeze(this.stores);
        Object.freeze(this);
    }

    updateStore = <T>(storeDispatch: symbol, key: Key, value: T) => {
        const store: Store<T> = new Map(this.stores.get(storeDispatch) ?? []);
        store.set(key, value);
        const updatedStores = new Map(this.stores);
        updatedStores.set(storeDispatch, store);
        return new CompilerContext({ stores: updatedStores });
    };
}

export function createContextStore<T>() {
    const symbol = Symbol();
    return {
        get(ctx: CompilerContext, key: Key): T | null {
            return ctx.stores.get(symbol)?.get(key) ?? null;
        },
        all(ctx: CompilerContext): Store<T> {
            return ctx.stores.get(symbol) ?? new Map();
        },
        set(ctx: CompilerContext, key: Key, v: T): CompilerContext {
            return ctx.updateStore(symbol, key, v);
        },
    };
}


## errors.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/errors.ts)
import path from "path";
import { cwd } from "process";
import { AstFuncId, AstId, AstTypeId } from "./grammar/ast";
import { SrcInfo } from "./grammar";

export class TactError extends Error {
    readonly loc?: SrcInfo;
    constructor(message: string, loc?: SrcInfo) {
        super(message);
        this.loc = loc;
    }
}

// Any regular compilation error shown to user:
// parsing, typechecking, code generation
export class TactCompilationError extends TactError {
    constructor(message: string, loc?: SrcInfo) {
        super(message, loc);
    }
}

export class TactInternalCompilerError extends TactError {
    constructor(message: string, loc?: SrcInfo) {
        super(message, loc);
    }
}

export class TactConstEvalError extends TactCompilationError {
    fatal: boolean = false;
    constructor(message: string, fatal: boolean, loc: SrcInfo) {
        super(message, loc);
        this.fatal = fatal;
    }
}

export function locationStr(sourceInfo: SrcInfo): string {
    if (sourceInfo.file) {
        const loc = sourceInfo.interval.getLineAndColumn() as {
            lineNum: number;
            colNum: number;
        };
        const file = path.relative(cwd(), sourceInfo.file);
        return `${file}:${loc.lineNum}:${loc.colNum}: `;
    } else {
        return "";
    }
}

export function throwCompilationError(
    message: string,
    source?: SrcInfo,
): never {
    const msg =
        source === undefined
            ? message
            : `${locationStr(source)}${message}\n${source.interval.getLineAndColumnMessage()}`;
    throw new TactCompilationError(msg, source);
}

export function throwInternalCompilerError(
    message: string,
    source?: SrcInfo,
): never {
    const msg = `[INTERNAL COMPILER ERROR]: ${message}\nPlease report at https://github.com/tact-lang/tact/issues`;
    throw source === undefined
        ? new TactInternalCompilerError(msg)
        : new TactInternalCompilerError(
              `${locationStr(source)}\n${msg}\n${source.interval.getLineAndColumnMessage()}`,
              source,
          );
}

export function throwConstEvalError(
    message: string,
    fatal: boolean,
    source: SrcInfo,
): never {
    throw new TactConstEvalError(
        `${locationStr(source)}${message}\n${source.interval.getLineAndColumnMessage()}`,
        fatal,
        source,
    );
}

export function idTextErr(
    ident: AstId | AstFuncId | AstTypeId | string,
): string {
    if (typeof ident === "string") {
        return `"${ident}"`;
    }
    return `"${ident.text}"`;
}

export type TactErrorCollection =
    | Error
    | TactCompilationError
    | TactInternalCompilerError
    | TactConstEvalError;


## index.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/index.ts)
export { enableFeatures, build } from "./pipeline/build";
export { precompile } from "./pipeline/precompile";
export {
    TactError,
    TactCompilationError,
    TactInternalCompilerError,
    TactConstEvalError,
    TactErrorCollection,
} from "./errors";
export {
    optionsSchema,
    projectSchema,
    configSchema,
} from "./config/parseConfig";
export { AstSorter } from "./grammar/sort";
export { AstRenamer } from "./grammar/rename";
export { AstHasher } from "./grammar/hash";
export { AstComparator } from "./grammar/compare";


## interpreter.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/interpreter.ts)
import { Address, beginCell, BitString, Cell, Slice, toNano } from "@ton/core";
import { paddedBufferToBits } from "@ton/core/dist/boc/utils/paddedBits";
import * as crc32 from "crc-32";
import { evalConstantExpression } from "./constEval";
import { CompilerContext } from "./context";
import {
    TactCompilationError,
    TactConstEvalError,
    idTextErr,
    throwConstEvalError,
    throwInternalCompilerError,
} from "./errors";
import {
    AstBinaryOperation,
    AstBoolean,
    AstCondition,
    AstConditional,
    AstConstantDef,
    AstContract,
    AstExpression,
    AstFieldAccess,
    AstFunctionDef,
    AstId,
    AstInitOf,
    AstMessageDecl,
    AstMethodCall,
    AstModuleItem,
    AstNativeFunctionDecl,
    AstNull,
    AstNumber,
    AstOpBinary,
    AstOpUnary,
    AstPrimitiveTypeDecl,
    FactoryAst,
    AstStatement,
    AstStatementAssign,
    AstStatementAugmentedAssign,
    AstStatementDestruct,
    AstStatementExpression,
    AstStatementForEach,
    AstStatementLet,
    AstStatementRepeat,
    AstStatementReturn,
    AstStatementTry,
    AstStatementTryCatch,
    AstStatementUntil,
    AstStatementWhile,
    AstStaticCall,
    AstString,
    AstStructDecl,
    AstStructInstance,
    AstTrait,
    AstUnaryOperation,
    eqNames,
    getAstFactory,
    idText,
    isSelfId,
} from "./grammar/ast";
import { SrcInfo, dummySrcInfo, Parser, getParser } from "./grammar";
import { divFloor, modFloor } from "./optimizer/util";
import {
    getStaticConstant,
    getStaticFunction,
    getType,
    hasStaticConstant,
    hasStaticFunction,
} from "./types/resolveDescriptors";
import { getExpType } from "./types/resolveExpression";
import {
    CommentValue,
    StructValue,
    TypeRef,
    Value,
    showValue,
} from "./types/types";
import { sha256_sync } from "@ton/crypto";

// TVM integers are signed 257-bit integers
const minTvmInt: bigint = -(2n ** 256n);
const maxTvmInt: bigint = 2n ** 256n - 1n;

// Range allowed in repeat statements
const minRepeatStatement: bigint = -(2n ** 256n); // Note it is the same as minimum for TVM
const maxRepeatStatement: bigint = 2n ** 31n - 1n;

// Throws a non-fatal const-eval error, in the sense that const-eval as a compiler
// optimization cannot be applied, e.g. to `let`-statements.
// Note that for const initializers this is a show-stopper.
export function throwNonFatalErrorConstEval(
    msg: string,
    source: SrcInfo,
): never {
    throwConstEvalError(
        `Cannot evaluate expression to a constant: ${msg}`,
        false,
        source,
    );
}

// Throws a fatal const-eval, meaning this is a meaningless program,
// so compilation should be aborted in all cases
function throwErrorConstEval(msg: string, source: SrcInfo): never {
    throwConstEvalError(
        `Cannot evaluate expression to a constant: ${msg}`,
        true,
        source,
    );
}
type EvalResult =
    | { kind: "ok"; value: Value }
    | { kind: "error"; message: string };

export function ensureInt(val: Value, source: SrcInfo): bigint {
    if (typeof val !== "bigint") {
        throwErrorConstEval(
            `integer expected, but got '${showValue(val)}'`,
            source,
        );
    }
    if (minTvmInt <= val && val <= maxTvmInt) {
        return val;
    } else {
        throwErrorConstEval(
            `integer '${showValue(val)}' does not fit into TVM Int type`,
            source,
        );
    }
}

function ensureRepeatInt(val: Value, source: SrcInfo): bigint {
    if (typeof val !== "bigint") {
        throwErrorConstEval(
            `integer expected, but got '${showValue(val)}'`,
            source,
        );
    }
    if (minRepeatStatement <= val && val <= maxRepeatStatement) {
        return val;
    } else {
        throwErrorConstEval(
            `repeat argument must be a number between -2^256 (inclusive) and 2^31 - 1 (inclusive)`,
            source,
        );
    }
}

function ensureBoolean(val: Value, source: SrcInfo): boolean {
    if (typeof val !== "boolean") {
        throwErrorConstEval(
            `boolean expected, but got '${showValue(val)}'`,
            source,
        );
    }
    return val;
}

function ensureString(val: Value, source: SrcInfo): string {
    if (typeof val !== "string") {
        throwErrorConstEval(
            `string expected, but got '${showValue(val)}'`,
            source,
        );
    }
    return val;
}

function ensureFunArity(arity: number, args: AstExpression[], source: SrcInfo) {
    if (args.length !== arity) {
        throwErrorConstEval(
            `function expects ${arity} argument(s), but got ${args.length}`,
            source,
        );
    }
}

function ensureMethodArity(
    arity: number,
    args: AstExpression[],
    source: SrcInfo,
) {
    if (args.length !== arity) {
        throwErrorConstEval(
            `method expects ${arity} argument(s), but got ${args.length}`,
            source,
        );
    }
}

export function evalUnaryOp(
    op: AstUnaryOperation,
    valOperand: Value,
    operandLoc: SrcInfo = dummySrcInfo,
    source: SrcInfo = dummySrcInfo,
): Value {
    switch (op) {
        case "+":
            return ensureInt(valOperand, operandLoc);
        case "-":
            return ensureInt(-ensureInt(valOperand, operandLoc), source);
        case "~":
            return ~ensureInt(valOperand, operandLoc);
        case "!":
            return !ensureBoolean(valOperand, operandLoc);
        case "!!":
            if (valOperand === null) {
                throwErrorConstEval(
                    "non-null value expected but got null",
                    operandLoc,
                );
            }
            return valOperand;
    }
}

export function evalBinaryOp(
    op: AstBinaryOperation,
    valLeft: Value,
    valRightContinuation: () => Value, // It needs to be a continuation, because some binary operators short-circuit
    locLeft: SrcInfo = dummySrcInfo,
    locRight: SrcInfo = dummySrcInfo,
    source: SrcInfo = dummySrcInfo,
): Value {
    switch (op) {
        case "+":
            return ensureInt(
                ensureInt(valLeft, locLeft) +
                    ensureInt(valRightContinuation(), locRight),
                source,
            );
        case "-":
            return ensureInt(
                ensureInt(valLeft, locLeft) -
                    ensureInt(valRightContinuation(), locRight),
                source,
            );
        case "*":
            return ensureInt(
                ensureInt(valLeft, locLeft) *
                    ensureInt(valRightContinuation(), locRight),
                source,
            );
        case "/": {
            // The semantics of integer division for TVM (and by extension in Tact)
            // is a non-conventional one: by default it rounds towards negative infinity,
            // meaning, for instance, -1 / 5 = -1 and not zero, as in many mainstream languages.
            // Still, the following holds: a / b * b + a % b == a, for all b != 0.
            const r = ensureInt(valRightContinuation(), locRight);
            if (r === 0n)
                throwErrorConstEval(
                    "divisor expression must be non-zero",
                    locRight,
                );
            return ensureInt(divFloor(ensureInt(valLeft, locLeft), r), source);
        }
        case "%": {
            // Same as for division, see the comment above
            // Example: -1 % 5 = 4
            const r = ensureInt(valRightContinuation(), locRight);
            if (r === 0n)
                throwErrorConstEval(
                    "divisor expression must be non-zero",
                    locRight,
                );
            return ensureInt(modFloor(ensureInt(valLeft, locLeft), r), source);
        }
        case "&":
            return (
                ensureInt(valLeft, locLeft) &
                ensureInt(valRightContinuation(), locRight)
            );
        case "|":
            return (
                ensureInt(valLeft, locLeft) |
                ensureInt(valRightContinuation(), locRight)
            );
        case "^":
            return (
                ensureInt(valLeft, locLeft) ^
                ensureInt(valRightContinuation(), locRight)
            );
        case "<<": {
            const valNum = ensureInt(valLeft, locLeft);
            const valBits = ensureInt(valRightContinuation(), locRight);
            if (0n > valBits || valBits > 256n) {
                throwErrorConstEval(
                    `the number of bits shifted ('${valBits}') must be within [0..256] range`,
                    locRight,
                );
            }
            try {
                return ensureInt(valNum << valBits, source);
            } catch (e) {
                if (e instanceof RangeError)
                    // this actually should not happen
                    throwErrorConstEval(
                        `integer does not fit into TVM Int type`,
                        source,
                    );
                throw e;
            }
        }
        case ">>": {
            const valNum = ensureInt(valLeft, locLeft);
            const valBits = ensureInt(valRightContinuation(), locRight);
            if (0n > valBits || valBits > 256n) {
                throwErrorConstEval(
                    `the number of bits shifted ('${valBits}') must be within [0..256] range`,
                    locRight,
                );
            }
            try {
                return ensureInt(valNum >> valBits, source);
            } catch (e) {
                if (e instanceof RangeError)
                    // this is actually should not happen
                    throwErrorConstEval(
                        `integer does not fit into TVM Int type`,
                        source,
                    );
                throw e;
            }
        }
        case ">":
            return (
                ensureInt(valLeft, locLeft) >
                ensureInt(valRightContinuation(), locRight)
            );
        case "<":
            return (
                ensureInt(valLeft, locLeft) <
                ensureInt(valRightContinuation(), locRight)
            );
        case ">=":
            return (
                ensureInt(valLeft, locLeft) >=
                ensureInt(valRightContinuation(), locRight)
            );
        case "<=":
            return (
                ensureInt(valLeft, locLeft) <=
                ensureInt(valRightContinuation(), locRight)
            );
        case "==": {
            const valR = valRightContinuation();

            // the null comparisons account for optional types, e.g.
            // a const x: Int? = 42 can be compared to null
            if (
                typeof valLeft !== typeof valR &&
                valLeft !== null &&
                valR !== null
            ) {
                throwErrorConstEval(
                    "operands of `==` must have same type",
                    source,
                );
            }
            return valLeft === valR;
        }
        case "!=": {
            const valR = valRightContinuation();
            if (typeof valLeft !== typeof valR) {
                throwErrorConstEval(
                    "operands of `!=` must have same type",
                    source,
                );
            }
            return valLeft !== valR;
        }
        case "&&":
            return (
                ensureBoolean(valLeft, locLeft) &&
                ensureBoolean(valRightContinuation(), locRight)
            );
        case "||":
            return (
                ensureBoolean(valLeft, locLeft) ||
                ensureBoolean(valRightContinuation(), locRight)
            );
    }
}

function interpretEscapeSequences(stringLiteral: string, source: SrcInfo) {
    return stringLiteral.replace(
        /\\\\|\\"|\\n|\\r|\\t|\\v|\\b|\\f|\\u{([0-9A-Fa-f]{1,6})}|\\u([0-9A-Fa-f]{4})|\\x([0-9A-Fa-f]{2})/g,
        (match, unicodeCodePoint, unicodeEscape, hexEscape) => {
            switch (match) {
                case "\\\\":
                    return "\\";
                case '\\"':
                    return '"';
                case "\\n":
                    return "\n";
                case "\\r":
                    return "\r";
                case "\\t":
                    return "\t";
                case "\\v":
                    return "\v";
                case "\\b":
                    return "\b";
                case "\\f":
                    return "\f";
                default:
                    // Handle Unicode code point escape
                    if (unicodeCodePoint) {
                        const codePoint = parseInt(unicodeCodePoint, 16);
                        if (codePoint > 0x10ffff) {
                            throwErrorConstEval(
                                `unicode code point is outside of valid range 000000-10FFFF: ${stringLiteral}`,
                                source,
                            );
                        }
                        return String.fromCodePoint(codePoint);
                    }
                    // Handle Unicode escape
                    if (unicodeEscape) {
                        const codeUnit = parseInt(unicodeEscape, 16);
                        return String.fromCharCode(codeUnit);
                    }
                    // Handle hex escape
                    if (hexEscape) {
                        const hexValue = parseInt(hexEscape, 16);
                        return String.fromCharCode(hexValue);
                    }
                    return match;
            }
        },
    );
}

class ReturnSignal extends Error {
    private value?: Value;

    constructor(value?: Value) {
        super();
        this.value = value;
    }

    public getValue(): Value | undefined {
        return this.value;
    }
}

export type InterpreterConfig = {
    // Options that tune the interpreter's behavior.

    // Maximum number of iterations inside a loop before a time out is issued.
    // This option only applies to: do...until and while loops
    maxLoopIterations: bigint;
};

const WILDCARD_NAME: string = "_";

type Environment = { values: Map<string, Value>; parent?: Environment };

class EnvironmentStack {
    private currentEnv: Environment;

    constructor() {
        this.currentEnv = { values: new Map() };
    }

    private findBindingMap(name: string): Map<string, Value> | undefined {
        let env: Environment | undefined = this.currentEnv;
        while (env !== undefined) {
            if (env.values.has(name)) {
                return env.values;
            } else {
                env = env.parent;
            }
        }
        return undefined;
    }

    /*
    Sets a binding for "name" in the **current** environment of the stack.
    If a binding for "name" already exists in the current environment, it 
    overwrites the binding with the provided value.
    As a special case, name "_" is ignored.

    Note that this method does not check if binding "name" already exists in 
    a parent environment.
    This means that if binding "name" already exists in a parent environment, 
    it will be shadowed by the provided value in the current environment.
    This shadowing behavior is useful for modelling recursive function calls.
    For example, consider the recursive implementation of factorial 
    (for simplification purposes, it returns 1 for the factorial of 
    negative numbers):

    1  fun factorial(a: Int): Int {
    2  if (a <= 1) {
    3     return 1;
    4  } else {
    5     return a * factorial(a - 1);
    6  }

    Just before factorial(4) finishes its execution, the environment stack will
    look as follows (the arrows point to their parent environment):

    a = 4 <------- a = 3 <-------- a = 2 <------- a = 1

    Note how each child environment shadows variable a, because each
    recursive call to factorial at line 5 creates a child
    environment with a new binding for a.

    When factorial(1) = 1 finishes execution, the environment at the top
    of the stack is popped:
    
    a = 4 <------- a = 3 <-------- a = 2

    and execution resumes at line 5 in the environment where a = 2,
    so that the return at line 5 is 2 * 1 = 2.

    This in turn causes the stack to pop the environment at the top:

    a = 4 <------- a = 3

    so that the return at line 5 (now in the environment a = 3) will 
    produce 3 * 2 = 6, and so on.
    */
    public setNewBinding(name: string, val: Value) {
        if (name !== WILDCARD_NAME) {
            this.currentEnv.values.set(name, val);
        }
    }

    /*
    Searches the binding "name" in the stack, starting at the current
    environment and moving towards the parent environments. 
    If it finds the binding, it updates its value
    to "val". If it does not find "name", the stack is unchanged.
    As a special case, name "_" is always ignored.
    */
    public updateBinding(name: string, val: Value) {
        if (name !== WILDCARD_NAME) {
            const bindings = this.findBindingMap(name);
            if (bindings !== undefined) {
                bindings.set(name, val);
            }
        }
    }

    /*
    Searches the binding "name" in the stack, starting at the current
    environment and moving towards the parent environments. 
    If it finds "name", it returns its value.
    If it does not find "name", it returns undefined.
    As a special case, name "_" always returns undefined.
    */
    public getBinding(name: string): Value | undefined {
        if (name === WILDCARD_NAME) {
            return undefined;
        }
        const bindings = this.findBindingMap(name);
        if (bindings !== undefined) {
            return bindings.get(name);
        } else {
            return undefined;
        }
    }

    public selfInEnvironment(): boolean {
        return this.findBindingMap("self") !== undefined;
    }

    /*
    Executes "code" in a fresh environment that is placed at the top
    of the environment stack. The fresh environment is initialized
    with the bindings in "initialBindings". Once "code" finishes
    execution, the new environment is automatically popped from 
    the stack. 
    
    This method is useful for starting a new local variables scope, 
    like in a function call.
    */
    public executeInNewEnvironment<T>(
        code: () => T,
        initialBindings: { names: string[]; values: Value[] } = {
            names: [],
            values: [],
        },
    ): T {
        const names = initialBindings.names;
        const values = initialBindings.values;

        const oldEnv = this.currentEnv;
        this.currentEnv = { values: new Map(), parent: oldEnv };

        names.forEach((name, index) => {
            this.setNewBinding(name, values[index]!);
        }, this);

        try {
            return code();
        } finally {
            this.currentEnv = oldEnv;
        }
    }
}

export function parseAndEvalExpression(
    sourceCode: string,
    ast: FactoryAst = getAstFactory(),
    parser: Parser = getParser(ast),
): EvalResult {
    try {
        const ast = parser.parseExpression(sourceCode);
        const constEvalResult = evalConstantExpression(
            ast,
            new CompilerContext(),
        );
        return { kind: "ok", value: constEvalResult };
    } catch (error) {
        if (
            error instanceof TactCompilationError ||
            error instanceof TactConstEvalError
        )
            return { kind: "error", message: error.message };
        throw error;
    }
}

const defaultInterpreterConfig: InterpreterConfig = {
    // We set the default max number of loop iterations
    // to the maximum number allowed for repeat loops
    maxLoopIterations: maxRepeatStatement,
};

/*
Interprets Tact AST trees. 
The constructor receives an optional CompilerContext which includes 
all external declarations that the interpreter will use during interpretation.
If no CompilerContext is provided, the interpreter will use an empty 
CompilerContext.

**IMPORTANT**: if a custom CompilerContext is provided, it should be the 
CompilerContext provided by the typechecker. 

The reason for requiring a CompilerContext is that the interpreter should work 
in the use case where the interpreter only knows part of the code.
For example, consider the following code (I marked with brackets [ ] the places 
where the interpreter gets called during expression simplification in the 
compilation phase):

const C: Int = [1];

contract TestContract {

   get fun test(): Int {
      return [C + 1];
   }
}

When the interpreter gets called inside the brackets, it does not know what 
other code is surrounding those brackets, because the interpreter did not execute the 
code outside the brackets. Hence, it relies on the typechecker to receive the 
CompilerContext that includes the declarations in the code 
(the constant C for example).

Since the interpreter relies on the typechecker, it assumes that the given AST tree
is already a valid Tact program.

Internally, the interpreter uses a stack of environments to keep track of
variables at different scopes. Each environment in the stack contains a map
that binds a variable name to its corresponding value.
*/
export class Interpreter {
    private envStack: EnvironmentStack;
    private context: CompilerContext;
    private config: InterpreterConfig;

    constructor(
        context: CompilerContext = new CompilerContext(),
        config: InterpreterConfig = defaultInterpreterConfig,
    ) {
        this.envStack = new EnvironmentStack();
        this.context = context;
        this.config = config;
    }

    public interpretModuleItem(ast: AstModuleItem): void {
        switch (ast.kind) {
            case "constant_def":
                this.interpretConstantDef(ast);
                break;
            case "function_def":
                this.interpretFunctionDef(ast);
                break;
            case "asm_function_def":
                throwNonFatalErrorConstEval(
                    "Asm functions are currently not supported.",
                    ast.loc,
                );
                break;
            case "struct_decl":
                this.interpretStructDecl(ast);
                break;
            case "message_decl":
                this.interpretMessageDecl(ast);
                break;
            case "native_function_decl":
                this.interpretFunctionDecl(ast);
                break;
            case "primitive_type_decl":
                this.interpretPrimitiveTypeDecl(ast);
                break;
            case "contract":
                this.interpretContract(ast);
                break;
            case "trait":
                this.interpretTrait(ast);
                break;
        }
    }

    public interpretConstantDef(ast: AstConstantDef) {
        throwNonFatalErrorConstEval(
            "Constant definitions are currently not supported.",
            ast.loc,
        );
    }

    public interpretFunctionDef(ast: AstFunctionDef) {
        throwNonFatalErrorConstEval(
            "Function definitions are currently not supported.",
            ast.loc,
        );
    }

    public interpretStructDecl(ast: AstStructDecl) {
        throwNonFatalErrorConstEval(
            "Struct declarations are currently not supported.",
            ast.loc,
        );
    }

    public interpretMessageDecl(ast: AstMessageDecl) {
        throwNonFatalErrorConstEval(
            "Message declarations are currently not supported.",
            ast.loc,
        );
    }

    public interpretPrimitiveTypeDecl(ast: AstPrimitiveTypeDecl) {
        throwNonFatalErrorConstEval(
            "Primitive type declarations are currently not supported.",
            ast.loc,
        );
    }

    public interpretFunctionDecl(ast: AstNativeFunctionDecl) {
        throwNonFatalErrorConstEval(
            "Native function declarations are currently not supported.",
            ast.loc,
        );
    }

    public interpretContract(ast: AstContract) {
        throwNonFatalErrorConstEval(
            "Contract declarations are currently not supported.",
            ast.loc,
        );
    }

    public interpretTrait(ast: AstTrait) {
        throwNonFatalErrorConstEval(
            "Trait declarations are currently not supported.",
            ast.loc,
        );
    }

    public interpretExpression(ast: AstExpression): Value {
        switch (ast.kind) {
            case "id":
                return this.interpretName(ast);
            case "method_call":
                return this.interpretMethodCall(ast);
            case "init_of":
                return this.interpretInitOf(ast);
            case "null":
                return this.interpretNull(ast);
            case "boolean":
                return this.interpretBoolean(ast);
            case "number":
                return this.interpretNumber(ast);
            case "string":
                return this.interpretString(ast);
            case "op_unary":
                return this.interpretUnaryOp(ast);
            case "op_binary":
                return this.interpretBinaryOp(ast);
            case "conditional":
                return this.interpretConditional(ast);
            case "struct_instance":
                return this.interpretStructInstance(ast);
            case "field_access":
                return this.interpretFieldAccess(ast);
            case "static_call":
                return this.interpretStaticCall(ast);
        }
    }

    public interpretName(ast: AstId): Value {
        if (hasStaticConstant(this.context, idText(ast))) {
            const constant = getStaticConstant(this.context, idText(ast));
            if (constant.value !== undefined) {
                return constant.value;
            } else {
                throwErrorConstEval(
                    `cannot evaluate declared constant ${idTextErr(ast)} as it does not have a body`,
                    ast.loc,
                );
            }
        }
        const variableBinding = this.envStack.getBinding(idText(ast));
        if (variableBinding !== undefined) {
            return variableBinding;
        }
        throwNonFatalErrorConstEval("cannot evaluate a variable", ast.loc);
    }

    public interpretMethodCall(ast: AstMethodCall): Value {
        switch (idText(ast.method)) {
            case "asComment": {
                ensureMethodArity(0, ast.args, ast.loc);
                const comment = ensureString(
                    this.interpretExpression(ast.self),
                    ast.self.loc,
                );
                return new CommentValue(comment);
            }
            default:
                throwNonFatalErrorConstEval(
                    `calls of ${idTextErr(ast.method)} are not supported at this moment`,
                    ast.loc,
                );
        }
    }

    public interpretInitOf(ast: AstInitOf): Value {
        throwNonFatalErrorConstEval(
            "initOf is not supported at this moment",
            ast.loc,
        );
    }

    public interpretNull(_ast: AstNull): null {
        return null;
    }

    public interpretBoolean(ast: AstBoolean): boolean {
        return ast.value;
    }

    public interpretNumber(ast: AstNumber): bigint {
        return ensureInt(ast.value, ast.loc);
    }

    public interpretString(ast: AstString): string {
        return ensureString(
            interpretEscapeSequences(ast.value, ast.loc),
            ast.loc,
        );
    }

    public interpretUnaryOp(ast: AstOpUnary): Value {
        // Tact grammar does not have negative integer literals,
        // so in order to avoid errors for `-115792089237316195423570985008687907853269984665640564039457584007913129639936`
        // which is `-(2**256)` we need to have a special case for it

        if (ast.operand.kind === "number" && ast.op === "-") {
            // emulating negative integer literals
            return ensureInt(-ast.operand.value, ast.loc);
        }

        const valOperand = this.interpretExpression(ast.operand);

        return evalUnaryOp(ast.op, valOperand, ast.operand.loc, ast.loc);
    }

    public interpretBinaryOp(ast: AstOpBinary): Value {
        const valLeft = this.interpretExpression(ast.left);
        const valRightContinuation = () => this.interpretExpression(ast.right);

        return evalBinaryOp(
            ast.op,
            valLeft,
            valRightContinuation,
            ast.left.loc,
            ast.right.loc,
            ast.loc,
        );
    }

    public interpretConditional(ast: AstConditional): Value {
        // here we rely on the typechecker that both branches have the same type
        const valCond = ensureBoolean(
            this.interpretExpression(ast.condition),
            ast.condition.loc,
        );
        if (valCond) {
            return this.interpretExpression(ast.thenBranch);
        } else {
            return this.interpretExpression(ast.elseBranch);
        }
    }

    public interpretStructInstance(ast: AstStructInstance): StructValue {
        const structTy = getType(this.context, ast.type);

        // initialize the resulting struct value with
        // the default values for fields with initializers
        // or null for uninitialized optional fields
        const resultWithDefaultFields: StructValue = structTy.fields.reduce(
            (resObj, field) => {
                if (field.default !== undefined) {
                    resObj[field.name] = field.default;
                } else {
                    if (field.type.kind === "ref" && field.type.optional) {
                        resObj[field.name] = null;
                    }
                }
                return resObj;
            },
            { $tactStruct: idText(ast.type) } as StructValue,
        );

        // this will override default fields set above
        return ast.args.reduce((resObj, fieldWithInit) => {
            resObj[idText(fieldWithInit.field)] = this.interpretExpression(
                fieldWithInit.initializer,
            );
            return resObj;
        }, resultWithDefaultFields);
    }

    public interpretFieldAccess(ast: AstFieldAccess): Value {
        // special case for contract/trait constant accesses via `self.constant`
        // interpret "self" as a contract/trait access only if "self"
        // is not already assigned in the environment (this would mean
        // we are executing inside an extends function)
        if (
            ast.aggregate.kind === "id" &&
            isSelfId(ast.aggregate) &&
            !this.envStack.selfInEnvironment()
        ) {
            const selfTypeRef = getExpType(this.context, ast.aggregate);
            if (selfTypeRef.kind === "ref") {
                const contractTypeDescription = getType(
                    this.context,
                    selfTypeRef.name,
                );
                const foundContractConst =
                    contractTypeDescription.constants.find((constId) =>
                        eqNames(ast.field, constId.name),
                    );
                if (foundContractConst === undefined) {
                    // not a constant, e.g. `self.storageVariable`
                    throwNonFatalErrorConstEval(
                        "cannot evaluate non-constant self field access",
                        ast.aggregate.loc,
                    );
                }
                if (foundContractConst.value !== undefined) {
                    return foundContractConst.value;
                } else {
                    throwErrorConstEval(
                        `cannot evaluate declared contract/trait constant ${idTextErr(ast.field)} as it does not have a body`,
                        ast.field.loc,
                    );
                }
            }
        }
        const valStruct = this.interpretExpression(ast.aggregate);
        if (
            valStruct === null ||
            typeof valStruct !== "object" ||
            !("$tactStruct" in valStruct)
        ) {
            throwErrorConstEval(
                `constant struct expected, but got ${showValue(valStruct)}`,
                ast.aggregate.loc,
            );
        }
        if (idText(ast.field) in valStruct) {
            return valStruct[idText(ast.field)]!;
        } else {
            // this cannot happen in a well-typed program
            throwInternalCompilerError(
                `struct field ${idTextErr(ast.field)} is missing`,
                ast.aggregate.loc,
            );
        }
    }

    public interpretStaticCall(ast: AstStaticCall): Value {
        switch (idText(ast.function)) {
            case "ton": {
                ensureFunArity(1, ast.args, ast.loc);
                const tons = ensureString(
                    this.interpretExpression(ast.args[0]!),
                    ast.args[0]!.loc,
                );
                try {
                    return ensureInt(
                        BigInt(toNano(tons).toString(10)),
                        ast.loc,
                    );
                } catch (e) {
                    if (e instanceof Error && e.message === "Invalid number") {
                        throwErrorConstEval(
                            `invalid ${idTextErr(ast.function)} argument`,
                            ast.loc,
                        );
                    }
                    throw e;
                }
            }
            case "pow": {
                ensureFunArity(2, ast.args, ast.loc);
                const valBase = ensureInt(
                    this.interpretExpression(ast.args[0]!),
                    ast.args[0]!.loc,
                );
                const valExp = ensureInt(
                    this.interpretExpression(ast.args[1]!),
                    ast.args[1]!.loc,
                );
                if (valExp < 0n) {
                    throwErrorConstEval(
                        `${idTextErr(ast.function)} builtin called with negative exponent ${valExp}`,
                        ast.loc,
                    );
                }
                try {
                    return ensureInt(valBase ** valExp, ast.loc);
                } catch (e) {
                    if (e instanceof RangeError) {
                        // even TS bigint type cannot hold it
                        throwErrorConstEval(
                            "integer does not fit into TVM Int type",
                            ast.loc,
                        );
                    }
                    throw e;
                }
            }
            case "pow2": {
                ensureFunArity(1, ast.args, ast.loc);
                const valExponent = ensureInt(
                    this.interpretExpression(ast.args[0]!),
                    ast.args[0]!.loc,
                );
                if (valExponent < 0n) {
                    throwErrorConstEval(
                        `${idTextErr(ast.function)} builtin called with negative exponent ${valExponent}`,
                        ast.loc,
                    );
                }
                try {
                    return ensureInt(2n ** valExponent, ast.loc);
                } catch (e) {
                    if (e instanceof RangeError) {
                        // even TS bigint type cannot hold it
                        throwErrorConstEval(
                            "integer does not fit into TVM Int type",
                            ast.loc,
                        );
                    }
                    throw e;
                }
            }
            case "sha256": {
                ensureFunArity(1, ast.args, ast.loc);
                const expr = this.interpretExpression(ast.args[0]!);
                if (expr instanceof Slice) {
                    throwNonFatalErrorConstEval(
                        "slice argument is currently not supported",
                        ast.loc,
                    );
                }
                const str = ensureString(expr, ast.args[0]!.loc);
                return BigInt("0x" + sha256_sync(str).toString("hex"));
            }
            case "emptyMap": {
                ensureFunArity(0, ast.args, ast.loc);
                return null;
            }
            case "cell":
                {
                    ensureFunArity(1, ast.args, ast.loc);
                    const str = ensureString(
                        this.interpretExpression(ast.args[0]!),
                        ast.args[0]!.loc,
                    );
                    try {
                        return Cell.fromBase64(str);
                    } catch (_) {
                        throwErrorConstEval(
                            `invalid base64 encoding for a cell: ${str}`,
                            ast.loc,
                        );
                    }
                }
                break;
            case "slice":
                {
                    ensureFunArity(1, ast.args, ast.loc);
                    const str = ensureString(
                        this.interpretExpression(ast.args[0]!),
                        ast.args[0]!.loc,
                    );
                    try {
                        return Cell.fromBase64(str).asSlice();
                    } catch (_) {
                        throwErrorConstEval(
                            `invalid base64 encoding for a cell: ${str}`,
                            ast.loc,
                        );
                    }
                }
                break;
            case "rawSlice":
                {
                    ensureFunArity(1, ast.args, ast.loc);
                    const str = ensureString(
                        this.interpretExpression(ast.args[0]!),
                        ast.args[0]!.loc,
                    );

                    if (!/^[0-9a-fA-F]*_?$/.test(str)) {
                        throwErrorConstEval(
                            `invalid hex string: ${str}`,
                            ast.loc,
                        );
                    }

                    // Remove underscores from the hex string
                    const hex = str.replace("_", "");
                    const paddedHex = hex.length % 2 === 0 ? hex : "0" + hex;
                    const buffer = Buffer.from(paddedHex, "hex");

                    // Initialize the BitString
                    let bits = new BitString(
                        buffer,
                        hex.length % 2 === 0 ? 0 : 4,
                        hex.length * 4,
                    );

                    // Handle the case where the string ends with an underscore
                    if (str.endsWith("_")) {
                        const paddedBits = paddedBufferToBits(buffer);

                        // Ensure there's enough length to apply the offset
                        const offset = hex.length % 2 === 0 ? 0 : 4;
                        if (paddedBits.length >= offset) {
                            bits = paddedBits.substring(
                                offset,
                                paddedBits.length - offset,
                            );
                        } else {
                            bits = new BitString(Buffer.from(""), 0, 0);
                        }
                    }

                    // Ensure the bit length is within acceptable limits
                    if (bits.length > 1023) {
                        throwErrorConstEval(
                            `slice constant is too long, expected up to 1023 bits, got ${bits.length}`,
                            ast.loc,
                        );
                    }

                    // Return the constructed slice
                    return beginCell().storeBits(bits).endCell().asSlice();
                }
                break;
            case "ascii":
                {
                    ensureFunArity(1, ast.args, ast.loc);
                    const str = ensureString(
                        this.interpretExpression(ast.args[0]!),
                        ast.args[0]!.loc,
                    );
                    const hex = Buffer.from(str).toString("hex");
                    if (hex.length > 64) {
                        throwErrorConstEval(
                            `ascii string is too long, expected up to 32 bytes, got ${Math.floor(hex.length / 2)}`,
                            ast.loc,
                        );
                    }
                    if (hex.length == 0) {
                        throwErrorConstEval(
                            `ascii string cannot be empty`,
                            ast.loc,
                        );
                    }
                    return BigInt("0x" + hex);
                }
                break;
            case "crc32":
                {
                    ensureFunArity(1, ast.args, ast.loc);
                    const str = ensureString(
                        this.interpretExpression(ast.args[0]!),
                        ast.args[0]!.loc,
                    );
                    return BigInt(crc32.str(str) >>> 0); // >>> 0 converts to unsigned
                }
                break;
            case "address":
                {
                    ensureFunArity(1, ast.args, ast.loc);
                    const str = ensureString(
                        this.interpretExpression(ast.args[0]!),
                        ast.args[0]!.loc,
                    );
                    try {
                        const address = Address.parse(str);
                        if (
                            address.workChain !== 0 &&
                            address.workChain !== -1
                        ) {
                            throwErrorConstEval(
                                `${str} is invalid address`,
                                ast.loc,
                            );
                        }
                        return address;
                    } catch (_) {
                        throwErrorConstEval(
                            `invalid address encoding: ${str}`,
                            ast.loc,
                        );
                    }
                }
                break;
            case "newAddress": {
                ensureFunArity(2, ast.args, ast.loc);
                const wc = ensureInt(
                    this.interpretExpression(ast.args[0]!),
                    ast.args[0]!.loc,
                );
                const addr = Buffer.from(
                    ensureInt(
                        this.interpretExpression(ast.args[1]!),
                        ast.args[1]!.loc,
                    )
                        .toString(16)
                        .padStart(64, "0"),
                    "hex",
                );
                if (wc !== 0n && wc !== -1n) {
                    throwErrorConstEval(
                        `expected workchain of an address to be equal 0 or -1, received: ${wc}`,
                        ast.loc,
                    );
                }
                return new Address(Number(wc), addr);
            }
            default:
                if (hasStaticFunction(this.context, idText(ast.function))) {
                    const functionDescription = getStaticFunction(
                        this.context,
                        idText(ast.function),
                    );
                    switch (functionDescription.ast.kind) {
                        case "function_def":
                            // Currently, no attribute is supported
                            if (functionDescription.ast.attributes.length > 0) {
                                throwNonFatalErrorConstEval(
                                    "calls to functions with attributes are currently not supported",
                                    ast.loc,
                                );
                            }
                            return this.evalStaticFunction(
                                functionDescription.ast,
                                ast.args,
                                functionDescription.returns,
                            );

                        case "asm_function_def":
                            throwNonFatalErrorConstEval(
                                `${idTextErr(ast.function)} cannot be interpreted because it's an asm-function`,
                                ast.loc,
                            );
                            break;
                        case "function_decl":
                            throwNonFatalErrorConstEval(
                                `${idTextErr(ast.function)} cannot be interpreted because it does not have a body`,
                                ast.loc,
                            );
                            break;
                        case "native_function_decl":
                            throwNonFatalErrorConstEval(
                                "native function calls are currently not supported",
                                ast.loc,
                            );
                            break;
                    }
                } else {
                    throwNonFatalErrorConstEval(
                        `function ${idTextErr(ast.function)} is not declared`,
                        ast.loc,
                    );
                }
        }
    }

    private evalStaticFunction(
        functionCode: AstFunctionDef,
        args: AstExpression[],
        returns: TypeRef,
    ): Value {
        // Evaluate the arguments in the current environment
        const argValues = args.map(this.interpretExpression, this);
        // Extract the parameter names
        const paramNames = functionCode.params.map((param) =>
            idText(param.name),
        );
        // Check parameter names do not shadow constants
        if (
            paramNames.some((paramName) =>
                hasStaticConstant(this.context, paramName),
            )
        ) {
            throwInternalCompilerError(
                `some parameter of function ${idText(functionCode.name)} shadows a constant with the same name`,
                functionCode.loc,
            );
        }
        // Call function inside a new environment
        return this.envStack.executeInNewEnvironment(
            () => {
                // Interpret all the statements
                try {
                    functionCode.statements.forEach(
                        this.interpretStatement,
                        this,
                    );
                    // At this point, the function did not execute a return.
                    // Execution continues after the catch.
                } catch (e) {
                    if (e instanceof ReturnSignal) {
                        const val = e.getValue();
                        if (val !== undefined) {
                            return val;
                        }
                        // The function executed a return without a value.
                        // Execution continues after the catch.
                    } else {
                        throw e;
                    }
                }
                // If execution reaches this point, it means that
                // the function had no return statement or executed a return
                // without a value. This is an error only if the return type of the
                // function is not void
                if (returns.kind !== "void") {
                    throwInternalCompilerError(
                        `function ${idText(functionCode.name)} must return a value`,
                        functionCode.loc,
                    );
                } else {
                    // The function does not return a value.
                    // We rely on the typechecker so that the function is called as a statement.
                    // Hence, we can return a dummy null, since the null will be discarded anyway.
                    return null;
                }
            },
            { names: paramNames, values: argValues },
        );
    }

    public interpretStatement(ast: AstStatement): void {
        switch (ast.kind) {
            case "statement_let":
                this.interpretLetStatement(ast);
                break;
            case "statement_destruct":
                this.interpretDestructStatement(ast);
                break;
            case "statement_assign":
                this.interpretAssignStatement(ast);
                break;
            case "statement_augmentedassign":
                this.interpretAugmentedAssignStatement(ast);
                break;
            case "statement_condition":
                this.interpretConditionStatement(ast);
                break;
            case "statement_expression":
                this.interpretExpressionStatement(ast);
                break;
            case "statement_foreach":
                this.interpretForEachStatement(ast);
                break;
            case "statement_repeat":
                this.interpretRepeatStatement(ast);
                break;
            case "statement_return":
                this.interpretReturnStatement(ast);
                break;
            case "statement_try":
                this.interpretTryStatement(ast);
                break;
            case "statement_try_catch":
                this.interpretTryCatchStatement(ast);
                break;
            case "statement_until":
                this.interpretUntilStatement(ast);
                break;
            case "statement_while":
                this.interpretWhileStatement(ast);
                break;
        }
    }

    public interpretLetStatement(ast: AstStatementLet) {
        if (hasStaticConstant(this.context, idText(ast.name))) {
            // Attempt of shadowing a constant in a let declaration
            throwInternalCompilerError(
                `declaration of ${idText(ast.name)} shadows a constant with the same name`,
                ast.loc,
            );
        }
        const val = this.interpretExpression(ast.expression);
        this.envStack.setNewBinding(idText(ast.name), val);
    }

    public interpretDestructStatement(ast: AstStatementDestruct) {
        for (const [_, name] of ast.identifiers.values()) {
            if (hasStaticConstant(this.context, idText(name))) {
                // Attempt of shadowing a constant in a destructuring declaration
                throwInternalCompilerError(
                    `declaration of ${idText(name)} shadows a constant with the same name`,
                    ast.loc,
                );
            }
        }
        const val = this.interpretExpression(ast.expression);
        if (
            val === null ||
            typeof val !== "object" ||
            !("$tactStruct" in val)
        ) {
            throwErrorConstEval(
                `destructuring assignment expected a struct, but got ${showValue(
                    val,
                )}`,
                ast.expression.loc,
            );
        }

        for (const [field, name] of ast.identifiers.values()) {
            if (name.text === "_") {
                continue;
            }
            const v = val[idText(field)];
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (v === undefined) {
                throwErrorConstEval(
                    `destructuring assignment expected field ${idTextErr(
                        field,
                    )}`,
                    ast.loc,
                );
            }
            this.envStack.setNewBinding(idText(name), v);
        }
    }

    public interpretAssignStatement(ast: AstStatementAssign) {
        if (ast.path.kind === "id") {
            const val = this.interpretExpression(ast.expression);
            this.envStack.updateBinding(idText(ast.path), val);
        } else {
            throwNonFatalErrorConstEval(
                "only identifiers are currently supported as path expressions",
                ast.path.loc,
            );
        }
    }

    public interpretAugmentedAssignStatement(ast: AstStatementAugmentedAssign) {
        if (ast.path.kind === "id") {
            const updateVal = () => this.interpretExpression(ast.expression);
            const currentPathValue = this.envStack.getBinding(idText(ast.path));
            if (currentPathValue === undefined) {
                throwNonFatalErrorConstEval(
                    "undeclared identifier",
                    ast.path.loc,
                );
            }
            const newVal = evalBinaryOp(
                ast.op,
                currentPathValue,
                updateVal,
                ast.path.loc,
                ast.expression.loc,
                ast.loc,
            );
            this.envStack.updateBinding(idText(ast.path), newVal);
        } else {
            throwNonFatalErrorConstEval(
                "only identifiers are currently supported as path expressions",
                ast.path.loc,
            );
        }
    }

    public interpretConditionStatement(ast: AstCondition) {
        const condition = ensureBoolean(
            this.interpretExpression(ast.condition),
            ast.condition.loc,
        );
        if (condition) {
            this.envStack.executeInNewEnvironment(() => {
                ast.trueStatements.forEach(this.interpretStatement, this);
            });
        } else if (ast.falseStatements !== null) {
            this.envStack.executeInNewEnvironment(() => {
                ast.falseStatements!.forEach(this.interpretStatement, this);
            });
        }
    }

    public interpretExpressionStatement(ast: AstStatementExpression) {
        this.interpretExpression(ast.expression);
    }

    public interpretForEachStatement(ast: AstStatementForEach) {
        throwNonFatalErrorConstEval("foreach currently not supported", ast.loc);
    }

    public interpretRepeatStatement(ast: AstStatementRepeat) {
        const iterations = ensureRepeatInt(
            this.interpretExpression(ast.iterations),
            ast.iterations.loc,
        );
        if (iterations > 0) {
            // We can create a single environment for all the iterations in the loop
            // (instead of a fresh environment for each iteration)
            // because the typechecker ensures that variables do not leak outside
            // the loop. Also, the language requires that all declared variables inside the
            // loop be initialized, which means that we can overwrite its value in the environment
            // in each iteration.
            this.envStack.executeInNewEnvironment(() => {
                for (let i = 1; i <= iterations; i++) {
                    ast.statements.forEach(this.interpretStatement, this);
                }
            });
        }
    }

    public interpretReturnStatement(ast: AstStatementReturn) {
        if (ast.expression !== null) {
            const val = this.interpretExpression(ast.expression);
            throw new ReturnSignal(val);
        } else {
            throw new ReturnSignal();
        }
    }

    public interpretTryStatement(ast: AstStatementTry) {
        throwNonFatalErrorConstEval(
            "try statements currently not supported",
            ast.loc,
        );
    }

    public interpretTryCatchStatement(ast: AstStatementTryCatch) {
        throwNonFatalErrorConstEval(
            "try-catch statements currently not supported",
            ast.loc,
        );
    }

    public interpretUntilStatement(ast: AstStatementUntil) {
        let condition;
        let iterCount = 0;
        // We can create a single environment for all the iterations in the loop
        // (instead of a fresh environment for each iteration)
        // because the typechecker ensures that variables do not leak outside
        // the loop. Also, the language requires that all declared variables inside the
        // loop be initialized, which means that we can overwrite its value in the environment
        // in each iteration.
        this.envStack.executeInNewEnvironment(() => {
            do {
                ast.statements.forEach(this.interpretStatement, this);

                iterCount++;
                if (iterCount >= this.config.maxLoopIterations) {
                    throwNonFatalErrorConstEval(
                        "loop timeout reached",
                        ast.loc,
                    );
                }
                // The typechecker ensures that the condition does not refer to
                // variables declared inside the loop.
                condition = ensureBoolean(
                    this.interpretExpression(ast.condition),
                    ast.condition.loc,
                );
            } while (!condition);
        });
    }

    public interpretWhileStatement(ast: AstStatementWhile) {
        let condition;
        let iterCount = 0;
        // We can create a single environment for all the iterations in the loop
        // (instead of a fresh environment for each iteration)
        // because the typechecker ensures that variables do not leak outside
        // the loop. Also, the language requires that all declared variables inside the
        // loop be initialized, which means that we can overwrite its value in the environment
        // in each iteration.
        this.envStack.executeInNewEnvironment(() => {
            do {
                // The typechecker ensures that the condition does not refer to
                // variables declared inside the loop.
                condition = ensureBoolean(
                    this.interpretExpression(ast.condition),
                    ast.condition.loc,
                );
                if (condition) {
                    ast.statements.forEach(this.interpretStatement, this);

                    iterCount++;
                    if (iterCount >= this.config.maxLoopIterations) {
                        throwNonFatalErrorConstEval(
                            "loop timeout reached",
                            ast.loc,
                        );
                    }
                }
            } while (condition);
        });
    }
}


## logger.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/logger.ts)
export enum LogLevel {
    /** Logging is turned off */
    NONE,
    /** Logs only error messages */
    ERROR,
    /** Logs warning and error messages */
    WARN,
    /** Logs informational, warning, and error messages */
    INFO,
    /** Logs debugging, informational, warning, and error messages */
    DEBUG,
}

type messageType = string | Error;

/**
 * Interface defining the logging methods used by the `Logger` class, enabling
 * custom logger implementations.
 */
export interface ILogger {
    debug: (message: messageType) => void;
    info: (message: messageType) => void;
    warn: (message: messageType) => void;
    error: (message: messageType) => void;
}

const logLevelToMethodName: { [key in LogLevel]: keyof ILogger | null } = {
    [LogLevel.NONE]: null,
    [LogLevel.ERROR]: "error",
    [LogLevel.WARN]: "warn",
    [LogLevel.INFO]: "info",
    [LogLevel.DEBUG]: "debug",
};

function getLoggingMethod(level: LogLevel): keyof ILogger | null {
    return logLevelToMethodName[level];
}

export class Logger {
    private level: LogLevel;
    private logMethods: ILogger;

    constructor(level: LogLevel = LogLevel.INFO) {
        this.level = level;
        this.logMethods = {
            debug: console.log,
            info: console.log,
            warn: console.warn,
            error: console.error,
        };
    }

    protected log(level: LogLevel, message: messageType) {
        if (this.level === LogLevel.NONE) {
            return;
        }

        if (message instanceof Error) {
            message = message.stack ?? message.message;
        } else {
            message = message.toString();
        }

        if (level > this.level) return;

        const loggingMethod = getLoggingMethod(level);
        if (!loggingMethod) return;

        this.logMethods[loggingMethod](message);
    }

    debug(message: messageType) {
        this.log(LogLevel.DEBUG, message);
    }

    info(message: messageType) {
        this.log(LogLevel.INFO, message);
    }

    warn(message: messageType) {
        this.log(LogLevel.WARN, message);
    }

    error(message: messageType) {
        this.log(LogLevel.ERROR, message);
    }

    setLevel(level: LogLevel) {
        this.level = level;
    }
}


## main.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/main.ts)
export {
    Config,
    ConfigProject,
    parseConfig,
    verifyConfig,
} from "./config/parseConfig";

export { PackageFileFormat } from "./packaging/fileFormat";

export { build } from "./pipeline/build";

export { VirtualFileSystem } from "./vfs/VirtualFileSystem";

export { createVirtualFileSystem } from "./vfs/createVirtualFileSystem";

export * from "./browser";
export * from "./verify";
export * from "./logger";
export * from "./errors";
export * from "./check";


## node.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/node.ts)
import path from "path";
import fs from "fs";
import { ConfigProject, Config, parseConfig } from "./config/parseConfig";
import { createNodeFileSystem } from "./vfs/createNodeFileSystem";
import { build } from "./pipeline/build";
import { LogLevel, Logger } from "./logger";
import { TactErrorCollection } from "./errors";

type AdditionalCliOptions = {
    mode?: ConfigProject["mode"];
};

type ConfigWithRootPath = Config & {
    rootPath: string;
    singleFile: boolean;
};

function configForSingleFile(fileName: string): ConfigWithRootPath {
    return {
        projects: [
            {
                name: path.basename(fileName, ".tact"),
                path: fileName,
                output: path.dirname(fileName),
                options: {
                    debug: true,
                    external: true,
                    ipfsAbiGetter: false,
                    interfacesGetter: false,
                },
                mode: "full",
            },
        ],
        rootPath: process.cwd(),
        singleFile: true,
    };
}

function loadConfig(
    fileName?: string,
    configPath?: string,
): ConfigWithRootPath | null {
    if (fileName) return configForSingleFile(fileName);

    if (!configPath) return null;

    let config: Config;

    // Load config
    const resolvedPath = path.resolve(configPath);
    const rootPath = path.dirname(resolvedPath);
    if (!fs.existsSync(resolvedPath)) {
        console.warn("Unable to find config file at " + resolvedPath);
        return null;
    }
    try {
        config = parseConfig(fs.readFileSync(resolvedPath, "utf8"));
    } catch (e) {
        console.log(e);
        console.warn("Unable to parse config file at " + resolvedPath);
        return null;
    }
    return { singleFile: false, rootPath, ...config };
}

export async function run(args: {
    fileName?: string;
    configPath?: string;
    projectNames?: string[];
    additionalCliOptions?: AdditionalCliOptions;
    suppressLog?: boolean;
}) {
    const configWithRootPath = await loadConfig(args.fileName, args.configPath);
    if (!configWithRootPath) {
        return {
            ok: false,
            error: [
                new Error(
                    `Unable to load config from path: ${args.configPath}`,
                ),
            ],
        };
    }

    const logger = new Logger(args.suppressLog ? LogLevel.NONE : LogLevel.INFO);

    // Resolve projects
    let projects = configWithRootPath.projects;
    if (args.projectNames && args.projectNames.length > 0) {
        // Check that all project names are valid
        for (const pp of args.projectNames) {
            if (!projects.find((v) => v.name === pp)) {
                const message = "Unable to find project " + pp;
                logger.warn(message);
                return {
                    ok: false,
                    error: [new Error(message)],
                };
            }
        }

        // Filter by names
        projects = projects.filter((v) => args.projectNames!.includes(v.name));
    }
    if (projects.length === 0) {
        const message = "No projects to compile";
        console.warn(message);
        return { ok: false, error: [new Error(message)] };
    }

    // Compile
    let success = true;
    let errorMessages: TactErrorCollection[] = [];
    const project = createNodeFileSystem(
        configWithRootPath.rootPath as string,
        false,
    );
    const stdlib = createNodeFileSystem(
        path.resolve(__dirname, "..", "stdlib"),
        false,
    ); // Improves developer experience
    for (const config of projects) {
        logger.info(`💼 Compiling project ${config.name} ...`);
        let cliConfig = { ...config };

        if (args.additionalCliOptions?.mode !== undefined) {
            cliConfig = { ...config, ...args.additionalCliOptions };
        }

        const built = await build({
            config: cliConfig,
            project,
            stdlib,
            logger,
        });
        success = success && built.ok;
        if (!built.ok && built.error.length > 0) {
            errorMessages = [...errorMessages, ...built.error];
        }
    }
    return { ok: success, error: errorMessages };
}

export { createNodeFileSystem } from "./vfs/createNodeFileSystem";

export { parseAndEvalExpression } from "./interpreter";


## prettyPrinter.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/prettyPrinter.ts)
import * as A from "./grammar/ast";
import { groupBy, intercalate, isUndefined } from "./utils/array";
import { makeVisitor } from "./utils/tricks";

//
// Types
//

export const ppAstTypeId = A.idText;

export const ppAstTypeIdWithStorage = (
    type: A.AstTypeId,
    storageType: A.AstId | null,
): string => {
    const alias = storageType ? ` as ${ppAstId(storageType)}` : "";
    return `${ppAstTypeId(type)}${alias}`;
};

export const ppAstMapType = ({
    keyType,
    keyStorageType,
    valueType,
    valueStorageType,
}: A.AstMapType): string => {
    const key = ppAstTypeIdWithStorage(keyType, keyStorageType);
    const value = ppAstTypeIdWithStorage(valueType, valueStorageType);
    return `map<${key}, ${value}>`;
};

export const ppAstBouncedMessageType = ({
    messageType,
}: A.AstBouncedMessageType): string => `bounced<${ppAstTypeId(messageType)}>`;

export const ppAstOptionalType = ({ typeArg }: A.AstOptionalType): string =>
    `${ppAstType(typeArg)}?`;

export const ppAstType = makeVisitor<A.AstType>()({
    type_id: ppAstTypeId,
    map_type: ppAstMapType,
    bounced_message_type: ppAstBouncedMessageType,
    optional_type: ppAstOptionalType,
});

//
// Expressions
//

export const unaryOperatorType: Record<A.AstUnaryOperation, "post" | "pre"> = {
    "+": "pre",
    "-": "pre",
    "!": "pre",
    "~": "pre",

    "!!": "post",
};

export const checkPostfix = (operator: A.AstUnaryOperation) =>
    unaryOperatorType[operator] === "post";

/**
 * Description of precedence of certain type of AST node
 */
export type Precedence = {
    /**
     * Add parentheses around `code` if in this `parent` position we need brackets
     * @param check Position-checking function from parent
     * @param code Code to put parentheses around
     * @returns
     */
    brace: (
        position: (childPrecedence: number) => boolean,
        code: string,
    ) => string;
    /**
     * Used in positions where grammar rule mentions itself
     *
     * Passed down when a position allows same unparenthesized operator
     * For example, on left side of addition we can use another addition without
     * parentheses: `1 + 2 + 3` means `(1 + 2) + 3`. Thus for left-associative
     * operators we pass `self` to their left argument printer.
     */
    self: (childPrecedence: number) => boolean;
    /**
     * Used in positions where grammar rule mentions other rule
     *
     * Passed down when a position disallows same unparenthesized operator
     * For example, on the right side of subtraction we can't use another subtraction
     * without parentheses: `1 - (2 - 3)` is not the same as `(1 - 2) - 3`. Thus for
     * left-associative operators we pass `child` to their right argument printer.
     */
    child: (childPrecedence: number) => boolean;
};

/**
 * Given numeric value of precedence, where higher values stand for higher binding power,
 * create a helper object for precedence checking
 */
export const makePrecedence = (myPrecedence: number): Precedence => ({
    brace: (position, code) => (position(myPrecedence) ? `(${code})` : code),
    self: (childPrecedence) => childPrecedence < myPrecedence,
    child: (childPrecedence) => childPrecedence <= myPrecedence,
});

// Least binding operator
export const lowestPrecedence = makePrecedence(0);

export const conditionalPrecedence = makePrecedence(20);

export const binaryPrecedence: Readonly<
    Record<A.AstBinaryOperation, Precedence>
> = {
    "||": makePrecedence(30),

    "&&": makePrecedence(40),

    "|": makePrecedence(50),

    "^": makePrecedence(60),

    "&": makePrecedence(70),

    "==": makePrecedence(80),
    "!=": makePrecedence(80),

    "<": makePrecedence(90),
    ">": makePrecedence(90),
    "<=": makePrecedence(90),
    ">=": makePrecedence(90),

    "<<": makePrecedence(100),
    ">>": makePrecedence(100),

    "+": makePrecedence(110),
    "-": makePrecedence(110),

    "*": makePrecedence(120),
    "/": makePrecedence(120),
    "%": makePrecedence(120),
};

export const prefixPrecedence = makePrecedence(140);

// Used by postfix unary !!, method calls and field accesses
export const postfixPrecedence = makePrecedence(150);

/**
 * Expression printer takes an expression and a function from parent AST node printer that checks
 * whether expressions with given precedence should be parenthesized in parent context
 */
export type ExprPrinter<T> = (
    expr: T,
) => (check: (childPrecedence: number) => boolean) => string;

/**
 * Wrapper for AST nodes that should never be parenthesized, and thus do not require information
 * about the position they're printed in
 *
 * Takes a regular printer function and returns corresponding ExprPrinter that ignores all
 * position and precedence information
 */
export const ppLeaf =
    <T>(printer: (t: T) => string): ExprPrinter<T> =>
    (node) =>
    () =>
        printer(node);

export const ppExprArgs = (args: A.AstExpression[]) =>
    args.map((arg) => ppAstExpression(arg)).join(", ");

export const ppAstStructFieldInit = (
    param: A.AstStructFieldInitializer,
): string => `${ppAstId(param.field)}: ${ppAstExpression(param.initializer)}`;

export const ppAstStructInstance = ({ type, args }: A.AstStructInstance) =>
    `${ppAstId(type)}{${args.map((x) => ppAstStructFieldInit(x)).join(", ")}}`;

export const ppAstInitOf = ({ contract, args }: A.AstInitOf) =>
    `initOf ${ppAstId(contract)}(${ppExprArgs(args)})`;

export const ppAstNumber = A.astNumToString;
export const ppAstBoolean = ({ value }: A.AstBoolean) => value.toString();
export const ppAstId = ({ text }: A.AstId) => text;
export const ppAstNull = (_expr: A.AstNull) => "null";
export const ppAstString = ({ value }: A.AstString) => `"${value}"`;

export const ppAstStaticCall = ({ function: func, args }: A.AstStaticCall) => {
    return `${ppAstId(func)}(${ppExprArgs(args)})`;
};

export const ppAstMethodCall: ExprPrinter<A.AstMethodCall> =
    ({ self: object, method, args }) =>
    (position) => {
        const { brace, self } = postfixPrecedence;
        return brace(
            position,
            `${ppAstExpressionNested(object)(self)}.${ppAstId(method)}(${ppExprArgs(args)})`,
        );
    };

export const ppAstFieldAccess: ExprPrinter<A.AstFieldAccess> =
    ({ aggregate, field }) =>
    (position) => {
        const { brace, self } = postfixPrecedence;
        return brace(
            position,
            `${ppAstExpressionNested(aggregate)(self)}.${ppAstId(field)}`,
        );
    };

export const ppAstOpUnary: ExprPrinter<A.AstOpUnary> =
    ({ op, operand }) =>
    (position) => {
        const isPostfix = checkPostfix(op);
        const { brace, self } = isPostfix
            ? postfixPrecedence
            : prefixPrecedence;
        const code = ppAstExpressionNested(operand)(self);
        return brace(position, isPostfix ? `${code}${op}` : `${op}${code}`);
    };

export const ppAstOpBinary: ExprPrinter<A.AstOpBinary> =
    ({ left, op, right }) =>
    (position) => {
        const { brace, self, child } = binaryPrecedence[op];
        const leftCode = ppAstExpressionNested(left)(self);
        const rightCode = ppAstExpressionNested(right)(child);
        return brace(position, `${leftCode} ${op} ${rightCode}`);
    };

export const ppAstConditional: ExprPrinter<A.AstConditional> =
    ({ condition, thenBranch, elseBranch }) =>
    (position) => {
        const { brace, self, child } = conditionalPrecedence;
        const conditionCode = ppAstExpressionNested(condition)(child);
        const thenCode = ppAstExpressionNested(thenBranch)(child);
        const elseCode = ppAstExpressionNested(elseBranch)(self);
        return brace(position, `${conditionCode} ? ${thenCode} : ${elseCode}`);
    };

export const ppAstExpressionNested = makeVisitor<A.AstExpression>()({
    struct_instance: ppLeaf(ppAstStructInstance),
    number: ppLeaf(ppAstNumber),
    boolean: ppLeaf(ppAstBoolean),
    id: ppLeaf(ppAstId),
    null: ppLeaf(ppAstNull),
    init_of: ppLeaf(ppAstInitOf),
    string: ppLeaf(ppAstString),
    static_call: ppLeaf(ppAstStaticCall),

    method_call: ppAstMethodCall,
    field_access: ppAstFieldAccess,

    op_unary: ppAstOpUnary,

    op_binary: ppAstOpBinary,

    conditional: ppAstConditional,
});

export const ppAstExpression = (expr: A.AstExpression): string => {
    return ppAstExpressionNested(expr)(lowestPrecedence.child);
};

/**
 * An intermediate language that is only concerned of spacing and indentation
 */
type Context<U> = {
    /**
     * Line of code with \n implied
     */
    row: (s: string) => U;

    /**
     * Stacks lines after each other
     */
    block: (rows: readonly U[]) => U;

    /**
     * Similar to `block`, but adjacent lines of groups get concatenated
     * [a, b] + [c, d] = [a, bc, d]
     */
    concat: (rows: readonly U[]) => U;

    /**
     * Same as `indent`, but indents `rows` 1 level deeper and adds `{` and `}`
     */
    braced: (rows: readonly U[]) => U;

    /**
     * Print a list of `items` with `print`
     */
    list: <T>(items: readonly T[], print: Printer<T>) => readonly U[];

    /**
     * Display `items` with `print` in groups distinguished by return value of `getTag`
     */
    grouped: <T, V>(options: {
        items: readonly T[];
        /**
         * Items with the same tag are displayed without extra empty line between them
         *
         * Use NaN for tag whenever items should always be displayed with empty line,
         * because NaN !== NaN
         */
        getTag: (t: T) => V;
        print: Printer<T>;
    }) => readonly U[];
};

/**
 * Generates line of code with indentation, given desired indentation level of outer scope
 */
type LevelFn = (level: number) => string;

/**
 * Result of printing an expression is an array of rows, parameterized over indentation
 * of outer scope
 */
type ContextModel = readonly LevelFn[];

/**
 * Concatenates an array of printing results, so that last line of each expression is merged
 * with first line of next expression
 *
 * Typically used to generate multiline indented code as part of single-line expression
 *
 * Roughly, `concat(["while (true)"], [" "], ["{", "...", "}"]) = ["while (true) {", "...", "}"]`
 */
const concat = ([head, ...tail]: readonly ContextModel[]): ContextModel => {
    // If we're concatenating an empty array, the result is always empty
    if (isUndefined(head)) {
        return [];
    }
    // Create a copy of first printing result, where we'll accumulate other results
    const init = [...head];
    // Recursively concatenate all printing results except for first
    const next = concat(tail);
    // Take last line of first printing result
    const last = init.pop();
    // If first printing result has no lines, return concatenation result of all others
    if (isUndefined(last)) {
        return next;
    }
    // Get first line on concatenated printing results starting with second
    const [nextHead, ...nextTail] = next;
    // If they all concatenated into an array of 0 lines, just return first printing result
    if (isUndefined(nextHead)) {
        return head;
    }
    // Otherwise concatenate results, leaving indent only in front of the merged line
    return [...init, (level) => last(level) + nextHead(0), ...nextTail];
};

const createContext = (spaces: number): Context<ContextModel> => {
    const row = (s: string) => [
        // Empty lines are not indented
        (level: number) => (s === "" ? s : " ".repeat(level * spaces) + s),
    ];
    const block = (rows: readonly ContextModel[]) => rows.flat();
    const indent = (rows: readonly ContextModel[]) =>
        block(rows).map((f) => (level: number) => f(level + 1));
    const braced = (rows: readonly ContextModel[]) =>
        block([row(`{`), indent(rows), row(`}`)]);
    const list = <T>(items: readonly T[], print: Printer<T>) =>
        items.map((node) => print(node)(ctx));
    const grouped = <T, V>({
        items,
        getTag,
        print,
    }: {
        items: readonly T[];
        getTag: (t: T) => V;
        print: Printer<T>;
    }) => {
        return intercalate(
            groupBy(items, getTag).map((group) => list(group, print)),
            row(""),
        );
    };
    const ctx: Context<ContextModel> = {
        row,
        concat,
        block,
        braced,
        list,
        grouped,
    };
    return ctx;
};

/**
 * Prints AST node of type `T` into an intermediate language of row of type `U`
 *
 * We enforce `U` to be a generic argument so that no implementation can (ab)use
 * the fact it's a string and generate some indentation without resorting to
 * methods of `Context`.
 */
type Printer<T> = (item: T) => <U>(ctx: Context<U>) => U;

export const ppAstModule: Printer<A.AstModule> =
    ({ imports, items }) =>
    (c) => {
        const itemsCode = c.grouped({
            items,
            getTag: ({ kind }) => (kind === "constant_def" ? 1 : NaN),
            print: ppModuleItem,
        });
        if (imports.length === 0) {
            return c.block(itemsCode);
        }
        return c.block([
            ...c.list(imports, ppAstImport),
            c.row(""),
            ...itemsCode,
        ]);
    };

export const ppAstStruct: Printer<A.AstStructDecl> =
    ({ name, fields }) =>
    (c) =>
        c.concat([
            c.row(`struct ${ppAstId(name)} `),
            c.braced(c.list(fields, ppAstFieldDecl)),
        ]);

export const ppAstContract: Printer<A.AstContract> =
    ({ name, traits, declarations, attributes }) =>
    (c) => {
        const attrsCode = attributes
            .map(({ name: { value } }) => `@interface("${value}") `)
            .join("");
        const traitsCode = traits.map((trait) => trait.text).join(", ");
        const header = traitsCode
            ? `contract ${ppAstId(name)} with ${traitsCode}`
            : `contract ${ppAstId(name)}`;
        return c.concat([
            c.row(`${attrsCode}${header} `),
            c.braced(
                c.grouped({
                    items: declarations,
                    getTag: ({ kind }) =>
                        kind === "constant_def"
                            ? 1
                            : kind === "field_decl"
                              ? 2
                              : NaN,
                    print: ppContractBody,
                }),
            ),
        ]);
    };

export const ppAstPrimitiveTypeDecl: Printer<A.AstPrimitiveTypeDecl> =
    ({ name }) =>
    (c) =>
        c.row(`primitive ${ppAstId(name)};`);

export const ppAstFunctionDef: Printer<A.AstFunctionDef> = (node) => (c) =>
    c.concat([
        c.row(ppAstFunctionSignature(node)),
        c.row(" "),
        ppStatementBlock(node.statements)(c),
    ]);

export const ppAsmShuffle = ({ args, ret }: A.AstAsmShuffle): string => {
    if (args.length === 0 && ret.length === 0) {
        return "";
    }
    const argsCode = args.map(({ text }) => text).join(" ");
    if (ret.length === 0) {
        return `(${argsCode})`;
    }
    const retCode = ret.map(({ value }) => value.toString()).join(" ");
    return `(${argsCode} -> ${retCode})`;
};

export const ppAstAsmFunctionDef: Printer<A.AstAsmFunctionDef> =
    (node) => (c) =>
        c.concat([
            c.row(
                `asm${ppAsmShuffle(node.shuffle)} ${ppAstFunctionSignature(node)} `,
            ),
            ppAsmInstructionsBlock(node.instructions)(c),
        ]);

export const ppAstNativeFunction: Printer<A.AstNativeFunctionDecl> =
    ({ name, nativeName, params, return: retTy, attributes }) =>
    (c) => {
        const attrs = attributes.map(({ type }) => type + " ").join("");
        const argsCode = params
            .map(({ name, type }) => `${ppAstId(name)}: ${ppAstType(type)}`)
            .join(", ");
        const returnType = retTy ? `: ${ppAstType(retTy)}` : "";
        return c.block([
            c.row(`@name(${ppAstFuncId(nativeName)})`),
            c.row(`${attrs}native ${ppAstId(name)}(${argsCode})${returnType};`),
        ]);
    };

export const ppAstTrait: Printer<A.AstTrait> =
    ({ name, traits, attributes, declarations }) =>
    (c) => {
        const attrsCode = attributes
            .map((attr) => `@${attr.type}("${attr.name.value}") `)
            .join("");
        const traitsCode = traits.map((t) => ppAstId(t)).join(", ");
        const header = traitsCode
            ? `trait ${ppAstId(name)} with ${traitsCode}`
            : `trait ${ppAstId(name)}`;
        return c.concat([
            c.row(`${attrsCode}${header} `),
            c.braced(
                c.grouped({
                    items: declarations,
                    getTag: ({ kind }) =>
                        kind === "constant_def" || kind === "constant_decl"
                            ? 1
                            : kind === "field_decl"
                              ? 2
                              : NaN,
                    print: ppTraitBody,
                }),
            ),
        ]);
    };

export const ppAstConstant: Printer<A.AstConstantDef> =
    ({ attributes, initializer, name, type }) =>
    (c) => {
        const attrsCode = attributes.map(({ type }) => type + " ").join("");
        return c.row(
            `${attrsCode}const ${ppAstId(name)}: ${ppAstType(type)} = ${ppAstExpression(initializer)};`,
        );
    };

export const ppAstMessage: Printer<A.AstMessageDecl> =
    ({ name, opcode, fields }) =>
    (c) => {
        const prefixCode =
            opcode !== null ? `(${ppAstExpression(opcode)})` : "";

        return c.concat([
            c.row(`message${prefixCode} ${ppAstId(name)} `),
            c.braced(c.list(fields, ppAstFieldDecl)),
        ]);
    };

export const ppModuleItem: Printer<A.AstModuleItem> =
    makeVisitor<A.AstModuleItem>()({
        struct_decl: ppAstStruct,
        contract: ppAstContract,
        primitive_type_decl: ppAstPrimitiveTypeDecl,
        function_def: ppAstFunctionDef,
        asm_function_def: ppAstAsmFunctionDef,
        native_function_decl: ppAstNativeFunction,
        trait: ppAstTrait,
        constant_def: ppAstConstant,
        message_decl: ppAstMessage,
    });

export const ppAstFieldDecl: Printer<A.AstFieldDecl> =
    ({ type, initializer, as, name }) =>
    (c) => {
        const asAlias = as ? ` as ${ppAstId(as)}` : "";
        const initializerCode = initializer
            ? ` = ${ppAstExpression(initializer)}`
            : "";
        return c.row(
            `${ppAstId(name)}: ${ppAstType(type)}${asAlias}${initializerCode};`,
        );
    };

export const ppAstReceiver: Printer<A.AstReceiver> =
    ({ selector, statements }) =>
    (c) =>
        c.concat([
            c.row(`${ppAstReceiverHeader(selector)} `),
            ppStatementBlock(statements)(c),
        ]);

export const ppAstFunctionDecl: Printer<A.AstFunctionDecl> = (f) => (c) =>
    c.row(`${ppAstFunctionSignature(f)};`);

export const ppAstConstDecl: Printer<A.AstConstantDecl> =
    ({ attributes, name, type }) =>
    (c) => {
        const attrsCode = attributes.map(({ type }) => type + " ").join("");
        return c.row(`${attrsCode}const ${ppAstId(name)}: ${ppAstType(type)};`);
    };

export const ppTraitBody: Printer<A.AstTraitDeclaration> =
    makeVisitor<A.AstTraitDeclaration>()({
        function_def: ppAstFunctionDef,
        asm_function_def: ppAstAsmFunctionDef,
        constant_def: ppAstConstant,
        field_decl: ppAstFieldDecl,
        receiver: ppAstReceiver,
        function_decl: ppAstFunctionDecl,
        constant_decl: ppAstConstDecl,
    });

export const ppAstInitFunction: Printer<A.AstContractInit> =
    ({ params, statements }) =>
    (c) => {
        const argsCode = params
            .map(({ name, type }) => `${ppAstId(name)}: ${ppAstType(type)}`)
            .join(", ");
        if (statements.length === 0) {
            return c.row(`init(${argsCode}) {}`);
        }
        return c.concat([
            c.row(`init(${argsCode}) `),
            c.braced(c.list(statements, ppAstStatement)),
        ]);
    };

export const ppContractBody: Printer<A.AstContractDeclaration> =
    makeVisitor<A.AstContractDeclaration>()({
        field_decl: ppAstFieldDecl,
        function_def: ppAstFunctionDef,
        asm_function_def: ppAstAsmFunctionDef,
        contract_init: ppAstInitFunction,
        receiver: ppAstReceiver,
        constant_def: ppAstConstant,
    });

export const ppAstImport: Printer<A.AstImport> =
    ({ path }) =>
    (c) =>
        c.row(`import "${path.value}";`);

export const ppAstFunctionSignature = ({
    name,
    attributes,
    return: retTy,
    params,
}: A.AstFunctionDef | A.AstAsmFunctionDef | A.AstFunctionDecl): string => {
    const argsCode = params
        .map(({ name, type }) => `${ppAstId(name)}: ${ppAstType(type)}`)
        .join(", ");
    const attrsCode = attributes
        .map((attr) => ppAstFunctionAttribute(attr) + " ")
        .join("");
    const returnType = retTy ? `: ${ppAstType(retTy)}` : "";
    return `${attrsCode}fun ${ppAstId(name)}(${argsCode})${returnType}`;
};

export const ppAstFunctionAttribute = (
    attr: A.AstFunctionAttribute,
): string => {
    if (attr.type === "get" && attr.methodId !== null) {
        return `get(${ppAstExpression(attr.methodId)})`;
    } else {
        return attr.type;
    }
};

export const ppAstReceiverHeader = makeVisitor<A.AstReceiverKind>()({
    bounce: ({ param: { name, type } }) =>
        `bounced(${ppAstId(name)}: ${ppAstType(type)})`,
    "internal-simple": ({ param: { name, type } }) =>
        `receive(${ppAstId(name)}: ${ppAstType(type)})`,
    "external-simple": ({ param: { name, type } }) =>
        `external(${ppAstId(name)}: ${ppAstType(type)})`,
    "internal-fallback": () => `receive()`,
    "external-fallback": () => `external()`,
    "internal-comment": ({ comment: { value } }) => `receive("${value}")`,
    "external-comment": ({ comment: { value } }) => `external("${value}")`,
});

export const ppAstFuncId = (func: A.AstFuncId): string => func.text;

//
// Statements
//

export const ppStatementBlock: Printer<A.AstStatement[]> = (stmts) => (c) =>
    c.braced(stmts.length === 0 ? [c.row("")] : c.list(stmts, ppAstStatement));

export const ppAsmInstructionsBlock: Printer<A.AstAsmInstruction[]> =
    (instructions) => (c) =>
        c.braced(instructions.map(c.row));

export const ppAstStatementLet: Printer<A.AstStatementLet> =
    ({ type, name, expression }) =>
    (c) => {
        const tyAnnotation = type === null ? "" : `: ${ppAstType(type)}`;
        return c.row(
            `let ${ppAstId(name)}${tyAnnotation} = ${ppAstExpression(expression)};`,
        );
    };

export const ppAstStatementReturn: Printer<A.AstStatementReturn> =
    ({ expression }) =>
    (c) =>
        c.row(`return ${expression ? ppAstExpression(expression) : ""};`);

export const ppAstStatementExpression: Printer<A.AstStatementExpression> =
    ({ expression }) =>
    (c) =>
        c.row(`${ppAstExpression(expression)};`);

export const ppAstStatementAssign: Printer<A.AstStatementAssign> =
    ({ path, expression }) =>
    (c) =>
        c.row(`${ppAstExpression(path)} = ${ppAstExpression(expression)};`);

export const ppAstStatementAugmentedAssign: Printer<
    A.AstStatementAugmentedAssign
> =
    ({ path, op, expression }) =>
    (c) =>
        c.row(
            `${ppAstExpression(path)} ${op}= ${ppAstExpression(expression)};`,
        );

export const ppAstCondition: Printer<A.AstCondition> =
    ({ condition, trueStatements, falseStatements }) =>
    (c) => {
        if (falseStatements) {
            return c.concat([
                c.row(`if (${ppAstExpression(condition)}) `),
                ppStatementBlock(trueStatements)(c),
                c.row(" else "),
                ppStatementBlock(falseStatements)(c),
            ]);
        } else {
            return c.concat([
                c.row(`if (${ppAstExpression(condition)}) `),
                ppStatementBlock(trueStatements)(c),
            ]);
        }
    };

export const ppAstStatementWhile: Printer<A.AstStatementWhile> =
    ({ condition, statements }) =>
    (c) =>
        c.concat([
            c.row(`while (${ppAstExpression(condition)}) `),
            ppStatementBlock(statements)(c),
        ]);

export const ppAstStatementRepeat: Printer<A.AstStatementRepeat> =
    ({ iterations, statements }) =>
    (c) =>
        c.concat([
            c.row(`repeat (${ppAstExpression(iterations)}) `),
            ppStatementBlock(statements)(c),
        ]);

export const ppAstStatementUntil: Printer<A.AstStatementUntil> =
    ({ condition, statements }) =>
    (c) =>
        c.concat([
            c.row(`do `),
            ppStatementBlock(statements)(c),
            c.row(` until (${ppAstExpression(condition)});`),
        ]);

export const ppAstStatementForEach: Printer<A.AstStatementForEach> =
    ({ keyName, valueName, map, statements }) =>
    (c) =>
        c.concat([
            c.row(
                `foreach (${ppAstId(keyName)}, ${ppAstId(valueName)} in ${ppAstExpression(map)}) `,
            ),
            ppStatementBlock(statements)(c),
        ]);

export const ppAstStatementTry: Printer<A.AstStatementTry> =
    ({ statements }) =>
    (c) =>
        c.concat([c.row(`try `), ppStatementBlock(statements)(c)]);

export const ppAstStatementTryCatch: Printer<A.AstStatementTryCatch> =
    ({ statements, catchName, catchStatements }) =>
    (c) =>
        c.concat([
            c.row(`try `),
            ppStatementBlock(statements)(c),
            c.row(` catch (${ppAstId(catchName)}) `),
            ppStatementBlock(catchStatements)(c),
        ]);

export const ppAstStatementDestruct: Printer<A.AstStatementDestruct> =
    ({ type, identifiers, ignoreUnspecifiedFields, expression }) =>
    (c) => {
        const ids: string[] = [];
        for (const [field, name] of identifiers.values()) {
            const id =
                field.text === name.text
                    ? ppAstId(name)
                    : `${ppAstId(field)}: ${ppAstId(name)}`;
            ids.push(id);
        }
        const restPattern = ignoreUnspecifiedFields ? ", .." : "";
        return c.row(
            `let ${ppAstTypeId(type)} {${ids.join(", ")}${restPattern}} = ${ppAstExpression(expression)};`,
        );
    };

export const ppAstStatement: Printer<A.AstStatement> =
    makeVisitor<A.AstStatement>()({
        statement_let: ppAstStatementLet,
        statement_return: ppAstStatementReturn,
        statement_expression: ppAstStatementExpression,
        statement_assign: ppAstStatementAssign,
        statement_augmentedassign: ppAstStatementAugmentedAssign,
        statement_condition: ppAstCondition,
        statement_while: ppAstStatementWhile,
        statement_until: ppAstStatementUntil,
        statement_repeat: ppAstStatementRepeat,
        statement_foreach: ppAstStatementForEach,
        statement_try: ppAstStatementTry,
        statement_try_catch: ppAstStatementTryCatch,
        statement_destruct: ppAstStatementDestruct,
    });

export const exprNode =
    <T>(exprPrinter: (expr: T) => string): Printer<T> =>
    (node) =>
    (c) =>
        c.row(exprPrinter(node));

export const ppAstNode: Printer<A.AstNode> = makeVisitor<A.AstNode>()({
    op_binary: exprNode(ppAstExpression),
    op_unary: exprNode(ppAstExpression),
    field_access: exprNode(ppAstExpression),
    method_call: exprNode(ppAstExpression),
    static_call: exprNode(ppAstExpression),
    struct_instance: exprNode(ppAstExpression),
    init_of: exprNode(ppAstExpression),
    conditional: exprNode(ppAstExpression),
    number: exprNode(ppAstExpression),
    id: exprNode(ppAstExpression),
    boolean: exprNode(ppAstExpression),
    string: exprNode(ppAstExpression),
    null: exprNode(ppAstExpression),
    type_id: exprNode(ppAstType),
    optional_type: exprNode(ppAstType),
    map_type: exprNode(ppAstType),
    bounced_message_type: exprNode(ppAstType),
    struct_field_initializer: exprNode(ppAstStructFieldInit),
    destruct_mapping: () => {
        throw new Error("Not implemented");
    },
    typed_parameter: () => {
        throw new Error("Not implemented");
    },
    destruct_end: () => {
        throw new Error("Not implemented");
    },

    module: ppAstModule,
    struct_decl: ppAstStruct,
    constant_def: ppAstConstant,
    constant_decl: ppAstConstDecl,
    function_def: ppAstFunctionDef,
    contract: ppAstContract,
    trait: ppAstTrait,
    primitive_type_decl: ppAstPrimitiveTypeDecl,
    message_decl: ppAstMessage,
    native_function_decl: ppAstNativeFunction,
    field_decl: ppAstFieldDecl,
    function_decl: ppAstFunctionDecl,
    receiver: ppAstReceiver,
    contract_init: ppAstInitFunction,
    statement_let: ppAstStatementLet,
    statement_return: ppAstStatementReturn,
    statement_expression: ppAstStatementExpression,
    statement_assign: ppAstStatementAssign,
    statement_augmentedassign: ppAstStatementAugmentedAssign,
    statement_condition: ppAstCondition,
    statement_while: ppAstStatementWhile,
    statement_until: ppAstStatementUntil,
    statement_repeat: ppAstStatementRepeat,
    statement_try: ppAstStatementTry,
    statement_try_catch: ppAstStatementTryCatch,
    statement_foreach: ppAstStatementForEach,
    import: ppAstImport,
    func_id: exprNode(ppAstFuncId),
    statement_destruct: ppAstStatementDestruct,
    function_attribute: exprNode(ppAstFunctionAttribute),
    asm_function_def: ppAstAsmFunctionDef,
});

/**
 * Pretty-prints an AST node into a string representation.
 * @param node The AST node to format.
 * @returns A string that represents the formatted AST node.
 */
export const prettyPrint = (node: A.AstNode): string =>
    ppAstNode(node)(createContext(4))
        // Initial level of indentation is 0
        .map((f) => f(0))
        // Lines are terminated with \n
        .join("\n");


## verify.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/verify.ts)
import normalize from "path-normalize";
import { Cell } from "@ton/core";
import { Config, Options } from "./config/parseConfig";
import { ILogger, Logger } from "./logger";
import { PackageFileFormat, run } from "./main";
import { fileFormat } from "./packaging/fileFormat";
import { getCompilerVersion } from "./pipeline/version";

export type VerifyResult =
    | {
          ok: true;
          package: PackageFileFormat;
          files: Record<string, string>;
      }
    | {
          ok: false;
          error:
              | "invalid-package-format"
              | "invalid-compiler"
              | "invalid-compiler-version"
              | "compilation-failed"
              | "verification-failed";
      };

export async function verify(args: {
    pkg: string;
    logger?: ILogger | null | undefined;
}): Promise<VerifyResult> {
    const logger: ILogger = args.logger ?? new Logger();

    // Loading package
    let unpacked: PackageFileFormat;
    try {
        const data = JSON.parse(args.pkg);
        unpacked = fileFormat.parse(data);
    } catch (e) {
        return { ok: false, error: "invalid-package-format" };
    }

    if (unpacked.sources === undefined) {
        return { ok: false, error: "invalid-package-format" };
    }

    // Check compiler and version
    if (unpacked.compiler.name !== "tact") {
        return { ok: false, error: "invalid-compiler" };
    }
    if (unpacked.compiler.version !== getCompilerVersion()) {
        return { ok: false, error: "invalid-compiler-version" };
    }

    // Create a options
    if (!unpacked.compiler.parameters) {
        return { ok: false, error: "invalid-package-format" };
    }
    const params = JSON.parse(unpacked.compiler.parameters);
    if (typeof params.entrypoint !== "string") {
        return { ok: false, error: "invalid-package-format" };
    }
    const options: Options = params.options || {};
    const entrypoint: string = params.entrypoint;

    // Create config
    const config: Config = {
        projects: [
            {
                name: "verifier",
                path: normalize("./contract/" + entrypoint),
                output: "./output",
                options,
            },
        ],
    };

    // Build
    const files: Record<string, string> = {};
    for (const [name, source] of Object.entries(unpacked.sources)) {
        files["contract/" + name] = source;
    }

    const result = await run({ config, files, logger });
    if (!result.ok) {
        return { ok: false, error: "compilation-failed" };
    }

    // Read output
    const compiledCell =
        files["output/verifier_" + unpacked.name + ".code.boc"];
    if (!compiledCell) {
        return { ok: false, error: "verification-failed" };
    }

    // Check output
    const a = Cell.fromBase64(compiledCell);
    const b = Cell.fromBase64(unpacked.code);
    if (!a.equals(b)) {
        return { ok: false, error: "verification-failed" };
    }

    // Return
    return { ok: true, package: unpacked, files };
}


## AbiFunction.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/abi/AbiFunction.ts)
import { AstExpression } from "../grammar/ast";
import { CompilerContext } from "../context";
import { WriterContext } from "../generator/Writer";
import { TypeRef } from "../types/types";
import { SrcInfo } from "../grammar";

export type AbiFunction = {
    name: string;
    resolve: (ctx: CompilerContext, args: TypeRef[], loc: SrcInfo) => TypeRef;
    generate: (
        ctx: WriterContext,
        args: TypeRef[],
        resolved: AstExpression[],
        loc: SrcInfo,
    ) => string;
};


## errors.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/abi/errors.ts)
// Errors 0-127 are reserved for VM errors
// Errors 128-255 are reserved for contract errors
export const contractErrors = {
    null: { id: 128, message: "Null reference exception" },
    invalidPrefix: { id: 129, message: "Invalid serialization prefix" },
    invalidMessage: { id: 130, message: "Invalid incoming message" },
    constraintsError: { id: 131, message: "Constraints error" },
    accessDenied: { id: 132, message: "Access denied" },
    contractStopped: { id: 133, message: "Contract stopped" },
    invalidArgument: { id: 134, message: "Invalid argument" },
    codeNotFound: { id: 135, message: "Code of a contract was not found" },
};


## global.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/abi/global.ts)
import { Address, beginCell, Cell, toNano } from "@ton/core";
import { enabledDebug } from "../config/features";
import {
    writeAddress,
    writeCell,
    writeSlice,
} from "../generator/writers/writeConstant";
import {
    writeExpression,
    writeValue,
} from "../generator/writers/writeExpression";
import { TactConstEvalError, throwCompilationError } from "../errors";
import { evalConstantExpression } from "../constEval";
import { getErrorId } from "../types/resolveErrors";
import { AbiFunction } from "./AbiFunction";
import { sha256_sync } from "@ton/crypto";
import path from "path";
import { cwd } from "process";
import { posixNormalize } from "../utils/filePath";

export const GlobalFunctions: Map<string, AbiFunction> = new Map([
    [
        "ton",
        {
            name: "ton",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError(
                        "ton() expects single string argument",
                        ref,
                    );
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "ton() expects single string argument",
                        ref,
                    );
                }
                if (arg0.name !== "String") {
                    throwCompilationError(
                        "ton() expects single string argument",
                        ref,
                    );
                }
                return { kind: "ref", name: "Int", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError(
                        "ton() expects single string argument",
                        ref,
                    );
                }
                const str = evalConstantExpression(
                    resolved[0]!,
                    ctx.ctx,
                ) as string;
                return toNano(str).toString(10);
            },
        },
    ],
    [
        "require",
        {
            name: "require",
            resolve: (ctx, args, ref) => {
                if (args.length !== 2) {
                    throwCompilationError(
                        "require() expects two arguments",
                        ref,
                    );
                }
                const arg0 = args[0]!;
                const arg1 = args[1]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "require() expects first Bool argument",
                        ref,
                    );
                }
                if (arg0.name !== "Bool") {
                    throwCompilationError(
                        "require() expects first Bool argument",
                        ref,
                    );
                }
                if (arg1.kind !== "ref") {
                    throwCompilationError(
                        "require() expects second string argument",
                        ref,
                    );
                }
                if (arg1.name !== "String") {
                    throwCompilationError(
                        "require() expects second string argument",
                        ref,
                    );
                }
                return { kind: "void" };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 2) {
                    throwCompilationError(
                        "require() expects two arguments",
                        ref,
                    );
                }
                const str = evalConstantExpression(
                    resolved[1]!,
                    ctx.ctx,
                ) as string;
                return `throw_unless(${getErrorId(str, ctx.ctx)}, ${writeExpression(resolved[0]!, ctx)})`;
            },
        },
    ],
    [
        "address",
        {
            name: "address",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError(
                        "address() expects one argument",
                        ref,
                    );
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "address() expects string argument",
                        ref,
                    );
                }
                if (arg0.name !== "String") {
                    throwCompilationError(
                        "address() expects string argument",
                        ref,
                    );
                }
                return { kind: "ref", name: "Address", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError(
                        "address() expects one argument",
                        ref,
                    );
                }
                const str = evalConstantExpression(
                    resolved[0]!,
                    ctx.ctx,
                ) as string;
                let address: Address;
                try {
                    address = Address.parse(str);
                } catch {
                    throwCompilationError(`${str} is not a valid address`, ref);
                }
                if (address.workChain !== 0 && address.workChain !== -1) {
                    throwCompilationError(
                        `Address ${str} invalid address`,
                        ref,
                    );
                }

                // Generate address
                const res = writeAddress(address, ctx);
                ctx.used(res);
                return res + "()";
            },
        },
    ],
    [
        "cell",
        {
            name: "cell",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError("cell() expects one argument", ref);
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "cell() expects string argument",
                        ref,
                    );
                }
                if (arg0.name !== "String") {
                    throwCompilationError(
                        "cell() expects string argument",
                        ref,
                    );
                }
                return { kind: "ref", name: "Cell", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError("cell() expects one argument", ref);
                }

                // Load cell data
                const str = evalConstantExpression(
                    resolved[0]!,
                    ctx.ctx,
                ) as string;
                let c: Cell;
                try {
                    c = Cell.fromBase64(str);
                } catch (e) {
                    throwCompilationError(`Invalid cell ${str}`, ref);
                }

                // Generate address
                const res = writeCell(c, ctx);
                ctx.used(res);
                return `${res}()`;
            },
        },
    ],
    [
        "dump",
        {
            name: "dump",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError("dump expects 1 argument", ref);
                }
                return { kind: "void" };
            },
            generate: (ctx, args, resolved, ref) => {
                if (!enabledDebug(ctx.ctx)) {
                    return `${ctx.used("__tact_nop")}()`;
                }
                const arg0 = args[0]!;

                const filePath = ref.file
                    ? posixNormalize(path.relative(cwd(), ref.file!))
                    : "unknown";
                const lineCol = ref.interval.getLineAndColumn();
                const debugPrint1 = `File ${filePath}:${lineCol.lineNum}:${lineCol.colNum}:`;
                const debugPrint2 = writeValue(ref.interval.contents, ctx);

                if (arg0.kind === "map") {
                    const exp = writeExpression(resolved[0]!, ctx);
                    return `${ctx.used(`__tact_debug`)}(${exp}, ${debugPrint2}, "${debugPrint1}")`;
                } else if (arg0.kind === "null") {
                    return `${ctx.used(`__tact_debug_str`)}("null", ${debugPrint2}, "${debugPrint1}")`;
                } else if (arg0.kind === "void") {
                    return `${ctx.used(`__tact_debug_str`)}("void", ${debugPrint2}, "${debugPrint1}")`;
                } else if (arg0.kind === "ref") {
                    if (arg0.name === "Int") {
                        const exp = writeExpression(resolved[0]!, ctx);
                        return `${ctx.used(`__tact_debug_str`)}(${ctx.used(`__tact_int_to_string`)}(${exp}), ${debugPrint2}, "${debugPrint1}")`;
                    } else if (arg0.name === "Bool") {
                        const exp = writeExpression(resolved[0]!, ctx);
                        return `${ctx.used(`__tact_debug_bool`)}(${exp}, ${debugPrint2}, "${debugPrint1}")`;
                    } else if (arg0.name === "String") {
                        const exp = writeExpression(resolved[0]!, ctx);
                        return `${ctx.used(`__tact_debug_str`)}(${exp}, ${debugPrint2}, "${debugPrint1}")`;
                    } else if (arg0.name === "Address") {
                        const exp = writeExpression(resolved[0]!, ctx);
                        return `${ctx.used(`__tact_debug_address`)}(${exp}, ${debugPrint2}, "${debugPrint1}")`;
                    } else if (
                        arg0.name === "Builder" ||
                        arg0.name === "Slice" ||
                        arg0.name === "Cell"
                    ) {
                        const exp = writeExpression(resolved[0]!, ctx);
                        return `${ctx.used(`__tact_debug`)}(${exp}, ${debugPrint2}, "${debugPrint1}")`;
                    }
                    throwCompilationError(
                        "dump() not supported for type: " + arg0.name,
                        ref,
                    );
                } else {
                    throwCompilationError(
                        "dump() not supported for argument",
                        ref,
                    );
                }
            },
        },
    ],
    [
        "dumpStack",
        {
            name: "dumpStack",
            resolve: (_ctx, args, ref) => {
                if (args.length !== 0) {
                    throwCompilationError(
                        "dumpStack expects no arguments",
                        ref,
                    );
                }
                return { kind: "void" };
            },
            generate: (ctx, _args, _resolved, ref) => {
                if (!enabledDebug(ctx.ctx)) {
                    return `${ctx.used("__tact_nop")}()`;
                }
                const filePath = ref.file
                    ? posixNormalize(path.relative(cwd(), ref.file!))
                    : "unknown";
                const lineCol = ref.interval.getLineAndColumn();
                const debugPrint1 = `File ${filePath}:${lineCol.lineNum}:${lineCol.colNum}:`;
                return `${ctx.used(`__tact_debug_stack`)}("dumpStack()", "${debugPrint1}")`;
            },
        },
    ],
    [
        "emptyMap",
        {
            name: "emptyMap",
            resolve: (ctx, args, ref) => {
                if (args.length !== 0) {
                    throwCompilationError("emptyMap expects no arguments", ref);
                }
                return { kind: "null" };
            },
            generate: (_ctx, _args, _resolved, _ref) => {
                return "null()";
            },
        },
    ],
    [
        "sha256",
        {
            name: "sha256",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError("sha256 expects 1 argument", ref);
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "sha256 expects string argument",
                        ref,
                    );
                }
                if (arg0.name !== "String" && arg0.name !== "Slice") {
                    throwCompilationError(
                        "sha256 expects string or slice argument",
                        ref,
                    );
                }
                return { kind: "ref", name: "Int", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (args.length !== 1) {
                    throwCompilationError("sha256 expects 1 argument", ref);
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "sha256 expects string argument",
                        ref,
                    );
                }

                // String case
                if (arg0.name === "String") {
                    let str: string | undefined;

                    // Try const-eval
                    try {
                        str = evalConstantExpression(
                            resolved[0]!,
                            ctx.ctx,
                        ) as string;
                    } catch (error) {
                        if (
                            !(error instanceof TactConstEvalError) ||
                            error.fatal
                        )
                            throw error;
                    }

                    // If const-eval did succeed
                    if (str !== undefined) {
                        return BigInt(
                            "0x" + sha256_sync(str).toString("hex"),
                        ).toString(10);
                    }

                    // Otherwise, revert back to runtime hash through SHA256U
                    const exp = writeExpression(resolved[0]!, ctx);
                    return `string_hash(${exp})`;
                }

                // Slice case
                if (arg0.name === "Slice") {
                    const exp = writeExpression(resolved[0]!, ctx);
                    return `string_hash(${exp})`;
                }

                throwCompilationError(
                    "sha256 expects string or slice argument",
                    ref,
                );
            },
        },
    ],
    [
        "slice",
        {
            name: "slice",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError("slice() expects one argument", ref);
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "slice() expects string argument",
                        ref,
                    );
                }
                if (arg0.name !== "String") {
                    throwCompilationError(
                        "slice() expects string argument",
                        ref,
                    );
                }
                return { kind: "ref", name: "Slice", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError("slice() expects one argument", ref);
                }

                // Load slice data
                const str = evalConstantExpression(
                    resolved[0]!,
                    ctx.ctx,
                ) as string;
                let c: Cell;
                try {
                    c = Cell.fromBase64(str);
                } catch (e) {
                    throwCompilationError(`Invalid slice ${str}`, ref);
                }

                const res = writeSlice(c.asSlice(), ctx);
                ctx.used(res);
                return `${res}()`;
            },
        },
    ],
    [
        "rawSlice",
        {
            name: "rawSlice",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError(
                        "rawSlice() expects one argument",
                        ref,
                    );
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "rawSlice() expects string argument",
                        ref,
                    );
                }
                if (arg0.name !== "String") {
                    throwCompilationError(
                        "rawSlice() expects string argument",
                        ref,
                    );
                }
                return { kind: "ref", name: "Slice", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError(
                        "rawSlice() expects one argument",
                        ref,
                    );
                }

                // Load slice data
                const str = evalConstantExpression(
                    resolved[0]!,
                    ctx.ctx,
                ) as string;
                let c: Cell;
                try {
                    c = beginCell().storeBuffer(Buffer.from(str)).endCell();
                } catch (e) {
                    throwCompilationError(`Invalid slice data ${str}`, ref);
                }

                const res = writeSlice(c.asSlice(), ctx);
                ctx.used(res);
                return `${res}()`;
            },
        },
    ],
    [
        "ascii",
        {
            name: "ascii",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError("ascii() expects one argument", ref);
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "ascii() expects string argument",
                        ref,
                    );
                }
                if (arg0.name !== "String") {
                    throwCompilationError(
                        "ascii() expects string argument",
                        ref,
                    );
                }
                return { kind: "ref", name: "Int", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError("ascii() expects one argument", ref);
                }

                // Load slice data
                const str = evalConstantExpression(
                    resolved[0]!,
                    ctx.ctx,
                ) as string;

                if (str.length > 32) {
                    throwCompilationError(
                        `ascii() expects string argument with length <= 32`,
                        ref,
                    );
                }

                return `"${str}"u`;
            },
        },
    ],
    [
        "crc32",
        {
            name: "crc32",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError("crc32() expects one argument", ref);
                }
                const arg0 = args[0]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "crc32() expects string argument",
                        ref,
                    );
                }
                if (arg0.name !== "String") {
                    throwCompilationError(
                        "crc32() expects string argument",
                        ref,
                    );
                }
                return { kind: "ref", name: "Int", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError("crc32() expects one argument", ref);
                }

                // Load slice data
                const str = evalConstantExpression(
                    resolved[0]!,
                    ctx.ctx,
                ) as string;

                return `"${str}"c`;
            },
        },
    ],
]);


## map.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/abi/map.ts)
import { CompilerContext } from "../context";
import { SrcInfo } from "../grammar";
import { TypeRef } from "../types/types";
import { WriterContext } from "../generator/Writer";
import { ops } from "../generator/writers/ops";
import { writeExpression } from "../generator/writers/writeExpression";
import { throwCompilationError } from "../errors";
import { getType } from "../types/resolveDescriptors";
import { AbiFunction } from "./AbiFunction";
import { AstExpression } from "../grammar/ast";

// Helper functions to avoid redundancy
function checkArgumentsLength(
    args: (TypeRef | undefined)[],
    expected: number,
    message: string,
    ref: SrcInfo,
): void {
    if (args.length !== expected || args.some((arg) => arg === undefined)) {
        throwCompilationError(message, ref);
    }
}

function checkMapType(
    self: TypeRef | undefined,
    ref: SrcInfo,
): asserts self is {
    kind: "map";
    key: string;
    keyAs: string | null;
    value: string;
    valueAs: string | null;
} {
    if (!self || self.kind !== "map") {
        throwCompilationError("expects a map as self argument", ref);
    }
    if (self.key !== "Int" && self.key !== "Address") {
        throwCompilationError("expects a map with Int or Address keys", ref);
    }
}

function checkKeyType(
    key: TypeRef | undefined,
    expectedType: string,
    ref: SrcInfo,
): void {
    if (
        !key ||
        key.kind !== "ref" ||
        key.optional ||
        key.name !== expectedType
    ) {
        throwCompilationError(
            `expects a "${expectedType}" as first argument`,
            ref,
        );
    }
}

function checkValueType(
    value: TypeRef | undefined,
    expectedType: string,
    ref: SrcInfo,
): void {
    if (!value || (value.kind !== "null" && value.kind !== "ref")) {
        throwCompilationError("expects a direct type as second argument", ref);
    }
    if (value.kind !== "null" && value.name !== expectedType) {
        throwCompilationError(
            `expects a "${expectedType}" as second argument`,
            ref,
        );
    }
}

function resolveMapKeyBits(
    self: { key: string; keyAs: string | null },
    ref: SrcInfo,
): { bits: number; kind: string } {
    if (self.key === "Int") {
        if (self.keyAs?.startsWith("int")) {
            return { bits: parseInt(self.keyAs.slice(3), 10), kind: "int" };
        }
        if (self.keyAs?.startsWith("uint")) {
            return { bits: parseInt(self.keyAs.slice(4), 10), kind: "uint" };
        }
        return { bits: 257, kind: "int" }; // Default for "Int" keys
    } else if (self.key === "Address") {
        return { bits: 267, kind: "slice" };
    }
    throwCompilationError(`Unsupported key type: ${self.key}`, ref);
}

function handleStructOrOtherValue(
    self: { value: string; valueAs: string | null },
    value: TypeRef,
    resolved: string[],
    ctx: WriterContext,
    ref: SrcInfo,
    bits: number,
    kind: string,
    operation: string = "set",
): string {
    const t = getType(ctx.ctx, self.value);
    if (["contract", "trait"].includes(t.kind)) {
        throwCompilationError(`"${t.name}" can't be value of a map`, ref);
    }
    if (t.kind === "struct") {
        const funcName = `__tact_dict_${operation}_${kind}_cell`;
        ctx.used(funcName);
        const writerFunc =
            value.kind === "ref" && !value.optional
                ? ops.writerCell(t.name, ctx)
                : ops.writerCellOpt(t.name, ctx);
        return `${resolved[0]}~${funcName}(${bits}, ${resolved[1]}, ${writerFunc}(${resolved[2]}))`;
    }
    throwCompilationError(`"${t.name}" can't be value of a map`, ref);
}

// The fully refactored MapFunctions object
export const MapFunctions: Map<string, AbiFunction> = new Map([
    [
        "set",
        {
            name: "set",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(args, 3, "set expects two arguments", ref);

                const [self, key, value] = args;
                checkMapType(self, ref);
                checkKeyType(key, self.key, ref);
                checkValueType(value, self.value, ref);

                // Returns nothing
                return { kind: "void" };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(args, 3, "set expects two arguments", ref);

                const [self, , value] = args;
                checkMapType(self, ref);

                const resolved = exprs.map((v) => writeExpression(v, ctx));
                const { bits, kind } = resolveMapKeyBits(self, ref);

                if (self.value === "Int") {
                    let vBits = 257;
                    let vKind = "int";
                    if (self.valueAs?.startsWith("int")) {
                        vBits = parseInt(self.valueAs.slice(3), 10);
                    } else if (self.valueAs?.startsWith("uint")) {
                        vBits = parseInt(self.valueAs.slice(4), 10);
                        vKind = "uint";
                    } else if (self.valueAs?.startsWith("coins")) {
                        vKind = "coins";
                        ctx.used(`__tact_dict_set_${kind}_${vKind}`);
                        return `${resolved[0]}~__tact_dict_set_${kind}_${vKind}(${bits}, ${resolved[1]}, ${resolved[2]})`;
                    }
                    ctx.used(`__tact_dict_set_${kind}_${vKind}`);
                    return `${resolved[0]}~__tact_dict_set_${kind}_${vKind}(${bits}, ${resolved[1]}, ${resolved[2]}, ${vBits})`;
                } else if (self.value === "Bool") {
                    ctx.used(`__tact_dict_set_${kind}_int`);
                    return `${resolved[0]}~__tact_dict_set_${kind}_int(${bits}, ${resolved[1]}, ${resolved[2]}, 1)`;
                } else if (self.value === "Cell") {
                    ctx.used(`__tact_dict_set_${kind}_cell`);
                    return `${resolved[0]}~__tact_dict_set_${kind}_cell(${bits}, ${resolved[1]}, ${resolved[2]})`;
                } else if (self.value === "Address") {
                    ctx.used(`__tact_dict_set_${kind}_slice`);
                    return `${resolved[0]}~__tact_dict_set_${kind}_slice(${bits}, ${resolved[1]}, ${resolved[2]})`;
                } else {
                    return handleStructOrOtherValue(
                        self,
                        value!,
                        resolved,
                        ctx,
                        ref,
                        bits,
                        kind,
                        "set",
                    );
                }
            },
        },
    ],
    [
        "get",
        {
            name: "get",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(args, 2, "get expects one argument", ref);

                const [self, key] = args;
                checkMapType(self, ref);
                checkKeyType(key, self.key, ref);

                return { kind: "ref", name: self.value, optional: true };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(args, 2, "get expects one argument", ref);

                const [self] = args;
                checkMapType(self, ref);

                const resolved = exprs.map((v) => writeExpression(v, ctx));
                const { bits, kind } = resolveMapKeyBits(self, ref);

                if (self.value === "Int") {
                    let vBits = 257;
                    let vKind = "int";
                    if (self.valueAs?.startsWith("int")) {
                        vBits = parseInt(self.valueAs.slice(3), 10);
                    } else if (self.valueAs?.startsWith("uint")) {
                        vBits = parseInt(self.valueAs.slice(4), 10);
                        vKind = "uint";
                    } else if (self.valueAs?.startsWith("coins")) {
                        vKind = "coins";
                        ctx.used(`__tact_dict_get_${kind}_${vKind}`);
                        return `__tact_dict_get_${kind}_${vKind}(${resolved[0]}, ${bits}, ${resolved[1]})`;
                    }
                    ctx.used(`__tact_dict_get_${kind}_${vKind}`);
                    return `__tact_dict_get_${kind}_${vKind}(${resolved[0]}, ${bits}, ${resolved[1]}, ${vBits})`;
                } else if (self.value === "Bool") {
                    ctx.used(`__tact_dict_get_${kind}_int`);
                    return `__tact_dict_get_${kind}_int(${resolved[0]}, ${bits}, ${resolved[1]}, 1)`;
                } else if (self.value === "Cell") {
                    ctx.used(`__tact_dict_get_${kind}_cell`);
                    return `__tact_dict_get_${kind}_cell(${resolved[0]}, ${bits}, ${resolved[1]})`;
                } else if (self.value === "Address") {
                    ctx.used(`__tact_dict_get_${kind}_slice`);
                    return `__tact_dict_get_${kind}_slice(${resolved[0]}, ${bits}, ${resolved[1]})`;
                } else {
                    const t = getType(ctx.ctx, self.value);
                    if (t.kind === "contract") {
                        throwCompilationError(
                            `Contract can't be value of a map`,
                            ref,
                        );
                    }
                    if (t.kind === "trait") {
                        throwCompilationError(
                            `Trait can't be value of a map`,
                            ref,
                        );
                    }
                    if (t.kind === "struct") {
                        ctx.used(`__tact_dict_get_${kind}_cell`);
                        return `${ops.readerOpt(t.name, ctx)}(__tact_dict_get_${kind}_cell(${resolved[0]}, ${bits}, ${resolved[1]}))`;
                    }
                    throwCompilationError(
                        `"${t.name}" can't be value of a map`,
                        ref,
                    );
                }
            },
        },
    ],
    [
        "del",
        {
            name: "del",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(args, 2, "del expects one argument", ref);

                const [self, key] = args;
                checkMapType(self, ref);
                checkKeyType(key, self.key, ref);

                // Returns boolean
                return { kind: "ref", name: "Bool", optional: false };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(args, 2, "del expects one argument", ref);

                const [self] = args;
                checkMapType(self, ref);

                const resolved = exprs.map((v) => writeExpression(v, ctx));
                const { bits, kind } = resolveMapKeyBits(self, ref);

                if (self.key === "Int") {
                    ctx.used(`__tact_dict_delete_${kind}`);
                    return `${resolved[0]}~__tact_dict_delete_${kind}(${bits}, ${resolved[1]})`;
                } else if (self.key === "Address") {
                    ctx.used(`__tact_dict_delete`);
                    return `${resolved[0]}~__tact_dict_delete(267, ${resolved[1]})`;
                }

                throwCompilationError(
                    `del expects a map with Int or Address keys`,
                    ref,
                );
            },
        },
    ],
    [
        "asCell",
        {
            name: "asCell",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    1,
                    "asCell expects one argument",
                    ref,
                );

                const [self] = args;
                checkMapType(self, ref);

                return { kind: "ref", name: "Cell", optional: true };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    1,
                    "asCell expects one argument",
                    ref,
                );

                const [self] = args;
                checkMapType(self, ref);

                return writeExpression(exprs[0]!, ctx);
            },
        },
    ],
    [
        "isEmpty",
        {
            name: "isEmpty",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    1,
                    "isEmpty expects one argument",
                    ref,
                );

                const [self] = args;
                checkMapType(self, ref);

                return { kind: "ref", name: "Bool", optional: false };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    1,
                    "isEmpty expects one argument",
                    ref,
                );

                const [self] = args;
                checkMapType(self, ref);

                return `null?(${writeExpression(exprs[0]!, ctx)})`;
            },
        },
    ],
    [
        "exists",
        {
            name: "exists",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    2,
                    "exists expects one argument",
                    ref,
                );

                const [self, key] = args;
                checkMapType(self, ref);
                checkKeyType(key, self.key, ref);

                // Returns boolean
                return { kind: "ref", name: "Bool", optional: false };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    2,
                    "exists expects one argument",
                    ref,
                );

                const [self] = args;
                checkMapType(self, ref);

                const resolved = exprs.map((v) => writeExpression(v, ctx));
                const { bits, kind } = resolveMapKeyBits(self, ref);

                if (self.key === "Int") {
                    ctx.used(`__tact_dict_exists_${kind}`);
                    return `__tact_dict_exists_${kind}(${resolved[0]}, ${bits}, ${resolved[1]})`;
                } else if (self.key === "Address") {
                    ctx.used(`__tact_dict_exists_slice`);
                    return `__tact_dict_exists_slice(${resolved[0]}, 267, ${resolved[1]})`;
                }

                throwCompilationError(
                    `exists expects a map with Int or Address keys`,
                    ref,
                );
            },
        },
    ],
    [
        "deepEquals",
        {
            name: "deepEquals",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    2,
                    "deepEquals expects two arguments",
                    ref,
                );

                const [self, other] = args;
                checkMapType(self, ref);
                checkMapType(other, ref);

                return { kind: "ref", name: "Bool", optional: false };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    2,
                    "deepEquals expects two arguments",
                    ref,
                );

                const [self, other] = args;
                checkMapType(self, ref);
                checkMapType(other, ref);

                // Determine key length based on key type
                let keyLength: number;
                if (self.key === "Int") {
                    if (self.keyAs) {
                        if (self.keyAs.startsWith("int")) {
                            keyLength = parseInt(self.keyAs.slice(3), 10);
                        } else if (self.keyAs.startsWith("uint")) {
                            keyLength = parseInt(self.keyAs.slice(4), 10);
                        } else {
                            throwCompilationError(
                                "Invalid key serialization type",
                                ref,
                            );
                        }
                    } else {
                        keyLength = 257;
                    }
                } else if (self.key === "Address") {
                    keyLength = 267;
                } else {
                    throwCompilationError(
                        `Unsupported key type: ${self.key}`,
                        ref,
                    );
                }

                ctx.used("__tact_dict_eq");
                return `__tact_dict_eq(${writeExpression(exprs[0]!, ctx)}, ${writeExpression(exprs[1]!, ctx)}, ${keyLength})`;
            },
        },
    ],
    [
        "replace",
        {
            name: "replace",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    3,
                    "replace expects two arguments",
                    ref,
                );

                const [self, key, value] = args;
                checkMapType(self, ref);
                checkKeyType(key, self.key, ref);
                checkValueType(value, self.value, ref);

                // Returns boolean indicating if the key was replaced
                return { kind: "ref", name: "Bool", optional: false };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    3,
                    "replace expects two arguments",
                    ref,
                );

                const [self, , value] = args;
                checkMapType(self, ref);

                const resolved = exprs.map((v) => writeExpression(v, ctx));
                const { bits, kind } = resolveMapKeyBits(self, ref);

                if (self.value === "Int") {
                    let vBits = 257;
                    let vKind = "int";
                    if (self.valueAs?.startsWith("int")) {
                        vBits = parseInt(self.valueAs.slice(3), 10);
                    } else if (self.valueAs?.startsWith("uint")) {
                        vBits = parseInt(self.valueAs.slice(4), 10);
                        vKind = "uint";
                    } else if (self.valueAs?.startsWith("coins")) {
                        vKind = "coins";
                        ctx.used(`__tact_dict_replace_${kind}_${vKind}`);
                        return `${resolved[0]}~__tact_dict_replace_${kind}_${vKind}(${bits}, ${resolved[1]}, ${resolved[2]})`;
                    }
                    ctx.used(`__tact_dict_replace_${kind}_${vKind}`);
                    return `${resolved[0]}~__tact_dict_replace_${kind}_${vKind}(${bits}, ${resolved[1]}, ${resolved[2]}, ${vBits})`;
                } else if (self.value === "Bool") {
                    ctx.used(`__tact_dict_replace_${kind}_int`);
                    return `${resolved[0]}~__tact_dict_replace_${kind}_int(${bits}, ${resolved[1]}, ${resolved[2]}, 1)`;
                } else if (self.value === "Cell") {
                    ctx.used(`__tact_dict_replace_${kind}_cell`);
                    return `${resolved[0]}~__tact_dict_replace_${kind}_cell(${bits}, ${resolved[1]}, ${resolved[2]})`;
                } else if (self.value === "Address") {
                    ctx.used(`__tact_dict_replace_${kind}_slice`);
                    return `${resolved[0]}~__tact_dict_replace_${kind}_slice(${bits}, ${resolved[1]}, ${resolved[2]})`;
                } else {
                    return handleStructOrOtherValue(
                        self,
                        value!,
                        resolved,
                        ctx,
                        ref,
                        bits,
                        kind,
                        "replace",
                    );
                }
            },
        },
    ],
    [
        "replaceGet",
        {
            name: "replaceGet",
            resolve(
                ctx: CompilerContext,
                args: (TypeRef | undefined)[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    3,
                    "replaceGet expects two arguments",
                    ref,
                );

                const [self, key, value] = args;
                checkMapType(self, ref);
                checkKeyType(key, self.key, ref);
                checkValueType(value, self.value, ref);

                // Returns the previous value if it exists
                return { kind: "ref", name: self.value, optional: true };
            },
            generate(
                ctx: WriterContext,
                args: (TypeRef | undefined)[],
                exprs: AstExpression[],
                ref: SrcInfo,
            ) {
                checkArgumentsLength(
                    args,
                    3,
                    "replaceGet expects two arguments",
                    ref,
                );

                const [self, , value] = args;
                checkMapType(self, ref);

                const resolved = exprs.map((v) => writeExpression(v, ctx));
                const { bits, kind } = resolveMapKeyBits(self, ref);

                if (self.value === "Int") {
                    let vBits = 257;
                    let vKind = "int";
                    if (self.valueAs?.startsWith("int")) {
                        vBits = parseInt(self.valueAs.slice(3), 10);
                    } else if (self.valueAs?.startsWith("uint")) {
                        vBits = parseInt(self.valueAs.slice(4), 10);
                        vKind = "uint";
                    } else if (self.valueAs?.startsWith("coins")) {
                        vKind = "coins";
                        ctx.used(`__tact_dict_replaceget_${kind}_${vKind}`);
                        return `${resolved[0]}~__tact_dict_replaceget_${kind}_${vKind}(${bits}, ${resolved[1]}, ${resolved[2]})`;
                    }
                    ctx.used(`__tact_dict_replaceget_${kind}_${vKind}`);
                    return `${resolved[0]}~__tact_dict_replaceget_${kind}_${vKind}(${bits}, ${resolved[1]}, ${resolved[2]}, ${vBits})`;
                } else if (self.value === "Bool") {
                    ctx.used(`__tact_dict_replaceget_${kind}_int`);
                    return `${resolved[0]}~__tact_dict_replaceget_${kind}_int(${bits}, ${resolved[1]}, ${resolved[2]}, 1)`;
                } else if (self.value === "Cell") {
                    ctx.used(`__tact_dict_replaceget_${kind}_cell`);
                    return `${resolved[0]}~__tact_dict_replaceget_${kind}_cell(${bits}, ${resolved[1]}, ${resolved[2]})`;
                } else if (self.value === "Address") {
                    ctx.used(`__tact_dict_replaceget_${kind}_slice`);
                    return `${resolved[0]}~__tact_dict_replaceget_${kind}_slice(${bits}, ${resolved[1]}, ${resolved[2]})`;
                } else {
                    const t = getType(ctx.ctx, self.value);
                    if (t.kind === "contract") {
                        throwCompilationError(
                            `Contract can't be value of a map`,
                            ref,
                        );
                    }
                    if (t.kind === "trait") {
                        throwCompilationError(
                            `Trait can't be value of a map`,
                            ref,
                        );
                    }
                    if (t.kind === "struct") {
                        const writerFunc =
                            value!.kind === "ref" && !value!.optional
                                ? ops.writerCell(t.name, ctx)
                                : ops.writerCellOpt(t.name, ctx);
                        ctx.used(`__tact_dict_replaceget_${kind}_cell`);
                        return `${ops.readerOpt(t.name, ctx)}(${resolved[0]}~__tact_dict_replaceget_${kind}_cell(${bits}, ${resolved[1]}, ${writerFunc}(${resolved[2]})))`;
                    }
                    throwCompilationError(
                        `"${t.name}" can't be value of a map`,
                        ref,
                    );
                }
            },
        },
    ],
]);


## struct.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/abi/struct.ts)
import { ops } from "../generator/writers/ops";
import { writeExpression } from "../generator/writers/writeExpression";
import { throwCompilationError } from "../errors";
import { getType } from "../types/resolveDescriptors";
import { AbiFunction } from "./AbiFunction";

export const StructFunctions: Map<string, AbiFunction> = new Map([
    [
        "toCell",
        {
            name: "toCell",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError("toCell() expects no arguments", ref);
                }
                const arg = args[0]!;
                if (arg.kind !== "ref") {
                    throwCompilationError(
                        `toCell() is not implemented for type '${arg.kind}'`,
                        ref,
                    );
                }
                const tp = getType(ctx, arg.name);
                if (tp.kind !== "struct") {
                    throwCompilationError(
                        `toCell() is not implemented for type '${arg.kind}'`,
                        ref,
                    );
                }
                return { kind: "ref", name: "Cell", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError("toCell() expects no arguments", ref);
                }
                const arg = args[0]!;
                if (arg.kind !== "ref") {
                    throwCompilationError(
                        `toCell() is not implemented for type '${arg.kind}'`,
                        ref,
                    );
                }
                return `${ops.writerCell(arg.name, ctx)}(${resolved.map((v) => writeExpression(v, ctx)).join(", ")})`;
            },
        },
    ],
    [
        "fromCell",
        {
            name: "fromCell",
            resolve: (ctx, args, ref) => {
                if (args.length !== 2) {
                    throwCompilationError(
                        "fromCell() expects one argument",
                        ref,
                    );
                }
                const arg0 = args[0]!;
                const arg1 = args[1]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "fromCell() is implemented only for struct types",
                        ref,
                    );
                }
                const tp = getType(ctx, arg0.name);
                if (tp.kind !== "struct") {
                    throwCompilationError(
                        "fromCell() is implemented only for struct types",
                        ref,
                    );
                }
                if (arg1.kind !== "ref" || arg1.name !== "Cell") {
                    throwCompilationError(
                        "fromCell() expects a Cell as an argument",
                        ref,
                    );
                }
                return { kind: "ref", name: arg0.name, optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 2) {
                    throwCompilationError(
                        "fromCell() expects one argument",
                        ref,
                    );
                }
                const arg0 = args[0]!;
                const arg1 = args[1]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "fromCell() is implemented only for struct types",
                        ref,
                    );
                }
                if (arg1.kind !== "ref" || arg1.name !== "Cell") {
                    throwCompilationError(
                        "fromCell() expects a Cell as an argument",
                        ref,
                    );
                }
                return `${ops.readerNonModifying(arg0.name, ctx)}(${writeExpression(resolved[1]!, ctx)}.begin_parse())`;
            },
        },
    ],
    [
        "toSlice",
        {
            name: "toSlice",
            resolve: (ctx, args, ref) => {
                if (args.length !== 1) {
                    throwCompilationError(
                        "toSlice() expects no arguments",
                        ref,
                    );
                }
                const arg = args[0]!;
                if (arg.kind !== "ref") {
                    throwCompilationError(
                        `toSlice() is not implemented for type '${arg.kind}'`,
                        ref,
                    );
                }
                const tp = getType(ctx, arg.name);
                if (tp.kind !== "struct") {
                    throwCompilationError(
                        `toSlice() is not implemented for type '${arg.kind}'`,
                        ref,
                    );
                }
                return { kind: "ref", name: "Slice", optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 1) {
                    throwCompilationError(
                        "toSlice() expects no arguments",
                        ref,
                    );
                }
                const arg = args[0]!;
                if (arg.kind !== "ref") {
                    throwCompilationError(
                        `toSlice() is not implemented for type '${arg.kind}'`,
                        ref,
                    );
                }
                return `${ops.writerCell(arg.name, ctx)}(${resolved.map((v) => writeExpression(v, ctx)).join(", ")}).begin_parse()`;
            },
        },
    ],
    [
        "fromSlice",
        {
            name: "fromSlice",
            resolve: (ctx, args, ref) => {
                if (args.length !== 2) {
                    throwCompilationError(
                        "fromSlice() expects one argument",
                        ref,
                    );
                }
                const arg0 = args[0]!;
                const arg1 = args[1]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "fromSlice() is implemented only for struct types",
                        ref,
                    );
                }
                const tp = getType(ctx, arg0.name);
                if (tp.kind !== "struct") {
                    throwCompilationError(
                        "fromSlice() is implemented only for struct types",
                        ref,
                    );
                }
                if (arg1.kind !== "ref" || arg1.name !== "Slice") {
                    throwCompilationError(
                        "fromSlice() expects a Slice as an argument",
                        ref,
                    );
                }
                return { kind: "ref", name: arg0.name, optional: false };
            },
            generate: (ctx, args, resolved, ref) => {
                if (resolved.length !== 2) {
                    throwCompilationError(
                        "fromSlice() expects one argument",
                        ref,
                    );
                }
                const arg0 = args[0]!;
                const arg1 = args[1]!;
                if (arg0.kind !== "ref") {
                    throwCompilationError(
                        "fromSlice() is implemented only for struct types",
                        ref,
                    );
                }
                if (arg1.kind !== "ref" || arg1.name !== "Slice") {
                    throwCompilationError(
                        "fromSlice() expects a Slice as an argument",
                        ref,
                    );
                }
                return `${ops.readerNonModifying(arg0.name, ctx)}(${writeExpression(resolved[1]!, ctx)})`;
            },
        },
    ],
]);


## benchmarks.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/benchmarks/benchmarks.spec.ts)
import {
    toNano,
    TransactionComputeVm,
    TransactionDescriptionGeneric,
} from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Functions } from "./contracts/output/benchmark_functions_Functions";
import { Functions as FunctionsInline } from "./contracts/output/benchmark_functions_inline_Functions";
import "@ton/test-utils";

describe("benchmarks", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("benchmarks");
    });

    it("benchmark functions", async () => {
        const functions = blockchain.openContract(await Functions.fromInit());

        const sendResult = await functions.send(
            treasure.getSender(),
            { value: toNano(1) },
            { $$type: "Add", value: 10n },
        );

        const gasUsed = (
            (
                sendResult.transactions[1]!
                    .description as TransactionDescriptionGeneric
            ).computePhase as TransactionComputeVm
        ).gasUsed;
        expect(gasUsed).toMatchInlineSnapshot(`3146n`);

        // Verify code size
        const codeSize = functions.init!.code.toBoc().length;
        expect(codeSize).toMatchInlineSnapshot(`241`);
    });

    it("benchmark functions (inline)", async () => {
        const functionsInline = blockchain.openContract(
            await FunctionsInline.fromInit(),
        );

        const sendResult = await functionsInline.send(
            treasure.getSender(),
            { value: toNano(1) },
            { $$type: "Add", value: 10n },
        );

        const gasUsed = (
            (
                sendResult.transactions[1]!
                    .description as TransactionDescriptionGeneric
            ).computePhase as TransactionComputeVm
        ).gasUsed;
        expect(gasUsed).toMatchInlineSnapshot(`3015n`);

        // Verify code size
        const codeSize = functionsInline.init!.code.toBoc().length;
        expect(codeSize).toMatchInlineSnapshot(`234`);
    });
});


## functions.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/benchmarks/contracts/functions.tact)
message Add {
    value: Int;
}

message Sub {
    value: Int;
}

contract Functions {
    value: Int;

    init() {
        self.value = 0;
    }

    fun update(delta: Int) {
        self.value = self.value + delta;
    }

    receive(msg: Add) {
        require(msg.value > 0, "Value must be greater than 0");
        self.update(msg.value);
    }

    receive(msg: Sub) {
        require(msg.value > 0, "Value must be greater than 0");
        self.update(-msg.value);
    }
}

## writeTypescript.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/bindings/writeTypescript.ts)
import * as changeCase from "change-case";
import { Writer } from "../utils/Writer";
import { ABIArgument, ABIType, ContractABI } from "@ton/core";
import {
    writeArgumentToStack,
    writeDictParser,
    writeGetParser,
    writeGetterTupleParser,
    writeInitSerializer,
    writeParser,
    writeSerializer,
    writeStruct,
    writeTupleParser,
    writeTupleSerializer,
} from "./typescript/writeStruct";
import { AllocationCell } from "../storage/operation";
import { throwInternalCompilerError } from "../errors";
import { topologicalSort } from "../utils/utils";
import {
    allocate,
    getAllocationOperationFromField,
} from "../storage/allocator";
import { serializers } from "./typescript/serializers";
import { eqNames } from "../grammar/ast";

function writeArguments(args: ABIArgument[]) {
    const res: string[] = [];
    outer: for (const f of args) {
        for (const s of serializers) {
            const v = s.abiMatcher(f.type);
            if (v) {
                res.push(`${f.name}: ${s.tsType(v)}`);
                continue outer;
            }
        }
        throwInternalCompilerError(
            `Unsupported type: ${JSON.stringify(f.type)}`,
        );
    }

    return res;
}

export function writeTypescript(
    abi: ContractABI,
    init?: {
        code: string;
        system: string;
        args: ABIArgument[];
        prefix?:
            | {
                  value: number;
                  bits: number;
              }
            | undefined;
    },
) {
    const w = new Writer();

    w.write(`
        import { 
            Cell,
            Slice, 
            Address, 
            Builder, 
            beginCell, 
            ComputeError, 
            TupleItem, 
            TupleReader, 
            Dictionary, 
            contractAddress, 
            ContractProvider, 
            Sender, 
            Contract, 
            ContractABI, 
            ABIType,
            ABIGetter,
            ABIReceiver,
            TupleBuilder,
            DictionaryValue
        } from '@ton/core';
    `);
    w.append();

    const allocations: Record<
        string,
        {
            size: { bits: number; refs: number };
            root: AllocationCell;
        }
    > = {};

    // Structs
    if (abi.types) {
        // Allocations
        const refs = (src: ABIType) => {
            const res: ABIType[] = [];
            const t: Set<string> = new Set();
            for (const f of src.fields) {
                const r = f.type;
                if (r.kind === "simple") {
                    const e = abi.types!.find((v) => eqNames(v.name, r.type));
                    if (e) {
                        if (!t.has(r.type)) {
                            t.add(r.type);
                            res.push(e);
                        }
                    }
                }
            }
            return res;
        };
        const sortedTypes = topologicalSort(abi.types, refs);
        for (const f of sortedTypes) {
            const ops = f.fields.map((v) => ({
                name: v.name,
                type: v.type,
                op: getAllocationOperationFromField(
                    v.type,
                    (s) => allocations[s]!.size,
                ),
            }));
            const headerBits = f.header ? 32 : 0;
            const allocation = allocate({
                reserved: { bits: headerBits, refs: 0 },
                ops,
            });
            allocations[f.name] = {
                size: {
                    bits: allocation.size.bits + headerBits,
                    refs: allocation.size.refs,
                },
                root: allocation,
            };
        }

        for (const s of abi.types) {
            writeStruct(s.name, s.fields, true, w);
            writeSerializer(s, allocations[s.name]!.root, w);
            writeParser(s, allocations[s.name]!.root, w);
            writeTupleParser(s, w);
            writeGetterTupleParser(s, w);
            writeTupleSerializer(s, w);
            writeDictParser(s, w);
        }
    }

    // Init
    if (init) {
        // Write serializer
        const argTypeName = (abi.name ?? "Contract") + "_init_args";
        const ops = init.args.map((v) => ({
            name: v.name,
            type: v.type,
            op: getAllocationOperationFromField(
                v.type,
                (s) => allocations[s]!.size,
            ),
        }));
        const allocation = allocate({
            reserved: { bits: init.prefix ? init.prefix.bits : 0, refs: 1 },
            ops,
        });
        writeStruct(argTypeName, init.args, false, w);
        writeInitSerializer(argTypeName, allocation, w);

        // Write init function
        w.append(
            `async function ${abi.name}_init(${writeArguments(init.args).join(", ")}) {`,
        );
        w.inIndent(() => {
            // Code references
            w.append(`const __code = Cell.fromBase64('${init.code}');`);
            w.append(`const __system = Cell.fromBase64('${init.system}');`);

            // Stack
            w.append("let builder = beginCell();");
            w.append(`builder.storeRef(__system);`);
            if (init.prefix) {
                w.append(
                    `builder.storeUint(${init.prefix.value}, ${init.prefix.bits});`,
                );
            }
            w.append(
                `init${argTypeName}({ ${[`$$type: '${argTypeName}'`, ...init.args.map((v) => v.name)].join(", ")} })(builder);`,
            );
            w.append(`const __data = builder.endCell();`);
            w.append(`return { code: __code, data: __data };`);
        });
        w.append(`}`);
        w.append();
    }

    // Errors
    w.append(
        `const ${abi.name}_errors: { [key: number]: { message: string } } = {`,
    );
    w.inIndent(() => {
        if (abi.errors) {
            Object.entries(abi.errors).forEach(([k, abiError]) => {
                w.append(
                    `${k}: { message: \`${abiError.message.replaceAll("`", "\\`")}\` },`,
                );
            });
        }
    });
    w.append(`}`);
    w.append();

    // Types
    w.append(`const ${abi.name}_types: ABIType[] = [`);
    w.inIndent(() => {
        if (abi.types) {
            for (const t of abi.types) {
                w.append(JSON.stringify(t) + ",");
            }
        }
    });
    w.append(`]`);
    w.append();

    const getterNames: Map<string, string> = new Map();

    // Getters
    w.append(`const ${abi.name}_getters: ABIGetter[] = [`);
    w.inIndent(() => {
        if (abi.getters) {
            for (const t of abi.getters) {
                w.append(JSON.stringify(t) + ",");

                let getterName = changeCase.pascalCase(t.name);
                if (Array.from(getterNames.values()).includes(getterName)) {
                    getterName = t.name;
                }
                getterNames.set(t.name, getterName);
            }
        }
    });
    w.append(`]`);
    w.append();

    // Getter mapping
    w.append(
        `export const ${abi.name}_getterMapping: { [key: string]: string } = {`,
    );
    w.inIndent(() => {
        if (abi.getters) {
            for (const t of abi.getters) {
                w.append(`'${t.name}': 'get${getterNames.get(t.name)}',`);
            }
        }
    });
    w.append(`}`);
    w.append();

    // Receivers
    w.append(`const ${abi.name}_receivers: ABIReceiver[] = [`);
    w.inIndent(() => {
        if (abi.receivers) {
            for (const t of abi.receivers) {
                w.append(JSON.stringify(t) + ",");
            }
        }
    });
    w.append(`]`);
    w.append();

    // Wrapper
    w.append(`export class ${abi.name} implements Contract {`);
    w.inIndent(() => {
        w.append();

        if (init) {
            w.append(
                `static async init(${writeArguments(init.args).join(", ")}) {`,
            );
            w.inIndent(() => {
                w.append(
                    `return await ${abi.name}_init(${init!.args.map((v) => v.name).join(", ")});`,
                );
            });
            w.append(`}`);
            w.append();

            w.append(
                `static async fromInit(${writeArguments(init.args).join(", ")}) {`,
            );
            w.inIndent(() => {
                w.append(
                    `const init = await ${abi.name}_init(${init!.args.map((v) => v.name).join(", ")});`,
                );
                w.append(`const address = contractAddress(0, init);`);
                w.append(`return new ${abi.name}(address, init);`);
            });
            w.append(`}`);
            w.append();
        }

        w.append(`static fromAddress(address: Address) {`);
        w.inIndent(() => {
            w.append(`return new ${abi.name}(address);`);
        });
        w.append(`}`);
        w.append();

        w.append(`readonly address: Address; `);
        w.append(`readonly init?: { code: Cell, data: Cell };`);
        w.append(`readonly abi: ContractABI = {`);
        w.inIndent(() => {
            w.append(`types:  ${abi.name}_types,`);
            w.append(`getters: ${abi.name}_getters,`);
            w.append(`receivers: ${abi.name}_receivers,`);
            w.append(`errors: ${abi.name}_errors,`);
        });
        w.append(`};`);
        w.append();
        w.append(
            `private constructor(address: Address, init?: { code: Cell, data: Cell }) {`,
        );
        w.inIndent(() => {
            w.append("this.address = address;");
            w.append("this.init = init;");
        });
        w.append("}");
        w.append();

        // Internal receivers
        if (
            abi.receivers &&
            abi.receivers.filter((v) => v.receiver === "internal").length > 0
        ) {
            // Types
            const receivers: string[] = [];
            for (const r of abi.receivers) {
                if (r.receiver !== "internal") {
                    continue;
                }
                switch (r.message.kind) {
                    case "empty":
                        {
                            receivers.push(`null`);
                        }
                        break;
                    case "typed":
                        {
                            receivers.push(r.message.type);
                        }
                        break;
                    case "text":
                        {
                            if (
                                r.message.text !== null &&
                                r.message.text !== undefined
                            ) {
                                receivers.push(JSON.stringify(r.message.text));
                            } else {
                                receivers.push(`string`);
                            }
                        }
                        break;
                    case "any":
                        {
                            receivers.push(`Slice`);
                        }
                        break;
                }
            }

            // Receiver function
            w.append(
                `async send(provider: ContractProvider, via: Sender, args: { value: bigint, bounce?: boolean| null | undefined }, message: ${receivers.join(" | ")}) {`,
            );
            w.inIndent(() => {
                w.append();

                // Parse message
                w.append(`let body: Cell | null = null;`);
                for (const r of abi.receivers!) {
                    if (r.receiver !== "internal") {
                        continue;
                    }
                    const msg = r.message;
                    switch (msg.kind) {
                        case "typed":
                            {
                                w.append(
                                    `if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === '${msg.type}') {`,
                                );
                                w.inIndent(() => {
                                    w.append(
                                        `body = beginCell().store(store${msg.type}(message)).endCell();`,
                                    );
                                });
                                w.append(`}`);
                            }
                            break;
                        case "empty":
                            {
                                w.append(`if (message === null) {`);
                                w.inIndent(() => {
                                    w.append(`body = new Cell();`);
                                });
                                w.append(`}`);
                            }
                            break;
                        case "text":
                            {
                                if (
                                    msg.text === null ||
                                    msg.text === undefined
                                ) {
                                    w.append(
                                        `if (typeof message === 'string') {`,
                                    );
                                    w.inIndent(() => {
                                        w.append(
                                            `body = beginCell().storeUint(0, 32).storeStringTail(message).endCell();`,
                                        );
                                    });
                                    w.append(`}`);
                                } else {
                                    w.append(
                                        `if (message === ${JSON.stringify(msg.text)}) {`,
                                    );
                                    w.inIndent(() => {
                                        w.append(
                                            `body = beginCell().storeUint(0, 32).storeStringTail(message).endCell();`,
                                        );
                                    });
                                    w.append(`}`);
                                }
                            }
                            break;
                        case "any": {
                            w.append(
                                `if (message && typeof message === 'object' && message instanceof Slice) {`,
                            );
                            w.inIndent(() => {
                                w.append(`body = message.asCell();`);
                            });
                            w.append(`}`);
                        }
                    }
                }
                w.append(
                    `if (body === null) { throw new Error('Invalid message type'); }`,
                );
                w.append();

                // Send message
                w.append(
                    `await provider.internal(via, { ...args, body: body });`,
                );
                w.append();
            });
            w.append(`}`);
            w.append();
        }

        if (
            abi.receivers &&
            abi.receivers.filter((v) => v.receiver === "external").length > 0
        ) {
            // Types
            const receivers: string[] = [];
            for (const r of abi.receivers) {
                if (r.receiver !== "external") {
                    continue;
                }
                switch (r.message.kind) {
                    case "empty":
                        {
                            receivers.push(`null`);
                        }
                        break;
                    case "typed":
                        {
                            receivers.push(r.message.type);
                        }
                        break;
                    case "text":
                        {
                            if (
                                r.message.text !== null &&
                                r.message.text !== undefined
                            ) {
                                receivers.push(`'${r.message.text}'`);
                            } else {
                                receivers.push(`string`);
                            }
                        }
                        break;
                    case "any":
                        {
                            receivers.push(`Slice`);
                        }
                        break;
                }
            }

            // Receiver function
            w.append(
                `async sendExternal(provider: ContractProvider, message: ${receivers.join(" | ")}) {`,
            );
            w.inIndent(() => {
                w.append();

                // Parse message
                w.append(`let body: Cell | null = null;`);
                for (const r of abi.receivers!) {
                    if (r.receiver !== "external") {
                        continue;
                    }
                    const msg = r.message;
                    switch (msg.kind) {
                        case "typed":
                            {
                                w.append(
                                    `if (message && typeof message === 'object' && !(message instanceof Slice) && message.$$type === '${msg.type}') {`,
                                );
                                w.inIndent(() => {
                                    w.append(
                                        `body = beginCell().store(store${msg.type}(message)).endCell();`,
                                    );
                                });
                                w.append(`}`);
                            }
                            break;
                        case "empty":
                            {
                                w.append(`if (message === null) {`);
                                w.inIndent(() => {
                                    w.append(`body = new Cell();`);
                                });
                                w.append(`}`);
                            }
                            break;
                        case "text":
                            {
                                if (
                                    msg.text === null ||
                                    msg.text === undefined
                                ) {
                                    w.append(
                                        `if (typeof message === 'string') {`,
                                    );
                                    w.inIndent(() => {
                                        w.append(
                                            `body = beginCell().storeUint(0, 32).storeStringTail(message).endCell();`,
                                        );
                                    });
                                    w.append(`}`);
                                } else {
                                    w.append(
                                        `if (message === '${msg.text}') {`,
                                    );
                                    w.inIndent(() => {
                                        w.append(
                                            `body = beginCell().storeUint(0, 32).storeStringTail(message).endCell();`,
                                        );
                                    });
                                    w.append(`}`);
                                }
                            }
                            break;
                        case "any": {
                            w.append(
                                `if (message && typeof message === 'object' && message instanceof Slice) {`,
                            );
                            w.inIndent(() => {
                                w.append(`body = message.asCell();`);
                            });
                            w.append(`}`);
                        }
                    }
                }
                w.append(
                    `if (body === null) { throw new Error('Invalid message type'); }`,
                );
                w.append();

                // Send message
                w.append(`await provider.external(body);`);
                w.append();
            });
            w.append(`}`);
            w.append();
        }

        // Getters
        if (abi.getters) {
            for (const g of abi.getters) {
                w.append(
                    `async get${getterNames.get(g.name)}(${["provider: ContractProvider", ...writeArguments(g.arguments ? g.arguments : [])].join(", ")}) {`,
                );
                w.inIndent(() => {
                    w.append(`let builder = new TupleBuilder();`);
                    if (g.arguments) {
                        for (const a of g.arguments) {
                            writeArgumentToStack(a.name, a.type, w);
                        }
                    }
                    if (g.methodId) {
                        // 'as any' is used because Sandbox contracts's getters can be called
                        // using the function name or the method id number
                        // but the ContractProvider's interface get methods can only
                        // take strings (function names)
                        w.append(
                            `let source = (await provider.get(${g.methodId} as any, builder.build())).stack;`,
                        );
                    } else {
                        w.append(
                            `let source = (await provider.get('${g.name}', builder.build())).stack;`,
                        );
                    }
                    if (g.returnType) {
                        writeGetParser("result", g.returnType, w);
                        w.append(`return result;`);
                    }
                });
                w.append(`}`);
                w.append();
            }
        }
    });
    w.append(`}`);

    return w.end();
}


## serializers.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/bindings/typescript/serializers.ts)
import { ABITypeRef } from "@ton/core";
import { Writer } from "../../utils/Writer";
import { throwInternalCompilerError } from "../../errors";

const primitiveTypes = [
    "int",
    "uint",
    "address",
    "bool",
    "string",
    "cell",
    "slice",
    "builder",
    "fixed-bytes",
];

type Serializer<T> = {
    // Typescript
    tsType: (v: T) => string;
    tsLoad: (v: T, slice: string, field: string, w: Writer) => void;
    tsLoadTuple: (
        v: T,
        reader: string,
        field: string,
        w: Writer,
        fromGet: boolean,
    ) => void;
    tsStore: (v: T, builder: string, field: string, w: Writer) => void;
    tsStoreTuple: (v: T, to: string, field: string, w: Writer) => void;

    // Matcher
    abiMatcher: (src: ABITypeRef) => T | null;
};

const intSerializer: Serializer<{ bits: number; optional: boolean }> = {
    tsType(v) {
        if (v.optional) {
            return "bigint | null";
        } else {
            return "bigint";
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${slice}.loadBit() ? ${slice}.loadIntBig(${v.bits}) : null;`,
            );
        } else {
            w.append(`let ${field} = ${slice}.loadIntBig(${v.bits});`);
        }
    },
    tsLoadTuple(v, reader, field, w) {
        if (v.optional) {
            w.append(`let ${field} = ${reader}.readBigNumberOpt();`);
        } else {
            w.append(`let ${field} = ${reader}.readBigNumber();`);
        }
    },
    tsStoreTuple(v, to, field, w) {
        w.append(`${to}.writeNumber(${field});`);
    },
    tsStore(v, builder, field, w) {
        if (v.optional) {
            w.append(
                `if (${field} !== null && ${field} !== undefined) { ${builder}.storeBit(true).storeInt(${field}, ${v.bits}); } else { ${builder}.storeBit(false); }`,
            );
        } else {
            w.append(`${builder}.storeInt(${field}, ${v.bits});`);
        }
    },
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (src.type === "int") {
                if (typeof src.format === "number") {
                    return {
                        bits: src.format,
                        optional: src.optional ? src.optional : false,
                    };
                } else if (src.format === null || src.format === undefined) {
                    return {
                        bits: 257,
                        optional: src.optional ? src.optional : false,
                    };
                }
            }
        }
        return null;
    },
};

const uintSerializer: Serializer<{ bits: number; optional: boolean }> = {
    tsType(v) {
        if (v.optional) {
            return "bigint | null";
        } else {
            return "bigint";
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${slice}.loadBit() ? ${slice}.loadUintBig(${v.bits}) : null;`,
            );
        } else {
            w.append(`let ${field} = ${slice}.loadUintBig(${v.bits});`);
        }
    },
    tsLoadTuple(v, reader, field, w) {
        if (v.optional) {
            w.append(`let ${field} = ${reader}.readBigNumberOpt();`);
        } else {
            w.append(`let ${field} = ${reader}.readBigNumber();`);
        }
    },
    tsStore(v, builder, field, w) {
        if (v.optional) {
            w.append(
                `if (${field} !== null && ${field} !== undefined) { ${builder}.storeBit(true).storeUint(${field}, ${v.bits}); } else { ${builder}.storeBit(false); }`,
            );
        } else {
            w.append(`${builder}.storeUint(${field}, ${v.bits});`);
        }
    },
    tsStoreTuple(v, to, field, w) {
        w.append(`${to}.writeNumber(${field});`);
    },
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (src.type === "uint") {
                if (typeof src.format === "number") {
                    return {
                        bits: src.format,
                        optional: src.optional ? src.optional : false,
                    };
                } else if (src.format === null || src.format === undefined) {
                    return {
                        bits: 256,
                        optional: src.optional ? src.optional : false,
                    };
                }
            }
        }
        return null;
    },
};

const coinsSerializer: Serializer<{ optional: boolean }> = {
    tsType(v) {
        if (v.optional) {
            return "bigint | null";
        } else {
            return "bigint";
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${slice}.loadBit() ? ${slice}.loadCoins() : null;`,
            );
        } else {
            w.append(`let ${field} = ${slice}.loadCoins();`);
        }
    },
    tsLoadTuple(v, reader, field, w) {
        if (v.optional) {
            w.append(`let ${field} = ${reader}.readBigNumberOpt();`);
        } else {
            w.append(`let ${field} = ${reader}.readBigNumber();`);
        }
    },
    tsStore(v, builder, field, w) {
        if (v.optional) {
            w.append(
                `if (${field} !== null && ${field} !== undefined) { ${builder}.storeBit(true).storeCoins(${field}); } else { ${builder}.storeBit(false); }`,
            );
        } else {
            w.append(`${builder}.storeCoins(${field});`);
        }
    },
    tsStoreTuple(v, to, field, w) {
        w.append(`${to}.writeNumber(${field});`);
    },
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (src.type === "uint") {
                if (src.format === "coins") {
                    return { optional: src.optional ? src.optional : false };
                }
            }
        }
        return null;
    },
};

const boolSerializer: Serializer<{ optional: boolean }> = {
    tsType(v) {
        if (v.optional) {
            return "boolean | null";
        } else {
            return "boolean";
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${slice}.loadBit() ? ${slice}.loadBit() : null;`,
            );
        } else {
            w.append(`let ${field} = ${slice}.loadBit();`);
        }
    },
    tsLoadTuple(v, reader, field, w) {
        if (v.optional) {
            w.append(`let ${field} = ${reader}.readBooleanOpt();`);
        } else {
            w.append(`let ${field} = ${reader}.readBoolean();`);
        }
    },
    tsStore(v, builder, field, w) {
        if (v.optional) {
            w.append(
                `if (${field} !== null && ${field} !== undefined) { ${builder}.storeBit(true).storeBit(${field}); } else { ${builder}.storeBit(false); }`,
            );
        } else {
            w.append(`${builder}.storeBit(${field});`);
        }
    },
    tsStoreTuple(v, to, field, w) {
        w.append(`${to}.writeBoolean(${field});`);
    },
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (src.type === "bool") {
                if (src.format === null || src.format === undefined) {
                    return { optional: src.optional ? src.optional : false };
                }
            }
        }
        return null;
    },
};

const addressSerializer: Serializer<{ optional: boolean }> = {
    tsType(v) {
        if (v.optional) {
            return "Address | null";
        } else {
            return "Address";
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(`let ${field} = ${slice}.loadMaybeAddress();`);
        } else {
            w.append(`let ${field} = ${slice}.loadAddress();`);
        }
    },
    tsLoadTuple(v, reader, field, w) {
        if (v.optional) {
            w.append(`let ${field} = ${reader}.readAddressOpt();`);
        } else {
            w.append(`let ${field} = ${reader}.readAddress();`);
        }
    },
    tsStore(v, builder, field, w) {
        w.append(`${builder}.storeAddress(${field});`);
    },
    tsStoreTuple(v, to, field, w) {
        w.append(`${to}.writeAddress(${field});`);
    },
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (src.type === "address") {
                if (src.format === null || src.format === undefined) {
                    return { optional: src.optional ? src.optional : false };
                }
            }
        }
        return null;
    },
};

function getCellLikeTsType(v: {
    kind: "cell" | "slice" | "builder";
    optional?: boolean;
}) {
    return v.kind == "cell" ? "Cell" : v.kind == "slice" ? "Slice" : "Builder";
}

function getCellLikeTsAsMethod(v: {
    kind: "cell" | "slice" | "builder";
    optional?: boolean;
}) {
    if (v.optional) {
        return `?.as${getCellLikeTsType(v)}() ?? null`;
    } else {
        return `.as${getCellLikeTsType(v)}()`;
    }
}

const cellSerializer: Serializer<{
    kind: "cell" | "slice" | "builder";
    optional: boolean;
}> = {
    tsType(v) {
        if (v.optional) {
            return `${getCellLikeTsType(v)} | null`;
        } else {
            return getCellLikeTsType(v);
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${slice}.loadBit() ? ${slice}.loadRef()${v.kind !== "cell" ? getCellLikeTsAsMethod(v) : ""} : null;`,
            );
        } else {
            w.append(
                `let ${field} = ${slice}.loadRef()${v.kind !== "cell" ? getCellLikeTsAsMethod(v) : ""};`,
            );
        }
    },
    tsLoadTuple(v, reader, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${reader}.readCellOpt()${v.kind !== "cell" ? getCellLikeTsAsMethod(v) : ""};`,
            );
        } else {
            w.append(
                `let ${field} = ${reader}.readCell()${v.kind !== "cell" ? getCellLikeTsAsMethod(v) : ""};`,
            );
        }
    },
    tsStore(v, builder, field, w) {
        if (v.optional) {
            w.append(
                `if (${field} !== null && ${field} !== undefined) { ${builder}.storeBit(true).storeRef(${field}${v.kind !== "cell" ? ".asCell()" : ""}); } else { ${builder}.storeBit(false); }`,
            );
        } else {
            w.append(
                `${builder}.storeRef(${field}${v.kind !== "cell" ? ".asCell()" : ""});`,
            );
        }
    },
    tsStoreTuple(v, to, field, w) {
        if (v.optional) {
            w.append(
                `${to}.write${getCellLikeTsType(v)}(${field}${v.kind !== "cell" ? "?.asCell()" : ""});`,
            );
        } else {
            w.append(
                `${to}.write${getCellLikeTsType(v)}(${field}${v.kind !== "cell" ? ".asCell()" : ""});`,
            );
        }
    },
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (
                src.type === "cell" ||
                src.type === "slice" ||
                src.type === "builder"
            ) {
                if (
                    src.format === null ||
                    src.format === undefined ||
                    src.format === "ref"
                ) {
                    return {
                        optional: src.optional ? src.optional : false,
                        kind: src.type,
                    };
                }
            }
        }
        return null;
    },
};

const remainderSerializer: Serializer<{ kind: "cell" | "slice" | "builder" }> =
    {
        tsType(v) {
            return getCellLikeTsType(v);
        },
        tsLoad(v, slice, field, w) {
            w.append(
                `let ${field} = ${slice}${v.kind !== "slice" ? getCellLikeTsAsMethod(v) : ""};`,
            );
        },
        tsLoadTuple(v, reader, field, w) {
            w.append(
                `let ${field} = ${reader}.readCell()${v.kind !== "cell" ? getCellLikeTsAsMethod(v) : ""};`,
            );
        },
        tsStore(v, builder, field, w) {
            w.append(
                `${builder}.storeBuilder(${field}${v.kind !== "builder" ? ".asBuilder()" : ""});`,
            );
        },
        tsStoreTuple(v, to, field, w) {
            w.append(
                `${to}.write${getCellLikeTsType(v)}(${field}${v.kind !== "cell" ? ".asCell()" : ""});`,
            );
        },
        abiMatcher(src) {
            if (src.kind === "simple") {
                if (
                    src.type === "cell" ||
                    src.type === "slice" ||
                    src.type === "builder"
                ) {
                    if (src.format === "remainder") {
                        return { kind: src.type };
                    }
                }
            }
            return null;
        },
    };

const fixedBytesSerializer: Serializer<{ bytes: number; optional: boolean }> = {
    tsType(v) {
        if (v.optional) {
            return "Buffer | null";
        } else {
            return "Buffer";
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${slice}.loadBit() ? ${slice}.loadBuffer(${v.bytes}) : null;`,
            );
        } else {
            w.append(`let ${field} = ${slice}.loadBuffer(${v.bytes});`);
        }
    },
    tsLoadTuple(v, reader, field, w) {
        if (v.optional) {
            w.append(`let ${field} = ${reader}.readBufferOpt();`);
        } else {
            w.append(`let ${field} = ${reader}.readBuffer();`);
        }
    },
    tsStore(v, builder, field, w) {
        if (v.optional) {
            w.append(
                `if (${field} !== null && ${field} !== undefined) { ${builder}.storeBit(true).storeBuffer(${field}); } else { ${builder}.storeBit(false); }`,
            );
        } else {
            w.append(`${builder}.storeBuffer(${field});`);
        }
    },
    tsStoreTuple(v, to, field, w) {
        w.append(`${to}.writeBuffer(${field});`);
    },
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (src.type === "fixed-bytes") {
                if (typeof src.format === "number") {
                    return {
                        bytes: src.format,
                        optional: src.optional ? src.optional : false,
                    };
                }
            }
        }
        return null;
    },
};

const stringSerializer: Serializer<{ optional: boolean }> = {
    tsType(v) {
        if (v.optional) {
            return "string | null";
        } else {
            return "string";
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${slice}.loadBit() ? ${slice}.loadStringRefTail() : null;`,
            );
        } else {
            w.append(`let ${field} = ${slice}.loadStringRefTail();`);
        }
    },
    tsLoadTuple(v, reader, field, w) {
        if (v.optional) {
            w.append(`let ${field} = ${reader}.readStringOpt();`);
        } else {
            w.append(`let ${field} = ${reader}.readString();`);
        }
    },
    tsStore(v, builder, field, w) {
        if (v.optional) {
            w.append(
                `if (${field} !== null && ${field} !== undefined) { ${builder}.storeBit(true).storeStringRefTail(${field}); } else { ${builder}.storeBit(false); }`,
            );
        } else {
            w.append(`${builder}.storeStringRefTail(${field});`);
        }
    },
    tsStoreTuple(v, to, field, w) {
        w.append(`${to}.writeString(${field});`);
    },
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (src.type === "string") {
                if (src.format === null || src.format === undefined) {
                    return { optional: src.optional ? src.optional : false };
                }
            }
        }
        return null;
    },
};

const guard: Serializer<unknown> = {
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (primitiveTypes.includes(src.type)) {
                throwInternalCompilerError(
                    `Unable to resolve serializer for ${src.type} with ${src.format ? src.format : null} format`,
                );
            }
        }
        return null;
    },
    tsType(_v) {
        throwInternalCompilerError("Unreachable");
    },
    tsLoad(_v, _slice, _field, _w) {
        throwInternalCompilerError("Unreachable");
    },
    tsLoadTuple(_v, _reader, _field, _w) {
        throwInternalCompilerError("Unreachable");
    },
    tsStore(_v, _builder, _field, _w) {
        throwInternalCompilerError("Unreachable");
    },
    tsStoreTuple(_v, _to, _field, _w) {
        throwInternalCompilerError("Unreachable");
    },
};

const struct: Serializer<{ name: string; optional: boolean }> = {
    abiMatcher(src) {
        if (src.kind === "simple") {
            if (src.format !== null && src.format !== undefined) {
                return null;
            }
            return {
                name: src.type,
                optional: src.optional ? src.optional : false,
            };
        }
        return null;
    },
    tsType(v) {
        if (v.optional) {
            return v.name + " | null";
        } else {
            return v.name;
        }
    },
    tsLoad(v, slice, field, w) {
        if (v.optional) {
            w.append(
                `let ${field} = ${slice}.loadBit() ? load${v.name}(${slice}) : null;`,
            );
        } else {
            w.append(`let ${field} = load${v.name}(${slice});`);
        }
    },
    tsLoadTuple(v, reader, field, w, fromGet: boolean) {
        if (v.optional) {
            w.append(`const ${field}_p = ${reader}.readTupleOpt();`);
            w.append(
                `const ${field} = ${field}_p ? loadTuple${v.name}(${field}_p) : null;`,
            );
        } else {
            if (fromGet) {
                w.append(
                    `const ${field} = loadGetterTuple${v.name}(${reader});`,
                );
            } else {
                w.append(`const ${field} = loadTuple${v.name}(${reader});`);
            }
        }
    },
    tsStore(v, builder, field, w) {
        if (v.optional) {
            w.append(
                `if (${field} !== null && ${field} !== undefined) { ${builder}.storeBit(true); ${builder}.store(store${v.name}(${field})); } else { ${builder}.storeBit(false); }`,
            );
        } else {
            w.append(`${builder}.store(store${v.name}(${field}));`);
        }
    },
    tsStoreTuple(v, to, field, w) {
        if (v.optional) {
            w.append(`if (${field} !== null && ${field} !== undefined) {`);
            w.inIndent(() => {
                w.append(`${to}.writeTuple(storeTuple${v.name}(${field}));`);
            });
            w.append(`} else {`);
            w.inIndent(() => {
                w.append(`${to}.writeTuple(null);`);
            });
            w.append(`}`);
        } else {
            w.append(`${to}.writeTuple(storeTuple${v.name}(${field}));`);
        }
    },
};

type MapSerializerDescrKey =
    | { kind: "int" | "uint"; bits: number }
    | { kind: "address" };
type MapSerializerDescrValue =
    | { kind: "int" | "uint"; bits: number }
    | { kind: "varuint"; length: number }
    | { kind: "boolean" }
    | { kind: "address" }
    | { kind: "cell" }
    | { kind: "struct"; type: string };
type MapSerializerDescr = {
    key: MapSerializerDescrKey;
    value: MapSerializerDescrValue;
};
function getKeyParser(src: MapSerializerDescrKey) {
    switch (src.kind) {
        case "int": {
            if (src.bits <= 32) {
                return `Dictionary.Keys.Int(${src.bits})`;
            } else {
                return `Dictionary.Keys.BigInt(${src.bits})`;
            }
        }
        case "uint": {
            if (src.bits <= 32) {
                return `Dictionary.Keys.Uint(${src.bits})`;
            } else {
                return `Dictionary.Keys.BigUint(${src.bits})`;
            }
        }
        case "address": {
            return "Dictionary.Keys.Address()";
        }
    }
}
function getValueParser(src: MapSerializerDescrValue) {
    switch (src.kind) {
        case "int": {
            if (src.bits <= 32) {
                return `Dictionary.Values.Int(${src.bits})`;
            } else {
                return `Dictionary.Values.BigInt(${src.bits})`;
            }
        }
        case "uint": {
            if (src.bits <= 32) {
                return `Dictionary.Values.Uint(${src.bits})`;
            } else {
                return `Dictionary.Values.BigUint(${src.bits})`;
            }
        }
        case "varuint": {
            return `Dictionary.Values.BigVarUint(${src.length})`;
        }
        case "address": {
            return "Dictionary.Values.Address()";
        }
        case "cell": {
            return "Dictionary.Values.Cell()";
        }
        case "boolean": {
            return "Dictionary.Values.Bool()";
        }
        case "struct": {
            return `dictValueParser${src.type}()`;
        }
    }
}

const map: Serializer<MapSerializerDescr> = {
    abiMatcher(src) {
        if (src.kind === "dict") {
            if (src.format !== null && src.format !== undefined) {
                return null;
            }

            // Resolve key
            let key:
                | { kind: "int" | "uint"; bits: number }
                | { kind: "address" }
                | null = null;
            if (src.key === "int") {
                if (typeof src.keyFormat === "number") {
                    key = { kind: "int", bits: src.keyFormat };
                } else if (
                    src.keyFormat === null ||
                    src.keyFormat === undefined
                ) {
                    key = { kind: "int", bits: 257 };
                }
            }
            if (src.key === "uint") {
                if (typeof src.keyFormat === "number") {
                    key = { kind: "uint", bits: src.keyFormat };
                } else if (
                    src.keyFormat === null ||
                    src.keyFormat === undefined
                ) {
                    key = { kind: "uint", bits: 256 };
                }
            }
            if (src.key === "address") {
                if (src.keyFormat === null || src.keyFormat === undefined) {
                    key = { kind: "address" };
                }
            }

            // Resolve value
            let value: MapSerializerDescrValue | null = null;
            if (src.value === "int") {
                if (typeof src.valueFormat === "number") {
                    value = { kind: "int", bits: src.valueFormat };
                } else if (
                    src.valueFormat === null ||
                    src.valueFormat === undefined
                ) {
                    value = { kind: "int", bits: 257 };
                }
            }
            if (src.value === "uint") {
                if (typeof src.valueFormat === "number") {
                    value = { kind: "uint", bits: src.valueFormat };
                } else if (
                    src.valueFormat === null ||
                    src.valueFormat === undefined
                ) {
                    value = { kind: "uint", bits: 256 };
                } else if (src.valueFormat === "coins") {
                    value = { kind: "varuint", length: 4 };
                }
            }
            if (src.value === "address") {
                if (src.valueFormat === null || src.valueFormat === undefined) {
                    value = { kind: "address" };
                }
            }
            if (src.value === "cell") {
                if (
                    src.valueFormat === null ||
                    src.valueFormat === undefined ||
                    src.valueFormat === "ref"
                ) {
                    value = { kind: "cell" };
                }
            }
            if (!primitiveTypes.includes(src.value)) {
                if (
                    src.valueFormat === null ||
                    src.valueFormat === undefined ||
                    src.valueFormat === "ref"
                ) {
                    value = { kind: "struct", type: src.value };
                }
            }
            if (src.value === "bool") {
                if (src.valueFormat === null || src.valueFormat === undefined) {
                    value = { kind: "boolean" };
                }
            }

            if (key && value) {
                return { key, value };
            }
        }
        return null;
    },
    tsType(v) {
        // Resolve key type
        let keyT: string;
        switch (v.key.kind) {
            case "int":
            case "uint":
                {
                    if (v.key.bits <= 32) {
                        keyT = `number`;
                    } else {
                        keyT = `bigint`;
                    }
                }
                break;
            case "address": {
                keyT = `Address`;
            }
        }

        // Resolve value type
        let valueT: string;
        switch (v.value.kind) {
            case "int":
            case "uint":
                {
                    if (v.value.bits <= 32) {
                        valueT = `number`;
                    } else {
                        valueT = `bigint`;
                    }
                }
                break;
            case "varuint": {
                valueT = `bigint`;
                break;
            }
            case "boolean":
                {
                    valueT = `boolean`;
                }
                break;
            case "address":
                {
                    valueT = `Address`;
                }
                break;
            case "cell":
                {
                    valueT = `Cell`;
                }
                break;
            case "struct":
                {
                    valueT = v.value.type;
                }
                break;
        }

        return `Dictionary<${keyT}, ${valueT}>`;
    },
    tsLoad(v, slice, field, w) {
        w.append(
            `let ${field} = Dictionary.load(${getKeyParser(v.key)}, ${getValueParser(v.value)}, ${slice});`,
        );
    },
    tsLoadTuple(v, reader, field, w) {
        w.append(
            `let ${field} = Dictionary.loadDirect(${getKeyParser(v.key)}, ${getValueParser(v.value)}, ${reader}.readCellOpt());`,
        );
    },
    tsStore(v, builder, field, w) {
        w.append(
            `${builder}.storeDict(${field}, ${getKeyParser(v.key)}, ${getValueParser(v.value)});`,
        );
    },
    tsStoreTuple(v, to, field, w) {
        w.append(
            `${to}.writeCell(${field}.size > 0 ? beginCell().storeDictDirect(${field}, ${getKeyParser(v.key)}, ${getValueParser(v.value)}).endCell() : null);`,
        );
    },
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const serializers: Serializer<any>[] = [
    // Primitive types
    intSerializer,
    uintSerializer,
    coinsSerializer,
    boolSerializer,
    addressSerializer,
    cellSerializer,
    remainderSerializer,
    fixedBytesSerializer,
    stringSerializer,

    // Guard to catch all primitive types that wasn't handled
    guard,

    // Structs as fallback
    struct,
    map,
];


## writeStruct.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/bindings/typescript/writeStruct.ts)
import { ABIType, ABITypeRef } from "@ton/core";
import { serializers } from "./serializers";
import { AllocationCell, AllocationOperation } from "../../storage/operation";
import { throwInternalCompilerError } from "../../errors";
import { Writer } from "../../utils/Writer";

export const maxTupleSize = 15;

function throwUnsupportedType(type: ABITypeRef): never {
    throwInternalCompilerError(`Unsupported type: ${JSON.stringify(type)}`);
}

export function writeStruct(
    name: string,
    fields: { name: string; type: ABITypeRef }[],
    exp: boolean,
    w: Writer,
) {
    w.append(`${exp ? "export " : " "}type ${name} = {`);
    w.inIndent(() => {
        w.append(`$$type: '${name}';`);
        outer: for (const f of fields) {
            for (const s of serializers) {
                const v = s.abiMatcher(f.type);
                if (v) {
                    w.append(`${f.name}: ${s.tsType(v)};`);
                    continue outer;
                }
            }
            throwUnsupportedType(f.type);
        }
    });
    w.append(`}`);
    w.append();
}

export function writeParser(s: ABIType, allocation: AllocationCell, w: Writer) {
    w.append(`export function load${s.name}(slice: Slice) {`);
    w.inIndent(() => {
        w.append(`let sc_0 = slice;`);
        if (s.header) {
            w.append(
                `if (sc_0.loadUint(32) !== ${s.header}) { throw Error('Invalid prefix'); }`,
            );
        }
        writeParserCell(0, allocation, s, w);
        w.append(
            `return { ${[`$$type: '${s.name}' as const`, ...s.fields.map((v) => v.name + ": _" + v.name)].join(", ")} };`,
        );
    });
    w.append(`}`);
    w.append();
}

function writeParserCell(
    gen: number,
    src: AllocationCell,
    s: ABIType,
    w: Writer,
) {
    for (const f of src.ops) {
        writeParserField(gen, f, s, w);
    }
    if (src.next) {
        w.append(`let sc_${gen + 1} = sc_${gen}.loadRef().beginParse();`);
        writeParserCell(gen + 1, src.next, s, w);
    }
}

function writeParserField(
    gen: number,
    field: AllocationOperation,
    s: ABIType,
    w: Writer,
) {
    const name = "_" + field.name;
    const type = field.type;
    for (const s of serializers) {
        const v = s.abiMatcher(type);
        if (v) {
            s.tsLoad(v, `sc_${gen}`, name, w);
            return;
        }
    }
    throwUnsupportedType(type);
}

export function writeSerializer(
    s: ABIType,
    allocation: AllocationCell,
    w: Writer,
) {
    w.append(`export function store${s.name}(src: ${s.name}) {`);
    w.inIndent(() => {
        w.append(`return (builder: Builder) => {`);
        w.inIndent(() => {
            w.append(`let b_0 = builder;`);
            if (s.header) {
                w.append(`b_0.storeUint(${s.header}, 32);`);
            }
            writeSerializerCell(0, allocation, w);
        });
        w.append(`};`);
    });
    w.append(`}`);
    w.append();
}

export function writeInitSerializer(
    name: string,
    allocation: AllocationCell,
    w: Writer,
) {
    w.append(`function init${name}(src: ${name}) {`);
    w.inIndent(() => {
        w.append(`return (builder: Builder) => {`);
        w.inIndent(() => {
            w.append(`let b_0 = builder;`);
            writeSerializerCell(0, allocation, w);
        });
        w.append(`};`);
    });
    w.append(`}`);
    w.append();
}

function writeSerializerCell(gen: number, src: AllocationCell, w: Writer) {
    for (const f of src.ops) {
        writeSerializerField(gen, f, w);
    }
    if (src.next) {
        w.append(`let b_${gen + 1} = new Builder();`);
        writeSerializerCell(gen + 1, src.next, w);
        w.append(`b_${gen}.storeRef(b_${gen + 1}.endCell());`);
    }
}

function writeSerializerField(gen: number, s: AllocationOperation, w: Writer) {
    const name = "src." + s.name;
    const type = s.type;
    for (const s of serializers) {
        const v = s.abiMatcher(type);
        if (v) {
            s.tsStore(v, `b_${gen}`, name, w);
            return;
        }
    }
    throwUnsupportedType(type);
}

export function writeTupleParser(s: ABIType, w: Writer) {
    w.append(`function loadTuple${s.name}(source: TupleReader) {`);
    w.inIndent(() => {
        if (s.fields.length <= maxTupleSize) {
            for (const f of s.fields) {
                writeTupleFieldParser("_" + f.name, f.type, w);
            }
        } else {
            const fields = [...s.fields];
            while (fields.length >= maxTupleSize) {
                const batch = fields.splice(0, maxTupleSize - 1);
                for (const f of batch) {
                    writeTupleFieldParser("_" + f.name, f.type, w);
                }
                w.append(`source = source.readTuple();`);
            }
            for (const f of fields) {
                writeTupleFieldParser("_" + f.name, f.type, w);
            }
        }
        w.append(
            `return { ${[`$$type: '${s.name}' as const`, ...s.fields.map((v) => v.name + ": _" + v.name)].join(", ")} };`,
        );
    });
    w.append(`}`);
    w.append();
}

export function writeGetterTupleParser(s: ABIType, w: Writer) {
    w.append(`function loadGetterTuple${s.name}(source: TupleReader) {`);
    w.inIndent(() => {
        for (const f of s.fields) {
            writeTupleFieldParser("_" + f.name, f.type, w, true);
        }
        w.append(
            `return { ${[`$$type: '${s.name}' as const`, ...s.fields.map((v) => v.name + ": _" + v.name)].join(", ")} };`,
        );
    });
    w.append(`}`);
    w.append();
}

export function writeGetParser(name: string, type: ABITypeRef, w: Writer) {
    writeTupleFieldParser(name, type, w, true);
}

function writeTupleFieldParser(
    name: string,
    type: ABITypeRef,
    w: Writer,
    fromGet = false,
) {
    for (const s of serializers) {
        const v = s.abiMatcher(type);
        if (v) {
            s.tsLoadTuple(v, `source`, name, w, fromGet);
            return;
        }
    }
    throwUnsupportedType(type);
}

export function writeTupleSerializer(s: ABIType, w: Writer) {
    w.append(`function storeTuple${s.name}(source: ${s.name}) {`);
    w.inIndent(() => {
        w.append(`let builder = new TupleBuilder();`);
        for (const f of s.fields) {
            writeVariableToStack(`source.${f.name}`, f.type, w);
        }
        w.append(`return builder.build();`);
    });
    w.append(`}`);
    w.append();
}

export function writeArgumentToStack(name: string, ref: ABITypeRef, w: Writer) {
    writeVariableToStack(name, ref, w);
}

function writeVariableToStack(name: string, type: ABITypeRef, w: Writer) {
    for (const s of serializers) {
        const v = s.abiMatcher(type);
        if (v) {
            s.tsStoreTuple(v, `builder`, name, w);
            return;
        }
    }
    throwUnsupportedType(type);
}

export function writeDictParser(s: ABIType, w: Writer) {
    w.write(`
        function dictValueParser${s.name}(): DictionaryValue<${s.name}> {
            return {
                serialize: (src, builder) => {
                    builder.storeRef(beginCell().store(store${s.name}(src)).endCell());
                },
                parse: (src) => {
                    return load${s.name}(src.loadRef().beginParse());
                }
            }
        }
    `);
    w.append();
}


## features.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/config/features.ts)
import { CompilerContext, createContextStore } from "../context";

const featureStore = createContextStore<boolean | null | string>();

export function enabledInline(ctx: CompilerContext) {
    return featureEnabled(ctx, "inline");
}

export function enabledDebug(ctx: CompilerContext) {
    return featureEnabled(ctx, "debug");
}

export function enabledExternals(ctx: CompilerContext) {
    return featureEnabled(ctx, "external");
}

export function enabledIpfsAbiGetter(ctx: CompilerContext) {
    return featureEnabled(ctx, "ipfsAbiGetter");
}

export function enabledInterfacesGetter(ctx: CompilerContext) {
    return featureEnabled(ctx, "interfacesGetter");
}

function featureEnabled(ctx: CompilerContext, key: string) {
    return featureStore.get(ctx, key) === true;
}

export function featureEnable(ctx: CompilerContext, key: string) {
    return featureStore.set(ctx, key, true);
}


## parseConfig.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/config/parseConfig.ts)
import { z } from "zod";

export const optionsSchema = z
    .object({
        /**
         * If set to true, enables debug output of a contract and allows usage of `dump()` function,
         * which is useful for debugging purposes.
         *
         * Read more: https://docs.tact-lang.org/book/debug
         */
        debug: z.boolean().optional(),
        /**
         * If set to true, enables support of external message receivers.
         *
         * Read more: https://docs.tact-lang.org/book/external
         */
        external: z.boolean().optional(),
        /**
         * If set to true, enables generation of a getter with IPFS links describing the contract's ABI.
         *
         * Read more: https://docs.tact-lang.org/ref/evolution/OTP-003
         */
        ipfsAbiGetter: z.boolean().optional(),
        /**
         * If set to true, enables generation of a getter with a list of interfaces provided by the contract.
         *
         * Read more: https://docs.tact-lang.org/book/contracts#interfaces
         */
        interfacesGetter: z.boolean().optional(),
        /**
         * Experimental options that might be removed in the future. Use with caution!
         */
        experimental: z
            .object({
                /**
                 * If set to true, enables inlining of all functions in contracts.
                 * This can reduce gas usage at the cost of bigger contracts.
                 */
                inline: z.boolean().optional(),
            })
            .strict()
            .optional(),
    })
    .strict();

export const projectSchema = z
    .object({
        /**
         * Name of the project. All generated files are prefixed with it.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-name
         */
        name: z.string(),
        /**
         * Path to the project's Tact file. You can only specify one Tact file per project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-path
         */
        path: z.string(),
        /**
         * Path to the directory where all generated files will be placed.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-output
         */
        output: z.string(),
        /**
         * Compilation options for the project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-options
         */
        options: optionsSchema.optional(),
        /**
         * Compilation mode of the project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects-mode
         */
        mode: z
            .enum(["fullWithDecompilation", "full", "funcOnly", "checkOnly"])
            .optional(),
    })
    .strict();

export const configSchema = z
    .object({
        /**
         * A property for specifying a path or URL to the JSON schema of tact.config.json
         *
         * Read more: https://docs.tact-lang.org/book/config#schema
         */
        $schema: z.string().optional(),
        /**
         * List of Tact projects with respective compilation options. Each .tact file represents its own Tact project.
         *
         * Read more: https://docs.tact-lang.org/book/config#projects
         */
        projects: z.array(projectSchema),
    })
    .strict();

/**
 * Compiler configuration schema
 *
 * Read more: https://docs.tact-lang.org/book/config
 */
export type Config = z.infer<typeof configSchema>;

/**
 * Per-project configuration options
 *
 * Read more: https://docs.tact-lang.org/book/config#projects
 */
export type ConfigProject = z.infer<typeof projectSchema>;

/**
 * Per-project configuration options
 *
 * Read more: https://docs.tact-lang.org/book/config#projects
 */
export type Options = z.infer<typeof optionsSchema>;

/**
 * Takes a stringified JSON [src] of a schema, converts to JSON and returns a parsed schema if it's valid
 *
 * @throws If the provided JSON string isn't a valid JSON
 * @throws If the provided JSON string isn't valid according to the config schema
 */
export function parseConfig(src: string) {
    const parsed = JSON.parse(src);
    return configSchema.parse(parsed);
}

/**
 * Takes a config schema object and verifies that it's valid
 *
 * @throws If the provided object isn't valid according to the config schema
 */
export function verifyConfig(config: Config) {
    return configSchema.parse(config);
}


## display-to-json.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/error/display-to-json.ts)
/**
 * Render error message to JSON for tests
 */

import { throwInternalCompilerError } from "../errors";
import { SrcInfo } from "../grammar";
import { srcInfoEqual } from "../grammar/src-info";
import { ErrorDisplay } from "./display";

export type ErrorJson = ErrorSub | ErrorText | ErrorLink | ErrorAt;

export type ErrorText = { kind: "text"; text: string };
export type ErrorSub = { kind: "sub"; parts: string[]; subst: ErrorJson[] };
export type ErrorLink = { kind: "link"; text: string; loc: SrcInfo };
export type ErrorAt = { kind: "at"; body: ErrorJson; loc: SrcInfo };

export const errorJsonEqual = (left: ErrorJson, right: ErrorJson): boolean => {
    switch (left.kind) {
        case "link": {
            return (
                left.kind === right.kind &&
                left.text === right.text &&
                srcInfoEqual(left.loc, right.loc)
            );
        }
        case "at": {
            return (
                left.kind === right.kind &&
                errorJsonEqual(left.body, right.body) &&
                srcInfoEqual(left.loc, right.loc)
            );
        }
        case "text": {
            return left.kind === right.kind && left.text === right.text;
        }
        case "sub": {
            if (left.kind !== right.kind) {
                return false;
            }
            if (left.parts.length !== right.parts.length) {
                return false;
            }
            if (left.parts.some((part, index) => part != right.parts[index])) {
                return false;
            }
            if (left.subst.length !== right.subst.length) {
                return false;
            }
            return left.subst.every((leftChild, index) => {
                const rightChild = right.subst[index];
                if (typeof rightChild === "undefined") {
                    throwInternalCompilerError(
                        "Impossible: by this moment array lengths must match",
                    );
                }
                return errorJsonEqual(leftChild, rightChild);
            });
        }
    }
};

export const displayToJson: ErrorDisplay<ErrorJson> = {
    text: (text) => ({ kind: "text", text }),
    sub: (parts, ...subst) => ({ kind: "sub", parts: [...parts], subst }),
    link: (text, loc) => ({ kind: "link", text, loc }),
    at: (loc, body) => ({ kind: "at", body, loc }),
};


## display-to-string.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/error/display-to-string.ts)
/**
 * Render error message to string for compiler CLI
 */

import { ErrorDisplay } from "./display";
import { locationStr } from "../errors";

export const displayToString: ErrorDisplay<string> = {
    text: (text) => text,
    sub: (parts, ...subst) => {
        const [head, ...tail] = parts;
        if (!head) {
            return "";
        }
        return tail.reduce((acc, part, index) => {
            const sub = subst[index];
            return acc + sub + part;
        }, head);
    },
    link: (text, _loc) => text,
    at: (loc, body) => {
        return `${locationStr(loc)}${body}\n${loc.interval.getLineAndColumnMessage()}`;
    },
};


## display.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/error/display.ts)
/**
 * Describes DSL for displaying errors
 */

import { SrcInfo } from "../grammar";

export interface ErrorDisplay<T> {
    // Specify main error location
    at: (loc: SrcInfo, body: T) => T;

    // Regular string
    text: (text: string) => T;

    // Text with substitutions
    sub: (text: TemplateStringsArray, ...subst: T[]) => T;

    // Reference some code location
    link: (text: string, loc: SrcInfo) => T;
}


## funcCompile.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/func/funcCompile.spec.ts)
import fs from "fs";
import path from "path";
import { Logger } from "../logger";
import { funcCompile } from "./funcCompile";
import files from "../imports/stdlib";

describe("funcCompile", () => {
    it("should compile small contract", async () => {
        const source = fs.readFileSync(
            path.resolve(__dirname, "__testdata__", "small.fc"),
            "utf8",
        );
        const res = await funcCompile({
            entries: ["/stdlib.fc", "/small.fc"],
            sources: [
                {
                    path: "/stdlib.fc",
                    content: Buffer.from(
                        files["stdlib.fc"]!,
                        "base64",
                    ).toString(),
                },
                { path: "/small.fc", content: source },
            ],
            logger: new Logger(),
        });
        expect(res.ok).toBe(true);
    });
});


## funcCompile.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/func/funcCompile.ts)
import { ILogger } from "../logger";

// Wasm Imports
// eslint-disable-next-line @typescript-eslint/no-var-requires
const CompilerModule = require("./funcfiftlib.js");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const FuncFiftLibWasm = require("./funcfiftlib.wasm.js").FuncFiftLibWasm;
const WasmBinary = Buffer.from(FuncFiftLibWasm, "base64");

type Pointer = unknown;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const writeToCString = (mod: any, data: string): Pointer => {
    const len = mod.lengthBytesUTF8(data) + 1;
    const ptr = mod._malloc(len);
    mod.stringToUTF8(data, ptr, len);
    return ptr;
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const writeToCStringPtr = (mod: any, str: string, ptr: any) => {
    const allocated = writeToCString(mod, str);
    mod.setValue(ptr, allocated, "*");
    return allocated;
};

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const readFromCString = (mod: any, pointer: Pointer): string =>
    mod.UTF8ToString(pointer);

function cutFirstLine(src: string) {
    return src.slice(src.indexOf("\n") + 1);
}

export type FuncCompilationResult =
    | {
          ok: false;
          log: string;
          fift: string | null;
          output: Buffer | null;
      }
    | {
          ok: true;
          log: string;
          fift: string;
          output: Buffer;
      };

type CompileResult =
    | {
          status: "error";
          message: string;
      }
    | {
          status: "ok";
          codeBoc: string;
          fiftCode: string;
          warnings: string;
      };

export async function funcCompile(args: {
    entries: string[];
    sources: { path: string; content: string }[];
    logger: ILogger;
}): Promise<FuncCompilationResult> {
    // Parameters
    const files: string[] = args.entries;
    const configStr = JSON.stringify({
        sources: files,
        optLevel: 2, // compileConfig.optLevel || 2
    });

    // Pointer tracking
    const allocatedPointers: Pointer[] = [];
    const allocatedFunctions: Pointer[] = [];
    const trackPointer = (pointer: Pointer): Pointer => {
        allocatedPointers.push(pointer);
        return pointer;
    };
    const trackFunctionPointer = (pointer: Pointer): Pointer => {
        allocatedFunctions.push(pointer);
        return pointer;
    };

    // Create module
    const logs: string[] = [];
    const mod = await CompilerModule({
        wasmBinary: WasmBinary,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        printErr: (e: any) => {
            logs.push(e);
        },
    });

    // Execute
    try {
        // Write config
        const configPointer = trackPointer(writeToCString(mod, configStr));

        // FS emulation callback
        const callbackPtr = trackFunctionPointer(
            mod.addFunction(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (_kind: any, _data: any, contents: any, error: any) => {
                    const kind: string = readFromCString(mod, _kind);
                    const data: string = readFromCString(mod, _data);
                    if (kind === "realpath") {
                        allocatedPointers.push(
                            writeToCStringPtr(mod, data, contents),
                        );
                    } else if (kind === "source") {
                        try {
                            const fl = args.sources.find(
                                (v) => v.path === data,
                            );
                            if (!fl) {
                                throw Error("File not found: " + data);
                            }
                            allocatedPointers.push(
                                writeToCStringPtr(mod, fl.content, contents),
                            );
                        } catch (err) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            const e = err as any;
                            allocatedPointers.push(
                                writeToCStringPtr(
                                    mod,
                                    "message" in e ? e.message : e.toString(),
                                    error,
                                ),
                            );
                        }
                    } else {
                        allocatedPointers.push(
                            writeToCStringPtr(
                                mod,
                                "Unknown callback kind " + kind,
                                error,
                            ),
                        );
                    }
                },
                "viiii",
            ),
        );

        // Execute
        const resultPointer = trackPointer(
            mod._func_compile(configPointer, callbackPtr),
        );
        const retJson = readFromCString(mod, resultPointer);
        const result = JSON.parse(retJson) as CompileResult;

        const msg = logs.join("\n");

        switch (result.status) {
            case "error": {
                return {
                    ok: false,
                    log:
                        logs.length > 0
                            ? msg
                            : result.message
                              ? result.message
                              : "Unknown error",
                    fift: null,
                    output: null,
                };
            }
            case "ok": {
                return {
                    ok: true,
                    log:
                        logs.length > 0
                            ? msg
                            : result.warnings
                              ? result.warnings
                              : "",
                    fift: cutFirstLine(result.fiftCode.replaceAll("\\n", "\n")),
                    output: Buffer.from(result.codeBoc, "base64"),
                };
            }
        }
    } catch (e) {
        args.logger.error(e as Error);
        throw Error("Unexpected compiler response");
    } finally {
        for (const i of allocatedFunctions) {
            mod.removeFunction(i);
        }
        for (const i of allocatedPointers) {
            mod._free(i);
        }
    }
    throw Error("Unexpected compiler response");
}


## funcfiftlib.js (https://github.com/tact-lang/tact/blob/main/tact-main/src/func/funcfiftlib.js)

var CompilerModule = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(CompilerModule) {
  CompilerModule = CompilerModule || {};

var Module=typeof CompilerModule!="undefined"?CompilerModule:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var crypto={getRandomValues:function(array){for(var i=0;i<array.length;i++)array[i]=Math.random()*256|0}};var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;err("exiting due to exception: "+toLog)}var fs;var nodePath;var requireNodeFS;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=require("path").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}requireNodeFS=()=>{if(!nodePath){fs=require("fs");nodePath=require("path")}};read_=function shell_read(filename,binary){requireNodeFS();filename=nodePath["normalize"](filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror)=>{requireNodeFS();filename=nodePath["normalize"](filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer)})};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",function(reason){throw reason});quit_=(status,toThrow)=>{if(keepRuntimeAlive()){process["exitCode"]=status;throw toThrow}logExceptionOnExit(toThrow);process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort(text)}}var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++}else if(c<=2047){len+=2}else if(c>=55296&&c<=57343){len+=4;++i}else{len+=3}}return len}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||33554432;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();FS.ignorePermissions=false;TTY.init();callRuntimeCallbacks(__ATINIT__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){{if(Module["onAbort"]){Module["onAbort"](what)}}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="funcfiftlib.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["La"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["Pa"];addOnInit(Module["asm"]["Ma"]);removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}var tempDouble;var tempI64;var ASM_CONSTS={1871016:()=>{return Module.getRandomValue()},1871052:()=>{if(Module.getRandomValue===undefined){try{var window_="object"===typeof window?window:self;var crypto_=typeof window_.crypto!=="undefined"?window_.crypto:window_.msCrypto;var randomValuesStandard=function(){var buf=new Uint32Array(1);crypto_.getRandomValues(buf);return buf[0]>>>0};randomValuesStandard();Module.getRandomValue=randomValuesStandard}catch(e){try{var crypto=require("crypto");var randomValueNodeJS=function(){var buf=crypto["randomBytes"](4);return(buf[0]<<24|buf[1]<<16|buf[2]<<8|buf[3])>>>0};randomValueNodeJS();Module.getRandomValue=randomValueNodeJS}catch(e){throw"No secure random number generator found"}}}},1871774:$0=>{throw UTF8ToString($0)}};function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){callbacks.shift()(Module)}}function jsStackTrace(){var error=new Error;if(!error.stack){try{throw new Error}catch(e){error=e}if(!error.stack){return"(no stack trace available)"}}return error.stack.toString()}function setValue(ptr,value,type="i8"){if(type.endsWith("*"))type="*";switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;case"*":HEAPU32[ptr>>2]=value;break;default:abort("invalid type for setValue: "+type)}}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function ___cxa_allocate_exception(size){return _malloc(size+24)+24}var exceptionCaught=[];function exception_addRef(info){info.add_ref()}var uncaughtExceptionCount=0;function ___cxa_begin_catch(ptr){var info=new ExceptionInfo(ptr);if(!info.get_caught()){info.set_caught(true);uncaughtExceptionCount--}info.set_rethrown(false);exceptionCaught.push(info);exception_addRef(info);return info.get_exception_ptr()}var exceptionLast=0;function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr}}function ___cxa_free_exception(ptr){return _free(new ExceptionInfo(ptr).ptr)}function getWasmTableEntry(funcPtr){return wasmTable.get(funcPtr)}function exception_decRef(info){if(info.release_ref()&&!info.get_rethrown()){var destructor=info.get_destructor();if(destructor){getWasmTableEntry(destructor)(info.excPtr)}___cxa_free_exception(info.excPtr)}}function ___cxa_end_catch(){_setThrew(0);var info=exceptionCaught.pop();exception_decRef(info);exceptionLast=0}function ___resumeException(ptr){if(!exceptionLast){exceptionLast=ptr}throw ptr}function ___cxa_find_matching_catch_2(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_3(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_4(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_5(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_6(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_find_matching_catch_7(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0}var info=new ExceptionInfo(thrown);info.set_adjusted_ptr(thrown);var thrownType=info.get_type();if(!thrownType){setTempRet0(0);return thrown}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}var adjusted_ptr_addr=info.ptr+16;if(___cxa_can_catch(caughtType,thrownType,adjusted_ptr_addr)){setTempRet0(caughtType);return thrown}}setTempRet0(thrownType);return thrown}function ___cxa_rethrow(){var info=exceptionCaught.pop();if(!info){abort("no exception to throw")}var ptr=info.excPtr;if(!info.get_rethrown()){exceptionCaught.push(info);info.set_rethrown(true);info.set_caught(false);uncaughtExceptionCount++}exceptionLast=ptr;throw ptr}function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}function ___cxa_uncaught_exceptions(){return uncaughtExceptionCount}function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}var PATH={isAbs:path=>path.charAt(0)==="/",splitPath:filename=>{var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:(parts,allowAboveRoot)=>{var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1)}else if(last===".."){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift("..")}}return parts},normalize:path=>{var isAbsolute=PATH.isAbs(path),trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(p=>!!p),!isAbsolute).join("/");if(!path&&!isAbsolute){path="."}if(path&&trailingSlash){path+="/"}return(isAbsolute?"/":"")+path},dirname:path=>{var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return"."}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:path=>{if(path==="/")return"/";path=PATH.normalize(path);path=path.replace(/\/$/,"");var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:(l,r)=>{return PATH.normalize(l+"/"+r)}};function getRandomDevice(){if(typeof crypto=="object"&&typeof crypto["getRandomValues"]=="function"){var randomBuffer=new Uint8Array(1);return()=>{crypto.getRandomValues(randomBuffer);return randomBuffer[0]}}else if(ENVIRONMENT_IS_NODE){try{var crypto_module=require("crypto");return()=>crypto_module["randomBytes"](1)[0]}catch(e){}}return()=>abort("randomDevice")}var PATH_FS={resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=PATH.isAbs(path)}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(p=>!!p),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||"."},relative:(from,to)=>{from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close:function(stream){stream.tty.ops.fsync(stream.tty)},fsync:function(stream){stream.tty.ops.fsync(stream.tty)},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now()}return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=Buffer.alloc(BUFSIZE);var bytesRead=0;try{bytesRead=fs.readSync(process.stdin.fd,buf,0,BUFSIZE,-1)}catch(e){if(e.toString().includes("EOF"))bytesRead=0;else throw e}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8")}else{result=null}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n"}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n"}}if(!result){return null}tty.input=intArrayFromString(result,true)}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync:function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[]}}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},fsync:function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[]}}}};function zeroMemory(address,size){HEAPU8.fill(0,address,address+size)}function alignMemory(size,alignment){return Math.ceil(size/alignment)*alignment}function mmapAlloc(size){size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(!ptr)return 0;zeroMemory(ptr,size);return ptr}var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}}}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp}return node},getFileDataAsTypedArray:function(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup:function(parent,name){throw FS.genericErrors[44]},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp;old_node.parent=new_dir},unlink:function(parent,name){delete parent.contents[name];parent.timestamp=Date.now()},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.timestamp=Date.now()},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key)}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink:function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write:function(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap:function(stream,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents.buffer===buffer){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}HEAP8.set(contents,ptr)}return{ptr:ptr,allocated:allocated}},msync:function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};function asyncLoad(url,onload,onerror,noRunDep){var dep=!noRunDep?getUniqueRunDependency("al "+url):"";readAsync(url,arrayBuffer=>{assert(arrayBuffer,'Loading data file "'+url+'" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency(dep)},event=>{if(onerror){onerror()}else{throw'Loading data file "'+url+'" failed.'}});if(dep)addRunDependency(dep)}var ERRNO_CODES={};var NODEFS={isWindows:false,staticInit:()=>{NODEFS.isWindows=!!process.platform.match(/^win/);var flags=process["binding"]("constants");if(flags["fs"]){flags=flags["fs"]}NODEFS.flagsForNodeMap={1024:flags["O_APPEND"],64:flags["O_CREAT"],128:flags["O_EXCL"],256:flags["O_NOCTTY"],0:flags["O_RDONLY"],2:flags["O_RDWR"],4096:flags["O_SYNC"],512:flags["O_TRUNC"],1:flags["O_WRONLY"],131072:flags["O_NOFOLLOW"]}},convertNodeCode:e=>{var code=e.code;return ERRNO_CODES[code]},mount:mount=>{return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)},createNode:(parent,name,mode,dev)=>{if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode)){throw new FS.ErrnoError(28)}var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node},getMode:path=>{var stat;try{stat=fs.lstatSync(path);if(NODEFS.isWindows){stat.mode=stat.mode|(stat.mode&292)>>2}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}return stat.mode},realPath:node=>{var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)},flagsForNode:flags=>{flags&=~2097152;flags&=~2048;flags&=~32768;flags&=~524288;flags&=~65536;var newFlags=0;for(var k in NODEFS.flagsForNodeMap){if(flags&k){newFlags|=NODEFS.flagsForNodeMap[k];flags^=k}}if(flags){throw new FS.ErrnoError(28)}return newFlags},node_ops:{getattr:node=>{var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}if(NODEFS.isWindows&&!stat.blksize){stat.blksize=4096}if(NODEFS.isWindows&&!stat.blocks){stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0}return{dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}},setattr:(node,attr)=>{var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,date,date)}if(attr.size!==undefined){fs.truncateSync(path,attr.size)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},lookup:(parent,name)=>{var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)},mknod:(parent,name,mode,dev)=>{var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode)){fs.mkdirSync(path,node.mode)}else{fs.writeFileSync(path,"",{mode:node.mode})}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}return node},rename:(oldNode,newDir,newName)=>{var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}oldNode.name=newName},unlink:(parent,name)=>{var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},rmdir:(parent,name)=>{var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},readdir:node=>{var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},symlink:(parent,newName,oldPath)=>{var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},readlink:node=>{var path=NODEFS.realPath(node);try{path=fs.readlinkSync(path);path=nodePath.relative(nodePath.resolve(node.mount.opts.root),path);return path}catch(e){if(!e.code)throw e;if(e.code==="UNKNOWN")throw new FS.ErrnoError(28);throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}}},stream_ops:{open:stream=>{var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode)){stream.nfd=fs.openSync(path,NODEFS.flagsForNode(stream.flags))}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},close:stream=>{try{if(FS.isFile(stream.node.mode)&&stream.nfd){fs.closeSync(stream.nfd)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},read:(stream,buffer,offset,length,position)=>{if(length===0)return 0;try{return fs.readSync(stream.nfd,Buffer.from(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},write:(stream,buffer,offset,length,position)=>{try{return fs.writeSync(stream.nfd,Buffer.from(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}},llseek:(stream,offset,whence)=>{var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){try{var stat=fs.fstatSync(stream.nfd);position+=stat.size}catch(e){throw new FS.ErrnoError(NODEFS.convertNodeCode(e))}}}if(position<0){throw new FS.ErrnoError(28)}return position},mmap:(stream,length,position,prot,flags)=>{if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr=mmapAlloc(length);NODEFS.stream_ops.read(stream,HEAP8,ptr,length,position);return{ptr:ptr,allocated:true}},msync:(stream,buffer,offset,length,mmapFlags)=>{if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(mmapFlags&2){return 0}var bytesWritten=NODEFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path,opts={})=>{path=PATH_FS.resolve(FS.cwd(),path);if(!path)return{path:"",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=PATH.normalizeArray(path.split("/").filter(p=>!!p),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return{path:current_path,node:current}},getPath:node=>{var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent}},hashName:(parentid,name)=>{var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode:node=>{var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode:node=>{var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode:(parent,name)=>{var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode:(parent,name,mode,rdev)=>{var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:node=>{FS.hashRemoveNode(node)},isRoot:node=>{return node===node.parent},isMountpoint:node=>{return!!node.mounted},isFile:mode=>{return(mode&61440)===32768},isDir:mode=>{return(mode&61440)===16384},isLink:mode=>{return(mode&61440)===40960},isChrdev:mode=>{return(mode&61440)===8192},isBlkdev:mode=>{return(mode&61440)===24576},isFIFO:mode=>{return(mode&61440)===4096},isSocket:mode=>{return(mode&49152)===49152},flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:str=>{var flags=FS.flagModes[str];if(typeof flags=="undefined"){throw new Error("Unknown file open mode: "+str)}return flags},flagsToPermissionString:flag=>{var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w"}return perms},nodePermissions:(node,perms)=>{if(FS.ignorePermissions){return 0}if(perms.includes("r")&&!(node.mode&292)){return 2}else if(perms.includes("w")&&!(node.mode&146)){return 2}else if(perms.includes("x")&&!(node.mode&73)){return 2}return 0},mayLookup:dir=>{var errCode=FS.nodePermissions(dir,"x");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate:(dir,name)=>{try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:(dir,name,isdir)=>{var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,"wx");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else{if(FS.isDir(node.mode)){return 31}}return 0},mayOpen:(node,flags)=>{if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:(fd_start=0,fd_end=FS.MAX_OPEN_FDS)=>{for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStream:fd=>FS.streams[fd],createStream:(stream,fd_start,fd_end)=>{if(!FS.FSStream){FS.FSStream=function(){this.shared={}};FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:function(){return this.node},set:function(val){this.node=val}},isRead:{get:function(){return(this.flags&2097155)!==1}},isWrite:{get:function(){return(this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}},flags:{get:function(){return this.shared.flags},set:function(val){this.shared.flags=val}},position:{get:function(){return this.shared.position},set:function(val){this.shared.position=val}}})}stream=Object.assign(new FS.FSStream,stream);var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:fd=>{FS.streams[fd]=null},chrdev_stream_ops:{open:stream=>{var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream)}},llseek:()=>{throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice:(dev,ops)=>{FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts:mount=>{var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts},syncfs:(populate,callback)=>{if(typeof populate=="function"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work")}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount:(type,opts,mountpoint)=>{var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount:mountpoint=>{var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup:(parent,name)=>{return parent.node_ops.lookup(parent,name)},mknod:(path,mode,dev)=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create:(path,mode)=>{mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:(path,mode)=>{mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree:(path,mode)=>{var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev:(path,mode,dev)=>{if(typeof dev=="undefined"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink:(oldpath,newpath)=>{if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename:(old_path,new_path)=>{var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,"w");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir:path=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink:path=>{var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat:(path,dontFollow)=>{var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat:path=>{return FS.stat(path,true)},chmod:(path,mode,dontFollow)=>{var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod:(path,mode)=>{FS.chmod(path,mode,true)},fchmod:(fd,mode)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chmod(stream.node,mode)},chown:(path,uid,gid,dontFollow)=>{var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()})},lchown:(path,uid,gid)=>{FS.chown(path,uid,gid,true)},fchown:(fd,uid,gid)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chown(stream.node,uid,gid)},truncate:(path,len)=>{if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,"w");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate:(fd,len)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len)},utime:(path,atime,mtime)=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open:(path,flags,mode)=>{if(path===""){throw new FS.ErrnoError(44)}flags=typeof flags=="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode=="undefined"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path=="object"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512&&!created){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false});if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1}}return stream},close:stream=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed:stream=>{return stream.fd===null},llseek:(stream,offset,whence)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read:(stream,buffer,offset,length,position)=>{if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:(stream,buffer,offset,length,position,canOwn)=>{if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate:(stream,offset,length)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length)},mmap:(stream,length,position,prot,flags)=>{if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}return stream.stream_ops.mmap(stream,length,position,prot,flags)},msync:(stream,buffer,offset,length,mmapFlags)=>{if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},munmap:stream=>0,ioctl:(stream,cmd,arg)=>{if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:(path,opts={})=>{opts.flags=opts.flags||0;opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding==="binary"){ret=buf}FS.close(stream);return ret},writeFile:(path,data,opts={})=>{opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data=="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error("Unsupported data type")}FS.close(stream)},cwd:()=>FS.currentPath,chdir:path=>{var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,"x");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories:()=>{FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user")},createDefaultDevices:()=>{FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device=getRandomDevice();FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp")},createSpecialDirectories:()=>{FS.mkdir("/proc");var proc_self=FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:()=>{var node=FS.createNode(proc_self,"fd",16384|511,73);node.node_ops={lookup:(parent,name)=>{var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;return ret}};return node}},{},"/proc/self/fd")},createStandardStreams:()=>{if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"])}else{FS.symlink("/dev/tty","/dev/stdin")}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"])}else{FS.symlink("/dev/tty","/dev/stdout")}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"])}else{FS.symlink("/dev/tty1","/dev/stderr")}var stdin=FS.open("/dev/stdin",0);var stdout=FS.open("/dev/stdout",1);var stderr=FS.open("/dev/stderr",1)},ensureErrnoError:()=>{if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=function(errno){this.errno=errno};this.setErrno(errno);this.message="FS error"};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[44].forEach(code=>{FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>"})},staticInit:()=>{FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"NODEFS":NODEFS}},init:(input,output,error)=>{FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams()},quit:()=>{FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},getMode:(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},findObject:(path,dontResolveLastLink)=>{var ret=FS.analyzePath(path,dontResolveLastLink);if(!ret.exists){return null}return ret.object},analyzePath:(path,dontResolveLastLink)=>{try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/"}catch(e){ret.error=e.errno}return ret},createPath:(parent,path,canRead,canWrite)=>{parent=typeof parent=="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile:(parent,name,properties,canRead,canWrite)=>{var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:(parent,name,data,canRead,canWrite,canOwn)=>{var path=name;if(parent){parent=typeof parent=="string"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data=="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node},createDevice:(parent,name,input,output)=>{var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:stream=>{stream.seekable=false},close:stream=>{if(output&&output.buffer&&output.buffer.length){output(10)}},read:(stream,buffer,offset,length,pos)=>{var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:(stream,buffer,offset,length,pos)=>{for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile:obj=>{if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(read_){try{obj.contents=intArrayFromString(read_(obj.url),true);obj.usedBytes=obj.contents.length}catch(e){throw new FS.ErrnoError(29)}}else{throw new Error("Cannot load without read() or XMLHttpRequest.")}},createLazyFile:(parent,name,url,canRead,canWrite)=>{function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}return intArrayFromString(xhr.responseText||"",true)};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]=="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]=="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out("LazyFiles on gzip forces download of the whole file when length is accessed")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._length}},chunkSize:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}});var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){FS.forceLoadFile(node);return fn.apply(null,arguments)}});function writeChunks(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size}stream_ops.read=(stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);return writeChunks(stream,buffer,offset,length,position)};stream_ops.mmap=(stream,length,position,prot,flags)=>{FS.forceLoadFile(node);var ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}writeChunks(stream,HEAP8,ptr,length,position);return{ptr:ptr,allocated:true}};node.stream_ops=stream_ops;return node},createPreloadedFile:(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency("cp "+fullname);function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}if(onload)onload();removeRunDependency(dep)}if(Browser.handledByPreloadPlugin(byteArray,fullname,finish,()=>{if(onerror)onerror();removeRunDependency(dep)})){return}finish(byteArray)}addRunDependency(dep);if(typeof url=="string"){asyncLoad(url,byteArray=>processData(byteArray),onerror)}else{processData(url)}},indexedDB:()=>{return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:()=>{return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=()=>{out("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME)};openRequest.onsuccess=()=>{var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(path=>{var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=()=>{ok++;if(ok+fail==total)finish()};putRequest.onerror=()=>{fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror},loadFilesFromDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=()=>{var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(path=>{var getRequest=files.get(path);getRequest.onsuccess=()=>{if(FS.analyzePath(path).exists){FS.unlink(path)}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()};getRequest.onerror=()=>{fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror}};var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt:function(dirfd,path,allowEmpty){if(PATH.isAbs(path)){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(8);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return PATH.join2(dir,path)},doStat:function(func,path,buf){try{var stat=func(path)}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return-54}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAP32[buf+48>>2]=4096;HEAP32[buf+52>>2]=stat.blocks;tempI64=[Math.floor(stat.atime.getTime()/1e3)>>>0,(tempDouble=Math.floor(stat.atime.getTime()/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+56>>2]=tempI64[0],HEAP32[buf+60>>2]=tempI64[1];HEAP32[buf+64>>2]=0;tempI64=[Math.floor(stat.mtime.getTime()/1e3)>>>0,(tempDouble=Math.floor(stat.mtime.getTime()/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+72>>2]=tempI64[0],HEAP32[buf+76>>2]=tempI64[1];HEAP32[buf+80>>2]=0;tempI64=[Math.floor(stat.ctime.getTime()/1e3)>>>0,(tempDouble=Math.floor(stat.ctime.getTime()/1e3),+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+88>>2]=tempI64[0],HEAP32[buf+92>>2]=tempI64[1];HEAP32[buf+96>>2]=0;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+104>>2]=tempI64[0],HEAP32[buf+108>>2]=tempI64[1];return 0},doMsync:function(addr,stream,len,flags,offset){var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},getStreamFromFD:function(fd){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);return stream}};function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return-28}var newStream;newStream=FS.createStream(stream,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 5:{var arg=SYSCALLS.get();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 6:case 7:return 0;case 16:case 8:return-28;case 9:setErrNo(28);return-1;default:{return-28}}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_fstat64(fd,buf){try{var stream=SYSCALLS.getStreamFromFD(fd);return SYSCALLS.doStat(FS.stat,stream.path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_getcwd(buf,size){try{if(size===0)return-28;var cwd=FS.cwd();var cwdLengthInBytes=lengthBytesUTF8(cwd)+1;if(size<cwdLengthInBytes)return-68;stringToUTF8(cwd,buf,size);return cwdLengthInBytes}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_getdents64(fd,dirp,count){try{var stream=SYSCALLS.getStreamFromFD(fd);if(!stream.getdents){stream.getdents=FS.readdir(stream.path)}var struct_size=280;var pos=0;var off=FS.llseek(stream,0,1);var idx=Math.floor(off/struct_size);while(idx<stream.getdents.length&&pos+struct_size<=count){var id;var type;var name=stream.getdents[idx];if(name==="."){id=stream.node.id;type=4}else if(name===".."){var lookup=FS.lookupPath(stream.path,{parent:true});id=lookup.node.id;type=4}else{var child=FS.lookupNode(stream.node,name);id=child.id;type=FS.isChrdev(child.mode)?2:FS.isDir(child.mode)?4:FS.isLink(child.mode)?10:8}tempI64=[id>>>0,(tempDouble=id,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[dirp+pos>>2]=tempI64[0],HEAP32[dirp+pos+4>>2]=tempI64[1];tempI64=[(idx+1)*struct_size>>>0,(tempDouble=(idx+1)*struct_size,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[dirp+pos+8>>2]=tempI64[0],HEAP32[dirp+pos+12>>2]=tempI64[1];HEAP16[dirp+pos+16>>1]=280;HEAP8[dirp+pos+18>>0]=type;stringToUTF8(name,dirp+pos+19,256);pos+=struct_size;idx+=1}FS.llseek(stream,idx*struct_size,0);return pos}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:case 21505:{if(!stream.tty)return-59;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return-59;return 0}case 21519:{if(!stream.tty)return-59;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0}case 21520:{if(!stream.tty)return-59;return-28}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-59;return 0}case 21524:{if(!stream.tty)return-59;return 0}default:return-28}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_lstat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.lstat,path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_newfstatat(dirfd,path,buf,flags){try{path=SYSCALLS.getStr(path);var nofollow=flags&256;var allowEmpty=flags&4096;flags=flags&~4352;path=SYSCALLS.calculateAt(dirfd,path,allowEmpty);return SYSCALLS.doStat(nofollow?FS.lstat:FS.stat,path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?SYSCALLS.get():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_readlinkat(dirfd,path,buf,bufsize){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(bufsize<=0)return-28;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.stat,path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function __emscripten_date_now(){return Date.now()}function __emscripten_fs_load_embedded_files(ptr){do{var name_addr=HEAPU32[ptr>>2];ptr+=4;var len=HEAPU32[ptr>>2];ptr+=4;var content=HEAPU32[ptr>>2];ptr+=4;var name=UTF8ToString(name_addr);FS.createPath("/",PATH.dirname(name),true,true);FS.createDataFile(name,null,HEAP8.subarray(content,content+len),true,true,true)}while(HEAPU32[ptr>>2])}var nowIsMonotonic=true;function __emscripten_get_now_is_monotonic(){return nowIsMonotonic}function readI53FromI64(ptr){return HEAPU32[ptr>>2]+HEAP32[ptr+4>>2]*4294967296}function __gmtime_js(time,tmPtr){var date=new Date(readI53FromI64(time)*1e3);HEAP32[tmPtr>>2]=date.getUTCSeconds();HEAP32[tmPtr+4>>2]=date.getUTCMinutes();HEAP32[tmPtr+8>>2]=date.getUTCHours();HEAP32[tmPtr+12>>2]=date.getUTCDate();HEAP32[tmPtr+16>>2]=date.getUTCMonth();HEAP32[tmPtr+20>>2]=date.getUTCFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getUTCDay();var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday}function __localtime_js(time,tmPtr){var date=new Date(readI53FromI64(time)*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var start=new Date(date.getFullYear(),0,1);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst}function __munmap_js(addr,len,prot,flags,fd,offset){try{var stream=FS.getStream(fd);if(stream){if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}FS.munmap(stream)}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function _tzset_impl(timezone,daylight,tzname){var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAP32[timezone>>2]=stdTimezoneOffset*60;HEAP32[daylight>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){HEAPU32[tzname>>2]=winterNamePtr;HEAPU32[tzname+4>>2]=summerNamePtr}else{HEAPU32[tzname>>2]=summerNamePtr;HEAPU32[tzname+4>>2]=winterNamePtr}}function __tzset_js(timezone,daylight,tzname){if(__tzset_js.called)return;__tzset_js.called=true;_tzset_impl(timezone,daylight,tzname)}function _abort(){abort("")}var readAsmConstArgsArray=[];function readAsmConstArgs(sigPtr,buf){readAsmConstArgsArray.length=0;var ch;buf>>=2;while(ch=HEAPU8[sigPtr++]){buf+=ch!=105&buf;readAsmConstArgsArray.push(ch==105?HEAP32[buf]:HEAPF64[buf++>>1]);++buf}return readAsmConstArgsArray}function _emscripten_asm_const_int(code,sigPtr,argbuf){var args=readAsmConstArgs(sigPtr,argbuf);return ASM_CONSTS[code].apply(null,args)}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=()=>{var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else _emscripten_get_now=()=>performance.now();function reallyNegative(x){return x<0||x===0&&1/x===-Infinity}function convertI32PairToI53(lo,hi){return(lo>>>0)+hi*4294967296}function convertU32PairToI53(lo,hi){return(lo>>>0)+(hi>>>0)*4294967296}function reSign(value,bits){if(value<=0){return value}var half=bits<=32?Math.abs(1<<bits-1):Math.pow(2,bits-1);if(value>=half&&(bits<=32||value>half)){value=-2*half+value}return value}function unSign(value,bits){if(value>=0){return value}return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}function strLen(ptr){var end=ptr;while(HEAPU8[end])++end;return end-ptr}function formatString(format,varargs){var textIndex=format;var argIndex=varargs;function prepVararg(ptr,type){if(type==="double"||type==="i64"){if(ptr&7){ptr+=4}}else{}return ptr}function getNextArg(type){var ret;argIndex=prepVararg(argIndex,type);if(type==="double"){ret=HEAPF64[argIndex>>3];argIndex+=8}else if(type=="i64"){ret=[HEAP32[argIndex>>2],HEAP32[argIndex+4>>2]];argIndex+=8}else{type="i32";ret=HEAP32[argIndex>>2];argIndex+=4}return ret}var ret=[];var curr,next,currArg;while(1){var startTextIndex=textIndex;curr=HEAP8[textIndex>>0];if(curr===0)break;next=HEAP8[textIndex+1>>0];if(curr==37){var flagAlwaysSigned=false;var flagLeftAlign=false;var flagAlternative=false;var flagZeroPad=false;var flagPadSign=false;flagsLoop:while(1){switch(next){case 43:flagAlwaysSigned=true;break;case 45:flagLeftAlign=true;break;case 35:flagAlternative=true;break;case 48:if(flagZeroPad){break flagsLoop}else{flagZeroPad=true;break}case 32:flagPadSign=true;break;default:break flagsLoop}textIndex++;next=HEAP8[textIndex+1>>0]}var width=0;if(next==42){width=getNextArg("i32");textIndex++;next=HEAP8[textIndex+1>>0]}else{while(next>=48&&next<=57){width=width*10+(next-48);textIndex++;next=HEAP8[textIndex+1>>0]}}var precisionSet=false,precision=-1;if(next==46){precision=0;precisionSet=true;textIndex++;next=HEAP8[textIndex+1>>0];if(next==42){precision=getNextArg("i32");textIndex++}else{while(1){var precisionChr=HEAP8[textIndex+1>>0];if(precisionChr<48||precisionChr>57)break;precision=precision*10+(precisionChr-48);textIndex++}}next=HEAP8[textIndex+1>>0]}if(precision<0){precision=6;precisionSet=false}var argSize;switch(String.fromCharCode(next)){case"h":var nextNext=HEAP8[textIndex+2>>0];if(nextNext==104){textIndex++;argSize=1}else{argSize=2}break;case"l":var nextNext=HEAP8[textIndex+2>>0];if(nextNext==108){textIndex++;argSize=8}else{argSize=4}break;case"L":case"q":case"j":argSize=8;break;case"z":case"t":case"I":argSize=4;break;default:argSize=null}if(argSize)textIndex++;next=HEAP8[textIndex+1>>0];switch(String.fromCharCode(next)){case"d":case"i":case"u":case"o":case"x":case"X":case"p":{var signed=next==100||next==105;argSize=argSize||4;currArg=getNextArg("i"+argSize*8);var argText;if(argSize==8){currArg=next==117?convertU32PairToI53(currArg[0],currArg[1]):convertI32PairToI53(currArg[0],currArg[1])}if(argSize<=4){var limit=Math.pow(256,argSize)-1;currArg=(signed?reSign:unSign)(currArg&limit,argSize*8)}var currAbsArg=Math.abs(currArg);var prefix="";if(next==100||next==105){argText=reSign(currArg,8*argSize).toString(10)}else if(next==117){argText=unSign(currArg,8*argSize).toString(10);currArg=Math.abs(currArg)}else if(next==111){argText=(flagAlternative?"0":"")+currAbsArg.toString(8)}else if(next==120||next==88){prefix=flagAlternative&&currArg!=0?"0x":"";if(currArg<0){currArg=-currArg;argText=(currAbsArg-1).toString(16);var buffer=[];for(var i=0;i<argText.length;i++){buffer.push((15-parseInt(argText[i],16)).toString(16))}argText=buffer.join("");while(argText.length<argSize*2)argText="f"+argText}else{argText=currAbsArg.toString(16)}if(next==88){prefix=prefix.toUpperCase();argText=argText.toUpperCase()}}else if(next==112){if(currAbsArg===0){argText="(nil)"}else{prefix="0x";argText=currAbsArg.toString(16)}}if(precisionSet){while(argText.length<precision){argText="0"+argText}}if(currArg>=0){if(flagAlwaysSigned){prefix="+"+prefix}else if(flagPadSign){prefix=" "+prefix}}if(argText.charAt(0)=="-"){prefix="-"+prefix;argText=argText.substr(1)}while(prefix.length+argText.length<width){if(flagLeftAlign){argText+=" "}else{if(flagZeroPad){argText="0"+argText}else{prefix=" "+prefix}}}argText=prefix+argText;argText.split("").forEach(function(chr){ret.push(chr.charCodeAt(0))});break}case"f":case"F":case"e":case"E":case"g":case"G":{currArg=getNextArg("double");var argText;if(isNaN(currArg)){argText="nan";flagZeroPad=false}else if(!isFinite(currArg)){argText=(currArg<0?"-":"")+"inf";flagZeroPad=false}else{var isGeneral=false;var effectivePrecision=Math.min(precision,20);if(next==103||next==71){isGeneral=true;precision=precision||1;var exponent=parseInt(currArg.toExponential(effectivePrecision).split("e")[1],10);if(precision>exponent&&exponent>=-4){next=(next==103?"f":"F").charCodeAt(0);precision-=exponent+1}else{next=(next==103?"e":"E").charCodeAt(0);precision--}effectivePrecision=Math.min(precision,20)}if(next==101||next==69){argText=currArg.toExponential(effectivePrecision);if(/[eE][-+]\d$/.test(argText)){argText=argText.slice(0,-1)+"0"+argText.slice(-1)}}else if(next==102||next==70){argText=currArg.toFixed(effectivePrecision);if(currArg===0&&reallyNegative(currArg)){argText="-"+argText}}var parts=argText.split("e");if(isGeneral&&!flagAlternative){while(parts[0].length>1&&parts[0].includes(".")&&(parts[0].slice(-1)=="0"||parts[0].slice(-1)==".")){parts[0]=parts[0].slice(0,-1)}}else{if(flagAlternative&&argText.indexOf(".")==-1)parts[0]+=".";while(precision>effectivePrecision++)parts[0]+="0"}argText=parts[0]+(parts.length>1?"e"+parts[1]:"");if(next==69)argText=argText.toUpperCase();if(currArg>=0){if(flagAlwaysSigned){argText="+"+argText}else if(flagPadSign){argText=" "+argText}}}while(argText.length<width){if(flagLeftAlign){argText+=" "}else{if(flagZeroPad&&(argText[0]=="-"||argText[0]=="+")){argText=argText[0]+"0"+argText.slice(1)}else{argText=(flagZeroPad?"0":" ")+argText}}}if(next<97)argText=argText.toUpperCase();argText.split("").forEach(function(chr){ret.push(chr.charCodeAt(0))});break}case"s":{var arg=getNextArg("i8*");var argLength=arg?strLen(arg):"(null)".length;if(precisionSet)argLength=Math.min(argLength,precision);if(!flagLeftAlign){while(argLength<width--){ret.push(32)}}if(arg){for(var i=0;i<argLength;i++){ret.push(HEAPU8[arg++>>0])}}else{ret=ret.concat(intArrayFromString("(null)".substr(0,argLength),true))}if(flagLeftAlign){while(argLength<width--){ret.push(32)}}break}case"c":{if(flagLeftAlign)ret.push(getNextArg("i8"));while(--width>0){ret.push(32)}if(!flagLeftAlign)ret.push(getNextArg("i8"));break}case"n":{var ptr=getNextArg("i32*");HEAP32[ptr>>2]=ret.length;break}case"%":{ret.push(curr);break}default:{for(var i=startTextIndex;i<textIndex+2;i++){ret.push(HEAP8[i>>0])}}}textIndex+=2}else{ret.push(curr);textIndex+=1}}return ret}function traverseStack(args){if(!args||!args.callee||!args.callee.name){return[null,"",""]}var funstr=args.callee.toString();var funcname=args.callee.name;var str="(";var first=true;for(var i in args){var a=args[i];if(!first){str+=", "}first=false;if(typeof a=="number"||typeof a=="string"){str+=a}else{str+="("+typeof a+")"}}str+=")";var caller=args.callee.caller;args=caller?caller.arguments:[];if(first)str="";return[args,funcname,str]}function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;if(ENVIRONMENT_IS_NODE)text="warning: "+text;err(text)}}function _emscripten_get_callstack_js(flags){var callstack=jsStackTrace();var iThisFunc=callstack.lastIndexOf("_emscripten_log");var iThisFunc2=callstack.lastIndexOf("_emscripten_get_callstack");var iNextLine=callstack.indexOf("\n",Math.max(iThisFunc,iThisFunc2))+1;callstack=callstack.slice(iNextLine);if(flags&32){warnOnce("EM_LOG_DEMANGLE is deprecated; ignoring")}if(flags&8&&typeof emscripten_source_map=="undefined"){warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');flags^=8;flags|=16}var stack_args=null;if(flags&128){stack_args=traverseStack(arguments);while(stack_args[1].includes("_emscripten_"))stack_args=traverseStack(stack_args[0])}var lines=callstack.split("\n");callstack="";var newFirefoxRe=new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)");var firefoxRe=new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?");var chromeRe=new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");for(var l in lines){var line=lines[l];var symbolName="";var file="";var lineno=0;var column=0;var parts=chromeRe.exec(line);if(parts&&parts.length==5){symbolName=parts[1];file=parts[2];lineno=parts[3];column=parts[4]}else{parts=newFirefoxRe.exec(line);if(!parts)parts=firefoxRe.exec(line);if(parts&&parts.length>=4){symbolName=parts[1];file=parts[2];lineno=parts[3];column=parts[4]|0}else{callstack+=line+"\n";continue}}var haveSourceMap=false;if(flags&8){var orig=emscripten_source_map.originalPositionFor({line:lineno,column:column});haveSourceMap=orig&&orig.source;if(haveSourceMap){if(flags&64){orig.source=orig.source.substring(orig.source.replace(/\\/g,"/").lastIndexOf("/")+1)}callstack+="    at "+symbolName+" ("+orig.source+":"+orig.line+":"+orig.column+")\n"}}if(flags&16||!haveSourceMap){if(flags&64){file=file.substring(file.replace(/\\/g,"/").lastIndexOf("/")+1)}callstack+=(haveSourceMap?"     = "+symbolName:"    at "+symbolName)+" ("+file+":"+lineno+":"+column+")\n"}if(flags&128&&stack_args[0]){if(stack_args[1]==symbolName&&stack_args[2].length>0){callstack=callstack.replace(/\s+$/,"");callstack+=" with values: "+stack_args[1]+stack_args[2]+"\n"}stack_args=traverseStack(stack_args[0])}}callstack=callstack.replace(/\s+$/,"");return callstack}function _emscripten_log_js(flags,str){if(flags&24){str=str.replace(/\s+$/,"");str+=(str.length>0?"\n":"")+_emscripten_get_callstack_js(flags)}if(flags&1){if(flags&4){console.error(str)}else if(flags&2){console.warn(str)}else if(flags&512){console.info(str)}else if(flags&256){console.debug(str)}else{console.log(str)}}else if(flags&6){err(str)}else{out(str)}}function _emscripten_log(flags,format,varargs){var result=formatString(format,varargs);var str=UTF8ArrayToString(result,0);_emscripten_log_js(flags,str)}function getHeapMax(){return 2147483648}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+"="+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAPU32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAPU32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAPU32[penviron_buf_size>>2]=bufSize;return 0}function _proc_exit(code){EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))}function exitJS(status,implicit){EXITSTATUS=status;_proc_exit(status)}var _exit=exitJS;function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function doReadv(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break}return ret}function convertI32PairToI53Checked(lo,hi){return hi+2097152>>>0<4194305-!!lo?(lo>>>0)+hi*4294967296:NaN}function _fd_pread(fd,iov,iovcnt,offset_low,offset_high,pnum){try{var offset=convertI32PairToI53Checked(offset_low,offset_high);if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt,offset);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doReadv(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{var offset=convertI32PairToI53Checked(offset_low,offset_high);if(isNaN(offset))return 61;var stream=SYSCALLS.getStreamFromFD(fd);FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function doWritev(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAPU32[iov>>2];var len=HEAPU32[iov+4>>2];iov+=8;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr}return ret}function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=doWritev(stream,iov,iovcnt);HEAPU32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}var tempRet0=0;function getTempRet0(){return tempRet0}var _getTempRet0=getTempRet0;function _getentropy(buffer,size){if(!_getentropy.randomDevice){_getentropy.randomDevice=getRandomDevice()}for(var i=0;i<size;i++){HEAP8[buffer+i>>0]=_getentropy.randomDevice()}return 0}function _llvm_eh_typeid_for(type){return type}function setTempRet0(val){tempRet0=val}var _setTempRet0=setTempRet0;function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule])}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value=="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}return thisDate.getFullYear()}return thisDate.getFullYear()-1}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return"\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return"AM"}return"PM"},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return"\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},"%V":function(date){var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&__isLeapYear(date.tm_year%400-1)){val++}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!__isLeapYear(date.tm_year)))val=1}return leadingNulls(val,2)},"%w":function(date){return date.tm_wday},"%W":function(date){var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},"%y":function(date){return(date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return"%"}};pattern=pattern.replace(/%%/g,"\0\0");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date))}}pattern=pattern.replace(/\0\0/g,"%");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}function _strftime_l(s,maxsize,format,tm){return _strftime(s,maxsize,format,tm)}function uleb128Encode(n,target){if(n<128){target.push(n)}else{target.push(n%128|128,n>>7)}}function sigToWasmTypes(sig){var typeNames={"i":"i32","j":"i64","f":"f32","d":"f64","p":"i32"};var type={parameters:[],results:sig[0]=="v"?[]:[typeNames[sig[0]]]};for(var i=1;i<sig.length;++i){type.parameters.push(typeNames[sig[i]])}return type}function convertJsFunctionToWasm(func,sig){if(typeof WebAssembly.Function=="function"){return new WebAssembly.Function(sigToWasmTypes(sig),func)}var typeSectionBody=[1,96];var sigRet=sig.slice(0,1);var sigParam=sig.slice(1);var typeCodes={"i":127,"p":127,"j":126,"f":125,"d":124};uleb128Encode(sigParam.length,typeSectionBody);for(var i=0;i<sigParam.length;++i){typeSectionBody.push(typeCodes[sigParam[i]])}if(sigRet=="v"){typeSectionBody.push(0)}else{typeSectionBody.push(1,typeCodes[sigRet])}var bytes=[0,97,115,109,1,0,0,0,1];uleb128Encode(typeSectionBody.length,bytes);bytes.push.apply(bytes,typeSectionBody);bytes.push(2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0);var module=new WebAssembly.Module(new Uint8Array(bytes));var instance=new WebAssembly.Instance(module,{"e":{"f":func}});var wrappedFunc=instance.exports["f"];return wrappedFunc}function updateTableMap(offset,count){if(functionsInTableMap){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i)}}}}var functionsInTableMap=undefined;var freeTableIndexes=[];function getEmptyTableSlot(){if(freeTableIndexes.length){return freeTableIndexes.pop()}try{wasmTable.grow(1)}catch(err){if(!(err instanceof RangeError)){throw err}throw"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."}return wasmTable.length-1}function setWasmTableEntry(idx,func){wasmTable.set(idx,func)}function addFunction(func,sig){if(!functionsInTableMap){functionsInTableMap=new WeakMap;updateTableMap(0,wasmTable.length)}if(functionsInTableMap.has(func)){return functionsInTableMap.get(func)}var ret=getEmptyTableSlot();try{setWasmTableEntry(ret,func)}catch(err){if(!(err instanceof TypeError)){throw err}var wrapped=convertJsFunctionToWasm(func,sig);setWasmTableEntry(ret,wrapped)}functionsInTableMap.set(func,ret);return ret}function removeFunction(index){functionsInTableMap.delete(getWasmTableEntry(index));freeTableIndexes.push(index)}function getCFunc(ident){var func=Module["_"+ident];return func}function ccall(ident,returnType,argTypes,args,opts){var toC={"string":str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},"array":arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string"){return UTF8ToString(ret)}if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret}function cwrap(ident,returnType,argTypes,opts){argTypes=argTypes||[];var numericArgs=argTypes.every(type=>type==="number"||type==="boolean");var numericRet=returnType!=="string";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return function(){return ccall(ident,returnType,argTypes,arguments,opts)}}var FSNode=function(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev};var readMode=292|73;var writeMode=146;Object.defineProperties(FSNode.prototype,{read:{get:function(){return(this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode}},write:{get:function(){return(this.mode&writeMode)===writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}});FS.FSNode=FSNode;FS.staticInit();Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_unlink"]=FS.unlink;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createDevice"]=FS.createDevice;if(ENVIRONMENT_IS_NODE){requireNodeFS();NODEFS.staticInit()}ERRNO_CODES={"EPERM":63,"ENOENT":44,"ESRCH":71,"EINTR":27,"EIO":29,"ENXIO":60,"E2BIG":1,"ENOEXEC":45,"EBADF":8,"ECHILD":12,"EAGAIN":6,"EWOULDBLOCK":6,"ENOMEM":48,"EACCES":2,"EFAULT":21,"ENOTBLK":105,"EBUSY":10,"EEXIST":20,"EXDEV":75,"ENODEV":43,"ENOTDIR":54,"EISDIR":31,"EINVAL":28,"ENFILE":41,"EMFILE":33,"ENOTTY":59,"ETXTBSY":74,"EFBIG":22,"ENOSPC":51,"ESPIPE":70,"EROFS":69,"EMLINK":34,"EPIPE":64,"EDOM":18,"ERANGE":68,"ENOMSG":49,"EIDRM":24,"ECHRNG":106,"EL2NSYNC":156,"EL3HLT":107,"EL3RST":108,"ELNRNG":109,"EUNATCH":110,"ENOCSI":111,"EL2HLT":112,"EDEADLK":16,"ENOLCK":46,"EBADE":113,"EBADR":114,"EXFULL":115,"ENOANO":104,"EBADRQC":103,"EBADSLT":102,"EDEADLOCK":16,"EBFONT":101,"ENOSTR":100,"ENODATA":116,"ETIME":117,"ENOSR":118,"ENONET":119,"ENOPKG":120,"EREMOTE":121,"ENOLINK":47,"EADV":122,"ESRMNT":123,"ECOMM":124,"EPROTO":65,"EMULTIHOP":36,"EDOTDOT":125,"EBADMSG":9,"ENOTUNIQ":126,"EBADFD":127,"EREMCHG":128,"ELIBACC":129,"ELIBBAD":130,"ELIBSCN":131,"ELIBMAX":132,"ELIBEXEC":133,"ENOSYS":52,"ENOTEMPTY":55,"ENAMETOOLONG":37,"ELOOP":32,"EOPNOTSUPP":138,"EPFNOSUPPORT":139,"ECONNRESET":15,"ENOBUFS":42,"EAFNOSUPPORT":5,"EPROTOTYPE":67,"ENOTSOCK":57,"ENOPROTOOPT":50,"ESHUTDOWN":140,"ECONNREFUSED":14,"EADDRINUSE":3,"ECONNABORTED":13,"ENETUNREACH":40,"ENETDOWN":38,"ETIMEDOUT":73,"EHOSTDOWN":142,"EHOSTUNREACH":23,"EINPROGRESS":26,"EALREADY":7,"EDESTADDRREQ":17,"EMSGSIZE":35,"EPROTONOSUPPORT":66,"ESOCKTNOSUPPORT":137,"EADDRNOTAVAIL":4,"ENETRESET":39,"EISCONN":30,"ENOTCONN":53,"ETOOMANYREFS":141,"EUSERS":136,"EDQUOT":19,"ESTALE":72,"ENOTSUP":138,"ENOMEDIUM":148,"EILSEQ":25,"EOVERFLOW":61,"ECANCELED":11,"ENOTRECOVERABLE":56,"EOWNERDEAD":62,"ESTRPIPE":135};var asmLibraryArg={"j":___cxa_allocate_exception,"s":___cxa_begin_catch,"t":___cxa_end_catch,"b":___cxa_find_matching_catch_2,"i":___cxa_find_matching_catch_3,"F":___cxa_find_matching_catch_4,"B":___cxa_find_matching_catch_5,"M":___cxa_find_matching_catch_6,"J":___cxa_find_matching_catch_7,"m":___cxa_free_exception,"O":___cxa_rethrow,"n":___cxa_throw,"sa":___cxa_uncaught_exceptions,"f":___resumeException,"V":___syscall_fcntl64,"Da":___syscall_fstat64,"va":___syscall_getcwd,"wa":___syscall_getdents64,"T":___syscall_ioctl,"Aa":___syscall_lstat64,"Ba":___syscall_newfstatat,"U":___syscall_openat,"ua":___syscall_readlinkat,"Ca":___syscall_stat64,"K":__emscripten_date_now,"Ja":__emscripten_fs_load_embedded_files,"Fa":__emscripten_get_now_is_monotonic,"Ga":__gmtime_js,"Ha":__localtime_js,"xa":__munmap_js,"Ia":__tzset_js,"z":_abort,"L":_emscripten_asm_const_int,"Ea":_emscripten_get_now,"W":_emscripten_log,"ta":_emscripten_resize_heap,"ya":_environ_get,"za":_environ_sizes_get,"Ka":_exit,"I":_fd_close,"Z":_fd_pread,"R":_fd_read,"_":_fd_seek,"S":_fd_write,"a":_getTempRet0,"pa":_getentropy,"P":invoke_diii,"Q":invoke_fiii,"w":invoke_i,"h":invoke_ii,"c":invoke_iii,"k":invoke_iiii,"l":invoke_iiiii,"ra":invoke_iiiiid,"p":invoke_iiiiii,"r":invoke_iiiiiii,"u":invoke_iiiiiiii,"N":invoke_iiiiiiiii,"G":invoke_iiiiiiiiii,"C":invoke_iiiiiiiiiiii,"Y":invoke_iiiiij,"aa":invoke_iiiij,"ma":invoke_iij,"da":invoke_iiji,"ia":invoke_j,"oa":invoke_ji,"ca":invoke_jii,"X":invoke_jiiii,"ea":invoke_jijj,"q":invoke_v,"d":invoke_vi,"g":invoke_vii,"e":invoke_viii,"o":invoke_viiii,"v":invoke_viiiii,"y":invoke_viiiiii,"A":invoke_viiiiiii,"D":invoke_viiiiiiiiii,"H":invoke_viiiiiiiiiiiiiii,"ha":invoke_viiij,"fa":invoke_viiijj,"$":invoke_viiijjj,"na":invoke_viij,"la":invoke_viijii,"ja":invoke_viijj,"ka":invoke_viijjii,"ga":invoke_vij,"ba":invoke_viji,"x":_llvm_eh_typeid_for,"E":_setTempRet0,"qa":_strftime_l};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["Ma"]).apply(null,arguments)};var _version=Module["_version"]=function(){return(_version=Module["_version"]=Module["asm"]["Na"]).apply(null,arguments)};var _func_compile=Module["_func_compile"]=function(){return(_func_compile=Module["_func_compile"]=Module["asm"]["Oa"]).apply(null,arguments)};var _free=Module["_free"]=function(){return(_free=Module["_free"]=Module["asm"]["Qa"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return(_malloc=Module["_malloc"]=Module["asm"]["Ra"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["Sa"]).apply(null,arguments)};var _emscripten_builtin_memalign=Module["_emscripten_builtin_memalign"]=function(){return(_emscripten_builtin_memalign=Module["_emscripten_builtin_memalign"]=Module["asm"]["Ta"]).apply(null,arguments)};var _setThrew=Module["_setThrew"]=function(){return(_setThrew=Module["_setThrew"]=Module["asm"]["Ua"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return(stackSave=Module["stackSave"]=Module["asm"]["Va"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return(stackRestore=Module["stackRestore"]=Module["asm"]["Wa"]).apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){return(stackAlloc=Module["stackAlloc"]=Module["asm"]["Xa"]).apply(null,arguments)};var ___cxa_can_catch=Module["___cxa_can_catch"]=function(){return(___cxa_can_catch=Module["___cxa_can_catch"]=Module["asm"]["Ya"]).apply(null,arguments)};var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=function(){return(___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=Module["asm"]["Za"]).apply(null,arguments)};var dynCall_ji=Module["dynCall_ji"]=function(){return(dynCall_ji=Module["dynCall_ji"]=Module["asm"]["_a"]).apply(null,arguments)};var dynCall_viij=Module["dynCall_viij"]=function(){return(dynCall_viij=Module["dynCall_viij"]=Module["asm"]["$a"]).apply(null,arguments)};var dynCall_iij=Module["dynCall_iij"]=function(){return(dynCall_iij=Module["dynCall_iij"]=Module["asm"]["ab"]).apply(null,arguments)};var dynCall_viijii=Module["dynCall_viijii"]=function(){return(dynCall_viijii=Module["dynCall_viijii"]=Module["asm"]["bb"]).apply(null,arguments)};var dynCall_viijjii=Module["dynCall_viijjii"]=function(){return(dynCall_viijjii=Module["dynCall_viijjii"]=Module["asm"]["cb"]).apply(null,arguments)};var dynCall_viijj=Module["dynCall_viijj"]=function(){return(dynCall_viijj=Module["dynCall_viijj"]=Module["asm"]["db"]).apply(null,arguments)};var dynCall_viiijj=Module["dynCall_viiijj"]=function(){return(dynCall_viiijj=Module["dynCall_viiijj"]=Module["asm"]["eb"]).apply(null,arguments)};var dynCall_j=Module["dynCall_j"]=function(){return(dynCall_j=Module["dynCall_j"]=Module["asm"]["fb"]).apply(null,arguments)};var dynCall_viiij=Module["dynCall_viiij"]=function(){return(dynCall_viiij=Module["dynCall_viiij"]=Module["asm"]["gb"]).apply(null,arguments)};var dynCall_vij=Module["dynCall_vij"]=function(){return(dynCall_vij=Module["dynCall_vij"]=Module["asm"]["hb"]).apply(null,arguments)};var dynCall_jijj=Module["dynCall_jijj"]=function(){return(dynCall_jijj=Module["dynCall_jijj"]=Module["asm"]["ib"]).apply(null,arguments)};var dynCall_iiji=Module["dynCall_iiji"]=function(){return(dynCall_iiji=Module["dynCall_iiji"]=Module["asm"]["jb"]).apply(null,arguments)};var dynCall_jii=Module["dynCall_jii"]=function(){return(dynCall_jii=Module["dynCall_jii"]=Module["asm"]["kb"]).apply(null,arguments)};var dynCall_viji=Module["dynCall_viji"]=function(){return(dynCall_viji=Module["dynCall_viji"]=Module["asm"]["lb"]).apply(null,arguments)};var dynCall_iiiij=Module["dynCall_iiiij"]=function(){return(dynCall_iiiij=Module["dynCall_iiiij"]=Module["asm"]["mb"]).apply(null,arguments)};var dynCall_viiijjj=Module["dynCall_viiijjj"]=function(){return(dynCall_viiijjj=Module["dynCall_viiijjj"]=Module["asm"]["nb"]).apply(null,arguments)};var dynCall_iiiiij=Module["dynCall_iiiiij"]=function(){return(dynCall_iiiiij=Module["dynCall_iiiiij"]=Module["asm"]["ob"]).apply(null,arguments)};var dynCall_jiiii=Module["dynCall_jiiii"]=function(){return(dynCall_jiiii=Module["dynCall_jiiii"]=Module["asm"]["pb"]).apply(null,arguments)};var ___emscripten_embedded_file_data=Module["___emscripten_embedded_file_data"]=1655368;function invoke_vii(index,a1,a2){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viii(index,a1,a2,a3){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vi(index,a1){var sp=stackSave();try{getWasmTableEntry(index)(a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ii(index,a1){var sp=stackSave();try{return getWasmTableEntry(index)(a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiii(index,a1,a2,a3,a4){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iii(index,a1,a2){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_v(index){var sp=stackSave();try{getWasmTableEntry(index)()}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_i(index){var sp=stackSave();try{return getWasmTableEntry(index)()}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiid(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fiii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_diii(index,a1,a2,a3){var sp=stackSave();try{return getWasmTableEntry(index)(a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15){var sp=stackSave();try{getWasmTableEntry(index)(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ji(index,a1){var sp=stackSave();try{return dynCall_ji(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viij(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viij(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iij(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iij(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viijii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viijii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viijjii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{dynCall_viijjii(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viijj(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viijj(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_j(index){var sp=stackSave();try{return dynCall_j(index)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiij(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viiij(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vij(index,a1,a2,a3){var sp=stackSave();try{dynCall_vij(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiijj(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viiijj(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jijj(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_jijj(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiji(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_iiji(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jii(index,a1,a2){var sp=stackSave();try{return dynCall_jii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viji(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viji(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiij(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iiiij(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiijjj(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{dynCall_viiijjj(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiij(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiij(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_jiiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}Module["UTF8ToString"]=UTF8ToString;Module["stringToUTF8"]=stringToUTF8;Module["lengthBytesUTF8"]=lengthBytesUTF8;Module["addRunDependency"]=addRunDependency;Module["removeRunDependency"]=removeRunDependency;Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createDevice"]=FS.createDevice;Module["FS_unlink"]=FS.unlink;Module["ccall"]=ccall;Module["cwrap"]=cwrap;Module["addFunction"]=addFunction;Module["removeFunction"]=removeFunction;Module["setValue"]=setValue;Module["FS"]=FS;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}run();


  return CompilerModule.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = CompilerModule;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return CompilerModule; });
else if (typeof exports === 'object')
  exports["CompilerModule"] = CompilerModule;


## small.fc (https://github.com/tact-lang/tact/blob/main/tact-main/src/func/__testdata__/small.fc)
int main(int a, int b) impure {
    return a + b;
}

## Writer.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/Writer.ts)
import { CompilerContext } from "../context";
import { escapeUnicodeControlCodes, trimIndent } from "../utils/text";
import { topologicalSort } from "../utils/utils";
import { Writer } from "../utils/Writer";

type Flag = "inline" | "impure" | "inline_ref";

type Body =
    | {
          kind: "generic";
          code: string;
      }
    | {
          kind: "asm";
          shuffle: string;
          code: string;
      }
    | {
          kind: "skip";
      };

export type WrittenFunction = {
    name: string;
    code: Body;
    signature: string;
    flags: Set<Flag>;
    depends: Set<string>;
    comment: string | null;
    context: string | null;
};

export class WriterContext {
    readonly ctx: CompilerContext;
    #name: string;
    #functions: Map<string, WrittenFunction> = new Map();
    #functionsRendering: Set<string> = new Set();
    #pendingWriter: Writer | null = null;
    #pendingCode: Body | null = null;
    #pendingDepends: Set<string> | null = null;
    #pendingName: string | null = null;
    #pendingSignature: string | null = null;
    #pendingFlags: Set<Flag> | null = null;
    #pendingComment: string | null = null;
    #pendingContext: string | null = null;
    #nextId = 0;
    // #headers: string[] = [];
    #rendered: Set<string> = new Set();

    constructor(ctx: CompilerContext, name: string) {
        this.ctx = ctx;
        this.#name = name;
    }

    get name() {
        return this.#name;
    }

    clone() {
        const res = new WriterContext(this.ctx, this.#name);
        res.#functions = new Map(this.#functions);
        res.#nextId = this.#nextId;
        // res.#headers = [...this.#headers];
        res.#rendered = new Set(this.#rendered);
        return res;
    }

    //
    // Rendering
    //

    extract(debug: boolean = false) {
        // Check dependencies
        const missing: Map<string, string[]> = new Map();
        for (const f of this.#functions.values()) {
            for (const d of f.depends) {
                if (!this.#functions.has(d)) {
                    if (!missing.has(d)) {
                        missing.set(d, [f.name]);
                    } else {
                        missing.set(d, [...missing.get(d)!, f.name]);
                    }
                }
            }
        }
        if (missing.size > 0) {
            throw new Error(
                `Functions ${Array.from(missing.keys())
                    .map((v) => `"${v}"`)
                    .join(", ")} wasn't rendered`,
            );
        }

        // All functions
        let all = Array.from(this.#functions.values());

        // Remove unused
        if (!debug) {
            const used: Set<string> = new Set();
            const visit = (name: string) => {
                used.add(name);
                const f = this.#functions.get(name)!;
                for (const d of f.depends) {
                    visit(d);
                }
            };
            visit("$main");
            all = all.filter((v) => used.has(v.name));
        }

        // Sort functions
        const sorted = topologicalSort(all, (f) =>
            Array.from(f.depends).map((v) => this.#functions.get(v)!),
        );

        return sorted;
    }

    //
    // Declaration
    //

    skip(name: string) {
        this.fun(name, () => {
            this.signature("<unknown>");
            this.context("stdlib");
            this.#pendingCode = { kind: "skip" };
        });
    }

    fun(name: string, handler: () => void) {
        //
        // Duplicates check
        //

        if (this.#functions.has(name)) {
            throw new Error(`Function "${name}" already defined`); // Should not happen
        }
        if (this.#functionsRendering.has(name)) {
            throw new Error(`Function "${name}" already rendering`); // Should not happen
        }

        //
        // Nesting check
        //

        if (this.#pendingName) {
            const w = this.#pendingWriter;
            const d = this.#pendingDepends;
            const n = this.#pendingName;
            const s = this.#pendingSignature;
            const f = this.#pendingFlags;
            const c = this.#pendingCode;
            const cc = this.#pendingComment;
            const cs = this.#pendingContext;
            this.#pendingDepends = null;
            this.#pendingWriter = null;
            this.#pendingName = null;
            this.#pendingSignature = null;
            this.#pendingFlags = null;
            this.#pendingCode = null;
            this.#pendingComment = null;
            this.#pendingContext = null;
            this.fun(name, handler);
            this.#pendingSignature = s;
            this.#pendingDepends = d;
            this.#pendingWriter = w;
            this.#pendingName = n;
            this.#pendingFlags = f;
            this.#pendingCode = c;
            this.#pendingComment = cc;
            this.#pendingContext = cs;
            return;
        }

        // Write function
        this.#functionsRendering.add(name);
        this.#pendingWriter = null;
        this.#pendingDepends = new Set();
        this.#pendingName = name;
        this.#pendingSignature = null;
        this.#pendingFlags = new Set();
        this.#pendingCode = null;
        this.#pendingComment = null;
        this.#pendingContext = null;
        handler();
        const depends = this.#pendingDepends;
        const signature = this.#pendingSignature!;
        const flags = this.#pendingFlags;
        const code = this.#pendingCode;
        const comment = this.#pendingComment;
        const context = this.#pendingContext;
        if (!signature && name !== "$main") {
            throw new Error(`Function "${name}" signature not set`);
        }
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (!code) {
            throw new Error(`Function "${name}" body not set`);
        }
        this.#pendingDepends = null;
        this.#pendingWriter = null;
        this.#pendingName = null;
        this.#pendingSignature = null;
        this.#pendingFlags = null;
        this.#functionsRendering.delete(name);
        this.#functions.set(name, {
            name,
            code,
            depends,
            signature,
            flags,
            comment,
            context,
        });
    }

    asm(shuffle: string, code: string) {
        if (this.#pendingName) {
            this.#pendingCode = {
                kind: "asm",
                shuffle,
                code,
            };
        } else {
            throw new Error(`ASM can be set only inside function`);
        }
    }

    body(handler: () => void) {
        if (this.#pendingWriter) {
            throw new Error(`Body can be set only once`);
        }
        this.#pendingWriter = new Writer();
        handler();
        this.#pendingCode = {
            kind: "generic",
            code: this.#pendingWriter!.end(),
        };
    }

    main(handler: () => void) {
        this.fun("$main", () => {
            this.body(() => {
                handler();
            });
        });
    }

    signature(sig: string) {
        if (this.#pendingName) {
            this.#pendingSignature = sig;
        } else {
            throw new Error(`Signature can be set only inside function`);
        }
    }

    flag(flag: Flag) {
        if (this.#pendingName) {
            this.#pendingFlags!.add(flag);
        } else {
            throw new Error(`Flag can be set only inside function`);
        }
    }

    used(name: string) {
        if (this.#pendingName !== name) {
            this.#pendingDepends!.add(name);
        }
        return name;
    }

    comment(src: string) {
        if (this.#pendingName) {
            this.#pendingComment = escapeUnicodeControlCodes(trimIndent(src));
        } else {
            throw new Error(`Comment can be set only inside function`);
        }
    }

    context(src: string) {
        if (this.#pendingName) {
            this.#pendingContext = src;
        } else {
            throw new Error(`Context can be set only inside function`);
        }
    }

    currentContext() {
        return this.#pendingName;
    }

    //
    // Writers
    //

    inIndent = (handler: () => void) => {
        this.#pendingWriter!.inIndent(handler);
    };

    append(src: string = "") {
        this.#pendingWriter!.append(src);
    }

    write(src: string = "") {
        this.#pendingWriter!.write(src);
    }

    //
    // Headers
    //

    // header(src: string) {
    //     this.#headers.push(src);
    // }

    //
    // Utils
    //

    isRendered(key: string) {
        return this.#rendered.has(key);
    }

    markRendered(key: string) {
        if (this.#rendered.has(key)) {
            throw new Error(`Key "${key}" already rendered`);
        }
        this.#rendered.add(key);
    }
}


## createABI.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/createABI.ts)
import { ABIGetter, ABIReceiver, ABIType, ContractABI } from "@ton/core";
import { contractErrors } from "../abi/errors";
import { CompilerContext } from "../context";
import { idText } from "../grammar/ast";
import { getSupportedInterfaces } from "../types/getSupportedInterfaces";
import { createABITypeRefFromTypeRef } from "../types/resolveABITypeRef";
import { getAllTypes } from "../types/resolveDescriptors";
import { getAllErrors } from "../types/resolveErrors";

export function createABI(ctx: CompilerContext, name: string): ContractABI {
    const allTypes = getAllTypes(ctx);

    // Contract
    const contract = allTypes.find((v) => v.name === name);
    if (!contract) {
        throw Error(`Contract "${name}" not found`);
    }
    if (contract.kind !== "contract") {
        throw Error("Not a contract");
    }

    // Structs
    const types: ABIType[] = [];
    for (const t of allTypes) {
        if (t.kind === "struct") {
            types.push({
                name: t.name,
                header: Number(t.header?.value),
                fields: t.fields.map((v) => v.abi),
            });
        } else if (t.kind === "contract") {
            types.push({
                name: t.name + "$Data",
                header: Number(t.header?.value),
                fields: t.fields.map((v) => v.abi),
            });
        }
    }

    // // Receivers
    const receivers: ABIReceiver[] = [];
    for (const r of contract.receivers) {
        if (r.selector.kind === "internal-binary") {
            receivers.push({
                receiver: "internal",
                message: {
                    kind: "typed",
                    type: r.selector.type,
                },
            });
        } else if (r.selector.kind === "external-binary") {
            receivers.push({
                receiver: "external",
                message: {
                    kind: "typed",
                    type: r.selector.type,
                },
            });
        } else if (r.selector.kind === "internal-empty") {
            receivers.push({
                receiver: "internal",
                message: {
                    kind: "empty",
                },
            });
        } else if (r.selector.kind === "external-empty") {
            receivers.push({
                receiver: "external",
                message: {
                    kind: "empty",
                },
            });
        } else if (r.selector.kind === "internal-comment") {
            receivers.push({
                receiver: "internal",
                message: {
                    kind: "text",
                    text: r.selector.comment,
                },
            });
        } else if (r.selector.kind === "external-comment") {
            receivers.push({
                receiver: "external",
                message: {
                    kind: "text",
                    text: r.selector.comment,
                },
            });
        } else if (r.selector.kind === "internal-comment-fallback") {
            receivers.push({
                receiver: "internal",
                message: {
                    kind: "text",
                },
            });
        } else if (r.selector.kind === "external-comment-fallback") {
            receivers.push({
                receiver: "external",
                message: {
                    kind: "text",
                },
            });
        } else if (r.selector.kind === "internal-fallback") {
            receivers.push({
                receiver: "internal",
                message: {
                    kind: "any",
                },
            });
        } else if (r.selector.kind === "external-fallback") {
            receivers.push({
                receiver: "external",
                message: {
                    kind: "any",
                },
            });
        }
    }

    // Getters
    const getters: ABIGetter[] = [];
    for (const f of contract.functions.values()) {
        if (f.isGetter) {
            getters.push({
                name: f.name,
                methodId: f.methodId,
                arguments: f.params.map((v) => ({
                    name: idText(v.name),
                    type: createABITypeRefFromTypeRef(ctx, v.type, v.loc),
                })),
                returnType:
                    f.returns.kind !== "void"
                        ? createABITypeRefFromTypeRef(ctx, f.returns, f.ast.loc)
                        : null,
            });
        }
    }

    // Errors
    const errors: Record<string, { message: string }> = {};
    errors["2"] = { message: "Stack underflow" };
    errors["3"] = { message: "Stack overflow" };
    errors["4"] = { message: "Integer overflow" };
    errors["5"] = { message: "Integer out of expected range" };
    errors["6"] = { message: "Invalid opcode" };
    errors["7"] = { message: "Type check error" };
    errors["8"] = { message: "Cell overflow" };
    errors["9"] = { message: "Cell underflow" };
    errors["10"] = { message: "Dictionary error" };
    errors["11"] = { message: "'Unknown' error" };
    errors["12"] = { message: "Fatal error" };
    errors["13"] = { message: "Out of gas error" };
    errors["14"] = { message: "Virtualization error" };
    errors["32"] = { message: "Action list is invalid" };
    errors["33"] = { message: "Action list is too long" };
    errors["34"] = { message: "Action is invalid or not supported" };
    errors["35"] = { message: "Invalid source address in outbound message" };
    errors["36"] = {
        message: "Invalid destination address in outbound message",
    };
    errors["37"] = { message: "Not enough Toncoin" };
    errors["38"] = { message: "Not enough extra currencies" };
    errors["39"] = {
        message: "Outbound message does not fit into a cell after rewriting",
    };
    errors["40"] = { message: "Cannot process a message" };
    errors["41"] = { message: "Library reference is null" };
    errors["42"] = { message: "Library change action error" };
    errors["43"] = {
        message:
            "Exceeded maximum number of cells in the library or the maximum depth of the Merkle tree",
    };
    errors["50"] = { message: "Account state size exceeded limits" };
    for (const e of Object.values(contractErrors)) {
        errors[e.id] = { message: e.message };
    }
    const codeErrors = getAllErrors(ctx);
    for (const c of codeErrors) {
        errors[c.id + ""] = { message: c.value };
    }

    // Interfaces
    const interfaces = [
        "org.ton.introspection.v0",
        ...getSupportedInterfaces(contract, ctx),
    ];

    return {
        name: contract.name,
        types,
        receivers,
        getters,
        errors,
        interfaces,
    } as object;
}


## writeProgram.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writeProgram.ts)
import { CompilerContext } from "../context";
import { getAllocation, getSortedTypes } from "../storage/resolveAllocation";
import {
    getAllStaticFunctions,
    getAllTypes,
    toBounced,
} from "../types/resolveDescriptors";
import { WriterContext, WrittenFunction } from "./Writer";
import {
    writeBouncedParser,
    writeOptionalParser,
    writeOptionalSerializer,
    writeParser,
    writeSerializer,
} from "./writers/writeSerialization";
import { writeStdlib } from "./writers/writeStdlib";
import { writeAccessors } from "./writers/writeAccessors";
import { ContractABI } from "@ton/core";
import { writeFunction } from "./writers/writeFunction";
import { calculateIPFSlink } from "../utils/calculateIPFSlink";
import { getRawAST } from "../grammar/store";
import { emit } from "./emitter/emit";
import {
    writeInit,
    writeMainContract,
    writeStorageOps,
} from "./writers/writeContract";
import { funcInitIdOf } from "./writers/id";
import { idToHex } from "../utils/idToHex";
import { trimIndent } from "../utils/text";

export async function writeProgram(
    ctx: CompilerContext,
    abiSrc: ContractABI,
    basename: string,
    debug: boolean = false,
) {
    //
    // Load ABI (required for generator)
    //

    const abi = JSON.stringify(abiSrc);
    const abiLink = await calculateIPFSlink(Buffer.from(abi));

    //
    // Render contract
    //

    const wCtx = new WriterContext(ctx, abiSrc.name!);
    writeAll(ctx, wCtx, abiSrc.name!, abiLink);
    const functions = wCtx.extract(debug);

    //
    // Emit files
    //

    const files: { name: string; code: string }[] = [];
    const imported: string[] = [];

    //
    // Headers
    //

    const headers: string[] = [];
    headers.push(`;;`);
    headers.push(`;; Header files for ${abiSrc.name}`);
    headers.push(`;; NOTE: declarations are sorted for optimal order`);
    headers.push(`;;`);
    headers.push(``);
    // const sortedHeaders = [...functions].sort((a, b) => a.name.localeCompare(b.name));
    for (const f of functions) {
        if (f.code.kind === "generic" && f.signature) {
            headers.push(`;; ${f.name}`);
            let sig = f.signature;
            if (f.flags.has("impure")) {
                sig = sig + " impure";
            }
            if (f.flags.has("inline")) {
                sig = sig + " inline";
            } else {
                sig = sig + " inline_ref";
            }
            headers.push(sig + ";");
            headers.push("");
        }
    }
    files.push({
        name: basename + ".headers.fc",
        code: headers.join("\n"),
    });

    //
    // stdlib
    //

    const stdlibHeader = trimIndent(`
        global (int, slice, int, slice) __tact_context;
        global slice __tact_context_sender;
        global cell __tact_context_sys;
        global int __tact_randomized;
    `);

    const stdlibFunctions = tryExtractModule(functions, "stdlib", []);
    if (stdlibFunctions) {
        imported.push("stdlib");
    }

    const stdlib = emit({
        header: stdlibHeader,
        functions: stdlibFunctions,
    });

    files.push({
        name: basename + ".stdlib.fc",
        code: stdlib,
    });

    //
    // native
    //

    const nativeSources = getRawAST(ctx).funcSources;
    if (nativeSources.length > 0) {
        imported.push("native");
        files.push({
            name: basename + ".native.fc",
            code: emit({
                header: [...nativeSources.map((v) => v.code)].join("\n\n"),
            }),
        });
    }

    //
    // constants
    //

    const constantsFunctions = tryExtractModule(
        functions,
        "constants",
        imported,
    );
    if (constantsFunctions) {
        imported.push("constants");
        files.push({
            name: basename + ".constants.fc",
            code: emit({ functions: constantsFunctions }),
        });
    }

    //
    // storage
    //

    const emittedTypes: string[] = [];
    const types = getSortedTypes(ctx);
    for (const t of types) {
        const ffs: WrittenFunction[] = [];
        if (t.kind === "struct" || t.kind === "contract" || t.kind == "trait") {
            const typeFunctions = tryExtractModule(
                functions,
                "type:" + t.name,
                imported,
            );
            if (typeFunctions) {
                imported.push("type:" + t.name);
                ffs.push(...typeFunctions);
            }
        }
        if (t.kind === "contract") {
            const typeFunctions = tryExtractModule(
                functions,
                "type:" + t.name + "$init",
                imported,
            );
            if (typeFunctions) {
                imported.push("type:" + t.name + "$init");
                ffs.push(...typeFunctions);
            }
        }
        if (ffs.length > 0) {
            const header: string[] = [];
            header.push(";;");
            header.push(`;; Type: ${t.name}`);
            if (t.header !== null) {
                header.push(`;; Header: 0x${idToHex(Number(t.header.value))}`);
            }
            if (t.tlb) {
                header.push(`;; TLB: ${t.tlb}`);
            }
            header.push(";;");

            emittedTypes.push(
                emit({
                    functions: ffs,
                    header: header.join("\n"),
                }),
            );
        }
    }
    if (emittedTypes.length > 0) {
        files.push({
            name: basename + ".storage.fc",
            code: [...emittedTypes].join("\n\n"),
        });
    }

    // const storageFunctions = tryExtractModule(functions, 'storage', imported);
    // if (storageFunctions) {
    //     imported.push('storage');
    //     files.push({
    //         name: basename + '.storage.fc',
    //         code: emit({ functions: storageFunctions })
    //     });
    // }

    //
    // Remaining
    //

    const remainingFunctions = tryExtractModule(functions, null, imported);
    const header: string[] = [];
    header.push("#pragma version =0.4.4;");
    header.push("#pragma allow-post-modification;");
    header.push("#pragma compute-asm-ltr;");
    header.push("");
    for (const i of files.map((v) => `#include "${v.name}";`)) {
        header.push(i);
    }
    header.push("");
    header.push(";;");
    header.push(`;; Contract ${abiSrc.name} functions`);
    header.push(";;");
    header.push("");
    const code = emit({
        header: header.join("\n"),
        functions: remainingFunctions,
    });
    files.push({
        name: basename + ".code.fc",
        code,
    });

    return {
        entrypoint: basename + ".code.fc",
        files,
        abi,
    };
}

function tryExtractModule(
    functions: WrittenFunction[],
    context: string | null,
    imported: string[],
): WrittenFunction[] | null {
    // Put to map
    const maps: Map<string, WrittenFunction> = new Map();
    for (const f of functions) {
        maps.set(f.name, f);
    }

    // Extract functions of a context
    const ctxFunctions: WrittenFunction[] = functions
        .filter((v) => v.code.kind !== "skip")
        .filter((v) => {
            if (context) {
                return v.context === context;
            } else {
                return v.context === null || !imported.includes(v.context);
            }
        });
    if (ctxFunctions.length === 0) {
        return null;
    }

    // Check dependencies
    // if (context) {
    //     for (let f of ctxFunctions) {
    //         for (let d of f.depends) {
    //             let c = maps.get(d)!.context;
    //             if (!c) {
    //                 console.warn(`Function ${f.name} depends on ${d} with generic context, but ${context} is needed`);
    //                 return null; // Found dependency to unknown function
    //             }
    //             if (c !== context && (c !== null && !imported.includes(c))) {
    //                 console.warn(`Function ${f.name} depends on ${d} with ${c} context, but ${context} is needed`);
    //                 return null; // Found dependency to another context
    //             }
    //         }
    //     }
    // }

    return ctxFunctions;
}

function writeAll(
    ctx: CompilerContext,
    wCtx: WriterContext,
    name: string,
    abiLink: string,
) {
    // Load all types
    const allTypes = getAllTypes(ctx);
    const contracts = allTypes.filter((v) => v.kind === "contract");
    const c = contracts.find((v) => v.name === name);
    if (!c) {
        throw Error(`Contract "${name}" not found`);
    }

    // Stdlib
    writeStdlib(wCtx);

    // Serializers
    const sortedTypes = getSortedTypes(ctx);
    for (const t of sortedTypes) {
        if (t.kind === "contract" || t.kind === "struct") {
            const allocation = getAllocation(ctx, t.name);
            const allocationBounced = getAllocation(ctx, toBounced(t.name));
            writeSerializer(
                t.name,
                t.kind === "contract",
                allocation,
                t.origin,
                wCtx,
            );
            writeOptionalSerializer(t.name, t.origin, wCtx);
            writeParser(
                t.name,
                t.kind === "contract",
                allocation,
                t.origin,
                wCtx,
            );
            writeOptionalParser(t.name, t.origin, wCtx);
            writeBouncedParser(
                t.name,
                t.kind === "contract",
                allocationBounced,
                t.origin,
                wCtx,
            );
        }
    }

    // Accessors
    for (const t of allTypes) {
        if (t.kind === "contract" || t.kind === "struct") {
            writeAccessors(t, t.origin, wCtx);
        }
    }

    // Init serializers
    for (const t of sortedTypes) {
        if (t.kind === "contract" && t.init) {
            const allocation = getAllocation(ctx, funcInitIdOf(t.name));
            writeSerializer(
                funcInitIdOf(t.name),
                true,
                allocation,
                t.origin,
                wCtx,
            );
            writeParser(
                funcInitIdOf(t.name),
                false,
                allocation,
                t.origin,
                wCtx,
            );
        }
    }

    // Storage Functions
    for (const t of sortedTypes) {
        if (t.kind === "contract") {
            writeStorageOps(t, t.origin, wCtx);
        }
    }

    // Static functions
    getAllStaticFunctions(ctx).forEach((f) => {
        writeFunction(f, wCtx);
    });

    // Extensions
    for (const c of allTypes) {
        if (c.kind !== "contract" && c.kind !== "trait") {
            // We are rendering contract functions separately
            for (const f of c.functions.values()) {
                writeFunction(f, wCtx);
            }
        }
    }

    // Contract functions
    for (const c of contracts) {
        // Init
        if (c.init) {
            writeInit(c, c.init, wCtx);
        }

        // Functions
        for (const f of c.functions.values()) {
            writeFunction(f, wCtx);
        }
    }

    // Write contract main
    writeMainContract(c, abiLink, wCtx);
}


## writeReport.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writeReport.ts)
import { ContractABI } from "@ton/core";
import { CompilerContext } from "../context";
import { PackageFileFormat } from "../packaging/fileFormat";
import { getType } from "../types/resolveDescriptors";
import { Writer } from "../utils/Writer";
import { TypeDescription } from "../types/types";

export function writeReport(ctx: CompilerContext, pkg: PackageFileFormat) {
    const w = new Writer();
    const abi = JSON.parse(pkg.abi) as ContractABI;
    w.write(`
        # TACT Compilation Report
        Contract: ${pkg.name}
        BOC Size: ${Buffer.from(pkg.code, "base64").length} bytes
    `);
    w.append();

    // Types
    w.write(`# Types`);
    w.write("Total Types: " + abi.types!.length);
    w.append();
    for (const t of abi.types!) {
        const tt = getType(
            ctx,
            t.name.endsWith("$Data") ? t.name.slice(0, -5) : t.name,
        );
        w.write(`## ${t.name}`);
        w.write(`TLB: \`${tt.tlb!}\``);
        w.write(`Signature: \`${tt.signature!}\``);
        w.append();
    }

    // Get methods
    w.write(`# Get Methods`);
    w.write("Total Get Methods: " + abi.getters!.length);
    w.append();
    for (const t of abi.getters!) {
        w.write(`## ${t.name}`);
        for (const arg of t.arguments!) {
            w.write(`Argument: ${arg.name}`);
        }
        w.append();
    }

    // Error Codes
    w.write(`# Error Codes`);
    Object.entries(abi.errors!).forEach(([t, abiError]) => {
        w.write(`* ${t}: ${abiError.message}`);
    });
    w.append();

    const t = getType(ctx, pkg.name);
    const writtenEdges: Set<string> = new Set();

    // Trait Inheritance Diagram
    w.write(`# Trait Inheritance Diagram`);
    w.append();
    w.write("```mermaid");
    w.write("graph TD");
    function writeTraits(t: TypeDescription) {
        for (const trait of t.traits) {
            const edge = `${t.name} --> ${trait.name}`;
            if (writtenEdges.has(edge)) {
                continue;
            }
            writtenEdges.add(edge);
            w.write(edge);
            writeTraits(trait);
        }
    }
    w.write(t.name);
    writeTraits(t);
    w.write("```");
    w.append();

    writtenEdges.clear();

    // Contract Dependency Diagram
    w.write(`# Contract Dependency Diagram`);
    w.append();
    w.write("```mermaid");
    w.write("graph TD");
    function writeDependencies(t: TypeDescription) {
        for (const dep of t.dependsOn) {
            const edge = `${t.name} --> ${dep.name}`;
            if (writtenEdges.has(edge)) {
                continue;
            }
            writtenEdges.add(edge);
            w.write(edge);
            writeDependencies(dep);
        }
    }
    writtenEdges.clear();
    w.write(t.name);
    writeDependencies(t);
    w.write("```");

    return w.end();
}


## createPadded.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/emitter/createPadded.ts)
import { trimIndent } from "../../utils/text";

export function createPadded(src: string) {
    return trimIndent(src)
        .split("\n")
        .map((v) => " ".repeat(4) + v)
        .join("\n");
}


## emit.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/emitter/emit.ts)
import { Maybe } from "@ton/core/dist/utils/maybe";
import { trimIndent } from "../../utils/text";
import { WrittenFunction } from "../Writer";
import { createPadded } from "./createPadded";

export function emit(args: {
    header?: Maybe<string>;
    functions?: Maybe<WrittenFunction[]>;
}) {
    // Emit header
    let res = "";
    if (args.header) {
        res = trimIndent(args.header);
    }

    // Emit functions
    if (args.functions) {
        for (const f of args.functions) {
            if (f.name === "$main") {
                continue;
            } else {
                if (res !== "") {
                    res += "\n\n";
                }
                if (f.comment) {
                    for (const s of f.comment.split("\n")) {
                        res += `;; ${s}\n`;
                    }
                }
                if (f.code.kind === "generic") {
                    let sig = f.signature;
                    if (f.flags.has("impure")) {
                        sig = `${sig} impure`;
                    }
                    if (f.flags.has("inline")) {
                        sig = `${sig} inline`;
                    } else {
                        sig = `${sig} inline_ref`;
                    }

                    res += `${sig} {\n${createPadded(f.code.code)}\n}`;
                } else if (f.code.kind === "asm") {
                    let sig = f.signature;
                    if (f.flags.has("impure")) {
                        sig = `${sig} impure`;
                    }
                    res += `${sig} asm${f.code.shuffle} """\n    ${f.code.code}\n""";`;
                } else {
                    throw new Error(`Unknown function body kind`);
                }
            }
        }

        // Emit main
        const m = args.functions.find((v) => v.name === "$main");
        if (m) {
            if (m.code.kind !== "generic") {
                throw new Error(`Main function should have generic body`);
            }
            if (res !== "") {
                res += "\n\n";
            }
            res += m.code.code;
        }
    }

    return res;
}


## cast.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/cast.ts)
import { getType } from "../../types/resolveDescriptors";
import { TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
import { ops } from "./ops";

export function cast(
    from: TypeRef,
    to: TypeRef,
    expression: string,
    ctx: WriterContext,
) {
    if (from.kind === "ref" && to.kind === "ref") {
        if (from.name !== to.name) {
            throw Error("Impossible");
        }
        if (!from.optional && to.optional) {
            const type = getType(ctx.ctx, from.name);
            if (type.kind === "struct") {
                return `${ops.typeAsOptional(type.name, ctx)}(${expression})`;
            }
        }
    }
    return expression;
}


## freshIdentifier.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/freshIdentifier.ts)
import { funcIdOf } from "./id";

let counter = 0;

export function freshIdentifier(prefix: string): string {
    const fresh = `fresh$${prefix}_${counter}`;
    counter += 1;
    return funcIdOf(fresh);
}


## id.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/id.ts)
import { AstId, idText } from "../../grammar/ast";

export function funcIdOf(ident: AstId | string): string {
    if (typeof ident === "string") {
        return "$" + ident;
    }
    return "$" + idText(ident);
}

export function funcInitIdOf(ident: AstId | string): string {
    if (typeof ident === "string") {
        return ident + "$init";
    }
    return idText(ident) + "$init";
}


## ops.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/ops.ts)
import { WriterContext } from "../Writer";

function used(name: string, ctx: WriterContext) {
    const c = ctx.currentContext();
    if (c) {
        ctx.used(name);
    }
    return name;
}

export const ops = {
    // Type operations
    writer: (type: string, ctx: WriterContext) => used(`$${type}$_store`, ctx),
    writerCell: (type: string, ctx: WriterContext) =>
        used(`$${type}$_store_cell`, ctx),
    writerCellOpt: (type: string, ctx: WriterContext) =>
        used(`$${type}$_store_opt`, ctx),
    reader: (type: string, ctx: WriterContext) => used(`$${type}$_load`, ctx),
    readerNonModifying: (type: string, ctx: WriterContext) =>
        used(`$${type}$_load_not_mut`, ctx),
    readerBounced: (type: string, ctx: WriterContext) =>
        used(`$${type}$_load_bounced`, ctx),
    readerOpt: (type: string, ctx: WriterContext) =>
        used(`$${type}$_load_opt`, ctx),
    typeField: (type: string, name: string, ctx: WriterContext) =>
        used(`$${type}$_get_${name}`, ctx),
    typeTensorCast: (type: string, ctx: WriterContext) =>
        used(`$${type}$_tensor_cast`, ctx),
    typeNotNull: (type: string, ctx: WriterContext) =>
        used(`$${type}$_not_null`, ctx),
    typeAsOptional: (type: string, ctx: WriterContext) =>
        used(`$${type}$_as_optional`, ctx),
    typeToTuple: (type: string, ctx: WriterContext) =>
        used(`$${type}$_to_tuple`, ctx),
    typeToOptTuple: (type: string, ctx: WriterContext) =>
        used(`$${type}$_to_opt_tuple`, ctx),
    typeFromTuple: (type: string, ctx: WriterContext) =>
        used(`$${type}$_from_tuple`, ctx),
    typeFromOptTuple: (type: string, ctx: WriterContext) =>
        used(`$${type}$_from_opt_tuple`, ctx),
    typeToExternal: (type: string, ctx: WriterContext) =>
        used(`$${type}$_to_external`, ctx),
    typeToOptExternal: (type: string, ctx: WriterContext) =>
        used(`$${type}$_to_opt_external`, ctx),
    typeConstructor: (type: string, fields: string[], ctx: WriterContext) =>
        used(`$${type}$_constructor_${fields.join("_")}`, ctx),

    // Contract operations
    contractInit: (type: string, ctx: WriterContext) =>
        used(`$${type}$_contract_init`, ctx),
    contractInitChild: (type: string, ctx: WriterContext) =>
        used(`$${type}$_init_child`, ctx),
    contractLoad: (type: string, ctx: WriterContext) =>
        used(`$${type}$_contract_load`, ctx),
    contractStore: (type: string, ctx: WriterContext) =>
        used(`$${type}$_contract_store`, ctx),
    contractRouter: (type: string, kind: "internal" | "external") =>
        `$${type}$_contract_router_${kind}`, // Not rendered as dependency

    // Router operations
    receiveEmpty: (type: string, kind: "internal" | "external") =>
        `%$${type}$_${kind}_empty`,
    receiveType: (type: string, kind: "internal" | "external", msg: string) =>
        `$${type}$_${kind}_binary_${msg}`,
    receiveAnyText: (type: string, kind: "internal" | "external") =>
        `$${type}$_${kind}_any_text`,
    receiveText: (type: string, kind: "internal" | "external", hash: string) =>
        `$${type}$_${kind}_text_${hash}`,
    receiveAny: (type: string, kind: "internal" | "external") =>
        `$${type}$_${kind}_any`,
    receiveTypeBounce: (type: string, msg: string) =>
        `$${type}$_receive_binary_bounce_${msg}`,
    receiveBounceAny: (type: string) => `$${type}$_receive_bounce`,

    // Functions
    extension: (type: string, name: string) => `$${type}$_fun_${name}`,
    global: (name: string) => `$global_${name}`,
    nonModifying: (name: string) => `${name}$not_mut`,

    // Constants
    str: (id: string, ctx: WriterContext) => used(`__gen_str_${id}`, ctx),
};


## resolveFuncFlatPack.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncFlatPack.ts)
import { getType } from "../../types/resolveDescriptors";
import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";

export function resolveFuncFlatPack(
    descriptor: TypeRef | TypeDescription | string,
    name: string,
    ctx: WriterContext,
    optional: boolean = false,
): string[] {
    // String
    if (typeof descriptor === "string") {
        return resolveFuncFlatPack(getType(ctx.ctx, descriptor), name, ctx);
    }

    // TypeRef
    if (descriptor.kind === "ref") {
        return resolveFuncFlatPack(
            getType(ctx.ctx, descriptor.name),
            name,
            ctx,
            descriptor.optional,
        );
    }
    if (descriptor.kind === "map") {
        return [name];
    }
    if (descriptor.kind === "ref_bounced") {
        throw Error("Unimplemented");
    }
    if (descriptor.kind === "void") {
        throw Error("Void type is not allowed in function arguments: " + name);
    }

    // TypeDescription
    if (descriptor.kind === "primitive_type_decl") {
        return [name];
    } else if (descriptor.kind === "struct") {
        if (optional || descriptor.fields.length === 0) {
            return [name];
        } else {
            return descriptor.fields.flatMap((v) =>
                resolveFuncFlatPack(v.type, name + `'` + v.name, ctx),
            );
        }
    } else if (descriptor.kind === "contract") {
        if (optional || descriptor.fields.length === 0) {
            return [name];
        } else {
            return descriptor.fields.flatMap((v) =>
                resolveFuncFlatPack(v.type, name + `'` + v.name, ctx),
            );
        }
    }

    // Unreachable
    throw Error("Unknown type: " + descriptor.kind);
}


## resolveFuncFlatTypes.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncFlatTypes.ts)
import { getType } from "../../types/resolveDescriptors";
import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
import { resolveFuncType } from "./resolveFuncType";

export function resolveFuncFlatTypes(
    descriptor: TypeRef | TypeDescription | string,
    ctx: WriterContext,
    optional: boolean = false,
): string[] {
    // String
    if (typeof descriptor === "string") {
        return resolveFuncFlatTypes(getType(ctx.ctx, descriptor), ctx);
    }

    // TypeRef
    if (descriptor.kind === "ref") {
        return resolveFuncFlatTypes(
            getType(ctx.ctx, descriptor.name),
            ctx,
            descriptor.optional,
        );
    }
    if (descriptor.kind === "map") {
        return ["cell"];
    }
    if (descriptor.kind === "ref_bounced") {
        throw Error("Unimplemented");
    }
    if (descriptor.kind === "void") {
        throw Error("Void type is not allowed in function arguments");
    }

    // TypeDescription
    if (descriptor.kind === "primitive_type_decl") {
        return [resolveFuncType(descriptor, ctx)];
    } else if (descriptor.kind === "struct") {
        if (optional || descriptor.fields.length === 0) {
            return ["tuple"];
        } else {
            return descriptor.fields.flatMap((v) =>
                resolveFuncFlatTypes(v.type, ctx),
            );
        }
    } else if (descriptor.kind === "contract") {
        if (optional || descriptor.fields.length === 0) {
            return ["tuple"];
        } else {
            return descriptor.fields.flatMap((v) =>
                resolveFuncFlatTypes(v.type, ctx),
            );
        }
    }

    // Unreachable
    throw Error("Unknown type: " + descriptor.kind);
}


## resolveFuncPrimitive.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncPrimitive.ts)
import { getType } from "../../types/resolveDescriptors";
import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";

export function resolveFuncPrimitive(
    descriptor: TypeRef | TypeDescription | string,
    ctx: WriterContext,
): boolean {
    // String
    if (typeof descriptor === "string") {
        return resolveFuncPrimitive(getType(ctx.ctx, descriptor), ctx);
    }

    // TypeRef
    if (descriptor.kind === "ref") {
        return resolveFuncPrimitive(getType(ctx.ctx, descriptor.name), ctx);
    }
    if (descriptor.kind === "map") {
        return true;
    }
    if (descriptor.kind === "ref_bounced") {
        throw Error("Unimplemented");
    }
    if (descriptor.kind === "void") {
        return true;
    }

    // TypeDescription
    if (descriptor.kind === "primitive_type_decl") {
        if (descriptor.name === "Int") {
            return true;
        } else if (descriptor.name === "Bool") {
            return true;
        } else if (descriptor.name === "Slice") {
            return true;
        } else if (descriptor.name === "Cell") {
            return true;
        } else if (descriptor.name === "Builder") {
            return true;
        } else if (descriptor.name === "Address") {
            return true;
        } else if (descriptor.name === "String") {
            return true;
        } else if (descriptor.name === "StringBuilder") {
            return true;
        } else {
            throw Error("Unknown primitive type: " + descriptor.name);
        }
    } else if (descriptor.kind === "struct") {
        return false;
    } else if (descriptor.kind === "contract") {
        return false;
    }

    // Unreachable
    throw Error("Unknown type: " + descriptor.kind);
}


## resolveFuncTupleType.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncTupleType.ts)
import { getType } from "../../types/resolveDescriptors";
import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";

export function resolveFuncTupleType(
    descriptor: TypeRef | TypeDescription | string,
    ctx: WriterContext,
): string {
    // String
    if (typeof descriptor === "string") {
        return resolveFuncTupleType(getType(ctx.ctx, descriptor), ctx);
    }

    // TypeRef
    if (descriptor.kind === "ref") {
        return resolveFuncTupleType(getType(ctx.ctx, descriptor.name), ctx);
    }
    if (descriptor.kind === "map") {
        return "cell";
    }
    if (descriptor.kind === "ref_bounced") {
        throw Error("Unimplemented");
    }
    if (descriptor.kind === "void") {
        return "()";
    }

    // TypeDescription
    if (descriptor.kind === "primitive_type_decl") {
        if (descriptor.name === "Int") {
            return "int";
        } else if (descriptor.name === "Bool") {
            return "int";
        } else if (descriptor.name === "Slice") {
            return "slice";
        } else if (descriptor.name === "Cell") {
            return "cell";
        } else if (descriptor.name === "Builder") {
            return "builder";
        } else if (descriptor.name === "Address") {
            return "slice";
        } else if (descriptor.name === "String") {
            return "slice";
        } else if (descriptor.name === "StringBuilder") {
            return "tuple";
        } else {
            throw Error("Unknown primitive type: " + descriptor.name);
        }
    } else if (descriptor.kind === "struct" || descriptor.kind === "contract") {
        return "tuple";
    }

    // Unreachable
    throw Error("Unknown type: " + descriptor.kind);
}


## resolveFuncType.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncType.spec.ts)
import { getAstFactory } from "../../grammar/ast";
import { resolveDescriptors } from "../../types/resolveDescriptors";
import { WriterContext } from "../Writer";
import { resolveFuncType } from "./resolveFuncType";
import { openContext } from "../../grammar/store";
import { CompilerContext } from "../../context";
import { getParser } from "../../grammar";

const primitiveCode = `
primitive Int;
primitive Bool;
primitive Builder;
primitive Cell;
primitive Slice;

trait BaseTrait {
    
}

struct Struct1 {
    a1: Int;
    a2: Int;
}

struct Struct2 {
    b1: Int;
}

contract Contract1 {
    c: Int;
    c2: Int;

    init() {
        
    }
}

contract Contract2 {
    d: Int;
    e: Struct1;

    init() {

    }
}
`;

describe("resolveFuncType", () => {
    it("should process primitive types", () => {
        const ast = getAstFactory();
        let ctx = openContext(
            new CompilerContext(),
            [{ code: primitiveCode, path: "<unknown>", origin: "user" }],
            [],
            getParser(ast),
        );
        ctx = resolveDescriptors(ctx, ast);
        const wCtx = new WriterContext(ctx, "Contract1");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Int", optional: false },
                wCtx,
            ),
        ).toBe("int");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Bool", optional: false },
                wCtx,
            ),
        ).toBe("int");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Cell", optional: false },
                wCtx,
            ),
        ).toBe("cell");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Slice", optional: false },
                wCtx,
            ),
        ).toBe("slice");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Builder", optional: false },
                wCtx,
            ),
        ).toBe("builder");
        expect(
            resolveFuncType({ kind: "ref", name: "Int", optional: true }, wCtx),
        ).toBe("int");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Bool", optional: true },
                wCtx,
            ),
        ).toBe("int");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Cell", optional: true },
                wCtx,
            ),
        ).toBe("cell");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Slice", optional: true },
                wCtx,
            ),
        ).toBe("slice");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Builder", optional: true },
                wCtx,
            ),
        ).toBe("builder");
    });

    it("should process contract and struct types", () => {
        const ast = getAstFactory();
        let ctx = openContext(
            new CompilerContext(),
            [{ code: primitiveCode, path: "<unknown>", origin: "user" }],
            [],
            getParser(ast),
        );
        ctx = resolveDescriptors(ctx, ast);
        const wCtx = new WriterContext(ctx, "Contract1");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Struct1", optional: false },
                wCtx,
            ),
        ).toBe("(int, int)");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Struct2", optional: false },
                wCtx,
            ),
        ).toBe("(int)");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Contract1", optional: false },
                wCtx,
            ),
        ).toBe("(int, int)");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Contract2", optional: false },
                wCtx,
            ),
        ).toBe("(int, (int, int))");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Struct1", optional: true },
                wCtx,
            ),
        ).toBe("tuple");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Struct2", optional: true },
                wCtx,
            ),
        ).toBe("tuple");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Contract1", optional: true },
                wCtx,
            ),
        ).toBe("tuple");
        expect(
            resolveFuncType(
                { kind: "ref", name: "Contract2", optional: true },
                wCtx,
            ),
        ).toBe("tuple");
    });
});


## resolveFuncType.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncType.ts)
import { getType } from "../../types/resolveDescriptors";
import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";

export function resolveFuncType(
    descriptor: TypeRef | TypeDescription | string,
    ctx: WriterContext,
    optional: boolean = false,
    usePartialFields: boolean = false,
): string {
    // String
    if (typeof descriptor === "string") {
        return resolveFuncType(
            getType(ctx.ctx, descriptor),
            ctx,
            false,
            usePartialFields,
        );
    }

    // TypeRef
    if (descriptor.kind === "ref") {
        return resolveFuncType(
            getType(ctx.ctx, descriptor.name),
            ctx,
            descriptor.optional,
            usePartialFields,
        );
    }
    if (descriptor.kind === "map") {
        return "cell";
    }
    if (descriptor.kind === "ref_bounced") {
        return resolveFuncType(
            getType(ctx.ctx, descriptor.name),
            ctx,
            false,
            true,
        );
    }
    if (descriptor.kind === "void") {
        return "()";
    }

    // TypeDescription
    if (descriptor.kind === "primitive_type_decl") {
        if (descriptor.name === "Int") {
            return "int";
        } else if (descriptor.name === "Bool") {
            return "int";
        } else if (descriptor.name === "Slice") {
            return "slice";
        } else if (descriptor.name === "Cell") {
            return "cell";
        } else if (descriptor.name === "Builder") {
            return "builder";
        } else if (descriptor.name === "Address") {
            return "slice";
        } else if (descriptor.name === "String") {
            return "slice";
        } else if (descriptor.name === "StringBuilder") {
            return "tuple";
        } else {
            throw Error("Unknown primitive type: " + descriptor.name);
        }
    } else if (descriptor.kind === "struct") {
        const fieldsToUse = usePartialFields
            ? descriptor.fields.slice(0, descriptor.partialFieldCount)
            : descriptor.fields;
        if (optional || fieldsToUse.length === 0) {
            return "tuple";
        } else {
            return (
                "(" +
                fieldsToUse
                    .map((v) =>
                        resolveFuncType(v.type, ctx, false, usePartialFields),
                    )
                    .join(", ") +
                ")"
            );
        }
    } else if (descriptor.kind === "contract") {
        if (optional || descriptor.fields.length === 0) {
            return "tuple";
        } else {
            return (
                "(" +
                descriptor.fields
                    .map((v) =>
                        resolveFuncType(v.type, ctx, false, usePartialFields),
                    )
                    .join(", ") +
                ")"
            );
        }
    }

    // Unreachable
    throw Error("Unknown type: " + descriptor.kind);
}


## resolveFuncTypeFromAbi.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncTypeFromAbi.ts)
import { ABITypeRef } from "@ton/core";
import { getType } from "../../types/resolveDescriptors";
import { WriterContext } from "../Writer";

export function resolveFuncTypeFromAbi(
    fields: ABITypeRef[],
    ctx: WriterContext,
): string {
    if (fields.length === 0) {
        return "tuple";
    }
    const res: string[] = [];
    for (const f of fields) {
        switch (f.kind) {
            case "dict":
                {
                    res.push("cell");
                }
                break;
            case "simple": {
                if (
                    f.type === "int" ||
                    f.type === "uint" ||
                    f.type === "bool"
                ) {
                    res.push("int");
                } else if (f.type === "cell") {
                    res.push("cell");
                } else if (f.type === "slice") {
                    res.push("slice");
                } else if (f.type === "builder") {
                    res.push("builder");
                } else if (f.type === "address") {
                    res.push("slice");
                } else if (f.type === "fixed-bytes") {
                    res.push("slice");
                } else if (f.type === "string") {
                    res.push("slice");
                } else {
                    const t = getType(ctx.ctx, f.type);
                    if (t.kind !== "struct") {
                        throw Error("Unsupported type: " + t.kind);
                    }
                    if (f.optional ?? t.fields.length === 0) {
                        res.push("tuple");
                    } else {
                        const loaded = t.fields.map((v) => v.abi.type);
                        res.push(resolveFuncTypeFromAbi(loaded, ctx));
                    }
                }
            }
        }
    }
    return `(${res.join(", ")})`;
}


## resolveFuncTypeFromAbiUnpack.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncTypeFromAbiUnpack.ts)
import { ABITypeRef } from "@ton/core";
import { getType } from "../../types/resolveDescriptors";
import { WriterContext } from "../Writer";

export function resolveFuncTypeFromAbiUnpack(
    name: string,
    fields: { name: string; type: ABITypeRef }[],
    ctx: WriterContext,
): string {
    if (fields.length === 0) {
        return name;
    }
    const res: string[] = [];
    for (const f of fields) {
        switch (f.type.kind) {
            case "dict":
                {
                    res.push(`${name}'${f.name}`);
                }
                break;
            case "simple":
                {
                    if (
                        f.type.type === "int" ||
                        f.type.type === "uint" ||
                        f.type.type === "bool"
                    ) {
                        res.push(`${name}'${f.name}`);
                    } else if (f.type.type === "cell") {
                        res.push(`${name}'${f.name}`);
                    } else if (f.type.type === "slice") {
                        res.push(`${name}'${f.name}`);
                    } else if (f.type.type === "builder") {
                        res.push(`${name}'${f.name}`);
                    } else if (f.type.type === "address") {
                        res.push(`${name}'${f.name}`);
                    } else if (f.type.type === "fixed-bytes") {
                        res.push(`${name}'${f.name}`);
                    } else if (f.type.type === "string") {
                        res.push(`${name}'${f.name}`);
                    } else {
                        const t = getType(ctx.ctx, f.type.type);
                        if (f.type.optional ?? t.fields.length === 0) {
                            res.push(`${name}'${f.name}`);
                        } else {
                            const loaded = t.fields.map((v) => v.abi);
                            res.push(
                                resolveFuncTypeFromAbiUnpack(
                                    `${name}'${f.name}`,
                                    loaded,
                                    ctx,
                                ),
                            );
                        }
                    }
                }
                break;
        }
    }
    return `(${res.join(", ")})`;
}


## resolveFuncTypeUnpack.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/resolveFuncTypeUnpack.ts)
import { getType } from "../../types/resolveDescriptors";
import { TypeDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";

export function resolveFuncTypeUnpack(
    descriptor: TypeRef | TypeDescription | string,
    name: string,
    ctx: WriterContext,
    optional: boolean = false,
    usePartialFields: boolean = false,
): string {
    // String
    if (typeof descriptor === "string") {
        return resolveFuncTypeUnpack(
            getType(ctx.ctx, descriptor),
            name,
            ctx,
            false,
            usePartialFields,
        );
    }

    // TypeRef
    if (descriptor.kind === "ref") {
        return resolveFuncTypeUnpack(
            getType(ctx.ctx, descriptor.name),
            name,
            ctx,
            descriptor.optional,
            usePartialFields,
        );
    }
    if (descriptor.kind === "map") {
        return name;
    }
    if (descriptor.kind === "ref_bounced") {
        return resolveFuncTypeUnpack(
            getType(ctx.ctx, descriptor.name),
            name,
            ctx,
            false,
            true,
        );
    }
    if (descriptor.kind === "void") {
        throw Error("Void type is not allowed in function arguments: " + name);
    }

    // TypeDescription
    if (descriptor.kind === "primitive_type_decl") {
        return name;
    } else if (descriptor.kind === "struct") {
        const fieldsToUse = usePartialFields
            ? descriptor.fields.slice(0, descriptor.partialFieldCount)
            : descriptor.fields;
        if (optional || fieldsToUse.length === 0) {
            return name;
        } else {
            return (
                "(" +
                fieldsToUse
                    .map((v) =>
                        resolveFuncTypeUnpack(
                            v.type,
                            name + `'` + v.name,
                            ctx,
                            false,
                            usePartialFields,
                        ),
                    )
                    .join(", ") +
                ")"
            );
        }
    } else if (descriptor.kind === "contract") {
        if (optional || descriptor.fields.length === 0) {
            return name;
        } else {
            return (
                "(" +
                descriptor.fields
                    .map((v) =>
                        resolveFuncTypeUnpack(
                            v.type,
                            name + `'` + v.name,
                            ctx,
                            false,
                            usePartialFields,
                        ),
                    )
                    .join(", ") +
                ")"
            );
        }
    }

    // Unreachable
    throw Error("Unknown type: " + descriptor.kind);
}


## writeAccessors.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeAccessors.ts)
import { contractErrors } from "../../abi/errors";
import { maxTupleSize } from "../../bindings/typescript/writeStruct";
import { ItemOrigin } from "../../grammar";
import { getType } from "../../types/resolveDescriptors";
import { TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
import { ops } from "./ops";
import { resolveFuncFlatPack } from "./resolveFuncFlatPack";
import { resolveFuncFlatTypes } from "./resolveFuncFlatTypes";
import { resolveFuncType } from "./resolveFuncType";
import { resolveFuncTypeUnpack } from "./resolveFuncTypeUnpack";

function chainVars(vars: string[]): string[] {
    // let's say we have vars = ['v1', 'v2, ..., 'v32']
    // we need to split it into chunks of size maxTupleSize - 1
    const chunks: string[][] = [];
    while (vars.length > 0) {
        chunks.push(vars.splice(0, maxTupleSize - 1));
    }
    // and now chain them into a string like this: [v1, v2, ..., v14, [v15, v16, ..., v28, [v29, v30, ..., v32]]
    while (chunks.length > 1) {
        const a = chunks.pop()!;
        chunks[chunks.length - 1]!.push(`[${a.join(", ")}]`);
    }
    return chunks[0]!;
}

export function writeAccessors(
    type: TypeDescription,
    origin: ItemOrigin,
    ctx: WriterContext,
) {
    // Getters
    for (const f of type.fields) {
        ctx.fun(ops.typeField(type.name, f.name, ctx), () => {
            ctx.signature(
                `_ ${ops.typeField(type.name, f.name, ctx)}(${resolveFuncType(type, ctx)} v)`,
            );
            ctx.flag("inline");
            ctx.context("type:" + type.name);
            ctx.body(() => {
                ctx.append(
                    `var (${type.fields.map((v) => `v'${v.name}`).join(", ")}) = v;`,
                );
                ctx.append(`return v'${f.name};`);
            });
        });
    }

    // Tensor cast
    ctx.fun(ops.typeTensorCast(type.name, ctx), () => {
        ctx.signature(
            `(${resolveFuncType(type, ctx)}) ${ops.typeTensorCast(type.name, ctx)}(${resolveFuncType(type, ctx)} v)`,
        );
        ctx.context("type:" + type.name);
        ctx.asm("", "NOP");
    });

    // Not null
    ctx.fun(ops.typeNotNull(type.name, ctx), () => {
        ctx.signature(
            `(${resolveFuncType(type, ctx)}) ${ops.typeNotNull(type.name, ctx)}(tuple v)`,
        );
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            ctx.append(`throw_if(${contractErrors.null.id}, null?(v));`);
            const flatPack = resolveFuncFlatPack(type, "vvv", ctx);
            const flatTypes = resolveFuncFlatTypes(type, ctx);
            if (flatPack.length !== flatTypes.length)
                throw Error("Flat pack and flat types length mismatch");
            const pairs = flatPack.map((v, i) => `${flatTypes[i]} ${v}`);
            if (flatPack.length <= maxTupleSize) {
                ctx.used(`__tact_tuple_destroy_${flatPack.length}`);
                ctx.append(
                    `var (${pairs.join(", ")}) = __tact_tuple_destroy_${flatPack.length}(v);`,
                );
            } else {
                flatPack.splice(0, maxTupleSize - 1);
                const pairsBatch = pairs.splice(0, maxTupleSize - 1);
                ctx.used(`__tact_tuple_destroy_${maxTupleSize}`);
                ctx.append(
                    `var (${pairsBatch.join(", ")}, next) = __tact_tuple_destroy_${maxTupleSize}(v);`,
                );
                while (flatPack.length >= maxTupleSize) {
                    flatPack.splice(0, maxTupleSize - 1);
                    const pairsBatch = pairs.splice(0, maxTupleSize - 1);
                    ctx.append(
                        `var (${pairsBatch.join(", ")}, next) = __tact_tuple_destroy_${maxTupleSize}(next);`,
                    );
                }
                ctx.used(`__tact_tuple_destroy_${flatPack.length}`);
                ctx.append(
                    `var (${pairs.join(", ")}) = __tact_tuple_destroy_${flatPack.length}(next);`,
                );
            }
            ctx.append(`return ${resolveFuncTypeUnpack(type, "vvv", ctx)};`);
        });
    });

    // As optional
    ctx.fun(ops.typeAsOptional(type.name, ctx), () => {
        ctx.signature(
            `tuple ${ops.typeAsOptional(type.name, ctx)}(${resolveFuncType(type, ctx)} v)`,
        );
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            ctx.append(`var ${resolveFuncTypeUnpack(type, "v", ctx)} = v;`);
            const flatPack = resolveFuncFlatPack(type, "v", ctx);
            if (flatPack.length <= maxTupleSize) {
                ctx.used(`__tact_tuple_create_${flatPack.length}`);
                ctx.append(
                    `return __tact_tuple_create_${flatPack.length}(${flatPack.join(", ")});`,
                );
            } else {
                const longTupleFlatPack = chainVars(flatPack);
                ctx.used(`__tact_tuple_create_${longTupleFlatPack.length}`);
                ctx.append(
                    `return __tact_tuple_create_${longTupleFlatPack.length}(${longTupleFlatPack.join(", ")});`,
                );
            }
        });
    });

    //
    // Convert to and from tuple representation
    //

    ctx.fun(ops.typeToTuple(type.name, ctx), () => {
        ctx.signature(
            `tuple ${ops.typeToTuple(type.name, ctx)}((${resolveFuncType(type, ctx)}) v)`,
        );
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            ctx.append(
                `var (${type.fields.map((v) => `v'${v.name}`).join(", ")}) = v;`,
            );
            const vars: string[] = [];
            for (const f of type.fields) {
                if (f.type.kind === "ref") {
                    const t = getType(ctx.ctx, f.type.name);
                    if (t.kind === "struct") {
                        if (f.type.optional) {
                            vars.push(
                                `${ops.typeToOptTuple(f.type.name, ctx)}(v'${f.name})`,
                            );
                        } else {
                            vars.push(
                                `${ops.typeToTuple(f.type.name, ctx)}(v'${f.name})`,
                            );
                        }
                        continue;
                    }
                }
                vars.push(`v'${f.name}`);
            }
            if (vars.length <= maxTupleSize) {
                ctx.used(`__tact_tuple_create_${vars.length}`);
                ctx.append(
                    `return __tact_tuple_create_${vars.length}(${vars.join(", ")});`,
                );
            } else {
                const longTupleVars = chainVars(vars);
                ctx.used(`__tact_tuple_create_${longTupleVars.length}`);
                ctx.append(
                    `return __tact_tuple_create_${longTupleVars.length}(${longTupleVars.join(", ")});`,
                );
            }
        });
    });

    ctx.fun(ops.typeToOptTuple(type.name, ctx), () => {
        ctx.signature(`tuple ${ops.typeToOptTuple(type.name, ctx)}(tuple v)`);
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            ctx.append(`if (null?(v)) { return null(); } `);
            ctx.append(
                `return ${ops.typeToTuple(type.name, ctx)}(${ops.typeNotNull(type.name, ctx)}(v)); `,
            );
        });
    });

    ctx.fun(ops.typeFromTuple(type.name, ctx), () => {
        ctx.signature(
            `(${type.fields.map((v) => resolveFuncType(v.type, ctx)).join(", ")}) ${ops.typeFromTuple(type.name, ctx)}(tuple v)`,
        );
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            // Resolve vars
            const vars: string[] = [];
            const out: string[] = [];
            for (const f of type.fields) {
                if (f.type.kind === "ref") {
                    const t = getType(ctx.ctx, f.type.name);
                    if (t.kind === "struct") {
                        vars.push(`tuple v'${f.name}`);
                        if (f.type.optional) {
                            out.push(
                                `${ops.typeFromOptTuple(f.type.name, ctx)}(v'${f.name})`,
                            );
                        } else {
                            out.push(
                                `${ops.typeFromTuple(f.type.name, ctx)}(v'${f.name})`,
                            );
                        }
                        continue;
                    } else if (
                        t.kind === "primitive_type_decl" &&
                        t.name === "Address"
                    ) {
                        vars.push(
                            `${resolveFuncType(f.type, ctx)} v'${f.name}`,
                        );
                        out.push(`v'${f.name}`);
                        continue;
                    }
                }
                vars.push(`${resolveFuncType(f.type, ctx)} v'${f.name}`);
                out.push(`v'${f.name}`);
            }
            if (vars.length <= maxTupleSize) {
                ctx.used(`__tact_tuple_destroy_${vars.length}`);
                ctx.append(
                    `var (${vars.join(", ")}) = __tact_tuple_destroy_${vars.length}(v);`,
                );
            } else {
                const batch = vars.splice(0, maxTupleSize - 1);
                ctx.used(`__tact_tuple_destroy_${maxTupleSize}`);
                ctx.append(
                    `var (${batch.join(", ")}, next) = __tact_tuple_destroy_${maxTupleSize}(v);`,
                );
                while (vars.length >= maxTupleSize) {
                    const batch = vars.splice(0, maxTupleSize - 1);
                    ctx.used(`__tact_tuple_destroy_${maxTupleSize}`);
                    ctx.append(
                        `var (${batch.join(", ")}, next) = __tact_tuple_destroy_${maxTupleSize}(next);`,
                    );
                }
                ctx.used(`__tact_tuple_destroy_${vars.length}`);
                ctx.append(
                    `var (${batch.join(", ")}) = __tact_tuple_destroy_${vars.length}(next);`,
                );
            }
            ctx.append(`return (${out.join(", ")});`);
        });
    });

    ctx.fun(ops.typeFromOptTuple(type.name, ctx), () => {
        ctx.signature(`tuple ${ops.typeFromOptTuple(type.name, ctx)}(tuple v)`);
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            ctx.append(`if (null?(v)) { return null(); } `);
            ctx.append(
                `return ${ops.typeAsOptional(type.name, ctx)}(${ops.typeFromTuple(type.name, ctx)}(v));`,
            );
        });
    });

    //
    // Convert to and from external representation
    //

    ctx.fun(ops.typeToExternal(type.name, ctx), () => {
        ctx.signature(
            `(${type.fields.map((f) => resolveFuncType(f.type, ctx)).join(", ")}) ${ops.typeToExternal(type.name, ctx)}((${resolveFuncType(type, ctx)}) v)`,
        );
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            ctx.append(
                `var (${type.fields.map((v) => `v'${v.name}`).join(", ")}) = v; `,
            );
            const vars: string[] = [];
            for (const f of type.fields) {
                vars.push(`v'${f.name}`);
            }
            ctx.append(`return (${vars.join(", ")});`);
        });
    });

    ctx.fun(ops.typeToOptExternal(type.name, ctx), () => {
        ctx.signature(
            `tuple ${ops.typeToOptExternal(type.name, ctx)}(tuple v)`,
        );
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            ctx.append(
                `var loaded = ${ops.typeToOptTuple(type.name, ctx)}(v);`,
            );
            ctx.append(`if (null?(loaded)) {`);
            ctx.inIndent(() => {
                ctx.append(`return null();`);
            });
            ctx.append(`} else {`);
            ctx.inIndent(() => {
                ctx.append(`return (loaded);`);
            });
            ctx.append(`}`);
        });
    });
}


## writeConstant.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeConstant.ts)
import { Address, beginCell, Cell, Slice } from "@ton/core";
import { WriterContext } from "../Writer";

export function writeString(str: string, ctx: WriterContext) {
    const cell = beginCell().storeStringTail(str).endCell();
    return writeRawSlice("string", `String "${str}"`, cell, ctx);
}

export function writeComment(str: string, ctx: WriterContext) {
    const cell = beginCell().storeUint(0, 32).storeStringTail(str).endCell();
    return writeRawCell("comment", `Comment "${str}"`, cell, ctx);
}

export function writeAddress(address: Address, ctx: WriterContext) {
    return writeRawSlice(
        "address",
        address.toString(),
        beginCell().storeAddress(address).endCell(),
        ctx,
    );
}

export function writeCell(cell: Cell, ctx: WriterContext) {
    return writeRawCell(
        "cell",
        "Cell " + cell.hash().toString("base64"),
        cell,
        ctx,
    );
}

export function writeSlice(slice: Slice, ctx: WriterContext) {
    const cell = slice.asCell();
    return writeRawSlice(
        "slice",
        "Slice " + cell.hash().toString("base64"),
        cell,
        ctx,
    );
}

function writeRawSlice(
    prefix: string,
    comment: string,
    cell: Cell,
    ctx: WriterContext,
) {
    const h = cell.hash().toString("hex");
    const t = cell.toBoc({ idx: false }).toString("hex");
    const k = "slice:" + prefix + ":" + h;
    if (ctx.isRendered(k)) {
        return `__gen_slice_${prefix}_${h}`;
    }
    ctx.markRendered(k);
    ctx.fun(`__gen_slice_${prefix}_${h}`, () => {
        ctx.signature(`slice __gen_slice_${prefix}_${h}()`);
        ctx.comment(comment);
        ctx.context("constants");
        ctx.asm("", `B{${t}} B>boc <s PUSHSLICE`);
    });
    return `__gen_slice_${prefix}_${h}`;
}

function writeRawCell(
    prefix: string,
    comment: string,
    cell: Cell,
    ctx: WriterContext,
) {
    const h = cell.hash().toString("hex");
    const t = cell.toBoc({ idx: false }).toString("hex");
    const k = "cell:" + prefix + ":" + h;
    if (ctx.isRendered(k)) {
        return `__gen_cell_${prefix}_${h}`;
    }
    ctx.markRendered(k);
    ctx.fun(`__gen_cell_${prefix}_${h}`, () => {
        ctx.signature(`cell __gen_cell_${prefix}_${h}()`);
        ctx.comment(comment);
        ctx.context("constants");
        ctx.asm("", `B{${t}} B>boc PUSHREF`);
    });
    return `__gen_cell_${prefix}_${h}`;
}


## writeContract.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeContract.ts)
import { contractErrors } from "../../abi/errors";
import {
    enabledInline,
    enabledInterfacesGetter,
    enabledIpfsAbiGetter,
} from "../../config/features";
import { ItemOrigin } from "../../grammar";
import { InitDescription, TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
import { funcIdOf, funcInitIdOf } from "./id";
import { ops } from "./ops";
import { resolveFuncPrimitive } from "./resolveFuncPrimitive";
import { resolveFuncType } from "./resolveFuncType";
import { resolveFuncTypeUnpack } from "./resolveFuncTypeUnpack";
import { writeValue } from "./writeExpression";
import { writeGetter, writeStatement } from "./writeFunction";
import { writeInterfaces } from "./writeInterfaces";
import { writeReceiver, writeRouter } from "./writeRouter";

export function writeStorageOps(
    type: TypeDescription,
    origin: ItemOrigin,
    ctx: WriterContext,
) {
    // Load function
    ctx.fun(ops.contractLoad(type.name, ctx), () => {
        ctx.signature(
            `${resolveFuncType(type, ctx)} ${ops.contractLoad(type.name, ctx)}()`,
        );
        ctx.flag("impure");
        // ctx.flag('inline');
        ctx.context("type:" + type.name + "$init");
        ctx.body(() => {
            // Load data slice
            ctx.append(`slice $sc = get_data().begin_parse();`);

            // Load context
            ctx.append(`__tact_context_sys = $sc~load_ref();`);
            ctx.append(`int $loaded = $sc~load_int(1);`);

            // Load data
            ctx.append(`if ($loaded) {`);
            ctx.inIndent(() => {
                if (type.fields.length > 0) {
                    ctx.append(`return $sc~${ops.reader(type.name, ctx)}();`);
                } else {
                    ctx.append(`return null();`);
                }
            });
            ctx.append(`} else {`);
            ctx.inIndent(() => {
                // Load arguments
                if (type.init!.params.length > 0) {
                    ctx.append(
                        `(${type.init!.params.map((v) => resolveFuncType(v.type, ctx) + " " + funcIdOf(v.name)).join(", ")}) = $sc~${ops.reader(funcInitIdOf(type.name), ctx)}();`,
                    );
                    ctx.append(`$sc.end_parse();`);
                }

                // Execute init function
                ctx.append(
                    `return ${ops.contractInit(type.name, ctx)}(${[...type.init!.params.map((v) => funcIdOf(v.name))].join(", ")});`,
                );
            });

            ctx.append(`}`);
        });
    });

    // Store function
    ctx.fun(ops.contractStore(type.name, ctx), () => {
        const sig = `() ${ops.contractStore(type.name, ctx)}(${resolveFuncType(type, ctx)} v)`;
        ctx.signature(sig);
        ctx.flag("impure");
        ctx.flag("inline");
        ctx.context("type:" + type.name + "$init");
        ctx.body(() => {
            ctx.append(`builder b = begin_cell();`);

            // Persist system cell
            ctx.append(`b = b.store_ref(__tact_context_sys);`);

            // Persist deployment flag
            ctx.append(`b = b.store_int(true, 1);`);

            // Build data
            if (type.fields.length > 0) {
                ctx.append(`b = ${ops.writer(type.name, ctx)}(b, v);`);
            }

            // Persist data
            ctx.append(`set_data(b.end_cell());`);
        });
    });
}

export function writeInit(
    t: TypeDescription,
    init: InitDescription,
    ctx: WriterContext,
) {
    ctx.fun(ops.contractInit(t.name, ctx), () => {
        const args = init.params.map(
            (v) => resolveFuncType(v.type, ctx) + " " + funcIdOf(v.name),
        );
        const sig = `${resolveFuncType(t, ctx)} ${ops.contractInit(t.name, ctx)}(${args.join(", ")})`;
        ctx.signature(sig);
        ctx.flag("impure");
        ctx.body(() => {
            // Unpack parameters
            for (const a of init.params) {
                if (!resolveFuncPrimitive(a.type, ctx)) {
                    ctx.append(
                        `var (${resolveFuncTypeUnpack(a.type, funcIdOf(a.name), ctx)}) = ${funcIdOf(a.name)};`,
                    );
                }
            }

            // Generate self initial tensor
            const initValues: string[] = [];
            t.fields.forEach((tField) => {
                let init = "null()";
                if (tField.default !== undefined) {
                    init = writeValue(tField.default!, ctx);
                }
                initValues.push(init);
            });
            if (initValues.length > 0) {
                // Special case for empty contracts
                ctx.append(
                    `var (${resolveFuncTypeUnpack(t, funcIdOf("self"), ctx)}) = (${initValues.join(", ")});`,
                );
            } else {
                ctx.append(`tuple ${funcIdOf("self")} = null();`);
            }

            // Generate statements
            const returns = resolveFuncTypeUnpack(t, funcIdOf("self"), ctx);
            for (const s of init.ast.statements) {
                if (s.kind === "statement_return") {
                    ctx.append(`return ${returns};`);
                } else {
                    writeStatement(s, returns, null, ctx);
                }
            }

            // Return result
            if (
                init.ast.statements.length === 0 ||
                init.ast.statements[init.ast.statements.length - 1]!.kind !==
                    "statement_return"
            ) {
                ctx.append(`return ${returns};`);
            }
        });
    });

    ctx.fun(ops.contractInitChild(t.name, ctx), () => {
        const args = [
            `cell sys'`,
            ...init.params.map(
                (v) => resolveFuncType(v.type, ctx) + " " + funcIdOf(v.name),
            ),
        ];
        const sig = `(cell, cell) ${ops.contractInitChild(t.name, ctx)}(${args.join(", ")})`;
        ctx.signature(sig);
        if (enabledInline(ctx.ctx)) {
            ctx.flag("inline");
        }
        ctx.context("type:" + t.name + "$init");
        ctx.body(() => {
            ctx.write(`
                slice sc' = sys'.begin_parse();
                cell source = sc'~load_dict();
                cell contracts = new_dict();

                ;; Contract Code: ${t.name}
                cell mine = ${ctx.used(`__tact_dict_get_code`)}(source, ${t.uid});
                contracts = ${ctx.used(`__tact_dict_set_code`)}(contracts, ${t.uid}, mine);
            `);

            // Copy contracts code
            for (const c of t.dependsOn) {
                ctx.append();
                ctx.write(`
                ;; Contract Code: ${c.name}
                cell code_${c.uid} = __tact_dict_get_code(source, ${c.uid});
                contracts = ${ctx.used(`__tact_dict_set_code`)}(contracts, ${c.uid}, code_${c.uid});
            `);
            }

            // Build cell
            ctx.append();
            ctx.append(`;; Build cell`);
            ctx.append(`builder b = begin_cell();`);
            ctx.append(
                `b = b.store_ref(begin_cell().store_dict(contracts).end_cell());`,
            );
            ctx.append(`b = b.store_int(false, 1);`);
            const args =
                t.init!.params.length > 0
                    ? [
                          "b",
                          "(" +
                              t
                                  .init!.params.map((a) => funcIdOf(a.name))
                                  .join(", ") +
                              ")",
                      ].join(", ")
                    : "b, null()";
            ctx.append(
                `b = ${ops.writer(funcInitIdOf(t.name), ctx)}(${args});`,
            );
            ctx.append(`return (mine, b.end_cell());`);
        });
    });
}

export function writeMainContract(
    type: TypeDescription,
    abiLink: string,
    ctx: WriterContext,
) {
    // Main field
    ctx.main(() => {
        // Comments
        ctx.append(`;;`);
        ctx.append(`;; Receivers of a Contract ${type.name}`);
        ctx.append(`;;`);
        ctx.append(``);

        // Write receivers
        for (const r of type.receivers) {
            writeReceiver(type, r, ctx);
        }

        // Comments
        ctx.append(`;;`);
        ctx.append(`;; Get methods of a Contract ${type.name}`);
        ctx.append(`;;`);
        ctx.append(``);

        // Getters
        for (const f of type.functions.values()) {
            if (f.isGetter) {
                writeGetter(f, ctx);
            }
        }

        // Interfaces
        if (enabledInterfacesGetter(ctx.ctx)) {
            writeInterfaces(type, ctx);
        }

        // ABI
        if (enabledIpfsAbiGetter(ctx.ctx)) {
            ctx.append(`_ get_abi_ipfs() method_id {`);
            ctx.inIndent(() => {
                ctx.append(`return "${abiLink}";`);
            });
            ctx.append(`}`);
            ctx.append();
        }

        // Deployed
        ctx.append(`_ lazy_deployment_completed() method_id {`);
        ctx.inIndent(() => {
            ctx.append(`return get_data().begin_parse().load_int(1);`);
        });
        ctx.append(`}`);
        ctx.append();

        // Comments
        ctx.append(`;;`);
        ctx.append(`;; Routing of a Contract ${type.name}`);
        ctx.append(`;;`);
        ctx.append(``);

        // Render body
        const hasExternal = type.receivers.find((v) =>
            v.selector.kind.startsWith("external-"),
        );
        writeRouter(type, "internal", ctx);
        if (hasExternal) {
            writeRouter(type, "external", ctx);
        }

        // Render internal receiver
        ctx.append(
            `() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {`,
        );
        ctx.inIndent(() => {
            // Load context
            ctx.append();
            ctx.append(`;; Context`);
            ctx.append(`var cs = in_msg_cell.begin_parse();`);
            ctx.append(`var msg_flags = cs~load_uint(4);`); // int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
            ctx.append(`var msg_bounced = -(msg_flags & 1);`);
            ctx.append(`slice msg_sender_addr = cs~load_msg_addr();`);
            ctx.append(
                `__tact_context = (msg_bounced, msg_sender_addr, msg_value, cs);`,
            );
            ctx.append(`__tact_context_sender = msg_sender_addr;`);
            ctx.append();

            // Load self
            ctx.append(`;; Load contract data`);
            ctx.append(`var self = ${ops.contractLoad(type.name, ctx)}();`);
            ctx.append();

            // Process operation
            ctx.append(`;; Handle operation`);
            ctx.append(
                `int handled = self~${ops.contractRouter(type.name, "internal")}(msg_bounced, in_msg);`,
            );
            ctx.append();

            // Throw if not handled
            ctx.append(`;; Throw if not handled`);
            ctx.append(
                `throw_unless(${contractErrors.invalidMessage.id}, handled);`,
            );
            ctx.append();

            // Persist state
            ctx.append(`;; Persist state`);
            ctx.append(`${ops.contractStore(type.name, ctx)}(self);`);
        });
        ctx.append("}");
        ctx.append();

        // Render external receiver
        if (hasExternal) {
            ctx.append(`() recv_external(slice in_msg) impure {`);
            ctx.inIndent(() => {
                // Load self
                ctx.append(`;; Load contract data`);
                ctx.append(`var self = ${ops.contractLoad(type.name, ctx)}();`);
                ctx.append();

                // Process operation
                ctx.append(`;; Handle operation`);
                ctx.append(
                    `int handled = self~${ops.contractRouter(type.name, "external")}(in_msg);`,
                );
                ctx.append();

                // Throw if not handled
                ctx.append(`;; Throw if not handled`);
                ctx.append(
                    `throw_unless(${contractErrors.invalidMessage.id}, handled);`,
                );
                ctx.append();

                // Persist state
                ctx.append(`;; Persist state`);
                ctx.append(`${ops.contractStore(type.name, ctx)}(self);`);
            });
            ctx.append("}");
            ctx.append();
        }
    });
}


## writeExpression.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeExpression.spec.ts)
import {
    getStaticFunction,
    resolveDescriptors,
} from "../../types/resolveDescriptors";
import { WriterContext } from "../Writer";
import { writeExpression } from "./writeExpression";
import { openContext } from "../../grammar/store";
import { resolveStatements } from "../../types/resolveStatements";
import { CompilerContext } from "../../context";
import { getParser } from "../../grammar";
import { getAstFactory } from "../../grammar/ast";

const code = `

primitive Int;
primitive Bool;
primitive Builder;
primitive Cell;
primitive Slice;

fun f1(a: Int): Int {
    return a;
}

struct A {
    a: Int;
    b: Int;
}

fun main() {
    let a: Int = 1;
    let b: Int = 2;
    let c: Int = a + b;
    let d: Int = a + b * c;
    let e: Int = a + b / c;
    let f: Bool = true;
    let g: Bool = false;
    let h: Bool = a > 1 || b < 2 && c == 3 || !(d != 4 && true && !false);
    let i: Int = f1(a);
    let j: A = A{a: 1, b: 2};
    let k: Int = j.a;
    let l: Int = A{a: 1, b}.b;
    let m: Int = -j.b + a;
    let n: Int = -j.b + a + (+b);
    let o: Int? = null;
    let p: Int? = o!! + 1;
    let q: Cell = j.toCell();
}
`;

const golden: string[] = [
    "1",
    "2",
    "($a + $b)",
    "($a + ($b * $c))",
    "($a + ($b / $c))",
    "true",
    "false",
    "( (( (($a > 1)) ? (true) : (( (($b < 2)) ? (($c == 3)) : (false) )) )) ? (true) : ((~ ( (( (($d != 4)) ? (true) : (false) )) ? (true) : (false) ))) )",
    "$global_f1($a)",
    "$A$_constructor_a_b(1, 2)",
    `$j'a`,
    "$A$_get_b($A$_constructor_a_b(1, $b))",
    `((- $j'b) + $a)`,
    `(((- $j'b) + $a) + (+ $b))`,
    "null()",
    "(__tact_not_null($o) + 1)",
    `$A$_store_cell(($j'a, $j'b))`,
];

describe("writeExpression", () => {
    it("should write expression", () => {
        const ast = getAstFactory();
        let ctx = openContext(
            new CompilerContext(),
            [{ code: code, path: "<unknown>", origin: "user" }],
            [],
            getParser(ast),
        );
        ctx = resolveDescriptors(ctx, ast);
        ctx = resolveStatements(ctx);
        const main = getStaticFunction(ctx, "main");
        if (main.ast.kind !== "function_def") {
            throw Error("Unexpected function kind");
        }
        let i = 0;
        for (const s of main.ast.statements) {
            if (s.kind !== "statement_let") {
                throw Error("Unexpected statement kind");
            }
            const wCtx = new WriterContext(ctx, "Contract1");
            wCtx.fun("$main", () => {
                wCtx.body(() => {
                    expect(writeExpression(s.expression, wCtx)).toBe(
                        golden[i]!,
                    );
                });
            });
            i++;
        }
    });
});


## writeExpression.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeExpression.ts)
import {
    AstExpression,
    AstId,
    eqNames,
    idText,
    tryExtractPath,
} from "../../grammar/ast";
import {
    idTextErr,
    TactConstEvalError,
    throwCompilationError,
} from "../../errors";
import { getExpType } from "../../types/resolveExpression";
import {
    getStaticConstant,
    getStaticFunction,
    getType,
    hasStaticConstant,
} from "../../types/resolveDescriptors";
import {
    FieldDescription,
    printTypeRef,
    TypeDescription,
    CommentValue,
    Value,
} from "../../types/types";
import { WriterContext } from "../Writer";
import { resolveFuncTypeUnpack } from "./resolveFuncTypeUnpack";
import { MapFunctions } from "../../abi/map";
import { GlobalFunctions } from "../../abi/global";
import { funcIdOf } from "./id";
import { StructFunctions } from "../../abi/struct";
import { resolveFuncType } from "./resolveFuncType";
import { Address, Cell, Slice } from "@ton/core";
import {
    writeAddress,
    writeCell,
    writeComment,
    writeSlice,
    writeString,
} from "./writeConstant";
import { ops } from "./ops";
import { writeCastedExpression } from "./writeFunction";
import { evalConstantExpression } from "../../constEval";
import { isLvalue } from "../../types/resolveStatements";

function isNull(wCtx: WriterContext, expr: AstExpression): boolean {
    return getExpType(wCtx.ctx, expr).kind === "null";
}

function writeStructConstructor(
    type: TypeDescription,
    args: string[],
    ctx: WriterContext,
) {
    // Check for duplicates
    const name = ops.typeConstructor(type.name, args, ctx);
    const renderKey = "$constructor$" + type.name + "$" + args.join(",");
    if (ctx.isRendered(renderKey)) {
        return name;
    }
    ctx.markRendered(renderKey);

    // Generate constructor
    ctx.fun(name, () => {
        const funcType = resolveFuncType(type, ctx);
        // rename a struct constructor formal parameter to avoid
        // name clashes with FunC keywords, e.g. `struct Foo {type: Int}`
        // is a perfectly fine Tact structure, but its constructor would
        // have the wrong parameter name: `$Foo$_constructor_type(int type)`
        const avoidFunCKeywordNameClash = (p: string) => `$${p}`;
        const sig = `(${funcType}) ${name}(${args.map((v) => resolveFuncType(type.fields.find((v2) => v2.name === v)!.type, ctx) + " " + avoidFunCKeywordNameClash(v)).join(", ")})`;
        ctx.signature(sig);
        ctx.flag("inline");
        ctx.context("type:" + type.name);
        ctx.body(() => {
            // Create expressions
            const expressions = type.fields.map((v) => {
                const arg = args.find((v2) => v2 === v.name);
                if (arg) {
                    return avoidFunCKeywordNameClash(arg);
                } else if (v.default !== undefined) {
                    return writeValue(v.default, ctx);
                } else {
                    throw Error(
                        `Missing argument for field "${v.name}" in struct "${type.name}"`,
                    ); // Must not happen
                }
            }, ctx);

            if (expressions.length === 0 && funcType === "tuple") {
                ctx.append(`return empty_tuple();`);
            } else {
                ctx.append(`return (${expressions.join(", ")});`);
            }
        });
    });
    return name;
}

export function writeValue(val: Value, wCtx: WriterContext): string {
    if (typeof val === "bigint") {
        return val.toString(10);
    }
    if (typeof val === "string") {
        const id = writeString(val, wCtx);
        wCtx.used(id);
        return `${id}()`;
    }
    if (typeof val === "boolean") {
        return val ? "true" : "false";
    }
    if (Address.isAddress(val)) {
        const res = writeAddress(val, wCtx);
        wCtx.used(res);
        return res + "()";
    }
    if (val instanceof Cell) {
        const res = writeCell(val, wCtx);
        wCtx.used(res);
        return `${res}()`;
    }
    if (val instanceof Slice) {
        const res = writeSlice(val, wCtx);
        wCtx.used(res);
        return `${res}()`;
    }
    if (val === null) {
        return "null()";
    }
    if (val instanceof CommentValue) {
        const id = writeComment(val.comment, wCtx);
        wCtx.used(id);
        return `${id}()`;
    }
    if (typeof val === "object" && "$tactStruct" in val) {
        // this is a struct value
        const structDescription = getType(
            wCtx.ctx,
            val["$tactStruct"] as string,
        );
        const fields = structDescription.fields.map((field) => field.name);
        const id = writeStructConstructor(structDescription, fields, wCtx);
        wCtx.used(id);
        const fieldValues = structDescription.fields.map((field) => {
            if (field.name in val) {
                if (field.type.kind === "ref" && field.type.optional) {
                    const ft = getType(wCtx.ctx, field.type.name);
                    if (ft.kind === "struct" && val[field.name] !== null) {
                        return `${ops.typeAsOptional(ft.name, wCtx)}(${writeValue(val[field.name]!, wCtx)})`;
                    }
                }
                return writeValue(val[field.name]!, wCtx);
            } else {
                throw Error(
                    `Struct value is missing a field: ${field.name}`,
                    val,
                );
            }
        });
        return `${id}(${fieldValues.join(", ")})`;
    }
    throw Error("Invalid value", val);
}

export function writePathExpression(path: AstId[]): string {
    return [funcIdOf(idText(path[0]!)), ...path.slice(1).map(idText)].join(`'`);
}

export function writeExpression(f: AstExpression, wCtx: WriterContext): string {
    // literals and constant expressions are covered here
    try {
        // Let us put a limit of 2 ^ 12 = 4096 iterations on loops to increase compiler responsiveness.
        // If a loop takes more than such number of iterations, the interpreter will fail evaluation.
        // I think maxLoopIterations should be a command line option in case a user wants to wait more
        // during evaluation.
        const value = evalConstantExpression(f, wCtx.ctx, {
            maxLoopIterations: 2n ** 12n,
        });
        return writeValue(value, wCtx);
    } catch (error) {
        if (!(error instanceof TactConstEvalError) || error.fatal) throw error;
    }

    //
    // ID Reference
    //

    if (f.kind === "id") {
        const t = getExpType(wCtx.ctx, f);

        // Handle packed type
        if (t.kind === "ref") {
            const tt = getType(wCtx.ctx, t.name);
            if (tt.kind === "contract" || tt.kind === "struct") {
                return resolveFuncTypeUnpack(t, funcIdOf(f.text), wCtx);
            }
        }

        if (t.kind === "ref_bounced") {
            const tt = getType(wCtx.ctx, t.name);
            if (tt.kind === "struct") {
                return resolveFuncTypeUnpack(
                    t,
                    funcIdOf(f.text),
                    wCtx,
                    false,
                    true,
                );
            }
        }

        // Handle constant
        if (hasStaticConstant(wCtx.ctx, f.text)) {
            const c = getStaticConstant(wCtx.ctx, f.text);
            return writeValue(c.value!, wCtx);
        }

        return funcIdOf(f.text);
    }

    // NOTE: We always wrap expressions in parentheses to avoid operator precedence issues
    if (f.kind === "op_binary") {
        // Special case for non-integer types and nullable
        if (f.op === "==" || f.op === "!=") {
            if (isNull(wCtx, f.left) && isNull(wCtx, f.right)) {
                if (f.op === "==") {
                    return "true";
                } else {
                    return "false";
                }
            } else if (isNull(wCtx, f.left) && !isNull(wCtx, f.right)) {
                if (f.op === "==") {
                    return `null?(${writeExpression(f.right, wCtx)})`;
                } else {
                    return `(~ null?(${writeExpression(f.right, wCtx)}))`;
                }
            } else if (!isNull(wCtx, f.left) && isNull(wCtx, f.right)) {
                if (f.op === "==") {
                    return `null?(${writeExpression(f.left, wCtx)})`;
                } else {
                    return `(~ null?(${writeExpression(f.left, wCtx)}))`;
                }
            }
        }

        // Special case for address
        const lt = getExpType(wCtx.ctx, f.left);
        const rt = getExpType(wCtx.ctx, f.right);

        // Case for addresses equality
        if (
            lt.kind === "ref" &&
            rt.kind === "ref" &&
            lt.name === "Address" &&
            rt.name === "Address"
        ) {
            let prefix = "";
            if (f.op == "!=") {
                prefix = "~ ";
            }
            if (lt.optional && rt.optional) {
                wCtx.used(`__tact_slice_eq_bits_nullable`);
                return `( ${prefix}__tact_slice_eq_bits_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)}) )`;
            }
            if (lt.optional && !rt.optional) {
                wCtx.used(`__tact_slice_eq_bits_nullable_one`);
                return `( ${prefix}__tact_slice_eq_bits_nullable_one(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)}) )`;
            }
            if (!lt.optional && rt.optional) {
                wCtx.used(`__tact_slice_eq_bits_nullable_one`);
                return `( ${prefix}__tact_slice_eq_bits_nullable_one(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)}) )`;
            }
            wCtx.used(`__tact_slice_eq_bits`);
            return `( ${prefix}__tact_slice_eq_bits(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)}) )`;
        }

        // Case for cells equality
        if (
            lt.kind === "ref" &&
            rt.kind === "ref" &&
            lt.name === "Cell" &&
            rt.name === "Cell"
        ) {
            const op = f.op === "==" ? "eq" : "neq";
            if (lt.optional && rt.optional) {
                wCtx.used(`__tact_cell_${op}_nullable`);
                return `__tact_cell_${op}_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (lt.optional && !rt.optional) {
                wCtx.used(`__tact_cell_${op}_nullable_one`);
                return `__tact_cell_${op}_nullable_one(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (!lt.optional && rt.optional) {
                wCtx.used(`__tact_cell_${op}_nullable_one`);
                return `__tact_cell_${op}_nullable_one(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
            }
            wCtx.used(`__tact_cell_${op}`);
            return `__tact_cell_${op}(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
        }

        // Case for slices and strings equality
        if (
            lt.kind === "ref" &&
            rt.kind === "ref" &&
            lt.name === rt.name &&
            (lt.name === "Slice" || lt.name === "String")
        ) {
            const op = f.op === "==" ? "eq" : "neq";
            if (lt.optional && rt.optional) {
                wCtx.used(`__tact_slice_${op}_nullable`);
                return `__tact_slice_${op}_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (lt.optional && !rt.optional) {
                wCtx.used(`__tact_slice_${op}_nullable_one`);
                return `__tact_slice_${op}_nullable_one(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (!lt.optional && rt.optional) {
                wCtx.used(`__tact_slice_${op}_nullable_one`);
                return `__tact_slice_${op}_nullable_one(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
            }
            wCtx.used(`__tact_slice_${op}`);
            return `__tact_slice_${op}(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
        }

        // Case for maps equality
        if (lt.kind === "map" && rt.kind === "map") {
            const op = f.op === "==" ? "eq" : "neq";
            wCtx.used(`__tact_cell_${op}_nullable`);
            return `__tact_cell_${op}_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
        }

        // Check for int or boolean types
        if (
            lt.kind !== "ref" ||
            rt.kind !== "ref" ||
            (lt.name !== "Int" && lt.name !== "Bool") ||
            (rt.name !== "Int" && rt.name !== "Bool")
        ) {
            const file = f.loc.file;
            const loc_info = f.loc.interval.getLineAndColumn();
            throw Error(
                `(Internal Compiler Error) Invalid types for binary operation: ${file}:${loc_info.lineNum}:${loc_info.colNum}`,
            ); // Should be unreachable
        }

        // Case for ints equality
        if (f.op === "==" || f.op === "!=") {
            const op = f.op === "==" ? "eq" : "neq";
            if (lt.optional && rt.optional) {
                wCtx.used(`__tact_int_${op}_nullable`);
                return `__tact_int_${op}_nullable(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (lt.optional && !rt.optional) {
                wCtx.used(`__tact_int_${op}_nullable_one`);
                return `__tact_int_${op}_nullable_one(${writeExpression(f.left, wCtx)}, ${writeExpression(f.right, wCtx)})`;
            }
            if (!lt.optional && rt.optional) {
                wCtx.used(`__tact_int_${op}_nullable_one`);
                return `__tact_int_${op}_nullable_one(${writeExpression(f.right, wCtx)}, ${writeExpression(f.left, wCtx)})`;
            }
            if (f.op === "==") {
                return `(${writeExpression(f.left, wCtx)} == ${writeExpression(f.right, wCtx)})`;
            } else {
                return `(${writeExpression(f.left, wCtx)} != ${writeExpression(f.right, wCtx)})`;
            }
        }

        // Case for "&&" operator
        if (f.op === "&&") {
            return `( (${writeExpression(f.left, wCtx)}) ? (${writeExpression(f.right, wCtx)}) : (false) )`;
        }

        // Case for "||" operator
        if (f.op === "||") {
            return `( (${writeExpression(f.left, wCtx)}) ? (true) : (${writeExpression(f.right, wCtx)}) )`;
        }

        // Other ops
        return (
            "(" +
            writeExpression(f.left, wCtx) +
            " " +
            f.op +
            " " +
            writeExpression(f.right, wCtx) +
            ")"
        );
    }

    //
    // Unary operations: !, -, +, !!
    // NOTE: We always wrap expressions in parentheses to avoid operator precedence issues
    //

    if (f.kind === "op_unary") {
        // NOTE: Logical not is written as a bitwise not
        switch (f.op) {
            case "!": {
                return "(~ " + writeExpression(f.operand, wCtx) + ")";
            }

            case "~": {
                return "(~ " + writeExpression(f.operand, wCtx) + ")";
            }

            case "-": {
                return "(- " + writeExpression(f.operand, wCtx) + ")";
            }

            case "+": {
                return "(+ " + writeExpression(f.operand, wCtx) + ")";
            }

            // NOTE: Assert function that ensures that the value is not null
            case "!!": {
                const t = getExpType(wCtx.ctx, f.operand);
                if (t.kind === "ref") {
                    const tt = getType(wCtx.ctx, t.name);
                    if (tt.kind === "struct") {
                        return `${ops.typeNotNull(tt.name, wCtx)}(${writeExpression(f.operand, wCtx)})`;
                    }
                }

                wCtx.used("__tact_not_null");
                return `${wCtx.used("__tact_not_null")}(${writeExpression(f.operand, wCtx)})`;
            }
        }
    }

    //
    // Field Access
    // NOTE: this branch resolves "a.b", where "a" is an expression and "b" is a field name
    //

    if (f.kind === "field_access") {
        // Resolve the type of the expression
        const src = getExpType(wCtx.ctx, f.aggregate);
        if (
            (src.kind !== "ref" || src.optional) &&
            src.kind !== "ref_bounced"
        ) {
            throwCompilationError(
                `Cannot access field of non-struct type: "${printTypeRef(src)}"`,
                f.loc,
            );
        }
        const srcT = getType(wCtx.ctx, src.name);

        // Resolve field
        let fields: FieldDescription[];

        fields = srcT.fields;
        if (src.kind === "ref_bounced") {
            fields = fields.slice(0, srcT.partialFieldCount);
        }

        const field = fields.find((v) => eqNames(v.name, f.field));
        const cst = srcT.constants.find((v) => eqNames(v.name, f.field));
        if (!field && !cst) {
            throwCompilationError(
                `Cannot find field ${idTextErr(f.field)} in struct ${idTextErr(srcT.name)}`,
                f.field.loc,
            );
        }

        if (field) {
            // Trying to resolve field as a path
            const path = tryExtractPath(f);
            if (path) {
                // Prepare path
                const idd = writePathExpression(path);

                // Special case for structs
                if (field.type.kind === "ref") {
                    const ft = getType(wCtx.ctx, field.type.name);
                    if (ft.kind === "struct" || ft.kind === "contract") {
                        return resolveFuncTypeUnpack(field.type, idd, wCtx);
                    }
                }

                return idd;
            }

            // Getter instead of direct field access
            return `${ops.typeField(srcT.name, field.name, wCtx)}(${writeExpression(f.aggregate, wCtx)})`;
        } else {
            return writeValue(cst!.value!, wCtx);
        }
    }

    //
    // Static Function Call
    //

    if (f.kind === "static_call") {
        // Check global functions
        if (GlobalFunctions.has(idText(f.function))) {
            return GlobalFunctions.get(idText(f.function))!.generate(
                wCtx,
                f.args.map((v) => getExpType(wCtx.ctx, v)),
                f.args,
                f.loc,
            );
        }

        const sf = getStaticFunction(wCtx.ctx, idText(f.function));
        let n = ops.global(idText(f.function));
        if (sf.ast.kind === "native_function_decl") {
            n = idText(sf.ast.nativeName);
            if (n.startsWith("__tact")) {
                wCtx.used(n);
            }
        } else {
            wCtx.used(n);
        }
        return (
            n +
            "(" +
            f.args
                .map((a, i) =>
                    writeCastedExpression(a, sf.params[i]!.type, wCtx),
                )
                .join(", ") +
            ")"
        );
    }

    //
    // Struct Constructor
    //

    if (f.kind === "struct_instance") {
        const src = getType(wCtx.ctx, f.type);

        // Write a constructor
        const id = writeStructConstructor(
            src,
            f.args.map((v) => idText(v.field)),
            wCtx,
        );
        wCtx.used(id);

        // Write an expression
        const expressions = f.args.map(
            (v) =>
                writeCastedExpression(
                    v.initializer,
                    src.fields.find((v2) => eqNames(v2.name, v.field))!.type,
                    wCtx,
                ),
            wCtx,
        );
        return `${id}(${expressions.join(", ")})`;
    }

    //
    // Object-based function call
    //

    if (f.kind === "method_call") {
        // Resolve source type
        const selfTyRef = getExpType(wCtx.ctx, f.self);

        // Reference type
        if (selfTyRef.kind === "ref") {
            // Render function call
            const selfTy = getType(wCtx.ctx, selfTyRef.name);

            // Check struct ABI
            if (selfTy.kind === "struct") {
                if (StructFunctions.has(idText(f.method))) {
                    const abi = StructFunctions.get(idText(f.method))!;
                    return abi.generate(
                        wCtx,
                        [
                            selfTyRef,
                            ...f.args.map((v) => getExpType(wCtx.ctx, v)),
                        ],
                        [f.self, ...f.args],
                        f.loc,
                    );
                }
            }

            // Resolve function
            const methodDescr = selfTy.functions.get(idText(f.method))!;
            let name = ops.extension(selfTyRef.name, idText(f.method));
            if (
                methodDescr.ast.kind === "function_def" ||
                methodDescr.ast.kind === "function_decl" ||
                methodDescr.ast.kind === "asm_function_def"
            ) {
                wCtx.used(name);
            } else {
                name = idText(methodDescr.ast.nativeName);
                if (name.startsWith("__tact")) {
                    wCtx.used(name);
                }
            }

            // Render arguments
            let renderedArguments = f.args.map((a, i) =>
                writeCastedExpression(a, methodDescr.params[i]!.type, wCtx),
            );

            // Hack to replace a single struct argument to a tensor wrapper since otherwise
            // func would convert (int) type to just int and break mutating functions
            if (methodDescr.isMutating) {
                if (f.args.length === 1) {
                    const t = getExpType(wCtx.ctx, f.args[0]!);
                    if (t.kind === "ref") {
                        const tt = getType(wCtx.ctx, t.name);
                        if (
                            (tt.kind === "contract" || tt.kind === "struct") &&
                            methodDescr.params[0]!.type.kind === "ref" &&
                            !methodDescr.params[0]!.type.optional
                        ) {
                            renderedArguments = [
                                `${ops.typeTensorCast(tt.name, wCtx)}(${renderedArguments[0]})`,
                            ];
                        }
                    }
                }
            }

            // Render
            const s = writeExpression(f.self, wCtx);
            if (methodDescr.isMutating) {
                // check if it's an l-value
                const path = tryExtractPath(f.self);
                if (path !== null && isLvalue(path, wCtx.ctx)) {
                    return `${s}~${name}(${renderedArguments.join(", ")})`;
                } else {
                    return `${wCtx.used(ops.nonModifying(name))}(${[s, ...renderedArguments].join(", ")})`;
                }
            } else {
                return `${name}(${[s, ...renderedArguments].join(", ")})`;
            }
        }

        // Map types
        if (selfTyRef.kind === "map") {
            if (!MapFunctions.has(idText(f.method))) {
                throwCompilationError(
                    `Map function "${idText(f.method)}" not found`,
                    f.loc,
                );
            }
            const abf = MapFunctions.get(idText(f.method))!;
            return abf.generate(
                wCtx,
                [selfTyRef, ...f.args.map((v) => getExpType(wCtx.ctx, v))],
                [f.self, ...f.args],
                f.loc,
            );
        }

        if (selfTyRef.kind === "ref_bounced") {
            throw Error("Unimplemented");
        }

        throwCompilationError(
            `Cannot call function of non - direct type: "${printTypeRef(selfTyRef)}"`,
            f.loc,
        );
    }

    //
    // Init of
    //

    if (f.kind === "init_of") {
        const type = getType(wCtx.ctx, f.contract);
        return `${ops.contractInitChild(idText(f.contract), wCtx)}(${["__tact_context_sys", ...f.args.map((a, i) => writeCastedExpression(a, type.init!.params[i]!.type, wCtx))].join(", ")})`;
    }

    //
    // Ternary operator
    //

    if (f.kind === "conditional") {
        return `(${writeExpression(f.condition, wCtx)} ? ${writeExpression(f.thenBranch, wCtx)} : ${writeExpression(f.elseBranch, wCtx)})`;
    }

    //
    // Unreachable
    //

    throw Error("Unknown expression");
}


## writeFunction.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeFunction.ts)
import { enabledInline } from "../../config/features";
import {
    AstAsmShuffle,
    AstCondition,
    AstExpression,
    AstStatement,
    idOfText,
    idText,
    isWildcard,
    tryExtractPath,
} from "../../grammar/ast";
import { getType, resolveTypeRef } from "../../types/resolveDescriptors";
import { getExpType } from "../../types/resolveExpression";
import { FunctionDescription, TypeRef } from "../../types/types";
import { WriterContext } from "../Writer";
import { resolveFuncPrimitive } from "./resolveFuncPrimitive";
import { resolveFuncType } from "./resolveFuncType";
import { resolveFuncTypeUnpack } from "./resolveFuncTypeUnpack";
import { funcIdOf } from "./id";
import { writeExpression, writePathExpression } from "./writeExpression";
import { cast } from "./cast";
import { resolveFuncTupleType } from "./resolveFuncTupleType";
import { ops } from "./ops";
import { freshIdentifier } from "./freshIdentifier";
import { idTextErr, throwInternalCompilerError } from "../../errors";
import { ppAsmShuffle } from "../../prettyPrinter";

export function writeCastedExpression(
    expression: AstExpression,
    to: TypeRef,
    ctx: WriterContext,
) {
    const expr = getExpType(ctx.ctx, expression);
    return cast(expr, to, writeExpression(expression, ctx), ctx); // Cast for nullable
}

function unwrapExternal(
    targetName: string,
    sourceName: string,
    type: TypeRef,
    ctx: WriterContext,
) {
    if (type.kind === "ref") {
        const t = getType(ctx.ctx, type.name);
        if (t.kind === "struct" || t.kind === "contract") {
            if (type.optional) {
                ctx.append(
                    `${resolveFuncType(type, ctx)} ${targetName} = ${ops.typeFromOptTuple(t.name, ctx)}(${sourceName});`,
                );
            } else {
                ctx.append(
                    `${resolveFuncType(type, ctx)} ${targetName} = ${ops.typeFromTuple(t.name, ctx)}(${sourceName});`,
                );
            }
            return;
        } else if (t.kind === "primitive_type_decl" && t.name === "Address") {
            ctx.append(
                `${resolveFuncType(type, ctx)} ${targetName} = ${sourceName};`,
            );
            return;
        }
    }
    ctx.append(`${resolveFuncType(type, ctx)} ${targetName} = ${sourceName};`);
}

export function writeStatement(
    f: AstStatement,
    self: string | null,
    returns: TypeRef | null,
    ctx: WriterContext,
) {
    switch (f.kind) {
        case "statement_return": {
            if (f.expression) {
                // Format expression
                const result = writeCastedExpression(
                    f.expression,
                    returns!,
                    ctx,
                );

                // Return
                if (self) {
                    // we introduce an intermediate return variable here
                    // to treat the case of a contract method call which
                    // can modify "self", otherwise the "self" below would
                    // contain the old state of contract, not the one
                    // updated in the "result" expression
                    const retVar = freshIdentifier("ret");
                    ctx.append(`var ${retVar} = ${result};`);
                    ctx.append(`return (${self}, ${retVar});`);
                } else {
                    ctx.append(`return ${result};`);
                }
            } else {
                if (self) {
                    ctx.append(`return (${self}, ());`);
                } else {
                    ctx.append(`return ();`);
                }
            }
            return;
        }
        case "statement_let": {
            // Underscore name case
            if (isWildcard(f.name)) {
                ctx.append(`${writeExpression(f.expression, ctx)};`);
                return;
            }

            // Contract/struct case
            const t =
                f.type === null
                    ? getExpType(ctx.ctx, f.expression)
                    : resolveTypeRef(ctx.ctx, f.type);

            if (t.kind === "ref") {
                const tt = getType(ctx.ctx, t.name);
                if (tt.kind === "contract" || tt.kind === "struct") {
                    if (t.optional) {
                        ctx.append(
                            `tuple ${funcIdOf(f.name)} = ${writeCastedExpression(f.expression, t, ctx)};`,
                        );
                    } else {
                        ctx.append(
                            `var ${resolveFuncTypeUnpack(t, funcIdOf(f.name), ctx)} = ${writeCastedExpression(f.expression, t, ctx)};`,
                        );
                    }
                    return;
                }
            }

            ctx.append(
                `${resolveFuncType(t, ctx)} ${funcIdOf(f.name)} = ${writeCastedExpression(f.expression, t, ctx)};`,
            );
            return;
        }
        case "statement_assign": {
            // Prepare lvalue
            const lvaluePath = tryExtractPath(f.path);
            if (lvaluePath === null) {
                // typechecker is supposed to catch this
                throwInternalCompilerError(
                    `Assignments are allowed only into path expressions, i.e. identifiers, or sequences of direct contract/struct/message accesses, like "self.foo" or "self.structure.field"`,
                    f.path.loc,
                );
            }
            const path = writePathExpression(lvaluePath);

            // Contract/struct case
            const t = getExpType(ctx.ctx, f.path);
            if (t.kind === "ref") {
                const tt = getType(ctx.ctx, t.name);
                if (tt.kind === "contract" || tt.kind === "struct") {
                    ctx.append(
                        `${resolveFuncTypeUnpack(t, path, ctx)} = ${writeCastedExpression(f.expression, t, ctx)};`,
                    );
                    return;
                }
            }

            ctx.append(
                `${path} = ${writeCastedExpression(f.expression, t, ctx)};`,
            );
            return;
        }
        case "statement_augmentedassign": {
            const lvaluePath = tryExtractPath(f.path);
            if (lvaluePath === null) {
                // typechecker is supposed to catch this
                throwInternalCompilerError(
                    `Assignments are allowed only into path expressions, i.e. identifiers, or sequences of direct contract/struct/message accesses, like "self.foo" or "self.structure.field"`,
                    f.path.loc,
                );
            }
            const path = writePathExpression(lvaluePath);
            const t = getExpType(ctx.ctx, f.path);
            const op = f.op === "&&" ? "&" : f.op === "||" ? "|" : f.op;
            ctx.append(
                `${path} = ${cast(t, t, `${path} ${op} ${writeExpression(f.expression, ctx)}`, ctx)};`,
            );
            return;
        }
        case "statement_condition": {
            writeCondition(f, self, false, returns, ctx);
            return;
        }
        case "statement_expression": {
            const exp = writeExpression(f.expression, ctx);
            ctx.append(`${exp};`);
            return;
        }
        case "statement_while": {
            ctx.append(`while (${writeExpression(f.condition, ctx)}) {`);
            ctx.inIndent(() => {
                for (const s of f.statements) {
                    writeStatement(s, self, returns, ctx);
                }
            });
            ctx.append(`}`);
            return;
        }
        case "statement_until": {
            ctx.append(`do {`);
            ctx.inIndent(() => {
                for (const s of f.statements) {
                    writeStatement(s, self, returns, ctx);
                }
            });
            ctx.append(`} until (${writeExpression(f.condition, ctx)});`);
            return;
        }
        case "statement_repeat": {
            ctx.append(`repeat (${writeExpression(f.iterations, ctx)}) {`);
            ctx.inIndent(() => {
                for (const s of f.statements) {
                    writeStatement(s, self, returns, ctx);
                }
            });
            ctx.append(`}`);
            return;
        }
        case "statement_try": {
            ctx.append(`try {`);
            ctx.inIndent(() => {
                for (const s of f.statements) {
                    writeStatement(s, self, returns, ctx);
                }
            });
            ctx.append("} catch (_) { }");
            return;
        }
        case "statement_try_catch": {
            ctx.append(`try {`);
            ctx.inIndent(() => {
                for (const s of f.statements) {
                    writeStatement(s, self, returns, ctx);
                }
            });
            if (isWildcard(f.catchName)) {
                ctx.append(`} catch (_) {`);
            } else {
                ctx.append(`} catch (_, ${funcIdOf(f.catchName)}) {`);
            }
            ctx.inIndent(() => {
                for (const s of f.catchStatements) {
                    writeStatement(s, self, returns, ctx);
                }
            });
            ctx.append(`}`);
            return;
        }
        case "statement_foreach": {
            const mapPath = tryExtractPath(f.map);
            if (mapPath === null) {
                // typechecker is supposed to catch this
                throwInternalCompilerError(
                    `foreach is only allowed over maps that are path expressions, i.e. identifiers, or sequences of direct contract/struct/message accesses, like "self.foo" or "self.structure.field"`,
                    f.map.loc,
                );
            }
            const path = writePathExpression(mapPath);

            const t = getExpType(ctx.ctx, f.map);
            if (t.kind !== "map") {
                throw Error("Unknown map type");
            }

            const flag = freshIdentifier("flag");
            const key = isWildcard(f.keyName)
                ? freshIdentifier("underscore")
                : funcIdOf(f.keyName);
            const value = isWildcard(f.valueName)
                ? freshIdentifier("underscore")
                : funcIdOf(f.valueName);

            // Handle Int key
            if (t.key === "Int") {
                let bits = 257;
                let kind = "int";
                if (t.keyAs?.startsWith("int")) {
                    bits = parseInt(t.keyAs.slice(3), 10);
                } else if (t.keyAs?.startsWith("uint")) {
                    bits = parseInt(t.keyAs.slice(4), 10);
                    kind = "uint";
                }
                if (t.value === "Int") {
                    let vBits = 257;
                    let vKind = "int";
                    if (t.valueAs?.startsWith("int")) {
                        vBits = parseInt(t.valueAs.slice(3), 10);
                    } else if (t.valueAs?.startsWith("uint")) {
                        vBits = parseInt(t.valueAs.slice(4), 10);
                        vKind = "uint";
                    }

                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_${vKind}`)}(${path}, ${bits}, ${vBits});`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_${vKind}`)}(${path}, ${bits}, ${key}, ${vBits});`,
                        );
                    });
                    ctx.append(`}`);
                } else if (t.value === "Bool") {
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_int`)}(${path}, ${bits}, 1);`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_int`)}(${path}, ${bits}, ${key}, 1);`,
                        );
                    });
                    ctx.append(`}`);
                } else if (t.value === "Cell") {
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_cell`)}(${path}, ${bits});`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_cell`)}(${path}, ${bits}, ${key});`,
                        );
                    });
                    ctx.append(`}`);
                } else if (t.value === "Address") {
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_slice`)}(${path}, ${bits});`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_slice`)}(${path}, ${bits}, ${key});`,
                        );
                    });
                    ctx.append(`}`);
                } else {
                    // value is struct
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_${kind}_cell`)}(${path}, ${bits});`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        ctx.append(
                            `var ${resolveFuncTypeUnpack(t.value, funcIdOf(f.valueName), ctx)} = ${ops.typeNotNull(t.value, ctx)}(${ops.readerOpt(t.value, ctx)}(${value}));`,
                        );
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_${kind}_cell`)}(${path}, ${bits}, ${key});`,
                        );
                    });
                    ctx.append(`}`);
                }
            }

            // Handle address key
            if (t.key === "Address") {
                if (t.value === "Int") {
                    let vBits = 257;
                    let vKind = "int";
                    if (t.valueAs?.startsWith("int")) {
                        vBits = parseInt(t.valueAs.slice(3), 10);
                    } else if (t.valueAs?.startsWith("uint")) {
                        vBits = parseInt(t.valueAs.slice(4), 10);
                        vKind = "uint";
                    }
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_${vKind}`)}(${path}, 267, ${vBits});`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_${vKind}`)}(${path}, 267, ${key}, ${vBits});`,
                        );
                    });
                    ctx.append(`}`);
                } else if (t.value === "Bool") {
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_int`)}(${path}, 267, 1);`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_int`)}(${path}, 267, ${key}, 1);`,
                        );
                    });
                    ctx.append(`}`);
                } else if (t.value === "Cell") {
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_cell`)}(${path}, 267);`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_cell`)}(${path}, 267, ${key});`,
                        );
                    });
                    ctx.append(`}`);
                } else if (t.value === "Address") {
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_slice`)}(${path}, 267);`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_slice`)}(${path}, 267, ${key});`,
                        );
                    });
                    ctx.append(`}`);
                } else {
                    // value is struct
                    ctx.append(
                        `var (${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_min_slice_cell`)}(${path}, 267);`,
                    );
                    ctx.append(`while (${flag}) {`);
                    ctx.inIndent(() => {
                        ctx.append(
                            `var ${resolveFuncTypeUnpack(t.value, funcIdOf(f.valueName), ctx)} = ${ops.typeNotNull(t.value, ctx)}(${ops.readerOpt(t.value, ctx)}(${value}));`,
                        );
                        for (const s of f.statements) {
                            writeStatement(s, self, returns, ctx);
                        }
                        ctx.append(
                            `(${key}, ${value}, ${flag}) = ${ctx.used(`__tact_dict_next_slice_cell`)}(${path}, 267, ${key});`,
                        );
                    });
                    ctx.append(`}`);
                }
            }

            return;
        }
        case "statement_destruct": {
            const t = getExpType(ctx.ctx, f.expression);
            if (t.kind !== "ref") {
                throwInternalCompilerError(
                    `invalid destruct expression kind: ${t.kind}`,
                    f.expression.loc,
                );
            }
            const ty = getType(ctx.ctx, t.name);
            const ids = ty.fields.map((field) => {
                const id = f.identifiers.get(field.name);
                return id === undefined || isWildcard(id[1])
                    ? "_"
                    : funcIdOf(id[1]);
            });
            ctx.append(
                `var (${ids.join(", ")}) = ${writeCastedExpression(f.expression, t, ctx)};`,
            );
            return;
        }
    }

    throw Error("Unknown statement kind");
}

function writeCondition(
    f: AstCondition,
    self: string | null,
    elseif: boolean,
    returns: TypeRef | null,
    ctx: WriterContext,
) {
    ctx.append(
        `${elseif ? "} else" : ""}if (${writeExpression(f.condition, ctx)}) {`,
    );
    ctx.inIndent(() => {
        for (const s of f.trueStatements) {
            writeStatement(s, self, returns, ctx);
        }
    });
    if (f.falseStatements && f.falseStatements.length > 0) {
        ctx.append(`} else {`);
        ctx.inIndent(() => {
            for (const s of f.falseStatements!) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
    } else if (f.elseif) {
        writeCondition(f.elseif, self, true, returns, ctx);
    } else {
        ctx.append(`}`);
    }
}

export function writeFunction(f: FunctionDescription, ctx: WriterContext) {
    // Resolve self
    const self = f.self?.kind === "ref" ? getType(ctx.ctx, f.self.name) : null;

    // Write function header
    let returns: string = resolveFuncType(f.returns, ctx);
    const returnsOriginal = returns;
    let returnsStr: string | null;
    if (self && f.isMutating) {
        if (f.returns.kind !== "void") {
            returns = `(${resolveFuncType(self, ctx)}, ${returns})`;
        } else {
            returns = `(${resolveFuncType(self, ctx)}, ())`;
        }
        returnsStr = resolveFuncTypeUnpack(self, funcIdOf("self"), ctx);
    }

    // Resolve function descriptor
    const params: string[] = [];
    if (self) {
        params.push(resolveFuncType(self, ctx) + " " + funcIdOf("self"));
    }
    for (const a of f.params) {
        params.push(resolveFuncType(a.type, ctx) + " " + funcIdOf(a.name));
    }

    const fAst = f.ast;
    switch (fAst.kind) {
        case "native_function_decl": {
            const name = idText(fAst.nativeName);
            if (f.isMutating && !ctx.isRendered(name)) {
                writeNonMutatingFunction(
                    f,
                    name,
                    params,
                    returnsOriginal,
                    false,
                    ctx,
                );
                ctx.markRendered(name);
            }
            return;
        }

        case "asm_function_def": {
            const name = self
                ? ops.extension(self.name, f.name)
                : ops.global(f.name);
            ctx.fun(name, () => {
                ctx.signature(`${returns} ${name}(${params.join(", ")})`);
                ctx.flag("impure");
                if (f.origin === "stdlib") {
                    ctx.context("stdlib");
                }
                // we need to do some renames (prepending $ to identifiers)
                const asmShuffleEscaped: AstAsmShuffle = {
                    ...fAst.shuffle,
                    args: fAst.shuffle.args.map((id) => idOfText(funcIdOf(id))),
                };
                ctx.asm(
                    ppAsmShuffle(asmShuffleEscaped),
                    fAst.instructions.join(" "),
                );
            });
            if (f.isMutating) {
                writeNonMutatingFunction(
                    f,
                    name,
                    params,
                    returnsOriginal,
                    true,
                    ctx,
                );
            }
            return;
        }

        case "function_def": {
            const name = self
                ? ops.extension(self.name, f.name)
                : ops.global(f.name);

            ctx.fun(name, () => {
                ctx.signature(`${returns} ${name}(${params.join(", ")})`);
                ctx.flag("impure");
                if (enabledInline(ctx.ctx) || f.isInline) {
                    ctx.flag("inline");
                }
                if (f.origin === "stdlib") {
                    ctx.context("stdlib");
                }
                ctx.body(() => {
                    // Unpack self
                    if (self) {
                        ctx.append(
                            `var (${resolveFuncTypeUnpack(self, funcIdOf("self"), ctx)}) = ${funcIdOf("self")};`,
                        );
                    }
                    for (const a of f.ast.params) {
                        if (
                            !resolveFuncPrimitive(
                                resolveTypeRef(ctx.ctx, a.type),
                                ctx,
                            )
                        ) {
                            ctx.append(
                                `var (${resolveFuncTypeUnpack(resolveTypeRef(ctx.ctx, a.type), funcIdOf(a.name), ctx)}) = ${funcIdOf(a.name)};`,
                            );
                        }
                    }

                    // Process statements
                    for (const s of fAst.statements) {
                        writeStatement(s, returnsStr, f.returns, ctx);
                    }

                    // Auto append return
                    if (f.self && f.returns.kind === "void" && f.isMutating) {
                        if (
                            fAst.statements.length === 0 ||
                            fAst.statements[fAst.statements.length - 1]!
                                .kind !== "statement_return"
                        ) {
                            ctx.append(`return (${returnsStr}, ());`);
                        }
                    }
                });
            });

            if (f.isMutating) {
                writeNonMutatingFunction(
                    f,
                    name,
                    params,
                    returnsOriginal,
                    true,
                    ctx,
                );
            }
            return;
        }
        default: {
            throwInternalCompilerError(
                `Unknown function kind: ${idTextErr(fAst.name)}`,
                fAst.loc,
            );
        }
    }
}

// Write a function in non-mutating form
function writeNonMutatingFunction(
    f: FunctionDescription,
    name: string,
    params: string[],
    returnsOriginal: string,
    markUsedName: boolean,
    ctx: WriterContext,
) {
    const nonMutName = ops.nonModifying(name);
    ctx.fun(nonMutName, () => {
        ctx.signature(`${returnsOriginal} ${nonMutName}(${params.join(", ")})`);
        ctx.flag("impure");
        if (enabledInline(ctx.ctx) || f.isInline) {
            ctx.flag("inline");
        }
        if (f.origin === "stdlib") {
            ctx.context("stdlib");
        }
        ctx.body(() => {
            ctx.append(
                `return ${funcIdOf("self")}~${markUsedName ? ctx.used(name) : name}(${f.ast.params
                    .slice(1)
                    .map((arg) => funcIdOf(arg.name))
                    .join(", ")});`,
            );
        });
    });
}

export function writeGetter(f: FunctionDescription, wCtx: WriterContext) {
    // Render tensors
    const self = f.self?.kind === "ref" ? getType(wCtx.ctx, f.self.name) : null;
    if (!self) {
        throw new Error(`No self type for getter ${idTextErr(f.name)}`); // Impossible
    }
    wCtx.append(
        `_ %${f.name}(${f.params.map((v) => resolveFuncTupleType(v.type, wCtx) + " " + funcIdOf(v.name)).join(", ")}) method_id(${f.methodId!}) {`,
    );
    wCtx.inIndent(() => {
        // Unpack parameters
        for (const param of f.params) {
            unwrapExternal(
                funcIdOf(param.name),
                funcIdOf(param.name),
                param.type,
                wCtx,
            );
        }

        // Load contract state
        wCtx.append(`var self = ${ops.contractLoad(self.name, wCtx)}();`);

        // Execute get method
        wCtx.append(
            `var res = self~${wCtx.used(ops.extension(self.name, f.name))}(${f.params.map((v) => funcIdOf(v.name)).join(", ")});`,
        );

        // Pack if needed
        if (f.returns.kind === "ref") {
            const t = getType(wCtx.ctx, f.returns.name);
            if (t.kind === "struct" || t.kind === "contract") {
                if (f.returns.optional) {
                    wCtx.append(
                        `return ${ops.typeToOptExternal(t.name, wCtx)}(res);`,
                    );
                } else {
                    wCtx.append(
                        `return ${ops.typeToExternal(t.name, wCtx)}(res);`,
                    );
                }
                return;
            }
        }

        // Return result
        wCtx.append(`return res;`);
    });
    wCtx.append(`}`);
    wCtx.append();
}


## writeInterfaces.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeInterfaces.ts)
import { getSupportedInterfaces } from "../../types/getSupportedInterfaces";
import { TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";

export function writeInterfaces(type: TypeDescription, ctx: WriterContext) {
    ctx.append(`_ supported_interfaces() method_id {`);
    ctx.inIndent(() => {
        ctx.append(`return (`);
        ctx.inIndent(() => {
            // Build interfaces list
            const interfaces: string[] = [];
            interfaces.push("org.ton.introspection.v0");
            interfaces.push(...getSupportedInterfaces(type, ctx.ctx));

            // Render interfaces
            for (let i = 0; i < interfaces.length; i++) {
                ctx.append(
                    `"${interfaces[i]}"H >> 128${i < interfaces.length - 1 ? "," : ""}`,
                );
            }
        });
        ctx.append(`);`);
    });
    ctx.append(`}`);
    ctx.append();
}


## writeRouter.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeRouter.ts)
import { beginCell } from "@ton/core";
import { getType } from "../../types/resolveDescriptors";
import { ReceiverDescription, TypeDescription } from "../../types/types";
import { WriterContext } from "../Writer";
import { funcIdOf } from "./id";
import { ops } from "./ops";
import { resolveFuncType } from "./resolveFuncType";
import { resolveFuncTypeUnpack } from "./resolveFuncTypeUnpack";
import { writeStatement } from "./writeFunction";
import { AstNumber } from "../../grammar/ast";

export function commentPseudoOpcode(comment: string): string {
    return beginCell()
        .storeUint(0, 32)
        .storeBuffer(Buffer.from(comment, "utf8"))
        .endCell()
        .hash()
        .toString("hex", 0, 64);
}

export function writeRouter(
    type: TypeDescription,
    kind: "internal" | "external",
    ctx: WriterContext,
) {
    const internal = kind === "internal";
    if (internal) {
        ctx.append(
            `(${resolveFuncType(type, ctx)}, int) ${ops.contractRouter(type.name, kind)}(${resolveFuncType(type, ctx)} self, int msg_bounced, slice in_msg) impure inline_ref {`,
        );
    } else {
        ctx.append(
            `(${resolveFuncType(type, ctx)}, int) ${ops.contractRouter(type.name, kind)}(${resolveFuncType(type, ctx)} self, slice in_msg) impure inline_ref {`,
        );
    }
    ctx.inIndent(() => {
        // Handle bounced
        if (internal) {
            ctx.append(`;; Handle bounced messages`);
            ctx.append(`if (msg_bounced) {`);
            ctx.inIndent(() => {
                const bounceReceivers = type.receivers.filter((r) => {
                    return r.selector.kind === "bounce-binary";
                });

                const fallbackReceiver = type.receivers.find((r) => {
                    return r.selector.kind === "bounce-fallback";
                });

                if (fallbackReceiver ?? bounceReceivers.length > 0) {
                    ctx.append();
                    ctx.append(`;; Skip 0xFFFFFFFF`);
                    ctx.append(`in_msg~skip_bits(32);`);
                    ctx.append();
                }

                if (bounceReceivers.length > 0) {
                    ctx.append(`;; Parse op`);
                    ctx.append(`int op = 0;`);
                    ctx.append(`if (slice_bits(in_msg) >= 32) {`);
                    ctx.inIndent(() => {
                        ctx.append(`op = in_msg.preload_uint(32);`);
                    });
                    ctx.append(`}`);
                    ctx.append();
                }

                for (const r of bounceReceivers) {
                    const selector = r.selector;
                    if (selector.kind !== "bounce-binary")
                        throw Error("Invalid selector type: " + selector.kind); // Should not happen
                    const allocation = getType(ctx.ctx, selector.type);
                    ctx.append(
                        `;; Bounced handler for ${selector.type} message`,
                    );
                    ctx.append(
                        `if (op == ${messageOpcode(allocation.header!)}) {`,
                    );
                    ctx.inIndent(() => {
                        // Read message
                        ctx.append(
                            `var msg = in_msg~${selector.bounced ? ops.readerBounced(selector.type, ctx) : ops.reader(selector.type, ctx)}();`,
                        );

                        // Execute function
                        ctx.append(
                            `self~${ops.receiveTypeBounce(type.name, selector.type)}(msg);`,
                        );

                        // Exit
                        ctx.append("return (self, true);");
                    });
                    ctx.append(`}`);
                    ctx.append();
                }

                if (fallbackReceiver) {
                    const selector = fallbackReceiver.selector;
                    if (selector.kind !== "bounce-fallback")
                        throw Error("Invalid selector type: " + selector.kind);

                    // Execute function
                    ctx.append(`;; Fallback bounce receiver`);
                    ctx.append(
                        `self~${ops.receiveBounceAny(type.name)}(in_msg);`,
                    );
                    ctx.append();

                    // Exit
                    ctx.append("return (self, true);");
                } else {
                    ctx.append(`return (self, true);`);
                }
            });
            ctx.append(`}`);
        }

        // Parse incoming message
        ctx.append();
        ctx.append(`;; Parse incoming message`);
        ctx.append(`int op = 0;`);
        ctx.append(`if (slice_bits(in_msg) >= 32) {`);
        ctx.inIndent(() => {
            ctx.append(`op = in_msg.preload_uint(32);`);
        });
        ctx.append(`}`);
        ctx.append();

        // Non-empty receivers
        for (const f of type.receivers) {
            const selector = f.selector;

            // Generic receiver
            if (
                selector.kind ===
                (internal ? "internal-binary" : "external-binary")
            ) {
                const allocation = getType(ctx.ctx, selector.type);
                if (!allocation.header) {
                    throw Error("Invalid allocation: " + selector.type);
                }
                ctx.append();
                ctx.append(`;; Receive ${selector.type} message`);
                ctx.append(`if (op == ${messageOpcode(allocation.header)}) {`);
                ctx.inIndent(() => {
                    // Read message
                    ctx.append(
                        `var msg = in_msg~${ops.reader(selector.type, ctx)}();`,
                    );

                    // Execute function
                    ctx.append(
                        `self~${ops.receiveType(type.name, kind, selector.type)}(msg);`,
                    );

                    // Exit
                    ctx.append("return (self, true);");
                });
                ctx.append(`}`);
            }

            if (
                selector.kind ===
                (internal ? "internal-empty" : "external-empty")
            ) {
                ctx.append();
                ctx.append(`;; Receive empty message`);
                ctx.append(`if ((op == 0) & (slice_bits(in_msg) <= 32)) {`);
                ctx.inIndent(() => {
                    // Execute function
                    ctx.append(`self~${ops.receiveEmpty(type.name, kind)}();`);

                    // Exit
                    ctx.append("return (self, true);");
                });
                ctx.append(`}`);
            }
        }

        // Text resolvers
        const hasComments = !!type.receivers.find((v) =>
            internal
                ? v.selector.kind === "internal-comment" ||
                  v.selector.kind === "internal-comment-fallback"
                : v.selector.kind === "external-comment" ||
                  v.selector.kind === "external-comment-fallback",
        );
        if (hasComments) {
            ctx.append();
            ctx.append(`;; Text Receivers`);
            ctx.append(`if (op == 0) {`);
            ctx.inIndent(() => {
                if (
                    type.receivers.find(
                        (v) =>
                            v.selector.kind ===
                            (internal
                                ? "internal-comment"
                                : "external-comment"),
                    )
                ) {
                    ctx.append(`var text_op = slice_hash(in_msg);`);
                    for (const r of type.receivers) {
                        const selector = r.selector;
                        if (
                            selector.kind ===
                            (internal ? "internal-comment" : "external-comment")
                        ) {
                            const hash = commentPseudoOpcode(selector.comment);
                            ctx.append();
                            ctx.append(
                                `;; Receive "${selector.comment}" message`,
                            );
                            ctx.append(`if (text_op == 0x${hash}) {`);
                            ctx.inIndent(() => {
                                // Execute function
                                ctx.append(
                                    `self~${ops.receiveText(type.name, kind, hash)}();`,
                                );

                                // Exit
                                ctx.append("return (self, true);");
                            });
                            ctx.append(`}`);
                        }
                    }
                }

                // Comment fallback resolver
                const fallback = type.receivers.find(
                    (v) =>
                        v.selector.kind ===
                        (internal
                            ? "internal-comment-fallback"
                            : "external-comment-fallback"),
                );
                if (fallback) {
                    ctx.append(`if (slice_bits(in_msg) >= 32) {`);
                    ctx.inIndent(() => {
                        // Execute function
                        ctx.append(
                            `self~${ops.receiveAnyText(type.name, kind)}(in_msg.skip_bits(32));`,
                        );

                        // Exit
                        ctx.append("return (self, true);");
                    });

                    ctx.append(`}`);
                }
            });
            ctx.append(`}`);
        }

        // Fallback
        const fallbackReceiver = type.receivers.find(
            (v) =>
                v.selector.kind ===
                (internal ? "internal-fallback" : "external-fallback"),
        );
        if (fallbackReceiver) {
            ctx.append();
            ctx.append(`;; Receiver fallback`);

            // Execute function
            ctx.append(`self~${ops.receiveAny(type.name, kind)}(in_msg);`);

            ctx.append("return (self, true);");
        } else {
            ctx.append();
            ctx.append("return (self, false);");
        }
    });
    ctx.append(`}`);
    ctx.append();
}

function messageOpcode(n: AstNumber): string {
    // FunC does not support binary and octal numerals
    switch (n.base) {
        case 10:
            return n.value.toString(n.base);
        case 2:
        case 8:
        case 16:
            return `0x${n.value.toString(n.base)}`;
    }
}

export function writeReceiver(
    self: TypeDescription,
    f: ReceiverDescription,
    ctx: WriterContext,
) {
    const selector = f.selector;
    const selfRes = resolveFuncTypeUnpack(self, funcIdOf("self"), ctx);
    const selfType = resolveFuncType(self, ctx);
    const selfUnpack = `var ${resolveFuncTypeUnpack(self, funcIdOf("self"), ctx)} = ${funcIdOf("self")};`;

    // Binary receiver
    if (
        selector.kind === "internal-binary" ||
        selector.kind === "external-binary"
    ) {
        const args = [
            selfType + " " + funcIdOf("self"),
            resolveFuncType(selector.type, ctx) + " " + funcIdOf(selector.name),
        ];
        ctx.append(
            `((${selfType}), ()) ${ops.receiveType(self.name, selector.kind === "internal-binary" ? "internal" : "external", selector.type)}(${args.join(", ")}) impure inline {`,
        );
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            ctx.append(
                `var ${resolveFuncTypeUnpack(selector.type, funcIdOf(selector.name), ctx)} = ${funcIdOf(selector.name)};`,
            );

            for (const s of f.ast.statements) {
                writeStatement(s, selfRes, null, ctx);
            }

            if (
                f.ast.statements.length === 0 ||
                f.ast.statements[f.ast.statements.length - 1]!.kind !==
                    "statement_return"
            ) {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }

    // Empty receiver
    if (
        selector.kind === "internal-empty" ||
        selector.kind === "external-empty"
    ) {
        ctx.append(
            `((${selfType}), ()) ${ops.receiveEmpty(self.name, selector.kind === "internal-empty" ? "internal" : "external")}(${selfType + " " + funcIdOf("self")}) impure inline {`,
        );
        ctx.inIndent(() => {
            ctx.append(selfUnpack);

            for (const s of f.ast.statements) {
                writeStatement(s, selfRes, null, ctx);
            }

            if (
                f.ast.statements.length === 0 ||
                f.ast.statements[f.ast.statements.length - 1]!.kind !==
                    "statement_return"
            ) {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }

    // Comment receiver
    if (
        selector.kind === "internal-comment" ||
        selector.kind === "external-comment"
    ) {
        const hash = commentPseudoOpcode(selector.comment);
        ctx.append(
            `(${selfType}, ()) ${ops.receiveText(self.name, selector.kind === "internal-comment" ? "internal" : "external", hash)}(${selfType + " " + funcIdOf("self")}) impure inline {`,
        );
        ctx.inIndent(() => {
            ctx.append(selfUnpack);

            for (const s of f.ast.statements) {
                writeStatement(s, selfRes, null, ctx);
            }

            if (
                f.ast.statements.length === 0 ||
                f.ast.statements[f.ast.statements.length - 1]!.kind !==
                    "statement_return"
            ) {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }

    // Fallback
    if (
        selector.kind === "internal-comment-fallback" ||
        selector.kind === "external-comment-fallback"
    ) {
        ctx.append(
            `(${selfType}, ()) ${ops.receiveAnyText(self.name, selector.kind === "internal-comment-fallback" ? "internal" : "external")}(${[selfType + " " + funcIdOf("self"), "slice " + funcIdOf(selector.name)].join(", ")}) impure inline {`,
        );
        ctx.inIndent(() => {
            ctx.append(selfUnpack);

            for (const s of f.ast.statements) {
                writeStatement(s, selfRes, null, ctx);
            }

            if (
                f.ast.statements.length === 0 ||
                f.ast.statements[f.ast.statements.length - 1]!.kind !==
                    "statement_return"
            ) {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }

    // Fallback
    if (selector.kind === "internal-fallback") {
        ctx.append(
            `(${selfType}, ()) ${ops.receiveAny(self.name, "internal")}(${selfType} ${funcIdOf("self")}, slice ${funcIdOf(selector.name)}) impure inline {`,
        );
        ctx.inIndent(() => {
            ctx.append(selfUnpack);

            for (const s of f.ast.statements) {
                writeStatement(s, selfRes, null, ctx);
            }

            if (
                f.ast.statements.length === 0 ||
                f.ast.statements[f.ast.statements.length - 1]!.kind !==
                    "statement_return"
            ) {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }

    // Bounced
    if (selector.kind === "bounce-fallback") {
        ctx.append(
            `(${selfType}, ()) ${ops.receiveBounceAny(self.name)}(${selfType} ${funcIdOf("self")}, slice ${funcIdOf(selector.name)}) impure inline {`,
        );
        ctx.inIndent(() => {
            ctx.append(selfUnpack);

            for (const s of f.ast.statements) {
                writeStatement(s, selfRes, null, ctx);
            }

            if (
                f.ast.statements.length === 0 ||
                f.ast.statements[f.ast.statements.length - 1]!.kind !==
                    "statement_return"
            ) {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }

    if (selector.kind === "bounce-binary") {
        const args = [
            selfType + " " + funcIdOf("self"),
            resolveFuncType(selector.type, ctx, false, selector.bounced) +
                " " +
                funcIdOf(selector.name),
        ];
        ctx.append(
            `((${selfType}), ()) ${ops.receiveTypeBounce(self.name, selector.type)}(${args.join(", ")}) impure inline {`,
        );
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            ctx.append(
                `var ${resolveFuncTypeUnpack(selector.type, funcIdOf(selector.name), ctx, false, selector.bounced)} = ${funcIdOf(selector.name)};`,
            );

            for (const s of f.ast.statements) {
                writeStatement(s, selfRes, null, ctx);
            }

            if (
                f.ast.statements.length === 0 ||
                f.ast.statements[f.ast.statements.length - 1]!.kind !==
                    "statement_return"
            ) {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }
}


## writeSerialization.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeSerialization.spec.ts)
import { CompilerContext } from "../../context";
import {
    getAllocation,
    resolveAllocations,
} from "../../storage/resolveAllocation";
import {
    getAllTypes,
    getType,
    resolveDescriptors,
} from "../../types/resolveDescriptors";
import { WriterContext } from "../Writer";
import { writeParser, writeSerializer } from "./writeSerialization";
import { writeStdlib } from "./writeStdlib";
import { openContext } from "../../grammar/store";
import { writeAccessors } from "./writeAccessors";
import { getParser } from "../../grammar";
import { getAstFactory } from "../../grammar/ast";

const code = `
primitive Int;
primitive Bool;
primitive Builder;
primitive Cell;
primitive Slice;
primitive Address;

struct A {
    a: Int;
    b: Int;
    c: Int?;
    d: Bool;
    e: Bool?;
    f: Int;
    g: Int;
}

struct B {
    a: Int;
    b: Int;
    c: Int?;
    d: Bool;
    e: Bool?;
    f: Int;
    g: Int;
}

struct C {
    a: Cell;
    b: Cell?;
    c: Slice?;
    d: Slice?;
    e: Bool;
    f: Int;
    g: Int;
    h: Address;
}
`;

describe("writeSerialization", () => {
    for (const s of ["A", "B", "C"]) {
        it("should write serializer for " + s, () => {
            const ast = getAstFactory();
            let ctx = openContext(
                new CompilerContext(),
                [{ code, path: "<unknown>", origin: "user" }],
                [],
                getParser(ast),
            );
            ctx = resolveDescriptors(ctx, ast);
            ctx = resolveAllocations(ctx);
            const wCtx = new WriterContext(ctx, s);
            writeStdlib(wCtx);
            writeSerializer(
                getType(ctx, s).name,
                false,
                getAllocation(ctx, s),
                "user",
                wCtx,
            );
            for (const t of getAllTypes(ctx)) {
                if (t.kind === "contract" || t.kind === "struct") {
                    writeAccessors(t, "user", wCtx);
                }
            }
            writeParser(
                getType(ctx, s).name,
                false,
                getAllocation(ctx, s),
                "user",
                wCtx,
            );
            const extracted = wCtx.extract(true);
            expect(extracted).toMatchSnapshot();
        });
    }
});


## writeSerialization.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeSerialization.ts)
import { contractErrors } from "../../abi/errors";
import { throwInternalCompilerError } from "../../errors";
import { dummySrcInfo, ItemOrigin } from "../../grammar";
import { AllocationCell, AllocationOperation } from "../../storage/operation";
import { StorageAllocation } from "../../storage/StorageAllocation";
import { getType } from "../../types/resolveDescriptors";
import { WriterContext } from "../Writer";
import { ops } from "./ops";
import { resolveFuncTypeFromAbi } from "./resolveFuncTypeFromAbi";
import { resolveFuncTypeFromAbiUnpack } from "./resolveFuncTypeFromAbiUnpack";

const SMALL_STRUCT_MAX_FIELDS = 5;

//
// Serializer
//

export function writeSerializer(
    name: string,
    forceInline: boolean,
    allocation: StorageAllocation,
    origin: ItemOrigin,
    ctx: WriterContext,
) {
    const isSmall = allocation.ops.length <= SMALL_STRUCT_MAX_FIELDS;

    // Write to builder
    ctx.fun(ops.writer(name, ctx), () => {
        ctx.signature(
            `builder ${ops.writer(name, ctx)}(builder build_0, ${resolveFuncTypeFromAbi(
                allocation.ops.map((v) => v.type),
                ctx,
            )} v)`,
        );
        if (forceInline || isSmall) {
            ctx.flag("inline");
        }
        ctx.context("type:" + name);
        ctx.body(() => {
            if (allocation.ops.length > 0) {
                ctx.append(
                    `var ${resolveFuncTypeFromAbiUnpack(`v`, allocation.ops, ctx)} = v;`,
                );
            }
            if (allocation.header) {
                ctx.append(
                    `build_0 = store_uint(build_0, ${allocation.header.value}, ${allocation.header.bits});`,
                );
            }
            writeSerializerCell(allocation.root, 0, ctx);
            ctx.append(`return build_0;`);
        });
    });

    // Write to cell
    ctx.fun(ops.writerCell(name, ctx), () => {
        ctx.signature(
            `cell ${ops.writerCell(name, ctx)}(${resolveFuncTypeFromAbi(
                allocation.ops.map((v) => v.type),
                ctx,
            )} v)`,
        );
        ctx.flag("inline");
        ctx.context("type:" + name);
        ctx.body(() => {
            ctx.append(
                `return ${ops.writer(name, ctx)}(begin_cell(), v).end_cell();`,
            );
        });
    });
}

export function writeOptionalSerializer(
    name: string,
    origin: ItemOrigin,
    ctx: WriterContext,
) {
    ctx.fun(ops.writerCellOpt(name, ctx), () => {
        ctx.signature(`cell ${ops.writerCellOpt(name, ctx)}(tuple v)`);
        ctx.flag("inline");
        ctx.context("type:" + name);
        ctx.body(() => {
            ctx.write(`
                if (null?(v)) {
                    return null();
                }
                return ${ops.writerCell(name, ctx)}(${ops.typeNotNull(name, ctx)}(v));
            `);
        });
    });
}

function writeSerializerCell(
    cell: AllocationCell,
    gen: number,
    ctx: WriterContext,
) {
    // Write fields
    for (const f of cell.ops) {
        writeSerializerField(f, gen, ctx);
    }

    // Tail
    if (cell.next) {
        ctx.append(`var build_${gen + 1} = begin_cell();`);
        writeSerializerCell(cell.next, gen + 1, ctx);
        ctx.append(
            `build_${gen} = store_ref(build_${gen}, build_${gen + 1}.end_cell());`,
        );
    }
}

function writeSerializerField(
    f: AllocationOperation,
    gen: number,
    ctx: WriterContext,
) {
    const fieldName = `v'${f.name}`;
    const op = f.op;

    switch (op.kind) {
        case "int": {
            if (op.optional) {
                ctx.append(
                    `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_int(${fieldName}, ${op.bits}) : build_${gen}.store_int(false, 1);`,
                );
            } else {
                ctx.append(
                    `build_${gen} = build_${gen}.store_int(${fieldName}, ${op.bits});`,
                );
            }
            return;
        }
        case "uint": {
            if (op.optional) {
                ctx.append(
                    `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_uint(${fieldName}, ${op.bits}) : build_${gen}.store_int(false, 1);`,
                );
            } else {
                ctx.append(
                    `build_${gen} = build_${gen}.store_uint(${fieldName}, ${op.bits});`,
                );
            }
            return;
        }
        case "coins": {
            if (op.optional) {
                ctx.append(
                    `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_coins(${fieldName}) : build_${gen}.store_int(false, 1);`,
                );
            } else {
                ctx.append(
                    `build_${gen} = build_${gen}.store_coins(${fieldName});`,
                );
            }
            return;
        }
        case "boolean": {
            if (op.optional) {
                ctx.append(
                    `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_int(${fieldName}, 1) : build_${gen}.store_int(false, 1);`,
                );
            } else {
                ctx.append(
                    `build_${gen} = build_${gen}.store_int(${fieldName}, 1);`,
                );
            }
            return;
        }
        case "address": {
            if (op.optional) {
                ctx.used(`__tact_store_address_opt`);
                ctx.append(
                    `build_${gen} = __tact_store_address_opt(build_${gen}, ${fieldName});`,
                );
            } else {
                ctx.used(`__tact_store_address`);
                ctx.append(
                    `build_${gen} = __tact_store_address(build_${gen}, ${fieldName});`,
                );
            }
            return;
        }
        case "cell": {
            switch (op.format) {
                case "default":
                    {
                        if (op.optional) {
                            ctx.append(
                                `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_ref(${fieldName}) : build_${gen}.store_int(false, 1);`,
                            );
                        } else {
                            ctx.append(
                                `build_${gen} = build_${gen}.store_ref(${fieldName});`,
                            );
                        }
                    }
                    break;
                case "remainder":
                    {
                        if (op.optional) {
                            throw Error("Impossible");
                        }
                        ctx.append(
                            `build_${gen} = build_${gen}.store_slice(${fieldName}.begin_parse());`,
                        );
                    }
                    break;
            }
            return;
        }
        case "slice": {
            switch (op.format) {
                case "default":
                    {
                        if (op.optional) {
                            ctx.append(
                                `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_ref(begin_cell().store_slice(${fieldName}).end_cell()) : build_${gen}.store_int(false, 1);`,
                            );
                        } else {
                            ctx.append(
                                `build_${gen} = build_${gen}.store_ref(begin_cell().store_slice(${fieldName}).end_cell());`,
                            );
                        }
                    }
                    break;
                case "remainder": {
                    if (op.optional) {
                        throw Error("Impossible");
                    }
                    ctx.append(
                        `build_${gen} = build_${gen}.store_slice(${fieldName});`,
                    );
                }
            }
            return;
        }
        case "builder": {
            switch (op.format) {
                case "default":
                    {
                        if (op.optional) {
                            ctx.append(
                                `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_ref(begin_cell().store_slice(${fieldName}.end_cell().begin_parse()).end_cell()) : build_${gen}.store_int(false, 1);`,
                            );
                        } else {
                            ctx.append(
                                `build_${gen} = build_${gen}.store_ref(begin_cell().store_slice(${fieldName}.end_cell().begin_parse()).end_cell());`,
                            );
                        }
                    }
                    break;
                case "remainder": {
                    if (op.optional) {
                        throw Error("Impossible");
                    }
                    ctx.append(
                        `build_${gen} = build_${gen}.store_slice(${fieldName}.end_cell().begin_parse());`,
                    );
                }
            }
            return;
        }
        case "string": {
            if (op.optional) {
                ctx.append(
                    `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_ref(begin_cell().store_slice(${fieldName}).end_cell()) : build_${gen}.store_int(false, 1);`,
                );
            } else {
                ctx.append(
                    `build_${gen} = build_${gen}.store_ref(begin_cell().store_slice(${fieldName}).end_cell());`,
                );
            }
            return;
        }
        case "fixed-bytes": {
            if (op.optional) {
                ctx.append(
                    `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).store_slice(${fieldName}) : build_${gen}.store_int(false, 1);`,
                );
            } else {
                ctx.append(
                    `build_${gen} = build_${gen}.store_slice(${fieldName});`,
                );
            }
            return;
        }
        case "map": {
            ctx.append(`build_${gen} = build_${gen}.store_dict(${fieldName});`);
            return;
        }
        case "struct": {
            if (op.ref) {
                throw Error("Not implemented");
            }
            if (op.optional) {
                ctx.append(
                    `build_${gen} = ~ null?(${fieldName}) ? build_${gen}.store_int(true, 1).${ops.writer(op.type, ctx)}(${ops.typeNotNull(op.type, ctx)}(${fieldName})) : build_${gen}.store_int(false, 1);`,
                );
            } else {
                const ff = getType(ctx.ctx, op.type).fields.map((f) => f.abi);
                ctx.append(
                    `build_${gen} = ${ops.writer(op.type, ctx)}(build_${gen}, ${resolveFuncTypeFromAbiUnpack(fieldName, ff, ctx)});`,
                );
            }
            return;
        }
    }

    throwInternalCompilerError(`Unsupported field kind`, dummySrcInfo);
}

//
// Parser
//

export function writeParser(
    name: string,
    forceInline: boolean,
    allocation: StorageAllocation,
    origin: ItemOrigin,
    ctx: WriterContext,
) {
    const isSmall = allocation.ops.length <= SMALL_STRUCT_MAX_FIELDS;

    ctx.fun(ops.reader(name, ctx), () => {
        ctx.signature(
            `(slice, (${resolveFuncTypeFromAbi(
                allocation.ops.map((v) => v.type),
                ctx,
            )})) ${ops.reader(name, ctx)}(slice sc_0)`,
        );
        if (forceInline || isSmall) {
            ctx.flag("inline");
        }
        ctx.context("type:" + name);
        ctx.body(() => {
            // Check prefix
            if (allocation.header) {
                ctx.append(
                    `throw_unless(${contractErrors.invalidPrefix.id}, sc_0~load_uint(${allocation.header.bits}) == ${allocation.header.value});`,
                );
            }

            // Write cell parser
            writeCellParser(allocation.root, 0, ctx);

            // Compile tuple
            if (allocation.ops.length === 0) {
                ctx.append(`return (sc_0, null());`);
            } else {
                ctx.append(
                    `return (sc_0, (${allocation.ops.map((v) => `v'${v.name}`).join(", ")}));`,
                );
            }
        });
    });

    // Write non-modifying variant

    ctx.fun(ops.readerNonModifying(name, ctx), () => {
        ctx.signature(
            `(${resolveFuncTypeFromAbi(
                allocation.ops.map((v) => v.type),
                ctx,
            )}) ${ops.readerNonModifying(name, ctx)}(slice sc_0)`,
        );
        if (forceInline || isSmall) {
            ctx.flag("inline");
        }
        ctx.context("type:" + name);
        ctx.body(() => {
            ctx.append(`var r = sc_0~${ops.reader(name, ctx)}();`);
            ctx.append(`sc_0.end_parse();`);
            ctx.append(`return r;`);
        });
    });
}

export function writeBouncedParser(
    name: string,
    forceInline: boolean,
    allocation: StorageAllocation,
    origin: ItemOrigin,
    ctx: WriterContext,
) {
    const isSmall = allocation.ops.length <= SMALL_STRUCT_MAX_FIELDS;

    ctx.fun(ops.readerBounced(name, ctx), () => {
        ctx.signature(
            `(slice, (${resolveFuncTypeFromAbi(
                allocation.ops.map((v) => v.type),
                ctx,
            )})) ${ops.readerBounced(name, ctx)}(slice sc_0)`,
        );
        if (forceInline || isSmall) {
            ctx.flag("inline");
        }
        ctx.context("type:" + name);
        ctx.body(() => {
            // Check prefix
            if (allocation.header) {
                ctx.append(
                    `throw_unless(${contractErrors.invalidPrefix.id}, sc_0~load_uint(${allocation.header.bits}) == ${allocation.header.value});`,
                );
            }

            // Write cell parser
            writeCellParser(allocation.root, 0, ctx);

            // Compile tuple
            if (allocation.ops.length === 0) {
                ctx.append(`return (sc_0, null());`);
            } else {
                ctx.append(
                    `return (sc_0, (${allocation.ops.map((v) => `v'${v.name}`).join(", ")}));`,
                );
            }
        });
    });
}

export function writeOptionalParser(
    name: string,
    origin: ItemOrigin,
    ctx: WriterContext,
) {
    ctx.fun(ops.readerOpt(name, ctx), () => {
        ctx.signature(`tuple ${ops.readerOpt(name, ctx)}(cell cl)`);
        ctx.flag("inline");
        ctx.context("type:" + name);
        ctx.body(() => {
            ctx.write(`
                if (null?(cl)) {
                    return null();
                }
                var sc = cl.begin_parse();
                return ${ops.typeAsOptional(name, ctx)}(sc~${ops.reader(name, ctx)}());
            `);
        });
    });
}

function writeCellParser(
    cell: AllocationCell,
    gen: number,
    ctx: WriterContext,
): number {
    // Write current fields
    for (const f of cell.ops) {
        writeFieldParser(f, gen, ctx);
    }

    // Handle next cell
    if (cell.next) {
        ctx.append(`slice sc_${gen + 1} = sc_${gen}~load_ref().begin_parse();`);
        return writeCellParser(cell.next, gen + 1, ctx);
    } else {
        return gen;
    }
}

function writeFieldParser(
    f: AllocationOperation,
    gen: number,
    ctx: WriterContext,
) {
    const op = f.op;
    const varName = `var v'${f.name}`;

    switch (op.kind) {
        case "int": {
            if (op.optional) {
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? sc_${gen}~load_int(${op.bits}) : null();`,
                );
            } else {
                ctx.append(`${varName} = sc_${gen}~load_int(${op.bits});`);
            }
            return;
        }
        case "uint": {
            if (op.optional) {
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? sc_${gen}~load_uint(${op.bits}) : null();`,
                );
            } else {
                ctx.append(`${varName} = sc_${gen}~load_uint(${op.bits});`);
            }
            return;
        }
        case "coins": {
            if (op.optional) {
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? sc_${gen}~load_coins() : null();`,
                );
            } else {
                ctx.append(`${varName} = sc_${gen}~load_coins();`);
            }
            return;
        }
        case "boolean": {
            if (op.optional) {
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? sc_${gen}~load_int(1) : null();`,
                );
            } else {
                ctx.append(`${varName} = sc_${gen}~load_int(1);`);
            }
            return;
        }
        case "address": {
            if (op.optional) {
                ctx.used(`__tact_load_address_opt`);
                ctx.append(`${varName} = sc_${gen}~__tact_load_address_opt();`);
            } else {
                ctx.used(`__tact_load_address`);
                ctx.append(`${varName} = sc_${gen}~__tact_load_address();`);
            }
            return;
        }
        case "cell": {
            if (op.optional) {
                if (op.format !== "default") {
                    throw new Error(`Impossible`);
                }
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? sc_${gen}~load_ref() : null();`,
                );
            } else {
                switch (op.format) {
                    case "default":
                        {
                            ctx.append(`${varName} = sc_${gen}~load_ref();`);
                        }
                        break;
                    case "remainder": {
                        ctx.append(
                            `${varName} = begin_cell().store_slice(sc_${gen}).end_cell();`,
                        );
                    }
                }
            }
            return;
        }
        case "slice": {
            if (op.optional) {
                if (op.format !== "default") {
                    throw new Error(`Impossible`);
                }
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? sc_${gen}~load_ref().begin_parse() : null();`,
                );
            } else {
                switch (op.format) {
                    case "default":
                        {
                            ctx.append(
                                `${varName} = sc_${gen}~load_ref().begin_parse();`,
                            );
                        }
                        break;
                    case "remainder":
                        {
                            ctx.append(`${varName} = sc_${gen};`);
                        }
                        break;
                }
            }
            return;
        }
        case "builder": {
            if (op.optional) {
                if (op.format !== "default") {
                    throw new Error(`Impossible`);
                }
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? begin_cell().store_slice(sc_${gen}~load_ref().begin_parse()) : null();`,
                );
            } else {
                switch (op.format) {
                    case "default":
                        {
                            ctx.append(
                                `${varName} = begin_cell().store_slice(sc_${gen}~load_ref().begin_parse());`,
                            );
                        }
                        break;
                    case "remainder":
                        {
                            ctx.append(
                                `${varName} = begin_cell().store_slice(sc_${gen});`,
                            );
                        }
                        break;
                }
            }
            return;
        }
        case "string": {
            if (op.optional) {
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? sc_${gen}~load_ref().begin_parse() : null();`,
                );
            } else {
                ctx.append(`${varName} = sc_${gen}~load_ref().begin_parse();`);
            }
            return;
        }
        case "fixed-bytes": {
            if (op.optional) {
                ctx.append(
                    `${varName} = sc_${gen}~load_int(1) ? sc_${gen}~load_bits(${op.bytes * 8}) : null();`,
                );
            } else {
                ctx.append(
                    `${varName} = sc_${gen}~load_bits(${op.bytes * 8});`,
                );
            }
            return;
        }
        case "map": {
            ctx.append(`${varName} = sc_${gen}~load_dict();`);
            return;
        }
        case "struct": {
            if (op.optional) {
                if (op.ref) {
                    throw Error("Not implemented");
                } else {
                    ctx.append(
                        `${varName} = sc_${gen}~load_int(1) ? ${ops.typeAsOptional(op.type, ctx)}(sc_${gen}~${ops.reader(op.type, ctx)}()) : null();`,
                    );
                }
            } else {
                if (op.ref) {
                    throw Error("Not implemented");
                } else {
                    ctx.append(
                        `${varName} = sc_${gen}~${ops.reader(op.type, ctx)}();`,
                    );
                }
            }
            return;
        }
    }
}


## writeStdlib.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/generator/writers/writeStdlib.ts)
import { contractErrors } from "../../abi/errors";
import { maxTupleSize } from "../../bindings/typescript/writeStruct";
import { match } from "../../utils/tricks";
import { WriterContext } from "../Writer";

export function writeStdlib(ctx: WriterContext): void {
    //
    // stdlib extension functions
    //

    ctx.skip("__tact_set");
    ctx.skip("__tact_nop");
    ctx.skip("__tact_str_to_slice");
    ctx.skip("__tact_slice_to_str");
    ctx.skip("__tact_address_to_slice");

    //
    // Addresses
    //

    ctx.fun("__tact_load_address", () => {
        ctx.signature(`(slice, slice) __tact_load_address(slice cs)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                slice raw = cs~load_msg_addr();
                return (cs, raw);
            `);
        });
    });

    ctx.fun("__tact_load_address_opt", () => {
        ctx.signature(`(slice, slice) __tact_load_address_opt(slice cs)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                if (cs.preload_uint(2) != 0) {
                    slice raw = cs~load_msg_addr();
                    return (cs, raw);
                } else {
                    cs~skip_bits(2);
                    return (cs, null());
                }
            `);
        });
    });

    ctx.fun("__tact_store_address", () => {
        ctx.signature(`builder __tact_store_address(builder b, slice address)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return b.store_slice(address);
            `);
        });
    });

    ctx.fun("__tact_store_address_opt", () => {
        ctx.signature(
            `builder __tact_store_address_opt(builder b, slice address)`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                if (null?(address)) {
                    b = b.store_uint(0, 2);
                    return b;
                } else {
                    return ${ctx.used(`__tact_store_address`)}(b, address);
                }
            `);
        });
    });

    ctx.fun("__tact_create_address", () => {
        ctx.signature(`slice __tact_create_address(int chain, int hash)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var b = begin_cell();
                b = b.store_uint(2, 2);
                b = b.store_uint(0, 1);
                b = b.store_int(chain, 8);
                b = b.store_uint(hash, 256);
                var addr = b.end_cell().begin_parse();
                return addr;
        `);
        });
    });

    ctx.fun("__tact_compute_contract_address", () => {
        ctx.signature(
            `slice __tact_compute_contract_address(int chain, cell code, cell data)`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var b = begin_cell();
                b = b.store_uint(0, 2);
                b = b.store_uint(3, 2);
                b = b.store_uint(0, 1);
                b = b.store_ref(code);
                b = b.store_ref(data);
                var hash = cell_hash(b.end_cell());
                return ${ctx.used(`__tact_create_address`)}(chain, hash);
            `);
        });
    });

    ctx.fun("__tact_not_null", () => {
        ctx.signature(`forall X -> X __tact_not_null(X x)`);
        ctx.flag("impure");
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(
                `throw_if(${contractErrors.null.id}, null?(x)); return x;`,
            );
        });
    });

    ctx.fun("__tact_dict_delete", () => {
        ctx.signature(
            `(cell, int) __tact_dict_delete(cell dict, int key_len, slice index)`,
        );
        ctx.context("stdlib");
        ctx.asm("(index dict key_len)", "DICTDEL");
    });

    ctx.fun("__tact_dict_delete_int", () => {
        ctx.signature(
            `(cell, int) __tact_dict_delete_int(cell dict, int key_len, int index)`,
        );
        ctx.context("stdlib");
        ctx.asm("(index dict key_len)", "DICTIDEL");
    });

    ctx.fun("__tact_dict_delete_uint", () => {
        ctx.signature(
            `(cell, int) __tact_dict_delete_uint(cell dict, int key_len, int index)`,
        );
        ctx.context("stdlib");
        ctx.asm("(index dict key_len)", "DICTUDEL");
    });

    ctx.fun("__tact_dict_set_ref", () => {
        ctx.signature(
            `((cell), ()) __tact_dict_set_ref(cell dict, int key_len, slice index, cell value)`,
        );
        ctx.context("stdlib");
        ctx.asm("(value index dict key_len)", "DICTSETREF");
    });

    ctx.fun("__tact_dict_replace_ref", () => {
        ctx.signature(
            `((cell), (int)) __tact_dict_replace_ref(cell dict, int key_len, slice index, cell value)`,
        );
        ctx.context("stdlib");
        ctx.asm("(value index dict key_len)", "DICTREPLACEREF");
    });

    ctx.fun("__tact_dict_replaceget_ref", () => {
        ctx.signature(
            `((cell), (cell, int)) __tact_dict_replaceget_ref(cell dict, int key_len, slice index, cell value)`,
        );
        ctx.context("stdlib");
        ctx.asm(
            "(value index dict key_len)",
            "DICTREPLACEGETREF NULLSWAPIFNOT",
        );
    });

    ctx.fun("__tact_dict_get", () => {
        ctx.signature(
            `(slice, int) __tact_dict_get(cell dict, int key_len, slice index)`,
        );
        ctx.context("stdlib");
        ctx.asm("(index dict key_len)", "DICTGET NULLSWAPIFNOT");
    });

    ctx.fun("__tact_dict_delete_get", () => {
        ctx.signature(
            `(cell, (slice, int)) __tact_dict_delete_get(cell dict, int key_len, slice index)`,
        );
        ctx.context("stdlib");
        ctx.asm("(index dict key_len)", "DICTDELGET NULLSWAPIFNOT");
    });

    ctx.fun("__tact_dict_delete_get_ref", () => {
        ctx.signature(
            `(cell, (cell, int)) __tact_dict_delete_get_ref(cell dict, int key_len, slice index)`,
        );
        ctx.context("stdlib");
        ctx.asm("(index dict key_len)", "DICTDELGETREF NULLSWAPIFNOT");
    });

    ctx.fun("__tact_dict_get_ref", () => {
        ctx.signature(
            `(cell, int) __tact_dict_get_ref(cell dict, int key_len, slice index)`,
        );
        ctx.context("stdlib");
        ctx.asm("(index dict key_len)", "DICTGETREF NULLSWAPIFNOT");
    });

    ctx.fun("__tact_dict_min", () => {
        ctx.signature(
            `(slice, slice, int) __tact_dict_min(cell dict, int key_len)`,
        );
        ctx.context("stdlib");
        ctx.asm("(dict key_len -> 1 0 2)", "DICTMIN  NULLSWAPIFNOT2");
    });

    ctx.fun("__tact_dict_min_ref", () => {
        ctx.signature(
            `(slice, cell, int) __tact_dict_min_ref(cell dict, int key_len)`,
        );
        ctx.context("stdlib");
        ctx.asm("(dict key_len -> 1 0 2)", "DICTMINREF NULLSWAPIFNOT2");
    });

    ctx.fun("__tact_dict_next", () => {
        ctx.signature(
            `(slice, slice, int) __tact_dict_next(cell dict, int key_len, slice pivot)`,
        );
        ctx.context("stdlib");
        ctx.asm("(pivot dict key_len -> 1 0 2)", "DICTGETNEXT NULLSWAPIFNOT2");
    });

    ctx.fun("__tact_dict_next_ref", () => {
        ctx.signature(
            `(slice, cell, int) __tact_dict_next_ref(cell dict, int key_len, slice pivot)`,
        );
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var (key, value, flag) = ${ctx.used(
                    "__tact_dict_next",
                )}(dict, key_len, pivot);
                if (flag) {
                    return (key, value~load_ref(), flag);
                } else {
                    return (null(), null(), flag);
                }
            `);
        });
    });

    ctx.fun("__tact_debug", () => {
        ctx.signature(
            `forall X -> () __tact_debug(X value, slice debug_print_1, slice debug_print_2)`,
        );
        ctx.flag("impure");
        ctx.context("stdlib");
        ctx.asm("", "STRDUMP DROP STRDUMP DROP s0 DUMP DROP");
    });

    ctx.fun("__tact_debug_str", () => {
        ctx.signature(
            `() __tact_debug_str(slice value, slice debug_print_1, slice debug_print_2)`,
        );
        ctx.flag("impure");
        ctx.context("stdlib");
        ctx.asm("", "STRDUMP DROP STRDUMP DROP STRDUMP DROP");
    });

    ctx.fun("__tact_debug_bool", () => {
        ctx.signature(
            `() __tact_debug_bool(int value, slice debug_print_1, slice debug_print_2)`,
        );
        ctx.flag("impure");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                if (value) {
                    ${ctx.used(
                        "__tact_debug_str",
                    )}("true", debug_print_1, debug_print_2);
                } else {
                    ${ctx.used(
                        "__tact_debug_str",
                    )}("false", debug_print_1, debug_print_2);
                }
            `);
        });
    });

    ctx.fun("__tact_preload_offset", () => {
        ctx.signature(
            `(slice) __tact_preload_offset(slice s, int offset, int bits)`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.asm("", "SDSUBSTR");
    });

    ctx.fun("__tact_crc16", () => {
        ctx.signature(`(slice) __tact_crc16(slice data)`);
        ctx.flag("inline_ref");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                slice new_data = begin_cell()
                    .store_slice(data)
                    .store_slice("0000"s)
                .end_cell().begin_parse();
                int reg = 0;
                while (~ new_data.slice_data_empty?()) {
                    int byte = new_data~load_uint(8);
                    int mask = 0x80;
                    while (mask > 0) {
                        reg <<= 1;
                        if (byte & mask) {
                            reg += 1;
                        }
                        mask >>= 1;
                        if (reg > 0xffff) {
                            reg &= 0xffff;
                            reg ^= 0x1021;
                        }
                    }
                }
                (int q, int r) = divmod(reg, 256);
                return begin_cell()
                    .store_uint(q, 8)
                    .store_uint(r, 8)
                .end_cell().begin_parse();
            `);
        });
    });

    ctx.fun("__tact_base64_encode", () => {
        ctx.signature(`(slice) __tact_base64_encode(slice data)`);
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                slice chars = "4142434445464748494A4B4C4D4E4F505152535455565758595A6162636465666768696A6B6C6D6E6F707172737475767778797A303132333435363738392D5F"s;
                builder res = begin_cell();
            
                while (data.slice_bits() >= 24) {
                    (int bs1, int bs2, int bs3) = (data~load_uint(8), data~load_uint(8), data~load_uint(8));
            
                    int n = (bs1 << 16) | (bs2 << 8) | bs3;
            
                    res = res
                        .store_slice(${ctx.used(
                            "__tact_preload_offset",
                        )}(chars, ((n >> 18) & 63) * 8, 8))
                        .store_slice(${ctx.used(
                            "__tact_preload_offset",
                        )}(chars, ((n >> 12) & 63) * 8, 8))
                        .store_slice(${ctx.used(
                            "__tact_preload_offset",
                        )}(chars, ((n >>  6) & 63) * 8, 8))
                        .store_slice(${ctx.used(
                            "__tact_preload_offset",
                        )}(chars, ((n      ) & 63) * 8, 8));
                }
                
                return res.end_cell().begin_parse();
            `);
        });
    });

    ctx.fun("__tact_address_to_user_friendly", () => {
        ctx.signature(`(slice) __tact_address_to_user_friendly(slice address)`);
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                (int wc, int hash) = address.parse_std_addr();

                slice user_friendly_address = begin_cell()
                    .store_slice("11"s)
                    .store_uint((wc + 0x100) % 0x100, 8)
                    .store_uint(hash, 256)
                .end_cell().begin_parse();
            
                slice checksum = ${ctx.used(
                    "__tact_crc16",
                )}(user_friendly_address);
                slice user_friendly_address_with_checksum = begin_cell()
                    .store_slice(user_friendly_address)
                    .store_slice(checksum)
                .end_cell().begin_parse();
            
                return ${ctx.used(
                    "__tact_base64_encode",
                )}(user_friendly_address_with_checksum);
            `);
        });
    });

    ctx.fun("__tact_debug_address", () => {
        ctx.signature(
            `() __tact_debug_address(slice address, slice debug_print_1, slice debug_print_2)`,
        );
        ctx.flag("impure");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                ${ctx.used("__tact_debug_str")}(${ctx.used(
                    "__tact_address_to_user_friendly",
                )}(address), debug_print_1, debug_print_2);
            `);
        });
    });

    ctx.fun("__tact_debug_stack", () => {
        ctx.signature(
            `() __tact_debug_stack(slice debug_print_1, slice debug_print_2)`,
        );
        ctx.flag("impure");
        ctx.context("stdlib");
        ctx.asm("", "STRDUMP DROP STRDUMP DROP DUMPSTK");
    });

    ctx.fun("__tact_context_get", () => {
        ctx.signature(`(int, slice, int, slice) __tact_context_get()`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`return __tact_context;`);
        });
    });

    ctx.fun("__tact_context_get_sender", () => {
        ctx.signature(`slice __tact_context_get_sender()`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`return __tact_context_sender;`);
        });
    });

    ctx.fun("__tact_prepare_random", () => {
        ctx.signature(`() __tact_prepare_random()`);
        ctx.flag("impure");
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                if (null?(__tact_randomized)) {
                    randomize_lt();
                    __tact_randomized = true;
                }
            `);
        });
    });

    ctx.fun("__tact_store_bool", () => {
        ctx.signature(`builder __tact_store_bool(builder b, int v)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return b.store_int(v, 1);
            `);
        });
    });

    ctx.fun("__tact_to_tuple", () => {
        ctx.signature(`forall X -> tuple __tact_to_tuple(X x)`);
        ctx.context("stdlib");
        ctx.asm("", "NOP");
    });

    ctx.fun("__tact_from_tuple", () => {
        ctx.signature(`forall X -> X __tact_from_tuple(tuple x)`);
        ctx.context("stdlib");
        ctx.asm("", "NOP");
    });

    //
    // Address
    //

    ctx.fun(`__tact_slice_eq_bits`, () => {
        ctx.signature(`int __tact_slice_eq_bits(slice a, slice b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return equal_slices_bits(a, b);
            `);
        });
    });

    ctx.fun(`__tact_slice_eq_bits_nullable_one`, () => {
        ctx.signature(
            `int __tact_slice_eq_bits_nullable_one(slice a, slice b)`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (null?(a)) ? (false) : (equal_slices_bits(a, b));
            `);
        });
    });

    ctx.fun(`__tact_slice_eq_bits_nullable`, () => {
        ctx.signature(`int __tact_slice_eq_bits_nullable(slice a, slice b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var a_is_null = null?(a);
                var b_is_null = null?(b);
                return ( a_is_null & b_is_null ) ? ( true ) : ( ( ( ~ a_is_null ) & ( ~ b_is_null ) ) ? ( equal_slices_bits(a, b) ) : ( false ) );
            `);
        });
    });

    //
    // Dictionary deep equality
    //

    ctx.fun(`__tact_dict_eq`, () => {
        ctx.signature(`int __tact_dict_eq(cell a, cell b, int kl)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                (slice key, slice value, int flag) = ${ctx.used(
                    "__tact_dict_min",
                )}(a, kl);
                while (flag) {
                    (slice value_b, int flag_b) = b~${ctx.used(
                        "__tact_dict_delete_get",
                    )}(kl, key);
                    ifnot (flag_b) {
                        return 0;
                    }
                    ifnot (value.slice_hash() == value_b.slice_hash()) {
                        return 0;
                    }
                    (key, value, flag) = ${ctx.used(
                        "__tact_dict_next",
                    )}(a, kl, key);
                }
                return null?(b);
            `);
        });
    });

    //
    // Int Eq
    //

    ctx.fun(`__tact_int_eq_nullable_one`, () => {
        ctx.signature(`int __tact_int_eq_nullable_one(int a, int b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (null?(a)) ? (false) : (a == b);
            `);
        });
    });

    ctx.fun(`__tact_int_neq_nullable_one`, () => {
        ctx.signature(`int __tact_int_neq_nullable_one(int a, int b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (null?(a)) ? (true) : (a != b);
            `);
        });
    });

    ctx.fun(`__tact_int_eq_nullable`, () => {
        ctx.signature(`int __tact_int_eq_nullable(int a, int b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var a_is_null = null?(a);
                var b_is_null = null?(b);
                return ( a_is_null & b_is_null ) ? ( true ) : ( ( ( ~ a_is_null ) & ( ~ b_is_null ) ) ? ( a == b ) : ( false ) );
            `);
        });
    });

    ctx.fun(`__tact_int_neq_nullable`, () => {
        ctx.signature(`int __tact_int_neq_nullable(int a, int b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var a_is_null = null?(a);
                var b_is_null = null?(b);
                return ( a_is_null & b_is_null ) ? ( false ) : ( ( ( ~ a_is_null ) & ( ~ b_is_null ) ) ? ( a != b ) : ( true ) );
            `);
        });
    });

    //
    // Cell Eq
    //

    ctx.fun(`__tact_cell_eq`, () => {
        ctx.signature(`int __tact_cell_eq(cell a, cell b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (a.cell_hash() ==  b.cell_hash());
            `);
        });
    });

    ctx.fun(`__tact_cell_neq`, () => {
        ctx.signature(`int __tact_cell_neq(cell a, cell b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (a.cell_hash() !=  b.cell_hash());
            `);
        });
    });

    ctx.fun(`__tact_cell_eq_nullable_one`, () => {
        ctx.signature(`int __tact_cell_eq_nullable_one(cell a, cell b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (null?(a)) ? (false) : (a.cell_hash() == b.cell_hash());
            `);
        });
    });

    ctx.fun(`__tact_cell_neq_nullable_one`, () => {
        ctx.signature(`int __tact_cell_neq_nullable_one(cell a, cell b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (null?(a)) ? (true) : (a.cell_hash() != b.cell_hash());
            `);
        });
    });

    ctx.fun(`__tact_cell_eq_nullable`, () => {
        ctx.signature(`int __tact_cell_eq_nullable(cell a, cell b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var a_is_null = null?(a);
                var b_is_null = null?(b);
                return ( a_is_null & b_is_null ) ? ( true ) : ( ( ( ~ a_is_null ) & ( ~ b_is_null ) ) ? ( a.cell_hash() == b.cell_hash() ) : ( false ) );
            `);
        });
    });

    ctx.fun(`__tact_cell_neq_nullable`, () => {
        ctx.signature(`int __tact_cell_neq_nullable(cell a, cell b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var a_is_null = null?(a);
                var b_is_null = null?(b);
                return ( a_is_null & b_is_null ) ? ( false ) : ( ( ( ~ a_is_null ) & ( ~ b_is_null ) ) ? ( a.cell_hash() != b.cell_hash() ) : ( true ) );
            `);
        });
    });

    //
    // Slice Eq
    //

    ctx.fun(`__tact_slice_eq`, () => {
        ctx.signature(`int __tact_slice_eq(slice a, slice b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (a.slice_hash() ==  b.slice_hash());
            `);
        });
    });

    ctx.fun(`__tact_slice_neq`, () => {
        ctx.signature(`int __tact_slice_neq(slice a, slice b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (a.slice_hash() !=  b.slice_hash());
            `);
        });
    });

    ctx.fun(`__tact_slice_eq_nullable_one`, () => {
        ctx.signature(`int __tact_slice_eq_nullable_one(slice a, slice b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (null?(a)) ? (false) : (a.slice_hash() == b.slice_hash());
            `);
        });
    });

    ctx.fun(`__tact_slice_neq_nullable_one`, () => {
        ctx.signature(`int __tact_slice_neq_nullable_one(slice a, slice b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return (null?(a)) ? (true) : (a.slice_hash() != b.slice_hash());
            `);
        });
    });

    ctx.fun(`__tact_slice_eq_nullable`, () => {
        ctx.signature(`int __tact_slice_eq_nullable(slice a, slice b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var a_is_null = null?(a);
                var b_is_null = null?(b);
                return ( a_is_null & b_is_null ) ? ( true ) : ( ( ( ~ a_is_null ) & ( ~ b_is_null ) ) ? ( a.slice_hash() == b.slice_hash() ) : ( false ) );
            `);
        });
    });

    ctx.fun(`__tact_slice_neq_nullable`, () => {
        ctx.signature(`int __tact_slice_neq_nullable(slice a, slice b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var a_is_null = null?(a);
                var b_is_null = null?(b);
                return ( a_is_null & b_is_null ) ? ( false ) : ( ( ( ~ a_is_null ) & ( ~ b_is_null ) ) ? ( a.slice_hash() != b.slice_hash() ) : ( true ) );
            `);
        });
    });

    //
    // Sys Dict
    //

    ctx.fun(`__tact_dict_set_code`, () => {
        ctx.signature(
            `cell __tact_dict_set_code(cell dict, int id, cell code)`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return udict_set_ref(dict, 16, id, code);
            `);
        });
    });

    ctx.fun(`__tact_dict_get_code`, () => {
        ctx.signature(`cell __tact_dict_get_code(cell dict, int id)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var (data, ok) = udict_get_ref?(dict, 16, id);
                throw_unless(${contractErrors.codeNotFound.id}, ok);
                return data;
            `);
        });
    });

    //
    // Tuples
    //

    ctx.fun(`__tact_tuple_create_0`, () => {
        ctx.signature(`tuple __tact_tuple_create_0()`);
        ctx.context("stdlib");
        ctx.asm("", "NIL");
    });
    ctx.fun(`__tact_tuple_destroy_0`, () => {
        ctx.signature(`() __tact_tuple_destroy_0()`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.append(`return ();`);
        });
    });

    for (let i = 1; i <= maxTupleSize; i++) {
        ctx.fun(`__tact_tuple_create_${i}`, () => {
            const args: string[] = [];
            for (let j = 0; j < i; j++) {
                args.push(`X${j}`);
            }
            ctx.signature(
                `forall ${args.join(
                    ", ",
                )} -> tuple __tact_tuple_create_${i}((${args.join(", ")}) v)`,
            );
            ctx.context("stdlib");
            ctx.asm("", `${i} TUPLE`);
        });
        ctx.fun(`__tact_tuple_destroy_${i}`, () => {
            const args: string[] = [];
            for (let j = 0; j < i; j++) {
                args.push(`X${j}`);
            }
            ctx.signature(
                `forall ${args.join(", ")} -> (${args.join(
                    ", ",
                )}) __tact_tuple_destroy_${i}(tuple v)`,
            );
            ctx.context("stdlib");
            ctx.asm("", `${i} UNTUPLE`);
        });
    }

    //
    // Strings
    //

    ctx.fun(`__tact_string_builder_start_comment`, () => {
        ctx.signature(`tuple __tact_string_builder_start_comment()`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return ${ctx.used(
                    "__tact_string_builder_start",
                )}(begin_cell().store_uint(0, 32));
            `);
        });
    });

    ctx.fun(`__tact_string_builder_start_tail_string`, () => {
        ctx.signature(`tuple __tact_string_builder_start_tail_string()`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return ${ctx.used(
                    "__tact_string_builder_start",
                )}(begin_cell().store_uint(0, 8));
            `);
        });
    });

    ctx.fun(`__tact_string_builder_start_string`, () => {
        ctx.signature(`tuple __tact_string_builder_start_string()`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return ${ctx.used("__tact_string_builder_start")}(begin_cell());
            `);
        });
    });

    ctx.fun(`__tact_string_builder_start`, () => {
        ctx.signature(`tuple __tact_string_builder_start(builder b)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return tpush(tpush(empty_tuple(), b), null());
            `);
        });
    });

    ctx.fun(`__tact_string_builder_end`, () => {
        ctx.signature(`cell __tact_string_builder_end(tuple builders)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                (builder b, tuple tail) = uncons(builders);
                cell c = b.end_cell();
                while(~ null?(tail)) {
                    (b, tail) = uncons(tail);
                    c = b.store_ref(c).end_cell();
                }
                return c;
            `);
        });
    });

    ctx.fun(`__tact_string_builder_end_slice`, () => {
        ctx.signature(`slice __tact_string_builder_end_slice(tuple builders)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                return ${ctx.used(
                    "__tact_string_builder_end",
                )}(builders).begin_parse();
            `);
        });
    });

    ctx.fun(`__tact_string_builder_append`, () => {
        ctx.signature(
            `((tuple), ()) __tact_string_builder_append(tuple builders, slice sc)`,
        );
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                int sliceRefs = slice_refs(sc);
                int sliceBits = slice_bits(sc);

                while((sliceBits > 0) | (sliceRefs > 0)) {

                    ;; Load the current builder
                    (builder b, tuple tail) = uncons(builders);
                    int remBytes = 127 - (builder_bits(b) / 8);
                    int exBytes = sliceBits / 8;

                    ;; Append bits
                    int amount = min(remBytes, exBytes);
                    if (amount > 0) {
                        slice read = sc~load_bits(amount * 8);
                        b = b.store_slice(read);
                    }

                    ;; Update builders
                    builders = cons(b, tail);

                    ;; Check if we need to add a new cell and continue
                    if (exBytes - amount > 0) {
                        var bb = begin_cell();
                        builders = cons(bb, builders);
                        sliceBits = (exBytes - amount) * 8;
                    } elseif (sliceRefs > 0) {
                        sc = sc~load_ref().begin_parse();
                        sliceRefs = slice_refs(sc);
                        sliceBits = slice_bits(sc);
                    } else {
                        sliceBits = 0;
                        sliceRefs = 0;
                    }
                }

                return ((builders), ());
            `);
        });
    });

    ctx.fun(`__tact_string_builder_append_not_mut`, () => {
        ctx.signature(
            `(tuple) __tact_string_builder_append_not_mut(tuple builders, slice sc)`,
        );
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                builders~${ctx.used("__tact_string_builder_append")}(sc);
                return builders;
            `);
        });
    });

    ctx.fun(`__tact_int_to_string`, () => {
        ctx.signature(`slice __tact_int_to_string(int src)`);
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var b = begin_cell();
                if (src < 0) {
                    b = b.store_uint(45, 8);
                    src = - src;
                }

                if (src < ${(10n ** 30n).toString(10)}) {
                    int len = 0;
                    int value = 0;
                    int mult = 1;
                    do {
                        (src, int res) = src.divmod(10);
                        value = value + (res + 48) * mult;
                        mult = mult * 256;
                        len = len + 1;
                    } until (src == 0);

                    b = b.store_uint(value, len * 8);
                } else {
                    tuple t = empty_tuple();
                    int len = 0;
                    do {
                        int digit = src % 10;
                        t~tpush(digit);
                        len = len + 1;
                        src = src / 10;
                    } until (src == 0);

                    int c = len - 1;
                    repeat(len) {
                        int v = t.at(c);
                        b = b.store_uint(v + 48, 8);
                        c = c - 1;
                    }
                }
                return b.end_cell().begin_parse();
            `);
        });
    });

    ctx.fun(`__tact_float_to_string`, () => {
        ctx.signature(`slice __tact_float_to_string(int src, int digits)`);
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                throw_if(${contractErrors.invalidArgument.id}, (digits <= 0) | (digits > 77));
                builder b = begin_cell();

                if (src < 0) {
                    b = b.store_uint(45, 8);
                    src = - src;
                }

                ;; Process rem part
                int skip = true;
                int len = 0;
                int rem = 0;
                tuple t = empty_tuple();
                repeat(digits) {
                    (src, rem) = src.divmod(10);
                    if ( ~ ( skip & ( rem == 0 ) ) ) {
                        skip = false;
                        t~tpush(rem + 48);
                        len = len + 1;
                    }
                }

                ;; Process dot
                if (~ skip) {
                    t~tpush(46);
                    len = len + 1;
                }

                ;; Main
                do {
                    (src, rem) = src.divmod(10);
                    t~tpush(rem + 48);
                    len = len + 1;
                } until (src == 0);

                ;; Assemble
                int c = len - 1;
                repeat(len) {
                    int v = t.at(c);
                    b = b.store_uint(v, 8);
                    c = c - 1;
                }

                ;; Result
                return b.end_cell().begin_parse();
            `);
        });
    });

    ctx.fun(`__tact_log`, () => {
        ctx.signature(`int __tact_log(int num, int base)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                throw_unless(5, num > 0);
                throw_unless(5, base > 1);
                if (num < base) {
                    return 0;
                }
                int result = 0;
                while (num >= base) {
                    num /= base;
                    result += 1;
                }
                return result;
            `);
        });
    });

    ctx.fun(`__tact_pow`, () => {
        ctx.signature(`int __tact_pow(int base, int exp)`);
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                throw_unless(5, exp >= 0);
                int result = 1;
                repeat (exp) {
                    result *= base;
                }
                return result;
            `);
        });
    });

    // generate dict operations for all combinations of key/value types
    for (const key of keyTypes) {
        for (const val of valTypes) {
            genTactDictGet(ctx, key, val);
            genTactDictGetMin(ctx, key, val);
            genTactDictGetNext(ctx, key, val);
            genTactDictSet(ctx, key, val);
            genTactDictReplace(ctx, key, val);
            genTactDictReplaceGet(ctx, key, val);
        }
    }
    for (const key of keyTypes) {
        genTactDictExists(ctx, key);
    }
}

const keyTypes = ["slice", "uint", "int"] as const;
type KeyType = (typeof keyTypes)[number];

const valTypes = ["slice", "int", "uint", "cell", "coins"] as const;
type ValType = (typeof valTypes)[number];

function getSignatureKeyType(key: KeyType): KeyType {
    return key === "uint" ? "int" : key;
}

function getSignatureValueType(value: ValType): ValType {
    return value === "uint" || value === "coins" ? "int" : value;
}

function genTactDictGet(
    ctx: WriterContext,
    key: KeyType,
    value: ValType,
): void {
    const signatureKeyType = getSignatureKeyType(key);
    const signatureValueType = getSignatureValueType(value);
    const dictGet = () => {
        const cellSuffix = value === "cell" ? "_ref" : "";
        switch (key) {
            case "slice":
                return ctx.used(`__tact_dict_get${cellSuffix}`);
            case "uint":
                return `udict_get${cellSuffix}?`;
            case "int":
                return `idict_get${cellSuffix}?`;
        }
    };
    const returnExpr = () => {
        switch (value) {
            case "slice":
            case "cell":
                return "r";
            case "uint":
                return "r~load_uint(vl)";
            case "int":
                return "r~load_int(vl)";
            case "coins":
                return "r~load_coins()";
        }
    };
    const valBitsArg = () => {
        switch (value) {
            case "slice":
            case "cell":
            case "coins":
                return "";
            case "uint":
            case "int":
                return ", int vl";
        }
    };
    ctx.fun(`__tact_dict_get_${key}_${value}`, () => {
        ctx.signature(
            `${signatureValueType} __tact_dict_get_${key}_${value}(cell d, int kl, ${signatureKeyType} k${valBitsArg()})`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var (r, ok) = ${dictGet()}(d, kl, k);
                if (ok) {
                    return ${returnExpr()};
                } else {
                    return null();
                }
            `);
        });
    });
}

function genTactDictExists(ctx: WriterContext, key: KeyType): void {
    const signatureKeyType = getSignatureKeyType(key);
    const dictGet = () => {
        switch (key) {
            case "slice":
                return ctx.used("__tact_dict_get");
            case "uint":
                return "udict_get?";
            case "int":
                return "idict_get?";
        }
    };
    ctx.fun(`__tact_dict_exists_${key}`, () => {
        ctx.signature(
            `int __tact_dict_exists_${key}(cell d, int kl, ${signatureKeyType} k)`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var (r, ok) = ${dictGet()}(d, kl, k);
                return ok;
            `);
        });
    });
}

function genTactDictSet(
    ctx: WriterContext,
    key: KeyType,
    value: ValType,
): void {
    const signatureKeyType = getSignatureKeyType(key);
    const signatureValueType = getSignatureValueType(value);
    const valBitsArg = () => {
        switch (value) {
            case "slice":
            case "cell":
            case "coins":
                return "";
            case "uint":
            case "int":
                return ", int vl";
        }
    };
    const dictDel = () => {
        switch (key) {
            case "slice":
                return ctx.used("__tact_dict_delete");
            case "uint":
                return "udict_delete?";
            case "int":
                return "idict_delete?";
        }
    };
    // prettier-ignore
    const returnExpr = () => match(key, value)
        .on("int", "int")(() => "(idict_set_builder(d, kl, k, begin_cell().store_int(v, vl)), ())")
        .on("int", "uint")(() => "(idict_set_builder(d, kl, k, begin_cell().store_uint(v, vl)), ())")
        .on("int", "coins")(() => "(idict_set_builder(d, kl, k, begin_cell().store_coins(v)), ())")
        .on("uint", "int")(() => "(udict_set_builder(d, kl, k, begin_cell().store_int(v, vl)), ())")
        .on("uint", "uint")(() => "(udict_set_builder(d, kl, k, begin_cell().store_uint(v, vl)), ())")
        .on("uint", "coins")(() => "(udict_set_builder(d, kl, k, begin_cell().store_coins(v)), ())")
        .on("slice", "int")(() => "(dict_set_builder(d, kl, k, begin_cell().store_int(v, vl)), ())")
        .on("slice", "uint")(() => "(dict_set_builder(d, kl, k, begin_cell().store_uint(v, vl)), ())")
        .on("slice", "coins")(() => "(dict_set_builder(d, kl, k, begin_cell().store_coins(v)), ())")
        .on("int", "cell")(() => "(idict_set_ref(d, kl, k, v), ())")
        .on("uint", "cell")(() => "(udict_set_ref(d, kl, k, v), ())")
        .on("int", "slice")(() => "(idict_set(d, kl, k, v), ())")
        .on("uint", "slice")(() => "(udict_set(d, kl, k, v), ())")
        .on("slice", "cell")(() => `${ctx.used("__tact_dict_set_ref")}(d, kl, k, v)`)
        .on("slice", "slice")(() => "(dict_set_builder(d, kl, k, begin_cell().store_slice(v)), ())")
        .end();
    ctx.fun(`__tact_dict_set_${key}_${value}`, () => {
        ctx.signature(
            `(cell, ()) __tact_dict_set_${key}_${value}(cell d, int kl, ${signatureKeyType} k, ${signatureValueType} v${valBitsArg()})`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                if (null?(v)) {
                    var (r, ok) = ${dictDel()}(d, kl, k);
                    return (r, ());
                } else {
                    return ${returnExpr()};
                }
            `);
        });
    });
}

function genTactDictGetMin(
    ctx: WriterContext,
    key: KeyType,
    value: ValType,
): void {
    const signatureKeyType = getSignatureKeyType(key);
    const signatureValueType = getSignatureValueType(value);
    const valBitsArg = () => {
        switch (value) {
            case "slice":
            case "cell":
            case "coins":
                return "";
            case "uint":
            case "int":
                return ", int vl";
        }
    };
    // prettier-ignore
    const dictGetMin = () => match(key, value)
        .on("int", "int")(() => "idict_get_min?")
        .on("int", "uint")(() => "idict_get_min?")
        .on("int", "coins")(() => "idict_get_min?")
        .on("int", "slice")(() => "idict_get_min?")
        .on("uint", "int")(() => "udict_get_min?")
        .on("uint", "uint")(() => "udict_get_min?")
        .on("uint", "coins")(() => "udict_get_min?")
        .on("uint", "slice")(() => "udict_get_min?")
        .on("slice", "int")(() => ctx.used("__tact_dict_min"))
        .on("slice", "uint")(() => ctx.used("__tact_dict_min"))
        .on("slice", "coins")(() => ctx.used("__tact_dict_min"))
        .on("slice", "slice")(() => ctx.used("__tact_dict_min"))
        .on("int", "cell")(() => "idict_get_min_ref?")
        .on("uint", "cell")(() => "udict_get_min_ref?")
        .on("slice", "cell")(() => ctx.used("__tact_dict_min_ref"))
        .end();
    const returnValExpr = () => {
        switch (value) {
            case "int":
                return "value~load_int(vl)";
            case "uint":
                return "value~load_uint(vl)";
            case "coins":
                return "value~load_coins()";
            case "slice":
            case "cell":
                return "value";
        }
    };
    ctx.fun(`__tact_dict_min_${key}_${value}`, () => {
        ctx.signature(
            `(${signatureKeyType}, ${signatureValueType}, int) __tact_dict_min_${key}_${value}(cell d, int kl${valBitsArg()})`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var (key, value, flag) = ${dictGetMin()}(d, kl);
                if (flag) {
                    return (key, ${returnValExpr()}, flag);
                } else {
                    return (null(), null(), flag);
                }
            `);
        });
    });
}

function genTactDictGetNext(
    ctx: WriterContext,
    key: KeyType,
    value: ValType,
): void {
    const signatureKeyType = getSignatureKeyType(key);
    const signatureValueType = getSignatureValueType(value);
    const valBitsArg = () => {
        switch (value) {
            case "slice":
            case "cell":
            case "coins":
                return "";
            case "uint":
            case "int":
                return ", int vl";
        }
    };
    const dictGetNext = () => {
        switch (key) {
            case "int":
                return "idict_get_next?";
            case "uint":
                return "udict_get_next?";
            case "slice":
                return ctx.used("__tact_dict_next");
        }
    };
    const returnValExpr = () => {
        switch (value) {
            case "int":
                return "value~load_int(vl)";
            case "uint":
                return "value~load_uint(vl)";
            case "coins":
                return "value~load_coins()";
            case "slice":
                return "value";
            case "cell":
                return "value~load_ref()";
        }
    };
    ctx.fun(`__tact_dict_next_${key}_${value}`, () => {
        ctx.signature(
            `(${signatureKeyType}, ${signatureValueType}, int) __tact_dict_next_${key}_${value}(cell d, int kl, ${signatureKeyType} pivot${valBitsArg()})`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            if (key === "slice" && value === "slice") {
                ctx.write(`
                    return ${ctx.used(`__tact_dict_next`)}(d, kl, pivot);
                `);
            } else {
                ctx.write(`
                    var (key, value, flag) = ${dictGetNext()}(d, kl, pivot);
                    if (flag) {
                        return (key, ${returnValExpr()}, flag);
                    } else {
                        return (null(), null(), flag);
                    }
                `);
            }
        });
    });
}

function genTactDictReplace(
    ctx: WriterContext,
    key: KeyType,
    value: ValType,
): void {
    const signatureKeyType = getSignatureKeyType(key);
    const signatureValueType = getSignatureValueType(value);
    const valBitsArg = () => {
        switch (value) {
            case "slice":
            case "cell":
            case "coins":
                return "";
            case "uint":
            case "int":
                return ", int vl";
        }
    };
    const dictDel = () => {
        switch (key) {
            case "slice":
                return ctx.used("__tact_dict_delete");
            case "uint":
                return "udict_delete?";
            case "int":
                return "idict_delete?";
        }
    };
    // prettier-ignore
    const returnExpr = () => match(key, value)
        .on("int", "int")(() => "idict_replace_builder?(d, kl, k, begin_cell().store_int(v, vl))")
        .on("int", "uint")(() => "idict_replace_builder?(d, kl, k, begin_cell().store_uint(v, vl))")
        .on("int", "coins")(() => "idict_replace_builder?(d, kl, k, begin_cell().store_coins(v))")
        .on("uint", "int")(() => "udict_replace_builder?(d, kl, k, begin_cell().store_int(v, vl))")
        .on("uint", "uint")(() => "udict_replace_builder?(d, kl, k, begin_cell().store_uint(v, vl))")
        .on("uint", "coins")(() => "udict_replace_builder?(d, kl, k, begin_cell().store_coins(v))")
        .on("slice", "int")(() => "dict_replace_builder?(d, kl, k, begin_cell().store_int(v, vl))")
        .on("slice", "uint")(() => "dict_replace_builder?(d, kl, k, begin_cell().store_uint(v, vl))")
        .on("slice", "coins")(() => "dict_replace_builder?(d, kl, k, begin_cell().store_coins(v))")
        .on("int", "cell")(() => "idict_replace_ref?(d, kl, k, v)")
        .on("uint", "cell")(() => "udict_replace_ref?(d, kl, k, v)")
        .on("int", "slice")(() => "idict_replace?(d, kl, k, v)")
        .on("uint", "slice")(() => "udict_replace?(d, kl, k, v)")
        .on("slice", "cell")(() => `${ctx.used("__tact_dict_replace_ref")}(d, kl, k, v)`)
        .on("slice", "slice")(() => "dict_replace_builder?(d, kl, k, begin_cell().store_slice(v))")
        .end();
    ctx.fun(`__tact_dict_replace_${key}_${value}`, () => {
        ctx.signature(
            `(cell, (int)) __tact_dict_replace_${key}_${value}(cell d, int kl, ${signatureKeyType} k, ${signatureValueType} v${valBitsArg()})`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                if (null?(v)) {
                    var (r, ok) = ${dictDel()}(d, kl, k);
                    return (r, (ok));
                } else {
                    return ${returnExpr()};
                }
            `);
        });
    });
}

function genTactDictReplaceGet(
    ctx: WriterContext,
    key: KeyType,
    value: ValType,
): void {
    const signatureKeyType = getSignatureKeyType(key);
    const signatureValueType = getSignatureValueType(value);
    const valBitsArg = () => {
        switch (value) {
            case "slice":
            case "cell":
            case "coins":
                return "";
            case "uint":
            case "int":
                return ", int vl";
        }
    };
    const dictDelGet = () => {
        const cellSuffix = value === "cell" ? "_ref" : "";
        switch (key) {
            case "slice":
                return ctx.used(`__tact_dict_delete_get${cellSuffix}`);
            case "uint":
                return `udict_delete_get${cellSuffix}?`;
            case "int":
                return `idict_delete_get${cellSuffix}?`;
        }
    };
    // prettier-ignore
    const returnExpr = () => match(key, value)
        .on("int", "int")(() => "d~idict_replaceget?(kl, k, begin_cell().store_int(v, vl).end_cell().begin_parse())")
        .on("int", "uint")(() => "d~idict_replaceget?(kl, k, begin_cell().store_uint(v, vl).end_cell().begin_parse())")
        .on("int", "coins")(() => "d~idict_replaceget?(kl, k, begin_cell().store_coins(v).end_cell().begin_parse())")
        .on("uint", "int")(() => "d~udict_replaceget?(kl, k, begin_cell().store_int(v, vl).end_cell().begin_parse())")
        .on("uint", "uint")(() => "d~udict_replaceget?(kl, k, begin_cell().store_uint(v, vl).end_cell().begin_parse())")
        .on("uint", "coins")(() => "d~udict_replaceget?(kl, k, begin_cell().store_coins(v).end_cell().begin_parse())")
        .on("slice", "int")(() => "d~dict_replaceget?(kl, k, begin_cell().store_int(v, vl).end_cell().begin_parse())")
        .on("slice", "uint")(() => "d~dict_replaceget?(kl, k, begin_cell().store_uint(v, vl).end_cell().begin_parse())")
        .on("slice", "coins")(() => "d~dict_replaceget?(kl, k, begin_cell().store_coins(v).end_cell().begin_parse())")
        .on("int", "cell")(() => "d~idict_replaceget_ref?(kl, k, v)")
        .on("uint", "cell")(() => "d~udict_replaceget_ref?(kl, k, v)")
        .on("int", "slice")(() => "d~idict_replaceget?(kl, k, v)")
        .on("uint", "slice")(() => "d~udict_replaceget?(kl, k, v)")
        .on("slice", "cell")(() => `d~${ctx.used("__tact_dict_replaceget_ref")}(kl, k, v)`)
        .on("slice", "slice")(() => "d~dict_replaceget?(kl, k, begin_cell().store_slice(v).end_cell().begin_parse())")
        .end();
    const parseExpr = () => {
        switch (value) {
            case "slice":
            case "cell":
                return "old";
            case "uint":
                return "old~load_uint(vl)";
            case "int":
                return "old~load_int(vl)";
            case "coins":
                return "old~load_coins()";
        }
    };
    ctx.fun(`__tact_dict_replaceget_${key}_${value}`, () => {
        ctx.signature(
            `(cell, (${signatureValueType})) __tact_dict_replaceget_${key}_${value}(cell d, int kl, ${signatureKeyType} k, ${signatureValueType} v${valBitsArg()})`,
        );
        ctx.flag("inline");
        ctx.context("stdlib");
        ctx.body(() => {
            ctx.write(`
                var (old, ok) = null?(v) ? d~${dictDelGet()}(kl, k) : ${returnExpr()};
                if (ok) {
                    return (d, ${parseExpr()});
                } else {
                    return (d, null());
                }
            `);
        });
    });
}


## ast.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/ast.ts)
import { dummySrcInfo, SrcInfo } from "./src-info";

export type AstModule = {
    kind: "module";
    imports: AstImport[];
    items: AstModuleItem[];
    id: number;
};

export type AstImport = {
    kind: "import";
    path: AstString;
    id: number;
    loc: SrcInfo;
};

export type AstModuleItem =
    | AstPrimitiveTypeDecl
    | AstFunctionDef
    | AstAsmFunctionDef
    | AstNativeFunctionDecl
    | AstConstantDef
    | AstStructDecl
    | AstMessageDecl
    | AstContract
    | AstTrait;

export type AstTypeDecl =
    | AstPrimitiveTypeDecl
    | AstStructDecl
    | AstMessageDecl
    | AstContract
    | AstTrait;

export type AstPrimitiveTypeDecl = {
    kind: "primitive_type_decl";
    name: AstId;
    id: number;
    loc: SrcInfo;
};

export type AstFunctionDef = {
    kind: "function_def";
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

export type AstAsmFunctionDef = {
    kind: "asm_function_def";
    shuffle: AstAsmShuffle;
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    instructions: AstAsmInstruction[];
    id: number;
    loc: SrcInfo;
};

export type AstAsmInstruction = string;
export type AstAsmShuffle = {
    args: AstId[];
    ret: AstNumber[];
};

export type AstFunctionDecl = {
    kind: "function_decl";
    attributes: AstFunctionAttribute[];
    name: AstId;
    return: AstType | null;
    params: AstTypedParameter[];
    id: number;
    loc: SrcInfo;
};

export type AstNativeFunctionDecl = {
    kind: "native_function_decl";
    attributes: AstFunctionAttribute[];
    name: AstId;
    nativeName: AstFuncId;
    params: AstTypedParameter[];
    return: AstType | null;
    id: number;
    loc: SrcInfo;
};

export type AstConstantDef = {
    kind: "constant_def";
    attributes: AstConstantAttribute[];
    name: AstId;
    type: AstType;
    initializer: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstConstantDecl = {
    kind: "constant_decl";
    attributes: AstConstantAttribute[];
    name: AstId;
    type: AstType;
    id: number;
    loc: SrcInfo;
};

export type AstStructDecl = {
    kind: "struct_decl";
    name: AstId;
    fields: AstFieldDecl[];
    id: number;
    loc: SrcInfo;
};

export type AstMessageDecl = {
    kind: "message_decl";
    name: AstId;
    opcode: AstExpression | null;
    fields: AstFieldDecl[];
    id: number;
    loc: SrcInfo;
};

export type AstContract = {
    kind: "contract";
    name: AstId;
    traits: AstId[];
    attributes: AstContractAttribute[];
    declarations: AstContractDeclaration[];
    id: number;
    loc: SrcInfo;
};

export type AstTrait = {
    kind: "trait";
    name: AstId;
    traits: AstId[];
    attributes: AstContractAttribute[];
    declarations: AstTraitDeclaration[];
    id: number;
    loc: SrcInfo;
};

export type AstContractDeclaration =
    | AstFieldDecl
    | AstFunctionDef
    | AstAsmFunctionDef
    | AstContractInit
    | AstReceiver
    | AstConstantDef;

export type AstTraitDeclaration =
    | AstFieldDecl
    | AstFunctionDef
    | AstAsmFunctionDef
    | AstFunctionDecl
    | AstReceiver
    | AstConstantDef
    | AstConstantDecl;

export type AstFieldDecl = {
    kind: "field_decl";
    name: AstId;
    type: AstType;
    initializer: AstExpression | null;
    as: AstId | null;
    id: number;
    loc: SrcInfo;
};

export type AstReceiver = {
    kind: "receiver";
    selector: AstReceiverKind;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

export type AstContractInit = {
    kind: "contract_init";
    params: AstTypedParameter[];
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

//
// Statements
//

export type AstStatement =
    | AstStatementLet
    | AstStatementReturn
    | AstStatementExpression
    | AstStatementAssign
    | AstStatementAugmentedAssign
    | AstCondition
    | AstStatementWhile
    | AstStatementUntil
    | AstStatementRepeat
    | AstStatementTry
    | AstStatementTryCatch
    | AstStatementForEach
    | AstStatementDestruct;

export type AstStatementLet = {
    kind: "statement_let";
    name: AstId;
    type: AstType | null;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstStatementReturn = {
    kind: "statement_return";
    expression: AstExpression | null;
    id: number;
    loc: SrcInfo;
};

export type AstStatementExpression = {
    kind: "statement_expression";
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstStatementAssign = {
    kind: "statement_assign";
    path: AstExpression; // left-hand side of `=`
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstAugmentedAssignOperation =
    | "+"
    | "-"
    | "*"
    | "/"
    | "&&"
    | "||"
    | "%"
    | "|"
    | "<<"
    | ">>"
    | "&"
    | "^";

export type AstStatementAugmentedAssign = {
    kind: "statement_augmentedassign";
    op: AstAugmentedAssignOperation;
    path: AstExpression;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstCondition = {
    kind: "statement_condition";
    condition: AstExpression;
    trueStatements: AstStatement[];
    falseStatements: AstStatement[] | null;
    elseif: AstCondition | null;
    id: number;
    loc: SrcInfo;
};

export type AstStatementWhile = {
    kind: "statement_while";
    condition: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

export type AstStatementUntil = {
    kind: "statement_until";
    condition: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

export type AstStatementRepeat = {
    kind: "statement_repeat";
    iterations: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

export type AstStatementTry = {
    kind: "statement_try";
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

export type AstStatementTryCatch = {
    kind: "statement_try_catch";
    statements: AstStatement[];
    catchName: AstId;
    catchStatements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

export type AstStatementForEach = {
    kind: "statement_foreach";
    keyName: AstId;
    valueName: AstId;
    map: AstExpression;
    statements: AstStatement[];
    id: number;
    loc: SrcInfo;
};

export type AstStatementDestruct = {
    kind: "statement_destruct";
    type: AstTypeId;
    /** field name -> [field id, local id] */
    identifiers: Map<string, [AstId, AstId]>;
    ignoreUnspecifiedFields: boolean;
    expression: AstExpression;
    id: number;
    loc: SrcInfo;
};

//
// Types
//

export type AstType =
    | AstTypeId
    | AstOptionalType
    | AstMapType
    | AstBouncedMessageType;

export type AstTypeId = {
    kind: "type_id";
    text: string;
    id: number;
    loc: SrcInfo;
};

export type AstOptionalType = {
    kind: "optional_type";
    typeArg: AstType;
    id: number;
    loc: SrcInfo;
};

export type AstMapType = {
    kind: "map_type";
    keyType: AstTypeId;
    keyStorageType: AstId | null;
    valueType: AstTypeId;
    valueStorageType: AstId | null;
    id: number;
    loc: SrcInfo;
};

export type AstBouncedMessageType = {
    kind: "bounced_message_type";
    messageType: AstTypeId;
    id: number;
    loc: SrcInfo;
};

//
// Expressions
//

export type AstExpression =
    | AstExpressionPrimary
    | AstOpBinary
    | AstOpUnary
    | AstConditional;

export type AstExpressionPrimary =
    | AstMethodCall
    | AstFieldAccess
    | AstStaticCall
    | AstStructInstance
    | AstNumber
    | AstBoolean
    | AstId
    | AstNull
    | AstInitOf
    | AstString;

export type AstBinaryOperation =
    | "+"
    | "-"
    | "*"
    | "/"
    | "!="
    | ">"
    | "<"
    | ">="
    | "<="
    | "=="
    | "&&"
    | "||"
    | "%"
    | "<<"
    | ">>"
    | "&"
    | "|"
    | "^";

export type AstOpBinary = {
    kind: "op_binary";
    op: AstBinaryOperation;
    left: AstExpression;
    right: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstUnaryOperation = "+" | "-" | "!" | "!!" | "~";

export type AstOpUnary = {
    kind: "op_unary";
    op: AstUnaryOperation;
    operand: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstFieldAccess = {
    kind: "field_access";
    aggregate: AstExpression; // contract, trait, struct, message
    field: AstId;
    id: number;
    loc: SrcInfo;
};

export type AstMethodCall = {
    kind: "method_call";
    self: AstExpression; // anything with a method
    method: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};

// builtins or top-level (module) functions
export type AstStaticCall = {
    kind: "static_call";
    function: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};

export type AstStructInstance = {
    kind: "struct_instance";
    type: AstId;
    args: AstStructFieldInitializer[];
    id: number;
    loc: SrcInfo;
};

export type AstStructFieldInitializer = {
    kind: "struct_field_initializer";
    field: AstId;
    initializer: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstInitOf = {
    kind: "init_of";
    contract: AstId;
    args: AstExpression[];
    id: number;
    loc: SrcInfo;
};

export type AstConditional = {
    kind: "conditional";
    condition: AstExpression;
    thenBranch: AstExpression;
    elseBranch: AstExpression;
    id: number;
    loc: SrcInfo;
};

export type AstId = {
    kind: "id";
    text: string;
    id: number;
    loc: SrcInfo;
};

export type AstFuncId = {
    kind: "func_id";
    text: string;
    id: number;
    loc: SrcInfo;
};

export function idText(ident: AstId | AstFuncId | AstTypeId): string {
    return ident.text;
}

export function isInt(ident: AstTypeId): boolean {
    return ident.text === "Int";
}

export function isBool(ident: AstTypeId): boolean {
    return ident.text === "Bool";
}

export function isCell(ident: AstTypeId): boolean {
    return ident.text === "Cell";
}

export function isSlice(ident: AstTypeId): boolean {
    return ident.text === "Slice";
}

export function isBuilder(ident: AstTypeId): boolean {
    return ident.text === "Builder";
}

export function isAddress(ident: AstTypeId): boolean {
    return ident.text === "Address";
}

export function isString(ident: AstTypeId): boolean {
    return ident.text === "String";
}

export function isStringBuilder(ident: AstTypeId): boolean {
    return ident.text === "StringBuilder";
}

export function isSelfId(ident: AstId): boolean {
    return ident.text === "self";
}

export function isWildcard(ident: AstId): boolean {
    return ident.text === "_";
}

export function isRequire(ident: AstId): boolean {
    return ident.text === "require";
}

export function eqNames(
    left: AstId | AstTypeId | string,
    right: AstId | AstTypeId | string,
): boolean {
    if (typeof left === "string") {
        if (typeof right === "string") {
            return left === right;
        }
        return left === right.text;
    } else {
        if (typeof right === "string") {
            return left.text === right;
        }
        return left.text === right.text;
    }
}

export function idOfText(text: string): AstId {
    return {
        kind: "id",
        text,
        id: 0,
        loc: dummySrcInfo,
    };
}

export const selfId: AstId = {
    kind: "id",
    text: "self",
    id: 0,
    loc: dummySrcInfo,
};

export type AstDestructMapping = {
    kind: "destruct_mapping";
    field: AstId;
    name: AstId;
    id: number;
    loc: SrcInfo;
};

export type AstDestructEnd = {
    kind: "destruct_end";
    ignoreUnspecifiedFields: boolean;
    id: number;
    loc: SrcInfo;
};

export type AstNumber = {
    kind: "number";
    base: AstNumberBase;
    value: bigint;
    id: number;
    loc: SrcInfo;
};

export type AstNumberBase = 2 | 8 | 10 | 16;

export function astNumToString(n: AstNumber): string {
    switch (n.base) {
        case 2:
            return `0b${n.value.toString(n.base)}`;
        case 8:
            return `0o${n.value.toString(n.base)}`;
        case 10:
            return n.value.toString(n.base);
        case 16:
            return `0x${n.value.toString(n.base)}`;
    }
}

export type AstBoolean = {
    kind: "boolean";
    value: boolean;
    id: number;
    loc: SrcInfo;
};

export type AstString = {
    kind: "string";
    value: string;
    id: number;
    loc: SrcInfo;
};

// `null` value is an inhabitant of several types:
// it can represent missing values in optional types,
// or empty map of any key and value types
export type AstNull = {
    kind: "null";
    id: number;
    loc: SrcInfo;
};

export type AstValue = AstNumber | AstBoolean | AstNull | AstString;

export type AstConstantAttribute =
    | { type: "virtual"; loc: SrcInfo }
    | { type: "override"; loc: SrcInfo }
    | { type: "abstract"; loc: SrcInfo };

export type AstContractAttribute = {
    type: "interface";
    name: AstString;
    loc: SrcInfo;
};

export type AstFunctionAttribute =
    | {
          kind: "function_attribute";
          type: "get";
          methodId: AstExpression | null;
          loc: SrcInfo;
      }
    | { kind: "function_attribute"; type: "mutates"; loc: SrcInfo }
    | { kind: "function_attribute"; type: "extends"; loc: SrcInfo }
    | { kind: "function_attribute"; type: "virtual"; loc: SrcInfo }
    | { kind: "function_attribute"; type: "abstract"; loc: SrcInfo }
    | { kind: "function_attribute"; type: "override"; loc: SrcInfo }
    | { kind: "function_attribute"; type: "inline"; loc: SrcInfo };

export type AstTypedParameter = {
    kind: "typed_parameter";
    name: AstId;
    type: AstType;
    id: number;
    loc: SrcInfo;
};

export type AstReceiverKind =
    | {
          kind: "internal-simple";
          param: AstTypedParameter;
      }
    | {
          kind: "internal-fallback";
      }
    | {
          kind: "internal-comment";
          comment: AstString;
      }
    | {
          kind: "bounce";
          param: AstTypedParameter;
      }
    | {
          kind: "external-simple";
          param: AstTypedParameter;
      }
    | {
          kind: "external-fallback";
      }
    | {
          kind: "external-comment";
          comment: AstString;
      };

export type AstNode =
    | AstFuncId
    | AstDestructMapping
    | AstDestructEnd
    | AstExpression
    | AstStatement
    | AstTypeDecl
    | AstFieldDecl
    | AstTypedParameter
    | AstFunctionDef
    | AstFunctionAttribute
    | AstAsmFunctionDef
    | AstFunctionDecl
    | AstModule
    | AstNativeFunctionDecl
    | AstStructFieldInitializer
    | AstType
    | AstContractInit
    | AstReceiver
    | AstImport
    | AstConstantDef
    | AstConstantDecl;

/**
 * Check if input expression is a 'path expression',
 * i.e. an identifier or a sequence of field accesses starting from an identifier.
 * @param path A path expression to check.
 * @returns An array of identifiers or null if the input expression is not a path expression.
 */
export function tryExtractPath(path: AstExpression): AstId[] | null {
    switch (path.kind) {
        case "id":
            return [path];
        case "field_access": {
            const p = tryExtractPath(path.aggregate);
            return p ? [...p, path.field] : null;
        }
        default:
            return null;
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
type DistributiveOmit<T, K extends keyof any> = T extends any
    ? Omit<T, K>
    : never;

export const getAstFactory = () => {
    let nextId = 1;
    function createNode(src: DistributiveOmit<AstNode, "id">): AstNode {
        return Object.freeze(Object.assign({ id: nextId++ }, src));
    }
    function cloneNode<T extends AstNode>(src: T): T {
        return { ...src, id: nextId++ };
    }
    return {
        createNode,
        cloneNode,
    };
};

export type FactoryAst = ReturnType<typeof getAstFactory>;

// Test equality of AstExpressions.
export function eqExpressions(
    ast1: AstExpression,
    ast2: AstExpression,
): boolean {
    if (ast1.kind !== ast2.kind) {
        return false;
    }

    switch (ast1.kind) {
        case "null":
            return true;
        case "boolean":
            return ast1.value === (ast2 as AstBoolean).value;
        case "number":
            return ast1.value === (ast2 as AstNumber).value;
        case "string":
            return ast1.value === (ast2 as AstString).value;
        case "id":
            return eqNames(ast1, ast2 as AstId);
        case "method_call":
            return (
                eqNames(ast1.method, (ast2 as AstMethodCall).method) &&
                eqExpressions(ast1.self, (ast2 as AstMethodCall).self) &&
                eqExpressionArrays(ast1.args, (ast2 as AstMethodCall).args)
            );
        case "init_of":
            return (
                eqNames(ast1.contract, (ast2 as AstInitOf).contract) &&
                eqExpressionArrays(ast1.args, (ast2 as AstInitOf).args)
            );
        case "op_unary":
            return (
                ast1.op === (ast2 as AstOpUnary).op &&
                eqExpressions(ast1.operand, (ast2 as AstOpUnary).operand)
            );
        case "op_binary":
            return (
                ast1.op === (ast2 as AstOpBinary).op &&
                eqExpressions(ast1.left, (ast2 as AstOpBinary).left) &&
                eqExpressions(ast1.right, (ast2 as AstOpBinary).right)
            );
        case "conditional":
            return (
                eqExpressions(
                    ast1.condition,
                    (ast2 as AstConditional).condition,
                ) &&
                eqExpressions(
                    ast1.thenBranch,
                    (ast2 as AstConditional).thenBranch,
                ) &&
                eqExpressions(
                    ast1.elseBranch,
                    (ast2 as AstConditional).elseBranch,
                )
            );
        case "struct_instance":
            return (
                eqNames(ast1.type, (ast2 as AstStructInstance).type) &&
                eqParameterArrays(ast1.args, (ast2 as AstStructInstance).args)
            );
        case "field_access":
            return (
                eqNames(ast1.field, (ast2 as AstFieldAccess).field) &&
                eqExpressions(
                    ast1.aggregate,
                    (ast2 as AstFieldAccess).aggregate,
                )
            );
        case "static_call":
            return (
                eqNames(ast1.function, (ast2 as AstStaticCall).function) &&
                eqExpressionArrays(ast1.args, (ast2 as AstStaticCall).args)
            );
    }
}

function eqParameters(
    arg1: AstStructFieldInitializer,
    arg2: AstStructFieldInitializer,
): boolean {
    return (
        eqNames(arg1.field, arg2.field) &&
        eqExpressions(arg1.initializer, arg2.initializer)
    );
}

function eqParameterArrays(
    arr1: AstStructFieldInitializer[],
    arr2: AstStructFieldInitializer[],
): boolean {
    if (arr1.length !== arr2.length) {
        return false;
    }

    for (let i = 0; i < arr1.length; i++) {
        if (!eqParameters(arr1[i]!, arr2[i]!)) {
            return false;
        }
    }

    return true;
}

function eqExpressionArrays(
    arr1: AstExpression[],
    arr2: AstExpression[],
): boolean {
    if (arr1.length !== arr2.length) {
        return false;
    }

    for (let i = 0; i < arr1.length; i++) {
        if (!eqExpressions(arr1[i]!, arr2[i]!)) {
            return false;
        }
    }

    return true;
}

export function isValue(ast: AstExpression): boolean {
    switch (ast.kind) {
        case "null":
        case "boolean":
        case "number":
        case "string":
            return true;

        case "struct_instance":
            return ast.args.every((arg) => isValue(arg.initializer));

        case "id":
        case "method_call":
        case "init_of":
        case "op_unary":
        case "op_binary":
        case "conditional":
        case "field_access":
        case "static_call":
            return false;
    }
}


## clone.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/clone.ts)
import { AstNode, FactoryAst } from "./ast";
import { throwInternalCompilerError } from "../errors";

export function cloneNode<T extends AstNode>(
    src: T,
    { cloneNode }: FactoryAst,
): T {
    const recurse = <T extends AstNode>(src: T): T => {
        if (src.kind === "boolean") {
            return cloneNode(src);
        } else if (src.kind === "id") {
            return cloneNode(src);
        } else if (src.kind === "null") {
            return cloneNode(src);
        } else if (src.kind === "number") {
            return cloneNode(src);
        } else if (src.kind === "string") {
            return cloneNode(src);
        } else if (src.kind === "statement_assign") {
            return cloneNode({
                ...src,
                path: recurse(src.path),
                expression: recurse(src.expression),
            });
        } else if (src.kind === "statement_augmentedassign") {
            return cloneNode({
                ...src,
                path: recurse(src.path),
                expression: recurse(src.expression),
            });
        } else if (src.kind === "statement_let") {
            return cloneNode({
                ...src,
                type: src.type ? cloneNode(src.type) : null,
                expression: recurse(src.expression),
            });
        } else if (src.kind === "statement_condition") {
            return cloneNode({
                ...src,
                condition: recurse(src.condition),
                trueStatements: src.trueStatements.map(recurse),
                falseStatements: src.falseStatements
                    ? src.falseStatements.map(recurse)
                    : null,
                elseif: src.elseif ? recurse(src.elseif) : null,
            });
        } else if (src.kind === "struct_field_initializer") {
            return cloneNode({
                ...src,
                initializer: recurse(src.initializer),
            });
        } else if (src.kind === "statement_expression") {
            return cloneNode({
                ...src,
                expression: recurse(src.expression),
            });
        } else if (src.kind === "op_binary") {
            return cloneNode({
                ...src,
                left: recurse(src.left),
                right: recurse(src.right),
            });
        } else if (src.kind === "op_unary") {
            return cloneNode({
                ...src,
                operand: recurse(src.operand),
            });
        } else if (src.kind === "struct_instance") {
            return cloneNode({
                ...src,
                args: src.args.map(recurse),
            });
        } else if (src.kind === "method_call") {
            return cloneNode({
                ...src,
                self: recurse(src.self),
                args: src.args.map(recurse),
            });
        } else if (src.kind === "field_access") {
            return cloneNode({
                ...src,
                aggregate: recurse(src.aggregate),
            });
        } else if (src.kind === "static_call") {
            return cloneNode({
                ...src,
                args: src.args.map(recurse),
            });
        } else if (src.kind === "conditional") {
            return cloneNode({
                ...src,
                condition: recurse(src.condition),
                thenBranch: recurse(src.thenBranch),
                elseBranch: recurse(src.elseBranch),
            });
        } else if (src.kind === "statement_return") {
            return cloneNode({
                ...src,
                expression: src.expression ? recurse(src.expression) : null,
            });
        } else if (src.kind === "statement_repeat") {
            return cloneNode({
                ...src,
                iterations: recurse(src.iterations),
                statements: src.statements.map(recurse),
            });
        } else if (src.kind === "statement_until") {
            return cloneNode({
                ...src,
                condition: recurse(src.condition),
                statements: src.statements.map(recurse),
            });
        } else if (src.kind === "statement_while") {
            return cloneNode({
                ...src,
                condition: recurse(src.condition),
                statements: src.statements.map(recurse),
            });
        } else if (src.kind === "statement_try") {
            return cloneNode({
                ...src,
                statements: src.statements.map(recurse),
            });
        } else if (src.kind === "statement_try_catch") {
            return cloneNode({
                ...src,
                statements: src.statements.map(recurse),
                catchStatements: src.catchStatements.map(recurse),
            });
        } else if (src.kind === "statement_foreach") {
            return cloneNode({
                ...src,
                map: recurse(src.map),
                statements: src.statements.map(recurse),
            });
        } else if (src.kind === "function_def") {
            return cloneNode({
                ...src,
                return: src.return ? cloneNode(src.return) : null,
                statements: src.statements.map(recurse),
                params: src.params.map(recurse),
            });
        } else if (src.kind === "function_decl") {
            return cloneNode({
                ...src,
                return: src.return ? cloneNode(src.return) : null,
                params: src.params.map(recurse),
            });
        } else if (src.kind === "native_function_decl") {
            return cloneNode({
                ...src,
                return: src.return ? cloneNode(src.return) : null,
                params: src.params.map(recurse),
            });
        } else if (src.kind === "receiver") {
            return cloneNode({
                ...src,
                statements: src.statements.map(recurse),
            });
        } else if (src.kind === "typed_parameter") {
            return cloneNode({
                ...src,
                type: cloneNode(src.type),
            });
        } else if (src.kind === "init_of") {
            return cloneNode({
                ...src,
                args: src.args.map(recurse),
            });
        } else if (src.kind === "constant_def") {
            return cloneNode({
                ...src,
                type: cloneNode(src.type),
                initializer: recurse(src.initializer),
            });
        } else if (src.kind === "constant_decl") {
            return cloneNode({
                ...src,
                type: cloneNode(src.type),
            });
        }

        throwInternalCompilerError(`Not implemented for ${src.kind}`);
    };

    return recurse(src);
}


## compare.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/compare.ts)
import {
    AstConstantDef,
    AstReceiverKind,
    AstStructFieldInitializer,
    AstFunctionAttribute,
    AstOpBinary,
    AstOpUnary,
    AstFieldAccess,
    AstConditional,
    AstMethodCall,
    AstStaticCall,
    AstNumber,
    AstBoolean,
    AstString,
    AstStructInstance,
    AstInitOf,
    AstConstantAttribute,
    AstContractAttribute,
    AstTypedParameter,
    AstImport,
    AstNativeFunctionDecl,
    AstReceiver,
    AstStatementRepeat,
    AstStatementUntil,
    AstStatementWhile,
    AstStatementForEach,
    AstStatementTry,
    AstStatementTryCatch,
    AstCondition,
    AstStatementAugmentedAssign,
    AstStatementAssign,
    AstStatementExpression,
    AstStatementReturn,
    AstStatementLet,
    AstFunctionDef,
    AstContract,
    AstTrait,
    AstId,
    AstModule,
    AstStructDecl,
    AstMessageDecl,
    AstFunctionDecl,
    AstConstantDecl,
    AstContractInit,
    AstPrimitiveTypeDecl,
    AstTypeId,
    AstMapType,
    AstBouncedMessageType,
    AstFieldDecl,
    AstOptionalType,
    AstNode,
    AstFuncId,
    AstAsmFunctionDef,
    AstAsmInstruction,
    AstDestructMapping,
    AstStatementDestruct,
} from "./ast";
import { AstRenamer } from "./rename";
import { throwInternalCompilerError } from "../errors";
import JSONbig from "json-bigint";

/**
 * Provides an API to compare two AST nodes with extra options.
 */
export class AstComparator {
    /**
     * @param sort Topologically sort AST entries before comparing. Should be enabled
     *        in order to handle duplicate entries shuffled in the source code.
     * @param canonicalize Introduce de Brujin indices for local bindings to handle
     *        duplicate code with different names. Should be enabled in order to
     *        treat duplicate entries with different names as the same elements.
     */
    private constructor(
        private readonly sort: boolean,
        private readonly canonicalize: boolean,
    ) {}

    public static make(
        options: Partial<{ sort: boolean; canonicalize: boolean }> = {},
    ): AstComparator {
        const { sort = true, canonicalize = true } = options;
        return new AstComparator(sort, canonicalize);
    }

    public compare(node1: AstNode, node2: AstNode): boolean {
        if (node1.kind !== node2.kind) {
            return false;
        }

        switch (node1.kind) {
            case "module": {
                if (this.canonicalize) {
                    const renamer = AstRenamer.make({ sort: this.sort });
                    node1 = renamer.renameModule(node1 as AstModule);
                    node2 = renamer.renameModule(node2 as AstModule);
                }
                const { imports: imports1, items: items1 } = node1 as AstModule;
                const { imports: imports2, items: items2 } = node2 as AstModule;
                return (
                    this.compareArray(imports1, imports2) &&
                    this.compareArray(items1, items2)
                );
            }

            case "import": {
                const { path: path1 } = node1 as AstImport;
                const { path: path2 } = node2 as AstImport;
                return this.compare(path1, path2);
            }

            case "primitive_type_decl": {
                const { name: name1 } = node1 as AstPrimitiveTypeDecl;
                const { name: name2 } = node2 as AstPrimitiveTypeDecl;
                return this.compare(name1, name2);
            }

            case "function_def": {
                const {
                    attributes: attributes1,
                    name: funcName1,
                    return: returnType1,
                    params: params1,
                    statements: statements1,
                } = node1 as AstFunctionDef;
                const {
                    attributes: attributes2,
                    name: funcName2,
                    return: returnType2,
                    params: params2,
                    statements: statements2,
                } = node2 as AstFunctionDef;
                return (
                    this.compareAttributes(attributes1, attributes2) &&
                    this.compare(funcName1, funcName2) &&
                    this.compareNullableNodes(returnType1, returnType2) &&
                    this.compareArray(params1, params2) &&
                    this.compareArray(statements1, statements2)
                );
            }

            case "asm_function_def": {
                const {
                    shuffle: shuffle1,
                    attributes: attributes1,
                    name: funcName1,
                    return: returnType1,
                    params: params1,
                    instructions: instructions1,
                } = node1 as AstAsmFunctionDef;
                const {
                    shuffle: shuffle2,
                    attributes: attributes2,
                    name: funcName2,
                    return: returnType2,
                    params: params2,
                    instructions: instructions2,
                } = node2 as AstAsmFunctionDef;
                return (
                    this.compareArray(shuffle1.args, shuffle2.args) &&
                    this.compareArray(shuffle1.ret, shuffle2.ret) &&
                    this.compareAttributes(attributes1, attributes2) &&
                    this.compare(funcName1, funcName2) &&
                    this.compareNullableNodes(returnType1, returnType2) &&
                    this.compareArray(params1, params2) &&
                    this.compareAsmInstructions(instructions1, instructions2)
                );
            }
            case "function_decl": {
                const {
                    attributes: declAttributes1,
                    name: declName1,
                    return: declReturnType1,
                    params: declParams1,
                } = node1 as AstFunctionDecl;
                const {
                    attributes: declAttributes2,
                    name: declName2,
                    return: declReturnType2,
                    params: declParams2,
                } = node2 as AstFunctionDecl;
                return (
                    this.compareAttributes(declAttributes1, declAttributes2) &&
                    this.compare(declName1, declName2) &&
                    this.compareNullableNodes(
                        declReturnType1,
                        declReturnType2,
                    ) &&
                    this.compareArray(declParams1, declParams2)
                );
            }

            case "native_function_decl": {
                const {
                    attributes: nativeAttributes1,
                    name: nativeName1,
                    nativeName: nativeFuncName1,
                    params: nativeParams1,
                    return: returnTy1,
                } = node1 as AstNativeFunctionDecl;
                const {
                    attributes: nativeAttributes2,
                    name: nativeName2,
                    nativeName: nativeFuncName2,
                    params: nativeParams2,
                    return: returnTy2,
                } = node2 as AstNativeFunctionDecl;
                return (
                    this.compareAttributes(
                        nativeAttributes1,
                        nativeAttributes2,
                    ) &&
                    this.compare(nativeName1, nativeName2) &&
                    this.compare(nativeFuncName1, nativeFuncName2) &&
                    this.compareNullableNodes(returnTy1, returnTy2) &&
                    this.compareArray(nativeParams1, nativeParams2)
                );
            }

            case "constant_def": {
                const {
                    attributes: constAttributes1,
                    name: constName1,
                    type: constType1,
                    initializer: constInitializer1,
                } = node1 as AstConstantDef;
                const {
                    attributes: constAttributes2,
                    name: constName2,
                    type: constType2,
                    initializer: constInitializer2,
                } = node2 as AstConstantDef;
                return (
                    this.compareAttributes(
                        constAttributes1,
                        constAttributes2,
                    ) &&
                    this.compare(constName1, constName2) &&
                    this.compare(constType1, constType2) &&
                    this.compare(constInitializer1, constInitializer2)
                );
            }

            case "constant_decl": {
                const {
                    attributes: constDeclAttributes1,
                    name: constDeclName1,
                    type: constDeclType1,
                } = node1 as AstConstantDecl;
                const {
                    attributes: constDeclAttributes2,
                    name: constDeclName2,
                    type: constDeclType2,
                } = node2 as AstConstantDecl;
                return (
                    this.compareAttributes(
                        constDeclAttributes1,
                        constDeclAttributes2,
                    ) &&
                    this.compare(constDeclName1, constDeclName2) &&
                    this.compare(constDeclType1, constDeclType2)
                );
            }

            case "struct_decl": {
                const { name: structName1, fields: structFields1 } =
                    node1 as AstStructDecl;
                const { name: structName2, fields: structFields2 } =
                    node2 as AstStructDecl;
                return (
                    this.compare(structName1, structName2) &&
                    this.compareArray(structFields1, structFields2)
                );
            }

            case "message_decl": {
                const { name: msgName1, fields: msgFields1 } =
                    node1 as AstMessageDecl;
                const { name: msgName2, fields: msgFields2 } =
                    node2 as AstMessageDecl;
                return (
                    this.compare(msgName1, msgName2) &&
                    this.compareArray(msgFields1, msgFields2)
                );
            }

            case "contract": {
                const {
                    name: contractName1,
                    traits: contractTraits1,
                    attributes: contractAttributes1,
                    declarations: contractDeclarations1,
                } = node1 as AstContract;
                const {
                    name: contractName2,
                    traits: contractTraits2,
                    attributes: contractAttributes2,
                    declarations: contractDeclarations2,
                } = node2 as AstContract;
                return (
                    this.compare(contractName1, contractName2) &&
                    this.compareArray(contractTraits1, contractTraits2) &&
                    this.compareAttributes(
                        contractAttributes1,
                        contractAttributes2,
                    ) &&
                    this.compareArray(
                        contractDeclarations1,
                        contractDeclarations2,
                    )
                );
            }

            case "trait": {
                const {
                    name: traitName1,
                    traits: traits1,
                    attributes: attributes1,
                    declarations: declarations1,
                } = node1 as AstTrait;
                const {
                    name: traitName2,
                    traits: traits2,
                    attributes: attributes2,
                    declarations: declarations2,
                } = node2 as AstTrait;
                return (
                    this.compare(traitName1, traitName2) &&
                    this.compareArray(traits1, traits2) &&
                    this.compareAttributes(attributes1, attributes2) &&
                    this.compareArray(declarations1, declarations2)
                );
            }

            case "field_decl": {
                const {
                    name: fieldName1,
                    type: fieldType1,
                    initializer: fieldInitializer1,
                    as: as1,
                } = node1 as AstFieldDecl;
                const {
                    name: fieldName2,
                    type: fieldType2,
                    initializer: fieldInitializer2,
                    as: as2,
                } = node2 as AstFieldDecl;
                return (
                    this.compare(fieldName1, fieldName2) &&
                    this.compare(fieldType1, fieldType2) &&
                    this.compareNullableNodes(
                        fieldInitializer1,
                        fieldInitializer2,
                    ) &&
                    this.compareNullableNodes(as1, as2)
                );
            }

            case "receiver": {
                const {
                    selector: receiverSelector1,
                    statements: receiverStatements1,
                } = node1 as AstReceiver;
                const {
                    selector: receiverSelector2,
                    statements: receiverStatements2,
                } = node2 as AstReceiver;
                return (
                    this.compareReceiverKinds(
                        receiverSelector1,
                        receiverSelector2,
                    ) &&
                    this.compareArray(receiverStatements1, receiverStatements2)
                );
            }

            case "contract_init": {
                const { params: initParams1, statements: initStatements1 } =
                    node1 as AstContractInit;
                const { params: initParams2, statements: initStatements2 } =
                    node2 as AstContractInit;
                return (
                    this.compareArray(initParams1, initParams2) &&
                    this.compareArray(initStatements1, initStatements2)
                );
            }

            case "statement_let": {
                const {
                    name: name1,
                    type: ty1,
                    expression: expr1,
                } = node1 as AstStatementLet;
                const {
                    name: name2,
                    type: ty2,
                    expression: expr2,
                } = node2 as AstStatementLet;
                return (
                    this.compare(name1, name2) &&
                    this.compareNullableNodes(ty1, ty2) &&
                    this.compare(expr1, expr2)
                );
            }

            case "statement_return": {
                const { expression: expr1 } = node1 as AstStatementReturn;
                const { expression: expr2 } = node2 as AstStatementReturn;
                return this.compareNullableNodes(expr1, expr2);
            }

            case "statement_expression": {
                const { expression: expr1 } = node1 as AstStatementExpression;
                const { expression: expr2 } = node2 as AstStatementExpression;
                return this.compareNullableNodes(expr1, expr2);
            }

            case "statement_assign": {
                const { path: assignPath1, expression: assignExpression1 } =
                    node1 as AstStatementAssign;
                const { path: assignPath2, expression: assignExpression2 } =
                    node2 as AstStatementAssign;
                return (
                    this.compare(assignPath1, assignPath2) &&
                    this.compare(assignExpression1, assignExpression2)
                );
            }

            case "statement_augmentedassign": {
                const {
                    op: augOp1,
                    path: augPath1,
                    expression: augExpression1,
                } = node1 as AstStatementAugmentedAssign;
                const {
                    op: augOp2,
                    path: augPath2,
                    expression: augExpression2,
                } = node2 as AstStatementAugmentedAssign;
                return (
                    augOp1 === augOp2 &&
                    this.compare(augPath1, augPath2) &&
                    this.compare(augExpression1, augExpression2)
                );
            }

            case "statement_condition": {
                const {
                    condition: cond1,
                    trueStatements: true1,
                    falseStatements: false1,
                    elseif: condElseIf1,
                } = node1 as AstCondition;
                const {
                    condition: cond2,
                    trueStatements: true2,
                    falseStatements: false2,
                    elseif: condElseIf2,
                } = node2 as AstCondition;
                return (
                    this.compare(cond1, cond2) &&
                    this.compareArray(true1, true2) &&
                    this.compareNullableArray(false1, false2) &&
                    this.compareNullableNodes(condElseIf1, condElseIf2)
                );
            }

            case "statement_while": {
                const {
                    condition: loopCondition1,
                    statements: loopStatements1,
                } = node1 as AstStatementWhile;
                const {
                    condition: loopCondition2,
                    statements: loopStatements2,
                } = node2 as AstStatementWhile;
                return (
                    this.compare(loopCondition1, loopCondition2) &&
                    this.compareArray(loopStatements1, loopStatements2)
                );
            }

            case "statement_until": {
                const {
                    condition: loopCondition1,
                    statements: loopStatements1,
                } = node1 as AstStatementUntil;
                const {
                    condition: loopCondition2,
                    statements: loopStatements2,
                } = node2 as AstStatementUntil;
                return (
                    this.compare(loopCondition1, loopCondition2) &&
                    this.compareArray(loopStatements1, loopStatements2)
                );
            }

            case "statement_repeat": {
                const { iterations: iter1, statements: stmts1 } =
                    node1 as AstStatementRepeat;
                const { iterations: iter2, statements: stmts2 } =
                    node2 as AstStatementRepeat;
                return (
                    this.compare(iter1, iter2) &&
                    this.compareArray(stmts1, stmts2)
                );
            }

            case "statement_try": {
                const { statements: tryStatements1 } = node1 as AstStatementTry;
                const { statements: tryStatements2 } = node2 as AstStatementTry;
                return this.compareArray(tryStatements1, tryStatements2);
            }

            case "statement_try_catch": {
                const {
                    statements: tryCatchStatements1,
                    catchName: catchName1,
                    catchStatements: catchStatements1,
                } = node1 as AstStatementTryCatch;
                const {
                    statements: tryCatchStatements2,
                    catchName: catchName2,
                    catchStatements: catchStatements2,
                } = node2 as AstStatementTryCatch;
                return (
                    this.compareArray(
                        tryCatchStatements1,
                        tryCatchStatements2,
                    ) &&
                    this.compare(catchName1, catchName2) &&
                    this.compareArray(catchStatements1, catchStatements2)
                );
            }

            case "statement_foreach": {
                const {
                    keyName: forEachKeyName1,
                    valueName: forEachValueName1,
                    map: forEachMap1,
                    statements: forEachStatements1,
                } = node1 as AstStatementForEach;
                const {
                    keyName: forEachKeyName2,
                    valueName: forEachValueName2,
                    map: forEachMap2,
                    statements: forEachStatements2,
                } = node2 as AstStatementForEach;
                return (
                    this.compare(forEachKeyName1, forEachKeyName2) &&
                    this.compare(forEachValueName1, forEachValueName2) &&
                    this.compare(forEachMap1, forEachMap2) &&
                    this.compareArray(forEachStatements1, forEachStatements2)
                );
            }

            case "destruct_mapping": {
                const {
                    field: destructMappingField1,
                    name: destructMappingName1,
                } = node1 as AstDestructMapping;
                const {
                    field: destructMappingField2,
                    name: destructMappingName2,
                } = node2 as AstDestructMapping;
                return (
                    this.compare(
                        destructMappingField1,
                        destructMappingField2,
                    ) &&
                    this.compare(destructMappingName1, destructMappingName2)
                );
            }

            case "statement_destruct": {
                const {
                    type: destructType1,
                    identifiers: destructIdentifiers1,
                    expression: destructExpression1,
                } = node1 as AstStatementDestruct;
                const {
                    type: destructType2,
                    identifiers: destructIdentifiers2,
                    expression: destructExpression2,
                } = node2 as AstStatementDestruct;
                const sortedIdentifiers1 = Array.from(
                    destructIdentifiers1.values(),
                ).sort();
                const sortedIdentifiers2 = Array.from(
                    destructIdentifiers2.values(),
                ).sort();
                if (sortedIdentifiers1.length !== sortedIdentifiers2.length) {
                    return false;
                }
                for (let i = 0; i < sortedIdentifiers1.length; i++) {
                    if (
                        !this.compare(
                            sortedIdentifiers1[i]![0],
                            sortedIdentifiers2[i]![0],
                        ) ||
                        !this.compare(
                            sortedIdentifiers1[i]![1],
                            sortedIdentifiers2[i]![1],
                        )
                    ) {
                        return false;
                    }
                }
                return (
                    this.compare(destructType1, destructType2) &&
                    this.compare(destructExpression1, destructExpression2)
                );
            }

            case "type_id": {
                const { text: typeIdText1 } = node1 as AstTypeId;
                const { text: typeIdText2 } = node2 as AstTypeId;
                return typeIdText1 === typeIdText2;
            }

            case "optional_type": {
                const { typeArg: optionalTypeArg1 } = node1 as AstOptionalType;
                const { typeArg: optionalTypeArg2 } = node2 as AstOptionalType;
                return this.compare(optionalTypeArg1, optionalTypeArg2);
            }

            case "map_type": {
                const {
                    keyType: mapKeyType1,
                    keyStorageType: mapKeyStorageType1,
                    valueType: mapValueType1,
                    valueStorageType: mapValueStorageType1,
                } = node1 as AstMapType;
                const {
                    keyType: mapKeyType2,
                    keyStorageType: mapKeyStorageType2,
                    valueType: mapValueType2,
                    valueStorageType: mapValueStorageType2,
                } = node2 as AstMapType;
                return (
                    this.compare(mapKeyType1, mapKeyType2) &&
                    this.compareNullableNodes(
                        mapKeyStorageType1,
                        mapKeyStorageType2,
                    ) &&
                    this.compare(mapValueType1, mapValueType2) &&
                    this.compareNullableNodes(
                        mapValueStorageType1,
                        mapValueStorageType2,
                    )
                );
            }

            case "bounced_message_type": {
                const { messageType: messageTy1 } =
                    node1 as AstBouncedMessageType;
                const { messageType: messageTy2 } =
                    node2 as AstBouncedMessageType;
                return this.compare(messageTy1, messageTy2);
            }

            case "op_binary": {
                const {
                    op: binaryOp1,
                    left: lhs1,
                    right: rhs1,
                } = node1 as AstOpBinary;
                const {
                    op: binaryOp2,
                    left: lhs2,
                    right: rhs2,
                } = node2 as AstOpBinary;
                return (
                    binaryOp1 === binaryOp2 &&
                    this.compare(lhs1, lhs2) &&
                    this.compare(rhs1, rhs2)
                );
            }

            case "op_unary": {
                const { op: op1, operand: operand1 } = node1 as AstOpUnary;
                const { op: op2, operand: operand2 } = node2 as AstOpUnary;
                return op1 === op2 && this.compare(operand1, operand2);
            }

            case "field_access": {
                const { aggregate: aggregate1, field: field1 } =
                    node1 as AstFieldAccess;
                const { aggregate: aggregate2, field: field2 } =
                    node2 as AstFieldAccess;
                return (
                    this.compare(aggregate1, aggregate2) &&
                    this.compare(field1, field2)
                );
            }

            case "method_call": {
                const {
                    self: self1,
                    method: method1,
                    args: args1,
                } = node1 as AstMethodCall;
                const {
                    self: self2,
                    method: method2,
                    args: args2,
                } = node2 as AstMethodCall;
                return (
                    this.compare(self1, self2) &&
                    this.compare(method1, method2) &&
                    this.compareArray(args1, args2)
                );
            }

            case "static_call": {
                const { function: staticFunction1, args: staticArgs1 } =
                    node1 as AstStaticCall;
                const { function: staticFunction2, args: staticArgs2 } =
                    node2 as AstStaticCall;
                return (
                    this.compare(staticFunction1, staticFunction2) &&
                    this.compareArray(staticArgs1, staticArgs2)
                );
            }

            case "struct_instance": {
                const { type: ty1, args: args1 } = node1 as AstStructInstance;
                const { type: ty2, args: args2 } = node2 as AstStructInstance;
                return (
                    this.compare(ty1, ty2) && this.compareArray(args1, args2)
                );
            }

            case "init_of": {
                const { contract: initOfContract1, args: initOfArgs1 } =
                    node1 as AstInitOf;
                const { contract: initOfContract2, args: initOfArgs2 } =
                    node2 as AstInitOf;
                return (
                    this.compare(initOfContract1, initOfContract2) &&
                    this.compareArray(initOfArgs1, initOfArgs2)
                );
            }

            case "conditional": {
                const {
                    condition: cond1,
                    thenBranch: then1,
                    elseBranch: else1,
                } = node1 as AstConditional;
                const {
                    condition: cond2,
                    thenBranch: then2,
                    elseBranch: else2,
                } = node2 as AstConditional;
                return (
                    this.compare(cond1, cond2) &&
                    this.compare(then1, then2) &&
                    this.compare(else1, else2)
                );
            }

            case "id": {
                const { text: text1 } = node1 as AstId;
                const { text: text2 } = node2 as AstId;
                return text1 === text2;
            }

            case "func_id": {
                const { text: text1 } = node1 as AstFuncId;
                const { text: text2 } = node2 as AstFuncId;
                return text1 === text2;
            }

            case "number": {
                const { value: val1 } = node1 as AstNumber;
                const { value: val2 } = node2 as AstNumber;
                return val1 === val2;
            }

            case "boolean": {
                const { value: val1 } = node1 as AstBoolean;
                const { value: val2 } = node2 as AstBoolean;
                return val1 === val2;
            }

            case "string": {
                const { value: val1 } = node1 as AstString;
                const { value: val2 } = node2 as AstString;
                return val1 === val2;
            }

            case "null": {
                return true;
            }

            case "typed_parameter": {
                const { name: name1, type: ty1 } = node1 as AstTypedParameter;
                const { name: name2, type: ty2 } = node1 as AstTypedParameter;
                return this.compare(name1, name2) && this.compare(ty1, ty2);
            }

            case "struct_field_initializer": {
                const { field: field1, initializer: initializer1 } =
                    node1 as AstStructFieldInitializer;
                const { field: field2, initializer: initializer2 } =
                    node2 as AstStructFieldInitializer;
                return (
                    this.compare(field1, field2) &&
                    this.compare(initializer1, initializer2)
                );
            }

            default:
                throwInternalCompilerError(
                    `Unsupported node: ${JSONbig.stringify(node1)}`,
                );
        }
    }

    private compareNullableNodes(
        node1: AstNode | null,
        node2: AstNode | null,
    ): boolean {
        if (node1 === null || node2 === null) {
            return node1 === node2;
        }
        return this.compare(node1, node2);
    }

    private compareArray(nodes1: AstNode[], nodes2: AstNode[]): boolean {
        if (nodes1.length !== nodes2.length) {
            return false;
        }
        for (let i = 0; i < nodes1.length; i++) {
            if (!this.compare(nodes1[i]!, nodes2[i]!)) {
                return false;
            }
        }
        return true;
    }

    private compareNullableArray(
        nodes1: AstNode[] | null,
        nodes2: AstNode[] | null,
    ): boolean {
        if (nodes1 === null || nodes2 === null) {
            return nodes1 === nodes2;
        }
        return this.compareArray(nodes1, nodes2);
    }

    private compareAsmInstructions(
        instructions1: AstAsmInstruction[],
        instructions2: AstAsmInstruction[],
    ): boolean {
        if (instructions1.length !== instructions2.length) {
            return false;
        }
        return instructions1.every((val1, i1) => val1 === instructions2[i1]);
    }

    private compareAttributes<
        T extends
            | AstFunctionAttribute
            | AstConstantAttribute
            | AstContractAttribute,
    >(attrs1: T[], attrs2: T[]): boolean {
        if (attrs1.length !== attrs2.length) {
            return false;
        }
        for (let i = 0; i < attrs1.length; i++) {
            if (attrs1[i]!.type !== attrs2[i]!.type) {
                return false;
            }
        }
        return true;
    }

    private compareReceiverKinds(
        kind1: AstReceiverKind,
        kind2: AstReceiverKind,
    ): boolean {
        if (kind1.kind !== kind2.kind) {
            return false;
        }
        if (
            (kind1.kind === "internal-simple" &&
                kind2.kind === "internal-simple") ||
            (kind1.kind === "bounce" && kind2.kind === "bounce") ||
            (kind1.kind === "external-simple" &&
                kind2.kind === "external-simple")
        ) {
            return this.compare(kind1.param, kind2.param);
        }
        if (
            (kind1.kind === "internal-comment" &&
                kind2.kind === "internal-comment") ||
            (kind1.kind === "external-comment" &&
                kind2.kind === "external-comment")
        ) {
            return this.compare(kind1.comment, kind2.comment);
        }
        return true;
    }
}


## grammar.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/grammar.spec.ts)
import { AstModule, getAstFactory } from "./ast";
import { loadCases } from "../utils/loadCases";
import { getParser } from "./grammar";
import { SrcInfo, isSrcInfo } from "./src-info";

expect.addSnapshotSerializer({
    test: (src) => isSrcInfo(src),
    print: (src) => (src as SrcInfo).contents,
});

describe("grammar", () => {
    // Test parsing of known Fift projects, wrapped in asm functions of Tact
    for (const r of loadCases(__dirname + "/test-asm/")) {
        it("should parse " + r.name, () => {
            const ast = getAstFactory();
            const { parse } = getParser(ast);
            const parsed: AstModule | undefined = parse(
                r.code,
                "<unknown>",
                "user",
            );

            // Don't produce snapshots
            expect(parsed).toBeDefined();
        });
    }

    for (const r of loadCases(__dirname + "/test/")) {
        it("should parse " + r.name, () => {
            const ast = getAstFactory();
            const { parse } = getParser(ast);
            expect(parse(r.code, "<unknown>", "user")).toMatchSnapshot();
        });
    }

    for (const r of loadCases(__dirname + "/test-failed/")) {
        it("should fail " + r.name, () => {
            const ast = getAstFactory();
            const { parse } = getParser(ast);
            expect(() =>
                parse(r.code, "<unknown>", "user"),
            ).toThrowErrorMatchingSnapshot();
        });
    }
});


## grammar.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/grammar.ts)
import { Node, IterationNode, NonterminalNode } from "ohm-js";
import tactGrammar from "./grammar.ohm-bundle";
import { throwInternalCompilerError } from "../errors";
import {
    AstAugmentedAssignOperation,
    AstConstantAttribute,
    AstContractAttribute,
    AstExpression,
    AstFunctionAttribute,
    AstNode,
    AstModule,
    AstReceiverKind,
    AstString,
    AstType,
    AstImport,
    AstConstantDef,
    AstNumberBase,
    AstId,
    FactoryAst,
} from "./ast";
import { getSrcInfoFromOhm, ItemOrigin, SrcInfo } from "./src-info";
import { parserErrorSchema, ParserErrors } from "./parser-error";
import { displayToString } from "../error/display-to-string";

type Context = {
    origin: ItemOrigin | null;
    currentFile: string | null;
    createNode: FactoryAst["createNode"] | null;
    errorTypes: ParserErrors | null;
};

const defaultContext: Context = Object.freeze({
    createNode: null,
    currentFile: null,
    origin: null,
    errorTypes: null,
});

let context: Context = defaultContext;

const withContext = <T>(ctx: Context, callback: () => T): T => {
    try {
        context = ctx;
        return callback();
    } finally {
        context = defaultContext;
    }
};

function createRef(s: Node): SrcInfo {
    if (context.origin === null) {
        throwInternalCompilerError("Parser context was not initialized");
    }

    return getSrcInfoFromOhm(s.source, context.currentFile, context.origin);
}

const createNode: FactoryAst["createNode"] = (...args) => {
    if (context.createNode === null) {
        throwInternalCompilerError("Parser context was not initialized");
    }

    return context.createNode(...args);
};

const err = () => {
    if (context.errorTypes === null) {
        throwInternalCompilerError("Parser context was not initialized");
    }

    return context.errorTypes;
};

// helper to unwrap optional grammar elements (marked with "?")
// ohm-js represents those essentially as lists (IterationNodes)
function unwrapOptNode<T>(
    optional: IterationNode,
    f: (n: Node) => T,
): T | null {
    const optNode = optional.children[0] as Node | undefined;
    return optNode !== undefined ? f(optNode) : null;
}

function checkVariableName(name: string, loc: SrcInfo) {
    if (name.startsWith("__gen")) {
        err().reservedVarPrefix("__gen")(loc);
    }
    if (name.startsWith("__tact")) {
        err().reservedVarPrefix("__tact")(loc);
    }
}

const checkAttributes =
    (kind: "constant" | "function") =>
    (
        isAbstract: boolean,
        attributes: (AstConstantAttribute | AstFunctionAttribute)[],
        loc: SrcInfo,
    ) => {
        const { duplicate, tooAbstract, notAbstract } = err()[kind];
        const k: Set<string> = new Set();
        for (const a of attributes) {
            if (k.has(a.type)) {
                duplicate(a.type)(a.loc);
            }
            k.add(a.type);
        }
        if (isAbstract && !k.has("abstract")) {
            notAbstract()(loc);
        }
        if (!isAbstract && k.has("abstract")) {
            tooAbstract()(loc);
        }
    };

const checkConstAttributes = checkAttributes("constant");

const checkFunctionAttributes = checkAttributes("function");

const semantics = tactGrammar.createSemantics();

semantics.addOperation<AstNode>("astOfModule", {
    Module(imports, items) {
        return createNode({
            kind: "module",
            imports: imports.children.map((item) => item.astOfImport()),
            items: items.children.map((item) => item.astOfModuleItem()),
        });
    },
});

semantics.addOperation<AstNode>("astOfImport", {
    Import(_importKwd, path, _semicolon) {
        const pathAST = path.astOfExpression() as AstString;
        if (pathAST.value.includes("\\")) {
            err().importWithBackslash()(createRef(path));
        }
        return createNode({
            kind: "import",
            path: pathAST,
            loc: createRef(this),
        });
    },
});

semantics.addOperation<AstImport[]>("astOfJustImports", {
    JustImports(imports, _restOfInput) {
        return imports.children.map((item) => item.astOfImport());
    },
});

semantics.addOperation<AstNode>("astOfModuleItem", {
    PrimitiveTypeDecl(_primitive_kwd, typeId, _semicolon) {
        checkVariableName(typeId.sourceString, createRef(typeId));
        return createNode({
            kind: "primitive_type_decl",
            name: typeId.astOfType(),
            loc: createRef(this),
        });
    },
    NativeFunctionDecl(
        _name,
        _lparen1,
        funcId,
        _rparen1,
        funAttributes,
        _nativeKwd,
        tactId,
        params,
        _optColon,
        optReturnType,
        _semicolon,
    ) {
        checkVariableName(tactId.sourceString, createRef(tactId));
        return createNode({
            kind: "native_function_decl",
            attributes: funAttributes.children.map((a) =>
                a.astOfFunctionAttributes(),
            ),
            name: tactId.astOfExpression(),
            nativeName: funcId.astOfExpression(),
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            params: params.astsOfList(),
            loc: createRef(this),
        });
    },
    StructDecl_regular(_structKwd, typeId, _lbrace, fields, _rbrace) {
        checkVariableName(typeId.sourceString, createRef(typeId));
        return createNode({
            kind: "struct_decl",
            name: typeId.astOfType(),
            fields: fields.astsOfList(),
            loc: createRef(this),
        });
    },
    StructDecl_message(
        _messageKwd,
        _optLparen,
        optIntMsgId,
        _optRparen,
        typeId,
        _lbrace,
        fields,
        _rbrace,
    ) {
        checkVariableName(typeId.sourceString, createRef(typeId));
        return createNode({
            kind: "message_decl",
            name: typeId.astOfType(),
            fields: fields.astsOfList(),
            opcode: unwrapOptNode(optIntMsgId, (msgId) =>
                msgId.astOfExpression(),
            ),
            loc: createRef(this),
        });
    },
    Contract(
        attributes,
        _contractKwd,
        contractId,
        _optWithKwd,
        optInheritedTraits,
        _lbrace,
        contractItems,
        _rbrace,
    ) {
        checkVariableName(contractId.sourceString, createRef(contractId));
        return createNode({
            kind: "contract",
            name: contractId.astOfExpression(),
            attributes: attributes.children.map((ca) =>
                ca.astOfContractAttributes(),
            ),
            declarations: contractItems.children.map((item) =>
                item.astOfItem(),
            ),
            traits: optInheritedTraits.children[0]?.astsOfList() ?? [],
            loc: createRef(this),
        });
    },
    Trait(
        attributes,
        _traitKwd,
        traitId,
        _optWithKwd,
        optInheritedTraits,
        _lbrace,
        traitItems,
        _rbrace,
    ) {
        checkVariableName(traitId.sourceString, createRef(traitId));
        return createNode({
            kind: "trait",
            name: traitId.astOfExpression(),
            attributes: attributes.children.map((ca) =>
                ca.astOfContractAttributes(),
            ),
            declarations: traitItems.children.map((item) => item.astOfItem()),
            traits: optInheritedTraits.children[0]?.astsOfList() ?? [],
            loc: createRef(this),
        });
    },
    ModuleFunction(fun) {
        return fun.astOfItem();
    },
    ModuleConstant(constant) {
        const astConstDef: AstConstantDef = constant.astOfItem();
        if (astConstDef.attributes.length !== 0) {
            err().topLevelConstantWithAttribute()(
                astConstDef.attributes[0]!.loc,
            );
        }
        return astConstDef;
    },
});

// top-level (module-level), contract or trait items:
// constant declarations/definitions, functions, receivers,
// getters, etc.
semantics.addOperation<AstNode>("astOfItem", {
    ConstantDefinition(
        constAttributes,
        _constKwd,
        constId,
        _colon,
        constType,
        _equals,
        initExpr,
        _semicolon,
    ) {
        const attributes = constAttributes.children.map((a) =>
            a.astOfConstAttribute(),
        ) as AstConstantAttribute[];
        checkConstAttributes(false, attributes, createRef(this));
        return createNode({
            kind: "constant_def",
            name: constId.astOfExpression(),
            type: constType.astOfType(),
            initializer: initExpr.astOfExpression(),
            attributes,
            loc: createRef(this),
        });
    },
    ConstantDeclaration(
        constAttributes,
        _constKwd,
        constId,
        _colon,
        constType,
        _semicolon,
    ) {
        const attributes = constAttributes.children.map((a) =>
            a.astOfConstAttribute(),
        ) as AstConstantAttribute[];
        checkConstAttributes(true, attributes, createRef(this));
        return createNode({
            kind: "constant_decl",
            name: constId.astOfExpression(),
            type: constType.astOfType(),
            attributes,
            loc: createRef(this),
        });
    },
    StorageVar(fieldDecl, _semicolon) {
        return fieldDecl.astOfDeclaration();
    },
    FunctionDefinition(
        funAttributes,
        _funKwd,
        funId,
        funParameters,
        _optColon,
        optReturnType,
        _lbrace,
        funBody,
        _rbrace,
    ) {
        const attributes = funAttributes.children.map((a) =>
            a.astOfFunctionAttributes(),
        ) as AstFunctionAttribute[];
        checkVariableName(funId.sourceString, createRef(funId));
        checkFunctionAttributes(false, attributes, createRef(this));
        return createNode({
            kind: "function_def",
            attributes,
            name: funId.astOfExpression(),
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            params: funParameters.astsOfList(),
            statements: funBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    AsmFunction(
        _asmKwd,
        optAsmShuffle,
        funAttributes,
        _funKwd,
        funId,
        funParameters,
        _optColon,
        optReturnType,
        _lbrace,
        asmInstructions,
        _rbrace,
    ) {
        const shuffle = optAsmShuffle.children[0]?.astsOfAsmShuffle() ?? {
            args: [],
            ret: [],
        };
        const attributes = funAttributes.children.map((a) =>
            a.astOfFunctionAttributes(),
        ) as AstFunctionAttribute[];
        checkVariableName(funId.sourceString, createRef(funId));
        checkFunctionAttributes(false, attributes, createRef(this));
        return createNode({
            kind: "asm_function_def",
            shuffle,
            attributes,
            name: funId.astOfExpression(),
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            params: funParameters.astsOfList(),
            instructions: asmInstructions.children.map((s) =>
                s.astOfAsmInstruction(),
            ),
            loc: createRef(this),
        });
    },
    FunctionDeclaration(
        funAttributes,
        _funKwd,
        funId,
        funParameters,
        _optColon,
        optReturnType,
        _semicolon,
    ) {
        const attributes = funAttributes.children.map((a) =>
            a.astOfFunctionAttributes(),
        ) as AstFunctionAttribute[];
        checkVariableName(funId.sourceString, createRef(funId));
        checkFunctionAttributes(true, attributes, createRef(this));
        return createNode({
            kind: "function_decl",
            attributes,
            name: funId.astOfExpression(),
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            params: funParameters.astsOfList(),
            loc: createRef(this),
        });
    },
    ContractInit(_initKwd, initParameters, _lbrace, initBody, _rbrace) {
        return createNode({
            kind: "contract_init",
            params: initParameters.astsOfList(),
            statements: initBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_regular(
        _receiveKwd,
        _lparen,
        optParameter,
        _rparen,
        _lbrace,
        receiverBody,
        _rbrace,
    ) {
        const optParam = optParameter.children[0] as Node | undefined;
        const selector: AstReceiverKind = optParam
            ? {
                  kind: "internal-simple",
                  param: optParam.astOfDeclaration(),
              }
            : { kind: "internal-fallback" };
        return createNode({
            kind: "receiver",
            selector,
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_comment(
        _receiveKwd,
        _lparen,
        comment,
        _rparen,
        _lbrace,
        receiverBody,
        _rbrace,
    ) {
        return createNode({
            kind: "receiver",
            selector: {
                kind: "internal-comment",
                comment: comment.astOfExpression(),
            },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_bounced(
        _bouncedKwd,
        _lparen,
        parameter,
        _rparen,
        _lbrace,
        receiverBody,
        _rbrace,
    ) {
        return createNode({
            kind: "receiver",
            selector: { kind: "bounce", param: parameter.astOfDeclaration() },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_externalRegular(
        _externalKwd,
        _lparen,
        optParameter,
        _rparen,
        _lbrace,
        receiverBody,
        _rbrace,
    ) {
        const optParam = optParameter.children[0] as Node | undefined;
        const selector: AstReceiverKind = optParam
            ? {
                  kind: "external-simple",
                  param: optParam.astOfDeclaration(),
              }
            : { kind: "external-fallback" };
        return createNode({
            kind: "receiver",
            selector,
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_externalComment(
        _externalKwd,
        _lparen,
        comment,
        _rparen,
        _lbrace,
        receiverBody,
        _rbrace,
    ) {
        return createNode({
            kind: "receiver",
            selector: {
                kind: "external-comment",
                comment: comment.astOfExpression(),
            },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
});

// Beginnings of the possible future AST for Fift-asm
semantics.addOperation<string>("astOfAsmInstruction", {
    asmInstruction(word) {
        return word.sourceString;
    },
    AsmInstruction(instruction) {
        return instruction.astOfAsmInstruction();
    },
    AsmInstruction_custom(instruction) {
        return instruction.astOfAsmInstruction();
    },
    AsmInstruction_internal(
        _leftBracket,
        _ws1,
        instructions,
        _rightBracket,
        _ws2,
    ) {
        return [
            "[",
            instructions.children.map((s) => s.astOfAsmInstruction()).join(" "),
            "]",
        ].join(" ");
    },
    AsmInstruction_list(_lbrace, _ws1, instructions, _rbrace, _ws2) {
        return [
            "{",
            instructions.children.map((s) => s.astOfAsmInstruction()).join(" "),
            "}",
        ].join(" ");
    },
    AsmInstruction_listNoStateCheck(
        _lbrace,
        _ws1,
        instructions,
        _rbrace,
        _ws2,
    ) {
        return [
            "({)",
            instructions.children.map((s) => s.astOfAsmInstruction()).join(" "),
            "(})",
        ].join(" ");
    },
    AsmInstruction_string(
        startQuotationMarkWord,
        string,
        _endQuotationMark,
        _ws,
    ) {
        return `${startQuotationMarkWord.sourceString}${string.sourceString}"`;
    },
    AsmInstruction_tick(_singleQuote, _ws1, instruction) {
        return `' ${instruction.sourceString}`;
    },
    AsmInstruction_char(_word, _ws1, char, _ws2) {
        return `char ${char.sourceString}`;
    },
    AsmInstruction_hexLiteral(prefix, digits, optUnderscore, _rbrace, _ws) {
        const length = digits.numChildren;
        const underscore = unwrapOptNode(optUnderscore, (t) => t.sourceString);
        if (length > 128) {
            err().literalTooLong()(createRef(this));
        }
        return `${prefix.sourceString}${digits.sourceString}${underscore ?? ""}}`;
    },
    AsmInstruction_binLiteral(_prefix, digits, _rbrace, _ws) {
        const length = digits.numChildren;
        if (length > 128) {
            err().literalTooLong()(createRef(this));
        }
        return `b{${digits.sourceString}}`;
    },
});

semantics.addOperation<AstFunctionAttribute>("astOfFunctionAttributes", {
    FunctionAttribute_getter(_getKwd, _optLparen, optMethodId, _optRparen) {
        return {
            kind: "function_attribute",
            type: "get",
            methodId: unwrapOptNode(optMethodId, (e) => e.astOfExpression()),
            loc: createRef(this),
        };
    },
    FunctionAttribute_extends(_) {
        return {
            kind: "function_attribute",
            type: "extends",
            loc: createRef(this),
        };
    },
    FunctionAttribute_mutates(_) {
        return {
            kind: "function_attribute",
            type: "mutates",
            loc: createRef(this),
        };
    },
    FunctionAttribute_override(_) {
        return {
            kind: "function_attribute",
            type: "override",
            loc: createRef(this),
        };
    },
    FunctionAttribute_inline(_) {
        return {
            kind: "function_attribute",
            type: "inline",
            loc: createRef(this),
        };
    },
    FunctionAttribute_virtual(_) {
        return {
            kind: "function_attribute",
            type: "virtual",
            loc: createRef(this),
        };
    },
    FunctionAttribute_abstract(_) {
        return {
            kind: "function_attribute",
            type: "abstract",
            loc: createRef(this),
        };
    },
});

semantics.addOperation<{ args: AstNode[]; ret: AstNode[] }>(
    "astsOfAsmShuffle",
    {
        AsmShuffle(_lparen, argsShuffle, _optArrow, optRetShuffle, _rparen) {
            return {
                args: argsShuffle.children.map((id) => id.astOfExpression()),
                ret:
                    optRetShuffle.children[0]?.children.map((num) =>
                        num.astOfExpression(),
                    ) ?? [],
            };
        },
    },
);

semantics.addOperation<AstConstantAttribute>("astOfConstAttribute", {
    ConstantAttribute_override(_) {
        return { type: "override", loc: createRef(this) };
    },
    ConstantAttribute_virtual(_) {
        return { type: "virtual", loc: createRef(this) };
    },
    ConstantAttribute_abstract(_) {
        return { type: "abstract", loc: createRef(this) };
    },
});

semantics.addOperation<AstNode[]>("astsOfList", {
    InheritedTraits(traits, _optTrailingComma) {
        return traits
            .asIteration()
            .children.map((id, _comma) => id.astOfExpression());
    },
    StructFields(fields, _optSemicolon) {
        return fields
            .asIteration()
            .children.map((field, _semicolon) => field.astOfDeclaration());
    },
    Parameters(_lparen, params, optTrailingComma, _rparen) {
        if (
            params.source.contents === "" &&
            optTrailingComma.sourceString === ","
        ) {
            err().extraneousComma()(createRef(optTrailingComma));
        }
        return params.asIteration().children.map((p) => p.astOfDeclaration());
    },
    Arguments(_lparen, args, optTrailingComma, _rparen) {
        if (
            args.source.contents === "" &&
            optTrailingComma.sourceString === ","
        ) {
            err().extraneousComma()(createRef(optTrailingComma));
        }
        return args.asIteration().children.map((arg) => arg.astOfExpression());
    },
});

semantics.addOperation<AstContractAttribute>("astOfContractAttributes", {
    ContractAttribute_interface(_interface, _lparen, interfaceName, _rparen) {
        return {
            type: "interface",
            name: interfaceName.astOfExpression(),
            loc: createRef(this),
        };
    },
});

semantics.addOperation<AstNode>("astOfDeclaration", {
    FieldDecl(
        id,
        _colon,
        type,
        _optAs,
        optStorageType,
        _optEq,
        optInitializer,
    ) {
        return createNode({
            kind: "field_decl",
            name: id.astOfExpression(),
            type: type.astOfType() as AstType,
            as: unwrapOptNode(optStorageType, (t) => t.astOfExpression()),
            initializer: unwrapOptNode(optInitializer, (e) =>
                e.astOfExpression(),
            ),
            loc: createRef(this),
        });
    },
    Parameter(id, _colon, type) {
        checkVariableName(id.sourceString, createRef(id));
        return createNode({
            kind: "typed_parameter",
            name: id.astOfExpression(),
            type: type.astOfType(),
            loc: createRef(this),
        });
    },
    StructFieldInitializer_full(fieldId, _colon, initializer) {
        return createNode({
            kind: "struct_field_initializer",
            field: fieldId.astOfExpression(),
            initializer: initializer.astOfExpression(),
            loc: createRef(this),
        });
    },
    StructFieldInitializer_punned(fieldId) {
        return createNode({
            kind: "struct_field_initializer",
            field: fieldId.astOfExpression(),
            initializer: fieldId.astOfExpression(),
            loc: createRef(this),
        });
    },
});

// Statements
semantics.addOperation<AstNode>("astOfStatement", {
    // TODO: process StatementBlock

    StatementLet(
        _letKwd,
        id,
        _optColon,
        optType,
        _equals,
        expression,
        _optSemicolonIfLastStmtInBlock,
    ) {
        checkVariableName(id.sourceString, createRef(id));

        return createNode({
            kind: "statement_let",
            name: id.astOfExpression(),
            type: unwrapOptNode(optType, (t) => t.astOfType()),
            expression: expression.astOfExpression(),
            loc: createRef(this),
        });
    },
    StatementReturn(_returnKwd, optExpression, _optSemicolonIfLastStmtInBlock) {
        return createNode({
            kind: "statement_return",
            expression: unwrapOptNode(optExpression, (e) =>
                e.astOfExpression(),
            ),
            loc: createRef(this),
        });
    },
    StatementExpression(expression, _optSemicolonIfLastStmtInBlock) {
        return createNode({
            kind: "statement_expression",
            expression: expression.astOfExpression(),
            loc: createRef(this),
        });
    },
    StatementAssign(
        lvalue,
        operator,
        expression,
        _optSemicolonIfLastStmtInBlock,
    ) {
        if (operator.sourceString === "=") {
            return createNode({
                kind: "statement_assign",
                path: lvalue.astOfExpression(),
                expression: expression.astOfExpression(),
                loc: createRef(this),
            });
        } else {
            let op: AstAugmentedAssignOperation;
            switch (operator.sourceString) {
                case "+=":
                    op = "+";
                    break;
                case "-=":
                    op = "-";
                    break;
                case "*=":
                    op = "*";
                    break;
                case "/=":
                    op = "/";
                    break;
                case "%=":
                    op = "%";
                    break;
                case "|=":
                    op = "|";
                    break;
                case "&=":
                    op = "&";
                    break;
                case "^=":
                    op = "^";
                    break;
                case "||=":
                    op = "||";
                    break;
                case "&&=":
                    op = "&&";
                    break;
                case "<<=":
                    op = "<<";
                    break;
                case ">>=":
                    op = ">>";
                    break;
                default:
                    throwInternalCompilerError(
                        "Unreachable augmented assignment operator.",
                    );
            }
            return createNode({
                kind: "statement_augmentedassign",
                path: lvalue.astOfExpression(),
                op,
                expression: expression.astOfExpression(),
                loc: createRef(this),
            });
        }
    },
    StatementCondition_noElse(_ifKwd, condition, _lbrace, thenBlock, _rbrace) {
        return createNode({
            kind: "statement_condition",
            condition: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: null,
            elseif: null,
            loc: createRef(this),
        });
    },
    StatementCondition_withElse(
        _ifKwd,
        condition,
        _lbraceThen,
        thenBlock,
        _rbraceThen,
        _elseKwd,
        _lbraceElse,
        elseBlock,
        _rbraceElse,
    ) {
        return createNode({
            kind: "statement_condition",
            condition: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: elseBlock.children.map((s) => s.astOfStatement()),
            elseif: null,
            loc: createRef(this),
        });
    },
    StatementCondition_withElseIf(
        _ifKwd,
        condition,
        _lbraceThen,
        thenBlock,
        _rbraceThen,
        _elseKwd,
        elseifClause,
    ) {
        return createNode({
            kind: "statement_condition",
            condition: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: null,
            elseif: elseifClause.astOfStatement(),
            loc: createRef(this),
        });
    },
    StatementWhile(
        _whileKwd,
        _lparen,
        condition,
        _rparen,
        _lbrace,
        loopBody,
        _rbrace,
    ) {
        return createNode({
            kind: "statement_while",
            condition: condition.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementRepeat(
        _repeatKwd,
        _lparen,
        iterations,
        _rparen,
        _lbrace,
        loopBody,
        _rbrace,
    ) {
        return createNode({
            kind: "statement_repeat",
            iterations: iterations.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementUntil(
        _doKwd,
        _lbrace,
        loopBody,
        _rbrace,
        _untilKwd,
        _lparen,
        condition,
        _rparen,
        _optSemicolonIfLastStmtInBlock,
    ) {
        return createNode({
            kind: "statement_until",
            condition: condition.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementTry_noCatch(_tryKwd, _lbraceTry, tryBlock, _rbraceTry) {
        return createNode({
            kind: "statement_try",
            statements: tryBlock.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementTry_withCatch(
        _tryKwd,
        _lbraceTry,
        tryBlock,
        _rbraceTry,
        _catchKwd,
        _lparen,
        exitCodeId,
        _rparen,
        _lbraceCatch,
        catchBlock,
        _rbraceCatch,
    ) {
        return createNode({
            kind: "statement_try_catch",
            statements: tryBlock.children.map((s) => s.astOfStatement()),
            catchName: exitCodeId.astOfExpression(),
            catchStatements: catchBlock.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementForEach(
        _foreachKwd,
        _lparen,
        keyId,
        _comma,
        valueId,
        _inKwd,
        mapId,
        _rparen,
        _lbrace,
        foreachBlock,
        _rbrace,
    ) {
        checkVariableName(keyId.sourceString, createRef(keyId));
        checkVariableName(valueId.sourceString, createRef(valueId));
        return createNode({
            kind: "statement_foreach",
            keyName: keyId.astOfExpression(),
            valueName: valueId.astOfExpression(),
            map: mapId.astOfExpression(),
            statements: foreachBlock.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementDestruct(
        _letKwd,
        typeId,
        _lparen,
        identifiers,
        endOfIdentifiers,
        _rparen,
        _equals,
        expression,
        _semicolon,
    ) {
        return createNode({
            kind: "statement_destruct",
            type: typeId.astOfType(),
            identifiers: identifiers
                .asIteration()
                .children.reduce((map, item) => {
                    const destructItem = item.astOfExpression();
                    if (map.has(destructItem.field.text)) {
                        err().duplicateField(destructItem.field.text)(
                            destructItem.loc,
                        );
                    }
                    map.set(destructItem.field.text, [
                        destructItem.field,
                        destructItem.name,
                    ]);
                    return map;
                }, new Map<string, [AstId, AstId]>()),
            ignoreUnspecifiedFields:
                endOfIdentifiers.astOfExpression().ignoreUnspecifiedFields,
            expression: expression.astOfExpression(),
            loc: createRef(this),
        });
    },
});

semantics.addOperation<AstNode>("astOfType", {
    typeId(firstTactTypeIdCharacter, restOfTactTypeId) {
        return createNode({
            kind: "type_id",
            text:
                firstTactTypeIdCharacter.sourceString +
                restOfTactTypeId.sourceString,
            loc: createRef(this),
        });
    },
    Type_optional(typeId, _questionMark) {
        return createNode({
            kind: "optional_type",
            typeArg: typeId.astOfType(),
            loc: createRef(this),
        });
    },
    Type_regular(typeId) {
        return typeId.astOfType();
    },
    Type_map(
        _mapKwd,
        _langle,
        keyTypeId,
        _optAsKwdKey,
        optKeyStorageType,
        _comma,
        valueTypeId,
        _optAsKwdValue,
        optValueStorageType,
        _rangle,
    ) {
        return createNode({
            kind: "map_type",
            keyType: keyTypeId.astOfType(),
            keyStorageType: unwrapOptNode(optKeyStorageType, (t) =>
                t.astOfExpression(),
            ),
            valueType: valueTypeId.astOfType(),
            valueStorageType: unwrapOptNode(optValueStorageType, (t) =>
                t.astOfExpression(),
            ),
            loc: createRef(this),
        });
    },
    Type_bounced(_bouncedKwd, _langle, typeId, _rangle) {
        return createNode({
            kind: "bounced_message_type",
            messageType: typeId.astOfType(),
            loc: createRef(this),
        });
    },
});

// handles binary, octal, decimal and hexadecimal integer literals
function bigintOfIntLiteral(litString: NonterminalNode): bigint {
    return BigInt(litString.sourceString.replaceAll("_", ""));
}

function baseOfIntLiteral(node: NonterminalNode): AstNumberBase {
    const basePrefix = node.sourceString.slice(0, 2).toLowerCase();
    switch (basePrefix) {
        case "0x":
            return 16;
        case "0o":
            return 8;
        case "0b":
            return 2;
        default:
            return 10;
    }
}

function astOfNumber(node: Node): AstNode {
    return createNode({
        kind: "number",
        base: baseOfIntLiteral(node),
        value: bigintOfIntLiteral(node),
        loc: createRef(node),
    });
}

// Expressions
semantics.addOperation<AstNode>("astOfExpression", {
    // Literals
    integerLiteral(_) {
        // Parses dec, hex, and bin numbers
        return astOfNumber(this);
    },
    integerLiteralDec(_) {
        return astOfNumber(this);
    },
    integerLiteralHex(_0x, _digit, _1, _2) {
        return astOfNumber(this);
    },
    boolLiteral(boolValue) {
        return createNode({
            kind: "boolean",
            value: boolValue.sourceString === "true",
            loc: createRef(this),
        });
    },
    id(firstTactIdCharacter, restOfTactId) {
        return createNode({
            kind: "id",
            text: firstTactIdCharacter.sourceString + restOfTactId.sourceString,
            loc: createRef(this),
        });
    },
    funcId(firstFuncIdCharacter, restOfFuncId) {
        return createNode({
            kind: "func_id",
            text: firstFuncIdCharacter.sourceString + restOfFuncId.sourceString,
            loc: createRef(this),
        });
    },
    null(_nullKwd) {
        return createNode({ kind: "null", loc: createRef(this) });
    },
    stringLiteral(_startQuotationMark, string, _endQuotationMark) {
        return createNode({
            kind: "string",
            value: string.sourceString,
            loc: createRef(this),
        });
    },
    DestructItem_punned(id) {
        return createNode({
            kind: "destruct_mapping",
            field: id.astOfExpression(),
            name: id.astOfExpression(),
            loc: createRef(this),
        });
    },
    DestructItem_regular(idFrom, _colon, id) {
        return createNode({
            kind: "destruct_mapping",
            field: idFrom.astOfExpression(),
            name: id.astOfExpression(),
            loc: createRef(this),
        });
    },
    EndOfIdentifiers_regular(_comma) {
        return createNode({
            kind: "destruct_end",
            ignoreUnspecifiedFields: false,
            loc: createRef(this),
        });
    },
    EndOfIdentifiers_ignoreUnspecifiedFields(_comma, _dotDot) {
        return createNode({
            kind: "destruct_end",
            ignoreUnspecifiedFields: true,
            loc: createRef(this),
        });
    },
    ExpressionAdd_add(left, _plus, right) {
        return createNode({
            kind: "op_binary",
            op: "+",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionAdd_sub(left, _minus, right) {
        return createNode({
            kind: "op_binary",
            op: "-",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionMul_div(left, _slash, right) {
        return createNode({
            kind: "op_binary",
            op: "/",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionMul_mul(left, _star, right) {
        return createNode({
            kind: "op_binary",
            op: "*",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionMul_rem(left, _percent, right) {
        return createNode({
            kind: "op_binary",
            op: "%",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionEquality_eq(left, _equalsEquals, right) {
        return createNode({
            kind: "op_binary",
            op: "==",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionEquality_not(left, _bangEquals, right) {
        return createNode({
            kind: "op_binary",
            op: "!=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionCompare_gt(left, _rangle, right) {
        return createNode({
            kind: "op_binary",
            op: ">",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionCompare_gte(left, _rangleEquals, right) {
        return createNode({
            kind: "op_binary",
            op: ">=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionCompare_lt(left, _langle, right) {
        return createNode({
            kind: "op_binary",
            op: "<",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionCompare_lte(left, _langleEquals, right) {
        return createNode({
            kind: "op_binary",
            op: "<=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionOr_or(left, _pipePipe, right) {
        return createNode({
            kind: "op_binary",
            op: "||",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionAnd_and(left, _ampersandAmpersand, right) {
        return createNode({
            kind: "op_binary",
            op: "&&",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseShift_shr(left, _rangleRangle, right) {
        return createNode({
            kind: "op_binary",
            op: ">>",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseShift_shl(left, _langleLangle, right) {
        return createNode({
            kind: "op_binary",
            op: "<<",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseAnd_bitwiseAnd(left, _ampersand, right) {
        return createNode({
            kind: "op_binary",
            op: "&",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseOr_bitwiseOr(left, _pipe, right) {
        return createNode({
            kind: "op_binary",
            op: "|",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseXor_bitwiseXor(left, _caret, right) {
        return createNode({
            kind: "op_binary",
            op: "^",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },

    // Unary
    ExpressionUnary_plus(_plus, operand) {
        return createNode({
            kind: "op_unary",
            op: "+",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionUnary_minus(_minus, operand) {
        return createNode({
            kind: "op_unary",
            op: "-",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionUnary_not(_bang, operand) {
        return createNode({
            kind: "op_unary",
            op: "!",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionUnary_bitwiseNot(_tilde, operand) {
        return createNode({
            kind: "op_unary",
            op: "~",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionParens(_lparen, expression, _rparen) {
        return expression.astOfExpression();
    },
    ExpressionUnboxNotNull(operand, _bangBang) {
        return createNode({
            kind: "op_unary",
            op: "!!",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },

    ExpressionFieldAccess(source, _dot, fieldId) {
        return createNode({
            kind: "field_access",
            aggregate: source.astOfExpression(),
            field: fieldId.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionMethodCall(source, _dot, methodId, methodArguments) {
        return createNode({
            kind: "method_call",
            self: source.astOfExpression(),
            method: methodId.astOfExpression(),
            args: methodArguments.astsOfList(),
            loc: createRef(this),
        });
    },
    ExpressionStaticCall(functionId, functionArguments) {
        return createNode({
            kind: "static_call",
            function: functionId.astOfExpression(),
            args: functionArguments.astsOfList(),
            loc: createRef(this),
        });
    },
    ExpressionStructInstance(
        typeId,
        _lbrace,
        structFields,
        optTrailingComma,
        _rbrace,
    ) {
        if (
            structFields.source.contents === "" &&
            optTrailingComma.sourceString === ","
        ) {
            err().extraneousComma()(createRef(optTrailingComma));
        }

        return createNode({
            kind: "struct_instance",
            type: typeId.astOfType(),
            args: structFields
                .asIteration()
                .children.map((d) => d.astOfDeclaration()),
            loc: createRef(this),
        });
    },
    ExpressionInitOf(_initOfKwd, contractId, initArguments) {
        return createNode({
            kind: "init_of",
            contract: contractId.astOfExpression(),
            args: initArguments.astsOfList(),
            loc: createRef(this),
        });
    },

    // Ternary conditional
    ExpressionConditional_ternary(
        condition,
        _questionMark,
        thenExpression,
        _colon,
        elseExpression,
    ) {
        return createNode({
            kind: "conditional",
            condition: condition.astOfExpression(),
            thenBranch: thenExpression.astOfExpression(),
            elseBranch: elseExpression.astOfExpression(),
            loc: createRef(this),
        });
    },
});

export const getParser = (ast: FactoryAst) => {
    const errorTypes = parserErrorSchema(displayToString);

    function parse(src: string, path: string, origin: ItemOrigin): AstModule {
        return withContext(
            {
                currentFile: path,
                origin,
                createNode: ast.createNode,
                errorTypes,
            },
            () => {
                const matchResult = tactGrammar.match(src);
                if (matchResult.failed()) {
                    errorTypes.generic(matchResult, path, origin);
                }
                return semantics(matchResult).astOfModule();
            },
        );
    }

    function parseExpression(sourceCode: string): AstExpression {
        return withContext(
            {
                currentFile: null,
                origin: "user",
                createNode: ast.createNode,
                errorTypes,
            },
            () => {
                const matchResult = tactGrammar.match(sourceCode, "Expression");
                if (matchResult.failed()) {
                    errorTypes.generic(matchResult, "", "user");
                }
                return semantics(matchResult).astOfExpression();
            },
        );
    }

    function parseImports(
        src: string,
        path: string,
        origin: ItemOrigin,
    ): AstImport[] {
        return withContext(
            {
                currentFile: path,
                origin,
                createNode: ast.createNode,
                errorTypes,
            },
            () => {
                const matchResult = tactGrammar.match(src, "JustImports");
                if (matchResult.failed()) {
                    errorTypes.generic(matchResult, path, origin);
                }
                return semantics(matchResult).astOfJustImports();
            },
        );
    }

    return {
        parse,
        parseExpression,
        parseImports,
    };
};

export type Parser = ReturnType<typeof getParser>;


## hash.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/hash.ts)
import {
    AstConstantDef,
    AstModuleItem,
    AstStatement,
    AstStructFieldInitializer,
    AstFunctionAttribute,
    AstConstantAttribute,
    AstContractAttribute,
    AstTypedParameter,
    AstImport,
    AstNativeFunctionDecl,
    AstReceiver,
    AstFunctionDef,
    AstContract,
    AstTrait,
    AstId,
    AstModule,
    AstStructDecl,
    AstMessageDecl,
    AstFunctionDecl,
    AstConstantDecl,
    AstContractInit,
    AstFieldDecl,
    AstNode,
    AstAsmFunctionDef,
    AstAsmInstruction,
} from "./ast";
import { createHash } from "crypto";
import { throwInternalCompilerError } from "../errors";
import JSONbig from "json-bigint";

export type AstHash = string;

/**
 * Provides functionality to hash AST nodes regardless of identifiers.
 */
export class AstHasher {
    private constructor(private readonly sort: boolean) {}
    public static make(params: Partial<{ sort: boolean }> = {}): AstHasher {
        const { sort = true } = params;
        return new AstHasher(sort);
    }

    public hash(node: AstNode): AstHash {
        const data =
            node.kind === "id" || node.kind === "func_id"
                ? `${node.kind}_${node.text}`
                : this.getHashData(node);
        return createHash("sha256").update(data).digest("hex");
    }

    /**
     * Generates a string that is used to create a hash.
     */
    private getHashData(node: AstNode): string {
        switch (node.kind) {
            case "module":
                return this.hashModule(node);
            case "struct_decl":
                return this.hashStructDecl(node);
            case "message_decl":
                return this.hashMessageDecl(node);
            case "function_def":
                return this.hashFunctionDef(node);
            case "asm_function_def":
                return this.hashAsmFunctionDef(node);
            case "constant_def":
                return this.hashConstantDef(node);
            case "trait":
                return this.hashTrait(node);
            case "contract":
                return this.hashContract(node);
            case "field_decl":
                return this.hashFieldDecl(node);
            case "primitive_type_decl":
                return `${node.kind}|${node.name.kind}`;
            case "contract_init":
                return this.hashContractInit(node);
            case "native_function_decl":
                return this.hashNativeFunctionDecl(node);
            case "receiver":
                return this.hashReceiver(node);
            case "id":
                return "id";
            case "func_id":
                return "func_id";
            case "typed_parameter":
                return this.hashTypedParameter(node);
            case "function_decl":
                return this.hashFunctionDecl(node);
            case "struct_field_initializer":
                return this.hashStructFieldInitializer(node);
            case "import":
                return this.hashImport(node);
            case "constant_decl":
                return this.hashConstantDecl(node);
            // Statements
            case "statement_let":
                return `${node.kind}|${node.type ? this.hash(node.type) : "null"}|${this.hash(node.expression)}`;
            case "statement_return":
                return `${node.kind}|${node.expression ? this.hash(node.expression) : "null"}`;
            case "statement_expression":
                return `${node.kind}|${this.hash(node.expression)}`;
            case "statement_assign":
                return `${node.kind}|${this.hash(node.path)}|${this.hash(node.expression)}`;
            case "statement_augmentedassign":
                return `${node.kind}|${node.op}|${this.hash(node.path)}|${this.hash(node.expression)}`;
            case "statement_condition": {
                const trueStatementsHash = this.hashStatements(
                    node.trueStatements,
                );
                const falseStatementsHash = node.falseStatements
                    ? this.hashStatements(node.falseStatements)
                    : "null";
                const elseifHash = node.elseif
                    ? this.hash(node.elseif)
                    : "null";
                return `${node.kind}|${this.hash(node.condition)}|${trueStatementsHash}|${falseStatementsHash}|${elseifHash}`;
            }
            case "statement_while":
                return `${node.kind}|${this.hash(node.condition)}|${this.hashStatements(node.statements)}`;
            case "statement_until":
                return `${node.kind}|${this.hash(node.condition)}|${this.hashStatements(node.statements)}`;
            case "statement_repeat":
                return `${node.kind}|${this.hash(node.iterations)}|${this.hashStatements(node.statements)}`;
            case "statement_try":
                return `${node.kind}|${this.hashStatements(node.statements)}`;
            case "statement_try_catch":
                return `${node.kind}|${this.hashStatements(node.statements)}|${this.hash(node.catchName)}|${this.hashStatements(node.catchStatements)}`;
            case "statement_foreach":
                return `${node.kind}|${this.hash(node.map)}|${this.hashStatements(node.statements)}`;
            case "statement_destruct":
                return `${node.kind}|${this.hash(node.type)}|${this.hashDestructIdentifiers(Array.from(node.identifiers.values()))}|${this.hash(node.expression)}`;
            // Expressions
            case "op_binary":
                return `${node.kind}|${node.op}|${this.hash(node.left)}|${this.hash(node.right)}`;
            case "op_unary":
                return `${node.kind}|${node.op}|${this.hash(node.operand)}`;
            case "field_access":
                return `${node.kind}|${this.hash(node.aggregate)}|${node.field.kind}`;
            case "method_call": {
                const argsHash = node.args
                    .map((arg) => this.hash(arg))
                    .join("|");
                return `${node.kind}|${argsHash}`;
            }
            case "static_call": {
                const staticArgsHash = node.args
                    .map((arg) => this.hash(arg))
                    .join("|");
                return `${node.kind}|${staticArgsHash}`;
            }
            case "struct_instance": {
                const structArgsHash = node.args
                    .map((arg) => this.hashStructFieldInitializer(arg))
                    .join("|");
                return `${node.kind}|${structArgsHash}`;
            }
            case "init_of": {
                const initArgsHash = node.args
                    .map((arg) => this.hash(arg))
                    .join("|");
                return `${node.kind}|${initArgsHash}`;
            }
            case "conditional":
                return `${node.kind}|${this.hash(node.condition)}|${this.hash(node.thenBranch)}|${this.hash(node.elseBranch)}`;
            case "number":
                return `${node.kind}|${node.value}`;
            case "boolean":
                return `${node.kind}|${node.value}`;
            case "string":
                return `${node.kind}|${node.value}`;
            case "null":
                return node.kind;
            // Types
            case "type_id":
                return `${node.kind}|${node.text}`;
            case "optional_type":
                return `${node.kind}|${this.hash(node.typeArg)}`;
            case "map_type": {
                const keyStorageHash = node.keyStorageType
                    ? this.hash(node.keyStorageType)
                    : "null";
                const valueStorageHash = node.valueStorageType
                    ? this.hash(node.valueStorageType)
                    : "null";
                return `${node.kind}|${this.hash(node.keyType)}|${keyStorageHash}|${this.hash(node.valueType)}|${valueStorageHash}`;
            }
            case "bounced_message_type":
                return `${node.kind}|${this.hash(node.messageType)}`;
            default:
                throwInternalCompilerError(
                    `Unsupported node: ${JSONbig.stringify(node)}`,
                );
        }
    }

    private hashDestructIdentifiers(identifiers: [AstId, AstId][]): string {
        const identifiersHash = identifiers
            .map(([key, value]) => `${this.hash(key)}|${this.hash(value)}`)
            .join("|");
        return identifiersHash;
    }

    private hashStructDecl(node: AstStructDecl): string {
        const fieldsHash = this.hashFields(node.fields);
        return `struct|${fieldsHash}`;
    }

    private hashMessageDecl(node: AstMessageDecl): string {
        const fieldsHash = this.hashFields(node.fields);
        return `message|${fieldsHash}|${node.opcode ? this.hash(node.opcode) : "null"}`;
    }

    private hashFunctionDef(node: AstFunctionDef): string {
        const attributesHash = this.hashAttributes(node.attributes);
        const returnHash = node.return ? this.hash(node.return) : "void";
        const paramsHash = this.hashParams(node.params);
        const statementsHash = this.hashStatements(node.statements);
        return `function|${attributesHash}|${returnHash}|${paramsHash}|${statementsHash}`;
    }

    private hashAsmFunctionDef(node: AstAsmFunctionDef): string {
        const asmAttributeHash = `asm|${this.hashIds(node.shuffle.args)}|->|${node.shuffle.ret.map((num) => num.value.toString()).join("|")}`;
        const attributesHash = this.hashAttributes(node.attributes);
        const returnHash = node.return ? this.hash(node.return) : "void";
        const paramsHash = this.hashParams(node.params);
        const instructionsHash = this.hashInstructions(node.instructions);
        return `function|${asmAttributeHash}|${attributesHash}|${returnHash}|${paramsHash}|${instructionsHash}`;
    }

    private hashConstantDef(node: AstConstantDef): string {
        const attributesHash = this.hashAttributes(node.attributes);
        const typeHash = this.hash(node.type);
        const initializerHash = this.hash(node.initializer);
        return `constant|${attributesHash}|${typeHash}|${initializerHash}`;
    }

    private hashTrait(node: AstTrait): string {
        const traitsHash = this.hashIds(node.traits);
        const attributesHash = this.hashContractAttributes(node.attributes);
        const declarationsHash = this.hashDeclarations(node.declarations);
        return `trait|${traitsHash}|${attributesHash}|${declarationsHash}`;
    }

    private hashContract(node: AstContract): string {
        const traitsHash = this.hashIds(node.traits);
        const attributesHash = this.hashContractAttributes(node.attributes);
        const declarationsHash = this.hashDeclarations(node.declarations);
        return `contract|${traitsHash}|${attributesHash}|${declarationsHash}`;
    }

    private hashFields(fields: AstFieldDecl[]): string {
        let hashedFields = fields.map((field) => this.hashFieldDecl(field));
        if (this.sort) {
            hashedFields = hashedFields.sort();
        }
        return hashedFields.join("|");
    }

    private hashParams(params: AstTypedParameter[]): string {
        let hashedParams = params.map((param) =>
            this.hashTypedParameter(param),
        );
        if (this.sort) {
            hashedParams = hashedParams.sort();
        }
        return hashedParams.join("|");
    }

    private hashTypedParameter(param: AstTypedParameter): string {
        const typeHash = this.hash(param.type);
        return `param|${typeHash}`;
    }

    private hashAttributes(
        attributes: (AstFunctionAttribute | AstConstantAttribute)[],
    ): string {
        return attributes
            .map((attr) => attr.type)
            .sort()
            .join("|");
    }

    private hashContractAttributes(attributes: AstContractAttribute[]): string {
        return attributes
            .map((attr) => `${attr.type}|${attr.name.value}`)
            .sort()
            .join("|");
    }

    private hashIds(ids: AstId[]): string {
        return ids
            .map((id) => id.kind)
            .sort()
            .join("|"); // Ignore actual id.text, just hash based on kind
    }

    private hashDeclarations(declarations: AstNode[]): string {
        let hashedDeclarations = declarations.map((decl) => this.hash(decl));
        if (this.sort) {
            hashedDeclarations = hashedDeclarations.sort();
        }
        return hashedDeclarations.join("|");
    }

    private hashStatements(statements: AstStatement[]): string {
        let hashedStatements = statements.map((stmt) => this.hash(stmt));
        if (this.sort) {
            hashedStatements = hashedStatements.sort();
        }
        return hashedStatements.join("|");
    }

    private hashInstructions(instructions: AstAsmInstruction[]): string {
        return instructions.join("|");
    }

    private hashStructFieldInitializer(
        initializer: AstStructFieldInitializer,
    ): string {
        return `field_initializer|${this.hash(initializer.initializer)}`;
    }

    private hashFieldDecl(field: AstFieldDecl): string {
        const typeHash = this.hash(field.type);
        return `field|${typeHash}`;
    }

    private hashContractInit(node: AstContractInit): string {
        const paramsHash = this.hashParams(node.params);
        const statementsHash = this.hashStatements(node.statements);
        return `${node.kind}|${paramsHash}|${statementsHash}`;
    }

    private hashNativeFunctionDecl(node: AstNativeFunctionDecl): string {
        const attributesHash = this.hashAttributes(node.attributes);
        const paramsHash = this.hashParams(node.params);
        const returnHash = node.return ? this.hash(node.return) : "void";
        return `${node.kind}|${attributesHash}|${paramsHash}|${returnHash}`;
    }

    private hashReceiver(node: AstReceiver): string {
        const selectorHash = node.selector.kind;
        const statementsHash = this.hashStatements(node.statements);
        return `${node.kind}|${selectorHash}|${statementsHash}`;
    }

    private hashFunctionDecl(node: AstFunctionDecl): string {
        const attributesHash = this.hashAttributes(node.attributes);
        const returnHash = node.return ? this.hash(node.return) : "void";
        const paramsHash = this.hashParams(node.params);
        return `${node.kind}|${attributesHash}|${returnHash}|${paramsHash}`;
    }

    private hashImport(node: AstImport): string {
        return `${node.kind}|${this.hash(node.path)}`;
    }

    private hashConstantDecl(node: AstConstantDecl): string {
        const attributesHash = this.hashAttributes(node.attributes);
        const typeHash = this.hash(node.type);
        return `${node.kind}|${attributesHash}|${typeHash}`;
    }

    private hashModule(node: AstModule): string {
        const importsHash = this.hashImports(node.imports);
        const itemsHash = this.hashModuleItems(node.items);
        return `${node.kind}|${importsHash}|${itemsHash}`;
    }

    private hashImports(imports: AstImport[]): string {
        let hashedImports = imports.map((imp) => this.hash(imp));
        if (this.sort) {
            hashedImports = hashedImports.sort();
        }
        return hashedImports.join("|");
    }

    private hashModuleItems(items: AstModuleItem[]): string {
        let hashedItems = items.map((item) => this.hash(item));
        if (this.sort) {
            hashedItems = hashedItems.sort();
        }
        return hashedItems.join("|");
    }
}


## index.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/index.ts)
export { getParser, Parser } from "./grammar";

export { dummySrcInfo, ItemOrigin, SrcInfo } from "./src-info";


## iterators.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/iterators.ts)
import { AstNode } from "./ast";

/**
 * Recursively iterates over each node in an AstNode and applies a callback to each AST element.
 * @public
 * @param node The node to traverse.
 * @param callback The callback function to apply to each AST element.
 */
export function traverse(node: AstNode, callback: (node: AstNode) => void) {
    callback(node);

    switch (node.kind) {
        case "module":
            node.imports.forEach((e) => {
                traverse(e, callback);
            });
            node.items.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "import":
            traverse(node.path, callback);
            break;
        case "primitive_type_decl":
            traverse(node.name, callback);
            break;
        case "function_def":
            node.attributes.forEach((attr) => {
                traverse(attr, callback);
            });
            traverse(node.name, callback);
            if (node.return) traverse(node.return, callback);
            node.params.forEach((e) => {
                traverse(e, callback);
            });
            node.statements.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "asm_function_def":
            node.shuffle.args.forEach((e) => {
                traverse(e, callback);
            });
            node.shuffle.ret.forEach((e) => {
                traverse(e, callback);
            });
            traverse(node.name, callback);
            if (node.return) traverse(node.return, callback);
            node.params.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "function_decl":
            node.attributes.forEach((attr) => {
                traverse(attr, callback);
            });
            traverse(node.name, callback);
            if (node.return) traverse(node.return, callback);
            node.params.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "native_function_decl":
            traverse(node.name, callback);
            traverse(node.nativeName, callback);
            node.params.forEach((e) => {
                traverse(e, callback);
            });
            if (node.return) traverse(node.return, callback);
            break;
        case "function_attribute":
            switch (node.type) {
                case "get":
                    {
                        if (node.methodId) traverse(node.methodId, callback);
                    }
                    break;
                case "mutates":
                case "extends":
                case "virtual":
                case "abstract":
                case "override":
                case "inline":
                    break;
            }
            break;
        case "constant_def":
            traverse(node.name, callback);
            traverse(node.type, callback);
            traverse(node.initializer, callback);
            break;
        case "constant_decl":
            traverse(node.name, callback);
            traverse(node.type, callback);
            break;
        case "struct_decl":
        case "message_decl":
            traverse(node.name, callback);
            if (node.kind === "message_decl" && node.opcode !== null) {
                traverse(node.opcode, callback);
            }
            node.fields.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "contract":
        case "trait":
            traverse(node.name, callback);
            node.traits.forEach((e) => {
                traverse(e, callback);
            });
            node.declarations.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "field_decl":
            traverse(node.name, callback);
            traverse(node.type, callback);
            if (node.initializer) traverse(node.initializer, callback);
            if (node.as) traverse(node.as, callback);
            break;
        case "receiver":
            node.statements.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "contract_init":
            node.params.forEach((e) => {
                traverse(e, callback);
            });
            node.statements.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "statement_let":
            traverse(node.name, callback);
            if (node.type) traverse(node.type, callback);
            traverse(node.expression, callback);
            break;
        case "statement_destruct":
            node.identifiers.forEach(([field, name], _) => {
                traverse(field, callback);
                traverse(name, callback);
            });
            traverse(node.expression, callback);
            break;
        case "destruct_end":
            break;
        case "statement_return":
            if (node.expression) traverse(node.expression, callback);
            break;
        case "statement_expression":
            traverse(node.expression, callback);
            break;
        case "statement_assign":
            traverse(node.path, callback);
            traverse(node.expression, callback);
            break;
        case "statement_augmentedassign":
            traverse(node.path, callback);
            traverse(node.expression, callback);
            break;
        case "statement_condition":
            traverse(node.condition, callback);
            node.trueStatements.forEach((e) => {
                traverse(e, callback);
            });
            if (node.falseStatements) {
                node.falseStatements.forEach((e) => {
                    traverse(e, callback);
                });
            }
            if (node.elseif) traverse(node.elseif, callback);
            break;
        case "statement_while":
        case "statement_until":
            traverse(node.condition, callback);
            node.statements.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "statement_repeat":
            traverse(node.iterations, callback);
            node.statements.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "statement_try":
            node.statements.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "statement_try_catch":
            node.statements.forEach((e) => {
                traverse(e, callback);
            });
            traverse(node.catchName, callback);
            node.catchStatements.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "statement_foreach":
            traverse(node.keyName, callback);
            traverse(node.valueName, callback);
            traverse(node.map, callback);
            node.statements.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "destruct_mapping":
            traverse(node.field, callback);
            traverse(node.name, callback);
            break;
        case "type_id":
            break;
        case "optional_type":
            traverse(node.typeArg, callback);
            break;
        case "map_type":
            traverse(node.keyType, callback);
            if (node.keyStorageType) traverse(node.keyStorageType, callback);
            traverse(node.valueType, callback);
            if (node.valueStorageType)
                traverse(node.valueStorageType, callback);
            break;
        case "bounced_message_type":
            traverse(node.messageType, callback);
            break;
        case "op_binary":
            traverse(node.left, callback);
            traverse(node.right, callback);
            break;
        case "op_unary":
            traverse(node.operand, callback);
            break;
        case "field_access":
            traverse(node.aggregate, callback);
            traverse(node.field, callback);
            break;
        case "method_call":
            traverse(node.self, callback);
            traverse(node.method, callback);
            node.args.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "static_call":
            traverse(node.function, callback);
            node.args.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "struct_instance":
            traverse(node.type, callback);
            node.args.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "struct_field_initializer":
            traverse(node.field, callback);
            traverse(node.initializer, callback);
            break;
        case "init_of":
            traverse(node.contract, callback);
            node.args.forEach((e) => {
                traverse(e, callback);
            });
            break;
        case "conditional":
            traverse(node.condition, callback);
            traverse(node.thenBranch, callback);
            traverse(node.elseBranch, callback);
            break;
        case "id":
        case "func_id":
        case "number":
        case "boolean":
        case "string":
        case "null":
            break;
        case "typed_parameter":
            traverse(node.name, callback);
            traverse(node.type, callback);
            break;
    }
}


## parser-error.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/parser-error.ts)
import { MatchResult } from "ohm-js";
import { ErrorDisplay } from "../error/display";
import { TactCompilationError } from "../errors";
import { getSrcInfoFromOhm, ItemOrigin, SrcInfo } from "./src-info";

const attributeSchema =
    (name: string) =>
    <T, U>({ text, sub }: ErrorDisplay<T>, handle: (t: T) => U) => ({
        duplicate: (attr: string) => {
            return handle(
                sub`Duplicate ${text(name)} attribute "${text(attr)}"`,
            );
        },
        notAbstract: () => {
            return handle(
                sub`Abstract ${text(name)} doesn't have abstract modifier`,
            );
        },
        tooAbstract: () => {
            return handle(
                sub`Non-abstract ${text(name)} has abstract modifier`,
            );
        },
    });

const syntaxErrorSchema = <T, U>(
    display: ErrorDisplay<T>,
    handle: (t: T) => U,
) => {
    const { sub, text } = display;

    return {
        constant: attributeSchema("constant")(display, handle),
        function: attributeSchema("function")(display, handle),
        topLevelConstantWithAttribute: () => {
            return handle(
                sub`Module-level constants do not support attributes`,
            );
        },
        literalTooLong: () => {
            return handle(sub`Bitstring has more than 128 digits`);
        },
        extraneousComma: () => {
            return handle(
                sub`Empty parameter list should not have a dangling comma`,
            );
        },
        duplicateField: (name: string) => {
            return handle(text(`Duplicate field destructuring: "${name}"`));
        },
        importWithBackslash: () => {
            return handle(sub`Import path can't contain "\\"`);
        },
        reservedVarPrefix: (prefix: string) => {
            return handle(text(`Variable name cannot start with "${prefix}"`));
        },
    };
};

export const parserErrorSchema = (display: ErrorDisplay<string>) => ({
    ...syntaxErrorSchema(display, (message) => (source: SrcInfo) => {
        throw new TactCompilationError(display.at(source, message), source);
    }),
    generic: (matchResult: MatchResult, path: string, origin: ItemOrigin) => {
        const interval = matchResult.getInterval();
        const source = getSrcInfoFromOhm(interval, path, origin);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const message = `Expected ${(matchResult as any).getExpectedText()}\n`;
        throw new TactCompilationError(display.at(source, message), source);
    },
});

export type ParserErrors = ReturnType<typeof parserErrorSchema>;


## rename.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/rename.ts)
import {
    AstConstantDef,
    AstModuleItem,
    AstStatement,
    AstModule,
    AstTraitDeclaration,
    AstContractDeclaration,
    AstExpression,
    AstStructFieldInitializer,
    AstCondition,
    AstFunctionDef,
    AstContract,
    AstTrait,
    AstId,
    AstFunctionDecl,
    AstConstantDecl,
    AstNode,
    AstFunctionAttribute,
} from "./ast";
import { AstSorter } from "./sort";
import { AstHasher, AstHash } from "./hash";
import { dummySrcInfo } from "./src-info";

type GivenName = string;

function id(text: string): AstId {
    return { kind: "id", text, id: 0, loc: dummySrcInfo };
}

/**
 * An utility class that provides alpha-renaming and topological sort functionality
 * for the AST comparison.
 */
export class AstRenamer {
    private constructor(
        private sort: boolean,
        private currentIdx: number = 0,
        private renamed: Map<AstHash, GivenName> = new Map(),
        private givenNames: Map<string, GivenName> = new Map(),
    ) {}
    public static make(params: Partial<{ sort: boolean }> = {}): AstRenamer {
        const { sort = true } = params;
        return new AstRenamer(sort);
    }

    /**
     * Renames the given node based on its AST.
     */
    public renameModule(module: AstModule): AstNode {
        return {
            ...module,
            items: this.renameModuleItems(module.items),
        };
    }

    private nextIdx(): number {
        const value = this.currentIdx;
        this.currentIdx += 1;
        return value;
    }

    /**
     * Generates a new unique node name.
     */
    private generateName(node: AstNode): GivenName {
        return `${node.kind}_${this.nextIdx()}`;
    }

    /**
     * Tries to get an identifier based on the node definition.
     */
    private getName(node: AstNode): string | undefined {
        switch (node.kind) {
            case "id":
            case "func_id":
                return node.text;
            case "primitive_type_decl":
            case "native_function_decl":
            case "struct_decl":
            case "message_decl":
            case "constant_def":
            case "constant_decl":
            case "function_def":
            case "function_decl":
            case "trait":
            case "contract":
                return node.name.text;
            default:
                return undefined;
        }
    }

    /**
     * Sets new or an existent name based on node's hash.
     */
    private setName(node: AstNode, forceName?: string): GivenName {
        const hash = AstHasher.make({ sort: this.sort }).hash(node);
        const giveNewName = (newName: string) => {
            const name = this.getName(node);
            if (name !== undefined) {
                this.givenNames.set(name, newName);
            }
        };
        const existentName = this.renamed.get(hash);
        if (existentName !== undefined) {
            giveNewName(existentName);
            return existentName;
        }
        const name = forceName ?? this.generateName(node);
        this.renamed.set(hash, name);
        giveNewName(name);
        return name;
    }

    public renameModuleItems(items: AstModuleItem[]): AstModuleItem[] {
        // Give new names to module-level elements.
        let renamedItems = items.map((item) => this.changeItemName(item));

        if (this.sort) {
            renamedItems.map((item) => this.sortAttributes(item));
        }

        // Apply renaming to the contents of these elements.
        renamedItems = renamedItems.map((item) =>
            this.renameModuleItemContents(item),
        );

        return this.sort ? this.sortModuleItems(renamedItems) : renamedItems;
    }

    /**
     * Lexicographically sort items based on their kinds and then by their names.
     */
    private sortModuleItems(items: AstModuleItem[]): AstModuleItem[] {
        const kindOrder = {
            primitive_type_decl: 1,
            native_function_decl: 2,
            struct_decl: 3,
            message_decl: 4,
            constant_def: 5,
            function_def: 6,
            asm_function_def: 7,
            trait: 8,
            contract: 9,
        };
        return items.sort((a, b) => {
            const kindComparison = kindOrder[a.kind] - kindOrder[b.kind];
            if (kindComparison !== 0) {
                return kindComparison;
            }
            return a.name.text.localeCompare(b.name.text);
        });
    }

    /**
     * Changes the name of a top-level/contract/trait element without inspecting its body.
     */
    private changeItemName<
        T extends AstModuleItem | AstConstantDecl | AstFunctionDecl,
    >(item: T): T {
        switch (item.kind) {
            case "primitive_type_decl":
                return item; // Skip renaming
            case "native_function_decl": {
                const newName = this.setName(
                    item,
                    `native_${item.nativeName.text}`,
                );
                return { ...item, name: id(newName) };
            }
            case "contract": {
                const newName = this.setName(item);
                const declarations = item.declarations.map((decl) => {
                    if (
                        decl.kind === "function_def" ||
                        decl.kind === "constant_def"
                    ) {
                        return this.changeItemName(
                            decl,
                        ) as AstContractDeclaration;
                    } else {
                        return decl;
                    }
                });
                return { ...item, name: id(newName), declarations };
            }
            case "trait": {
                const newName = this.setName(item);
                const declarations = item.declarations.map((decl) => {
                    if (
                        decl.kind === "function_def" ||
                        decl.kind === "constant_def" ||
                        decl.kind === "function_decl" ||
                        decl.kind === "constant_decl"
                    ) {
                        return this.changeItemName(decl) as AstTraitDeclaration;
                    } else {
                        return decl;
                    }
                });
                return { ...item, name: id(newName), declarations };
            }
            default: {
                const newName = this.setName(item);
                return { ...item, name: id(newName) };
            }
        }
    }

    /**
     * Renames the contents of an AstModuleItem based on its kind.
     */
    private renameModuleItemContents(item: AstModuleItem): AstModuleItem {
        switch (item.kind) {
            case "struct_decl":
                return item;
            case "message_decl":
                if (item.opcode !== null) {
                    return {
                        ...item,
                        opcode: this.renameExpression(item.opcode),
                    };
                }
                return item;
            case "function_def":
                return this.renameFunctionContents(item as AstFunctionDef);
            case "constant_def":
                return this.renameConstantContents(item as AstConstantDef);
            case "trait":
                return this.renameTraitContents(item as AstTrait);
            case "contract":
                return this.renameContractContents(item as AstContract);
            default:
                return item; // No further renaming needed for other kinds
        }
    }

    /**
     * Sorts attributes within an item if available.
     */
    private sortAttributes<
        T extends AstModuleItem | AstContractDeclaration | AstTraitDeclaration,
    >(item: T): T {
        switch (item.kind) {
            case "trait":
            case "contract":
                return {
                    ...item,
                    attributes: AstSorter.sortAttributes(item.attributes),
                    declarations: item.declarations.map((decl) =>
                        this.sortAttributes(decl),
                    ),
                };
            case "constant_decl":
            case "constant_def":
                return {
                    ...item,
                    attributes: AstSorter.sortAttributes(item.attributes),
                };
            case "function_decl":
            case "function_def":
                return {
                    ...item,
                    attributes: AstSorter.sortAttributes(item.attributes),
                };
            default:
                return item;
        }
    }

    /**
     * Renames the contents of a function.
     */
    private renameFunctionContents(
        functionDef: AstFunctionDef,
    ): AstFunctionDef {
        const attributes = this.renameFunctionAttributes(
            functionDef.attributes,
        );
        const statements = this.renameStatements(functionDef.statements);
        return { ...functionDef, attributes, statements };
    }

    /**
     * Renames getter's methodId expression.
     */
    private renameFunctionAttributes(
        functionAttrs: AstFunctionAttribute[],
    ): AstFunctionAttribute[] {
        return functionAttrs.map((attr) => {
            if (attr.type === "get" && attr.methodId !== null) {
                return {
                    ...attr,
                    methodId: this.renameExpression(attr.methodId),
                };
            } else {
                return attr;
            }
        });
    }

    /**
     * Renames the contents of a constant, focusing on the initializer.
     */
    private renameConstantContents(
        constantDef: AstConstantDef,
    ): AstConstantDef {
        const initializer = this.renameExpression(constantDef.initializer);
        return { ...constantDef, initializer };
    }

    /**
     * Renames the contents of a trait, including its declarations.
     */
    private renameTraitContents(trait: AstTrait): AstTrait {
        const declarations = trait.declarations.map((decl) => {
            if (decl.kind === "function_def") {
                return this.renameFunctionContents(decl as AstFunctionDef);
            } else if (decl.kind === "constant_def") {
                return this.renameConstantContents(decl as AstConstantDef);
            } else {
                return decl;
            }
        });
        return { ...trait, declarations };
    }

    /**
     * Renames the contents of a contract, including its declarations and parameters.
     */
    private renameContractContents(contract: AstContract): AstContract {
        const declarations = contract.declarations.map((decl) => {
            if (decl.kind === "function_def") {
                return this.renameFunctionContents(decl as AstFunctionDef);
            } else if (decl.kind === "constant_def") {
                return this.renameConstantContents(decl as AstConstantDef);
            } else {
                return decl;
            }
        });
        return { ...contract, declarations };
    }

    private renameStatements(statements: AstStatement[]): AstStatement[] {
        return statements.map((stmt) => {
            return this.renameStatement(stmt);
        });
    }

    private renameStatement(stmt: AstStatement): AstStatement {
        switch (stmt.kind) {
            case "statement_let":
                return {
                    ...stmt,
                    expression: this.renameExpression(stmt.expression),
                };
            case "statement_return":
                return {
                    ...stmt,
                    expression: stmt.expression
                        ? this.renameExpression(stmt.expression)
                        : null,
                };
            case "statement_expression":
                return {
                    ...stmt,
                    expression: this.renameExpression(stmt.expression),
                };
            case "statement_assign":
                return {
                    ...stmt,
                    path: this.renameExpression(stmt.path),
                    expression: this.renameExpression(stmt.expression),
                };
            case "statement_augmentedassign":
                return {
                    ...stmt,
                    path: this.renameExpression(stmt.path),
                    expression: this.renameExpression(stmt.expression),
                };
            case "statement_condition":
                return {
                    ...stmt,
                    condition: this.renameExpression(stmt.condition),
                    trueStatements: this.renameStatements(stmt.trueStatements),
                    falseStatements: stmt.falseStatements
                        ? this.renameStatements(stmt.falseStatements)
                        : null,
                    elseif: stmt.elseif
                        ? (this.renameStatement(stmt.elseif) as AstCondition)
                        : null,
                };
            case "statement_while":
            case "statement_until":
                return {
                    ...stmt,
                    condition: this.renameExpression(stmt.condition),
                    statements: this.renameStatements(stmt.statements),
                };
            case "statement_repeat":
                return {
                    ...stmt,
                    iterations: this.renameExpression(stmt.iterations),
                    statements: this.renameStatements(stmt.statements),
                };
            case "statement_try":
                return {
                    ...stmt,
                    statements: this.renameStatements(stmt.statements),
                };
            case "statement_try_catch":
                return {
                    ...stmt,
                    statements: this.renameStatements(stmt.statements),
                    catchStatements: this.renameStatements(
                        stmt.catchStatements,
                    ),
                };
            case "statement_foreach":
                return {
                    ...stmt,
                    map: this.renameExpression(stmt.map),
                    statements: this.renameStatements(stmt.statements),
                };
            case "statement_destruct":
                return {
                    ...stmt,
                    expression: this.renameExpression(stmt.expression),
                };
            default:
                return stmt;
        }
    }

    private renameExpression(expr: AstExpression): AstExpression {
        switch (expr.kind) {
            case "id":
                return {
                    ...expr,
                    text: this.givenNames.get(expr.text) ?? expr.text,
                };
            case "op_binary":
                return {
                    ...expr,
                    left: this.renameExpression(expr.left),
                    right: this.renameExpression(expr.right),
                };
            case "op_unary":
                return {
                    ...expr,
                    operand: this.renameExpression(expr.operand),
                };
            case "field_access":
                return {
                    ...expr,
                    aggregate: this.renameExpression(expr.aggregate),
                };
            case "method_call":
            case "static_call":
                return {
                    ...expr,
                    args: expr.args.map((arg) => this.renameExpression(arg)),
                };
            case "struct_instance":
                return {
                    ...expr,
                    args: expr.args.map((arg) =>
                        this.renameStructFieldInitializer(arg),
                    ),
                };
            case "init_of":
                return {
                    ...expr,
                    args: expr.args.map((arg) => this.renameExpression(arg)),
                };
            case "conditional":
                return {
                    ...expr,
                    condition: this.renameExpression(expr.condition),
                    thenBranch: this.renameExpression(expr.thenBranch),
                    elseBranch: this.renameExpression(expr.elseBranch),
                };
            case "number":
            case "boolean":
            case "string":
            case "null":
                return expr;
            default:
                return expr;
        }
    }

    private renameStructFieldInitializer(
        initializer: AstStructFieldInitializer,
    ): AstStructFieldInitializer {
        return {
            ...initializer,
            initializer: this.renameExpression(initializer.initializer),
        };
    }
}


## sort.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/sort.ts)
import {
    AstPrimitiveTypeDecl,
    AstFunctionAttribute,
    AstConstantAttribute,
    AstContractAttribute,
    AstNode,
} from "./ast";
import { throwInternalCompilerError } from "../errors";

/**
 * Provides utilities to sort lists of AST nodes.
 */
// eslint-disable-next-line @typescript-eslint/no-extraneous-class
export class AstSorter {
    public static sort<T extends AstNode>(items: T[]): T[] {
        if (items.length === 0) {
            return items;
        }
        const kind = items[0]!.kind;
        switch (kind) {
            case "primitive_type_decl":
                return this.sortPrimitiveTypeDecls(
                    items as AstPrimitiveTypeDecl[],
                ) as T[];
            default:
                throwInternalCompilerError(`Unsupported node kind: ${kind}`);
        }
    }

    private static sortPrimitiveTypeDecls(
        decls: AstPrimitiveTypeDecl[],
    ): AstPrimitiveTypeDecl[] {
        return decls.sort((a, b) => {
            // Case-insensitive sorting
            const nameA = a.name.text.toLowerCase();
            const nameB = b.name.text.toLowerCase();
            if (nameA < nameB) {
                return -1;
            }
            if (nameA > nameB) {
                return 1;
            }
            return 0;
        });
    }

    public static sortAttributes<
        T extends
            | AstConstantAttribute
            | AstContractAttribute
            | AstFunctionAttribute,
    >(attributes: T[]): T[] {
        return attributes.sort((a, b) => a.type.localeCompare(b.type));
    }
}


## src-info.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/src-info.ts)
import { Interval as RawInterval } from "ohm-js";

import { throwInternalCompilerError } from "../errors";

export type ItemOrigin = "stdlib" | "user";

type LineAndColumnInfo = {
    lineNum: number;
    colNum: number;
    toString(...ranges: number[][]): string;
};

type Interval = {
    contents: string;
    getLineAndColumnMessage(): string;
    getLineAndColumn(): LineAndColumnInfo;
    startIdx: number;
    endIdx: number;
};

// Do not export! Use isSrcInfo
const srcInfoSymbol = Symbol("src-info");

export const isSrcInfo = (t: unknown): t is SrcInfo => {
    return (
        typeof t === "object" &&
        t !== null &&
        srcInfoSymbol in t &&
        Boolean(t[srcInfoSymbol])
    );
};

export interface SrcInfo {
    file: string | null;
    contents: string;
    interval: Interval;
    origin: ItemOrigin;

    /**
     * Tag so that custom snapshot serializer can distinguish it
     */
    [srcInfoSymbol]: true;
    /**
     * toJSON method is provided, so that it's not serialized into snapshots
     */
    toJSON: () => object;
}

export const srcInfoEqual = (left: SrcInfo, right: SrcInfo): boolean => {
    return (
        left.file === right.file &&
        left.interval.contents === right.interval.contents &&
        left.interval.startIdx === right.interval.startIdx &&
        left.interval.endIdx === right.interval.endIdx
    );
};

const isEndline = (s: string) => s === "\n";

const repeat = (s: string, n: number): string => new Array(n + 1).join(s);

type Range = {
    start: number;
    end: number;
};

const intersect = (a: Range, b: Range): Range => {
    return {
        start: Math.max(a.start, b.start),
        end: Math.min(a.end, b.end),
    };
};

const shift = (a: Range, b: number) => {
    return {
        start: a.start + b,
        end: a.end + b,
    };
};

type Line = {
    id: number;
    text: string;
    range: Range;
};

/**
 * Convert code into a list of lines
 */
const toLines = (source: string): Line[] => {
    const result: Line[] = [];
    let position = 0;
    for (const [id, text] of source.split("\n").entries()) {
        result.push({
            id,
            text,
            range: {
                start: position,
                end: position + text.length,
            },
        });
        position += text.length + 1;
    }
    return result;
};

/**
 * Should wrap string into ANSI codes for coloring
 */
type Colorer = (s: string) => string;

type ErrorPrinterParams = {
    /**
     * Number of context lines below and above error
     */
    contextLines: number;
    /**
     * Colorer for code with error
     */
    error: Colorer;
    /**
     * Colorer for context lines of code
     */
    context: Colorer;
};

const getErrorPrinter = ({
    error,
    context,
    contextLines,
}: ErrorPrinterParams) => {
    const displayLine = (line: Line, range: Range) => {
        // Only the line that contains range.start is underlined in error message
        // Otherwise error on `while (...) {}` would display the whole loop body, for example
        const hasInterval =
            line.range.start <= range.start && range.start < line.range.end;

        // Find the line-relative range
        const mapped = shift(intersect(range, line.range), -line.range.start);

        // All lines except with error message are displayed in gray
        if (!hasInterval) {
            return [
                {
                    id: line.id,
                    text: context(line.text),
                    hasInterval,
                    startOfError: mapped.start,
                },
            ];
        }

        // Source line with error colored
        const sourceLine = {
            id: line.id,
            text: [
                line.text.substring(0, mapped.start),
                error(line.text.substring(mapped.start, mapped.end)),
                line.text.substring(mapped.end),
            ].join(""),
            hasInterval: true,
            startOfError: mapped.start,
        };

        // Wiggly line underneath it
        const underline = {
            id: null,
            text: [
                repeat(" ", mapped.start),
                "^",
                repeat("~", Math.max(0, mapped.end - mapped.start - 1)),
            ].join(""),
            hasInterval: true,
            startOfError: mapped.start,
        };

        return [sourceLine, underline];
    };

    const show = (str: string, range: Range): string => {
        // Display all lines of source file
        const lines = toLines(str).flatMap((line) => displayLine(line, range));

        // Find first and lines lines with error message
        const firstLineNum = lines.findIndex((line) => line.hasInterval);
        const lastLineNum = lines.findLastIndex((line) => line.hasInterval);
        if (firstLineNum === -1 || lastLineNum === -1) {
            throwInternalCompilerError(
                `Interval [${range.start}, ${range.end}[ is empty or out of source bounds (${str.length})`,
            );
        }

        // Expand the line range so that `contextLines` are above and below
        const rangeStart = Math.max(0, firstLineNum - contextLines);
        const rangeEnd = Math.min(lines.length - 1, lastLineNum + contextLines);

        // Pick displayed lines out of full list
        const displayedLines = lines.slice(rangeStart, rangeEnd + 1);

        // Find padding based on the line with largest line number
        const maxLineId = displayedLines.reduce((acc, line) => {
            return line.id === null ? acc : Math.max(acc, line.id);
        }, 1);
        const lineNumLength = String(maxLineId + 1).length;

        // Add line numbers and cursor to lines
        const paddedLines = displayedLines.map(({ hasInterval, id, text }) => {
            const prefix = hasInterval && id !== null ? ">" : " ";
            const paddedLineNum =
                id === null
                    ? repeat(" ", lineNumLength) + "  "
                    : String(id + 1).padStart(lineNumLength) + " |";
            return `${prefix} ${paddedLineNum} ${text}`;
        });

        // Add header and concatenate lines
        const header = `Line ${firstLineNum + 1}, col ${(lines[firstLineNum]?.startOfError ?? 0) + 1}:`;
        return [header, ...paddedLines].join("\n") + "\n";
    };

    const getLineAndColumn = (str: string, range: Range) => {
        const prefix = str.substring(0, range.start).split("");
        const lineNum = prefix.filter(isEndline).length;
        const prevLineEndPos = prefix.findLastIndex(isEndline);
        const lineStartPos = prevLineEndPos === -1 ? 0 : prevLineEndPos + 1;
        const colNum = range.start - lineStartPos;

        return {
            offset: range.start,
            lineNum: lineNum + 1,
            colNum: colNum + 1,
            toString: () => show(str, range),
        };
    };

    return { show, getLineAndColumn };
};

// Default error printer. Should be initialized in entry point instead
const errorPrinter = getErrorPrinter({
    // This should be `chalk.red`
    error: (s) => s,
    // This should be `chalk.gray`
    context: (s) => s,
    contextLines: 1,
});

const getSrcInfo = (
    sourceString: string,
    startIdx: number,
    endIdx: number,
    file: string | null,
    origin: ItemOrigin,
): SrcInfo => {
    const getLineAndColumn = () => {
        return errorPrinter.getLineAndColumn(sourceString, {
            start: startIdx,
            end: endIdx,
        });
    };

    const getLineAndColumnMessage = () => {
        return getLineAndColumn().toString();
    };

    const contents = sourceString.substring(startIdx, endIdx);

    return {
        [srcInfoSymbol]: true,
        contents: contents,
        file,
        interval: {
            contents: contents,
            startIdx: startIdx,
            endIdx: endIdx,
            getLineAndColumn,
            getLineAndColumnMessage,
        },
        origin,
        toJSON: () => ({}),
    };
};

/**
 * @deprecated
 */
export const getSrcInfoFromOhm = (
    { sourceString, startIdx, endIdx }: RawInterval,
    file: string | null,
    origin: ItemOrigin,
): SrcInfo => {
    return getSrcInfo(sourceString, startIdx, endIdx, file, origin);
};

export const dummySrcInfo: SrcInfo = getSrcInfo("", 0, 0, null, "user");


## store.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/store.ts)
import {
    AstModule,
    AstConstantDef,
    AstFunctionDef,
    AstNativeFunctionDecl,
    AstTypeDecl,
    AstAsmFunctionDef,
} from "./ast";
import { throwInternalCompilerError } from "../errors";
import { CompilerContext, createContextStore } from "../context";
import { ItemOrigin } from "./src-info";
import { Parser } from "./grammar";

/**
 * @public
 */
export type TactSource = { code: string; path: string; origin: ItemOrigin };

/**
 * Represents the storage for all AST-related data within the compiler context.
 * @public
 * @property functions AST entries representing top-level functions.
 * @property constants AST entries representing top-level constant definitions.
 * @property types AST entries representing structures, contracts, and traits.
 */
export type AstStore = {
    sources: TactSource[];
    funcSources: { code: string; path: string }[];
    functions: (AstFunctionDef | AstNativeFunctionDecl | AstAsmFunctionDef)[];
    constants: AstConstantDef[];
    types: AstTypeDecl[];
};

const store = createContextStore<AstStore>();

/**
 * Retrieves the raw AST for the given context.
 * @public
 * @param ctx The compiler context from which the AST is retrieved.
 * @throws Will throw an error if the AST is not found in the context.
 * @returns The AST types associated with the context.
 */
export function getRawAST(ctx: CompilerContext): AstStore {
    const r = store.get(ctx, "types");
    if (!r) {
        throwInternalCompilerError("No AST found in context");
    }
    return r;
}

/**
 * Parses multiple Tact source files into AST modules.
 * @public
 */
export function parseModules(
    sources: TactSource[],
    parser: Parser,
): AstModule[] {
    return sources.map((source) =>
        parser.parse(source.code, source.path, source.origin),
    );
}

/**
 * Extends the compiler context by adding AST entries and source information from
 * given sources and parsed programs.
 * @public
 * @param parsedModules An optional array of previously parsed programs. If not defined, they will be parsed from `sources`.
 * @returns The updated compiler context.
 */
export function openContext(
    ctx: CompilerContext,
    sources: TactSource[],
    funcSources: { code: string; path: string }[],
    parser: Parser,
    parsedModules?: AstModule[],
): CompilerContext {
    const modules = parsedModules
        ? parsedModules
        : parseModules(sources, parser);
    const types: AstTypeDecl[] = [];
    const functions: (
        | AstNativeFunctionDecl
        | AstFunctionDef
        | AstAsmFunctionDef
    )[] = [];
    const constants: AstConstantDef[] = [];
    for (const module of modules) {
        for (const item of module.items) {
            switch (item.kind) {
                case "struct_decl":
                case "message_decl":
                case "contract":
                case "trait":
                case "primitive_type_decl":
                    {
                        types.push(item);
                    }
                    break;
                case "function_def":
                case "asm_function_def":
                case "native_function_decl":
                    {
                        functions.push(item);
                    }
                    break;
                case "constant_def":
                    {
                        constants.push(item);
                    }
                    break;
            }
        }
    }
    ctx = store.set(ctx, "types", {
        sources,
        funcSources,
        functions,
        constants,
        types,
    });
    return ctx;
}


## embed-asm-fif.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-asm/embed-asm-fif.tact)
/// Tests parsing of Asm.fif by embedding its contents
asm fun embedAsmFif() {
    library TVM_Asm
    // simple TVM Assembler
    namespace Asm
    Asm definitions
    "0.4.5" constant asm-fif-version

    variable @atend
    variable @was-split
    false @was-split !
    { "not in asm context" abort } @atend !
    { `normal eq? not abort"must be terminated by }>" } : @normal?
    { context@ @atend @ 2 { @atend ! context! @normal? } does @atend ! } : @pushatend
    { @pushatend Asm <b } : <{
    { @atend @ execute } : @endblk
    { false @was-split ! `normal @endblk } : }>
    { }> b> } : }>c
    { }>c <s } : }>s
    { @atend @ 2 { true @was-split ! @atend ! rot b> ref, swap @endblk } does @atend ! <b } : @|
    { @atend @ 3 { @atend ! 2swap rot execute } does @atend ! <b } : @doafter<{
    { over brembits <= } : @havebits
    { rot + -rot + swap } : pair+
    { rot >= -rot <= and } : 2x<=
    { 2 pick brembitrefs 1- 2x<= } : @havebitrefs
    { @havebits ' @| ifnot } : @ensurebits
    { @havebitrefs ' @| ifnot } : @ensurebitrefs
    { rot over @ensurebits -rot u, } : @simpleuop
    { tuck sbitrefs @ensurebitrefs swap s, } : @addop
    { tuck bbitrefs @ensurebitrefs swap b+ } : @addopb
    ' @addopb : @inline
    { 1 ' @addop does create } : @Defop
    { 1 { <b swap s, swap 8 u, @addopb } does create } : @Defop(8u)
    { 1 { <b swap s, swap 8 i, @addopb } does create } : @Defop(8i)
    { 1 { <b swap s, swap 1- 8 u, @addopb } does create } : @Defop(8u+1)
    { 1 { <b swap s, swap 4 u, @addopb } does create } : @Defop(4u)
    { 1 { <b swap s, swap 12 u, @addopb } does create } : @Defop(12u)
    { 1 { <b swap s, rot 4 u, swap 4 u, @addopb } does create } : @Defop(4u,4u)
    { 1 { <b swap s, swap ref, @addopb } does create } : @Defop(ref)
    { 1 { <b swap s, rot ref, swap ref, @addopb } does create } : @Defop(ref*2)
    { <b 0xef 8 u, swap 12 i, b> } : si()
    // x mi ma -- ?
    { rot tuck >= -rot <= and } : @range
    { rot tuck < -rot > or } : @-range
    { @-range abort"Out of range" } : @rangechk
    { dup 0 < over 255 > or abort"Invalid stack register number" si() } : s()
    { si() constant } : @Sreg
    -2 @Sreg s(-2)
    -1 @Sreg s(-1)
    0 @Sreg s0
    1 @Sreg s1
    2 @Sreg s2
    3 @Sreg s3
    4 @Sreg s4
    5 @Sreg s5
    6 @Sreg s6
    7 @Sreg s7
    8 @Sreg s8
    9 @Sreg s9
    10 @Sreg s10
    11 @Sreg s11
    12 @Sreg s12
    13 @Sreg s13
    14 @Sreg s14
    15 @Sreg s15
    { dup 0 < over 7 > or abort"Invalid control register number" <b 0xcc 8 u, swap 4 u, b> } : c()
    { c() constant } : @Creg
    0 @Creg c0
    1 @Creg c1
    2 @Creg c2
    3 @Creg c3
    4 @Creg c4
    5 @Creg c5
    7 @Creg c7
    { <s 8 u@+ swap 0xef <> abort"not a stack register" 12 i@+ s> } : @bigsridx
    { @bigsridx dup 16 >= over 0< or abort"stack register s0..s15 expected" } : @sridx
    { rot @bigsridx tuck < -rot tuck > rot or abort"stack register out of range" } : @sridxrange
    { swap @bigsridx + dup 16 >= over 0< or abort"stack register out of range" } : @sridx+
    { <s 8 u@+ 4 u@+ s> swap 0xcc <> over 7 > or over 6 = or abort"not a control register c0..c5 or c7" } : @cridx
    { <s 8 u@ 0xcc = } : @iscr?
    { <b swap s, 1 { swap @sridx 4 u, @addopb } does create } : @Defop(s)
    { <b swap s, 1 { rot @sridx 4 u, swap @sridx 4 u, @addopb } does create } : @Defop(s,s)
    { <b swap s, 1 { swap @cridx 4 u, @addopb } does create } : @Defop(c)
    //
    // stack manipulation primitives
    // (simple stack primitives)
    //
    x{00} @Defop NOP
    x{01} @Defop SWAP
    x{0} @Defop(s) XCHG0
    { @bigsridx swap @bigsridx 2dup =
      { 2drop <b }
      { 2dup < { swap } if dup 0=
        { drop dup 16 <
          { <b x{0} s, swap 4 u, }
          { <b x{11} s, swap 8 u, }
          cond
        }
        { over 16 >=
          { tuck 16 >=
            { <b x{11} s, 2 pick 8 u, x{11} s, swap 8 u, x{11} s, swap 8 u, }
    	{ <b x{0} s, 2 pick 4 u, x{11} s, swap 8 u, x{0} s, swap 4 u, } cond
          }
          { dup 1 =
            { drop <b x{1} s, swap 4 u, }
            { <b x{10} s, swap 4 u, swap 4 u, }
            cond
          } cond
        } cond
      } cond
      @addopb } : XCHG
    x{ED4} @Defop(c) PUSHCTR
    x{ED5} @Defop(c) POPCTR
    { dup @iscr?
      ' PUSHCTR
      { @bigsridx dup 16 <
        { <b x{2} s, swap 4 u, }
        { <b x{56} s, swap 8 u,
        } cond
      @addopb
      } cond
    } : PUSH
    x{20} @Defop DUP
    x{21} @Defop OVER
    { dup @iscr?
      ' POPCTR
      { @bigsridx dup 16 <
        { <b x{3} s, swap 4 u, }
        { <b x{57} s, swap 8 u,
        } cond
      @addopb
      } cond
    } : POP
    x{30} @Defop DROP
    x{31} @Defop NIP

    // compound stack primitives
    { @sridx rot @sridx rot @sridx swap <b x{4} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : XCHG3
    x{50} @Defop(s,s) XCHG2
    x{51} @Defop(s,s) XCPU
    { <b x{52} s, rot @sridx 4 u, swap 1 @sridx+ 4 u, @addopb } : PUXC
    x{53} @Defop(s,s) PUSH2
    { @sridx rot @sridx rot @sridx swap <b x{540} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : XCHG3_l
    { @sridx rot @sridx rot @sridx swap <b x{541} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : XC2PU
    { 1 @sridx+ rot @sridx rot @sridx swap <b x{542} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : XCPUXC
    { @sridx rot @sridx rot @sridx swap <b x{543} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : XCPU2
    { 1 @sridx+ rot @sridx rot 1 @sridx+ swap <b x{544} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : PUXC2
    { 1 @sridx+ rot @sridx rot 1 @sridx+ swap <b x{545} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : PUXCPU
    { 2 @sridx+ rot @sridx rot 1 @sridx+ swap <b x{546} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : PU2XC
    { @sridx rot @sridx rot @sridx swap <b x{547} s, swap 4 u, swap 4 u, swap 4 u, @addopb } : PUSH3
    { <b x{55} s, rot 1- 4 u, swap 1- 4 u, @addopb } : BLKSWAP
    { dup { 1 swap BLKSWAP } { drop } cond } : ROLL
    { dup { 1 BLKSWAP } { drop } cond } dup : -ROLL : ROLLREV
    x{5513} dup @Defop 2ROT @Defop ROT2

    // exotic stack primitives
    x{58} @Defop ROT
    x{59} dup @Defop -ROT @Defop ROTREV
    x{5A} dup @Defop 2SWAP @Defop SWAP2
    x{5B} dup @Defop 2DROP @Defop DROP2
    x{5C} dup @Defop 2DUP @Defop DUP2
    x{5D} dup @Defop 2OVER @Defop OVER2
    { <b x{5E} s, rot 2 - 4 u, swap 4 u, @addopb } : REVERSE
    { <b x{5F0} s, swap 4 u, @addopb } : BLKDROP
    { over 0= abort"first argument must be non-zero"
      <b x{5F} s, rot 4 u, swap 4 u, @addopb } : BLKPUSH
    x{60} dup @Defop PICK @Defop PUSHX
    x{61} @Defop ROLLX
    x{62} dup @Defop -ROLLX @Defop ROLLREVX
    x{63} @Defop BLKSWX
    x{64} @Defop REVX
    x{65} @Defop DROPX
    x{66} @Defop TUCK
    x{67} @Defop XCHGX
    x{68} @Defop DEPTH
    x{69} @Defop CHKDEPTH
    x{6A} @Defop ONLYTOPX
    x{6B} @Defop ONLYX
    { over 0= abort"first argument must be non-zero"
      <b x{6C} s, rot 4 u, swap 4 u, @addopb } : BLKDROP2

    // null primitives
    x{6D} dup @Defop NULL @Defop PUSHNULL
    x{6E} @Defop ISNULL
    // tuple primitives
    x{6F0} @Defop(4u) TUPLE
    x{6F00} @Defop NIL
    x{6F01} @Defop SINGLE
    x{6F02} dup @Defop PAIR @Defop CONS
    x{6F03} @Defop TRIPLE
    x{6F1} @Defop(4u) INDEX
    x{6F10} dup @Defop FIRST @Defop CAR
    x{6F11} dup @Defop SECOND @Defop CDR
    x{6F12} @Defop THIRD
    x{6F2} @Defop(4u) UNTUPLE
    x{6F21} @Defop UNSINGLE
    x{6F22} dup @Defop UNPAIR @Defop UNCONS
    x{6F23} @Defop UNTRIPLE
    x{6F3} @Defop(4u) UNPACKFIRST
    x{6F30} @Defop CHKTUPLE
    x{6F4} @Defop(4u) EXPLODE
    x{6F5} @Defop(4u) SETINDEX
    x{6F50} @Defop SETFIRST
    x{6F51} @Defop SETSECOND
    x{6F52} @Defop SETTHIRD
    x{6F6} @Defop(4u) INDEXQ
    x{6F60} dup @Defop FIRSTQ @Defop CARQ
    x{6F61} dup @Defop SECONDQ @Defop CDRQ
    x{6F62} @Defop THIRDQ
    x{6F7} @Defop(4u) SETINDEXQ
    x{6F70} @Defop SETFIRSTQ
    x{6F71} @Defop SETSECONDQ
    x{6F72} @Defop SETTHIRDQ
    x{6F80} @Defop TUPLEVAR
    x{6F81} @Defop INDEXVAR
    x{6F82} @Defop UNTUPLEVAR
    x{6F83} @Defop UNPACKFIRSTVAR
    x{6F84} @Defop EXPLODEVAR
    x{6F85} @Defop SETINDEXVAR
    x{6F86} @Defop INDEXVARQ
    x{6F87} @Defop SETINDEXVARQ
    x{6F88} @Defop TLEN
    x{6F89} @Defop QTLEN
    x{6F8A} @Defop ISTUPLE
    x{6F8B} @Defop LAST
    x{6F8C} dup @Defop TPUSH @Defop COMMA
    x{6F8D} @Defop TPOP
    x{6FA0} @Defop NULLSWAPIF
    x{6FA1} @Defop NULLSWAPIFNOT
    x{6FA2} @Defop NULLROTRIF
    x{6FA3} @Defop NULLROTRIFNOT
    x{6FA4} @Defop NULLSWAPIF2
    x{6FA5} @Defop NULLSWAPIFNOT2
    x{6FA6} @Defop NULLROTRIF2
    x{6FA7} @Defop NULLROTRIFNOT2
    { <b x{6FB} s, rot 2 u, swap 2 u, @addopb } : INDEX2
    x{6FB4} @Defop CADR
    x{6FB5} @Defop CDDR
    { <b x{6FE_} s, 3 roll 2 u, rot 2 u, swap 2 u, @addopb } : INDEX3
    x{6FD4} @Defop CADDR
    x{6FD5} @Defop CDDDR

    // integer constants
    x{70} dup @Defop ZERO @Defop FALSE
    x{71} @Defop ONE
    x{72} @Defop TWO
    x{7A} @Defop TEN
    x{7F} @Defop TRUE
    { dup 10 <= over -5 >= and
      { 15 and <b x{7} s, swap 4 u, }
      { dup 8 fits
        { <b x{80} s, swap 8 i, }
        { dup 16 fits
          { <b x{81} s, swap 16 i, }
          { 11 { dup 259 > abort"integer too large" 8 + 2dup fits } until
            <b x{82} s, over 3 >> 2- 5 u, -rot i,
          } cond
        } cond
      } cond
      @addopb } dup : PUSHINT : INT
    { dup 256 = abort"use PUSHNAN instead of 256 PUSHPOW2" <b x{83} s, swap 1- 8 u, @addopb } : PUSHPOW2
    x{83FF} @Defop PUSHNAN
    { <b x{84} s, swap 1- 8 u, @addopb } : PUSHPOW2DEC
    { <b x{85} s, swap 1- 8 u, @addopb } : PUSHNEGPOW2
    //
    // other constants
    x{88} @Defop(ref) PUSHREF
    x{89} @Defop(ref) PUSHREFSLICE
    x{8A} @Defop(ref) PUSHREFCONT
    { 1- dup 0< over 8 >= or abort"invalid slice padding"
      swap 1 1 u, 0 rot u, } : @scomplete
    { tuck sbitrefs swap 26 + swap @havebitrefs not
      { <b rot s, b> PUSHREFSLICE }
      { over sbitrefs 2dup 123 0 2x<=
        { drop tuck 4 + 3 >> swap x{8B} s, over 4 u, 3 roll s,
          -rot 3 << 4 + swap - @scomplete }
        { 2dup 1 >= swap 248 <= and
          { rot x{8C} s, swap 1- 2 u, over 7 + 3 >> tuck 5 u, 3 roll s,
            -rot 3 << 1 + swap - @scomplete }
          { rot x{8D} s, swap 3 u, over 2 + 3 >> tuck 7 u, 3 roll s,
            -rot 3 << 6 + swap - @scomplete
          } cond
        } cond
      } cond
    } dup : PUSHSLICE : SLICE
    // ( b' -- ? )
    { bbitrefs or 0= } : @cont-empty?
    { bbits 7 and 0= } : @cont-aligned?
    // ( b b' -- ? )
    { bbitrefs over 7 and { 2drop drop false } {
      swap 16 + swap @havebitrefs nip
      } cond
    } : @cont-fits?
    // ( b b' -- ? )
    { bbitrefs over 7 and { 2drop drop false } {
      32 1 pair+ @havebitrefs nip
      } cond
    } : @cont-ref-fit?
    // ( b b' b'' -- ? )
    { over @cont-aligned? over @cont-aligned? and not { 2drop drop false } {
      bbitrefs rot bbitrefs pair+ swap 32 + swap @havebitrefs nip
      } cond
    } : @two-cont-fit?
    { 2dup @cont-fits? not
      { b> PUSHREFCONT }
      { swap over bbitrefs 2dup 120 0 2x<=
        { drop swap x{9} s, swap 3 >> 4 u, swap b+ }
        { rot x{8F_} s, swap 2 u, swap 3 >> 7 u, swap b+ } cond
      } cond
    } dup : PUSHCONT : CONT
    { }> PUSHCONT } : }>CONT
    { { @normal? PUSHCONT } @doafter<{ } : CONT:<{

    // arithmetic operations
    { 2 { rot dup 8 fits
          { nip <b rot s, swap 8 i, }
          { rot drop <b swap PUSHINT swap s, }
          cond @addopb
        } does create
    } : @Defop(8i,alt)
    x{A0} @Defop ADD
    x{A1} @Defop SUB
    x{A2} @Defop SUBR
    x{A3} @Defop NEGATE
    x{A4} @Defop INC
    x{A5} @Defop DEC
    x{A6} x{A0} @Defop(8i,alt) ADDCONST
    { negate ADDCONST } : SUBCONST
    x{A7} x{A8} @Defop(8i,alt) MULCONST
    ' ADDCONST : ADDINT
    ' SUBCONST : SUBINT
    ' MULCONST : MULINT
    x{A8} @Defop MUL

    x{A904} @Defop DIV
    x{A905} @Defop DIVR
    x{A906} @Defop DIVC
    x{A908} @Defop MOD
    x{A909} @Defop MODR
    x{A90A} @Defop MODC
    x{A90C} @Defop DIVMOD
    x{A90D} @Defop DIVMODR
    x{A90E} @Defop DIVMODC
    x{A900} @Defop ADDDIVMOD
    x{A901} @Defop ADDDIVMODR
    x{A902} @Defop ADDDIVMODC

    x{A925} @Defop RSHIFTR
    x{A926} @Defop RSHIFTC
    x{A928} @Defop MODPOW2
    x{A929} @Defop MODPOW2R
    x{A92A} @Defop MODPOW2C
    x{A92C} @Defop RSHIFTMOD
    x{A92D} @Defop RSHIFTMODR
    x{A92E} @Defop RSHIFTMODC
    x{A920} @Defop ADDRSHIFTMOD
    x{A921} @Defop ADDRSHIFTMODR
    x{A922} @Defop ADDRSHIFTMODC

    x{A935} @Defop(8u+1) RSHIFTR#
    x{A936} @Defop(8u+1) RSHIFTC#
    x{A938} @Defop(8u+1) MODPOW2#
    x{A939} @Defop(8u+1) MODPOW2R#
    x{A93A} @Defop(8u+1) MODPOW2C#
    x{A93C} @Defop(8u+1) RSHIFT#MOD
    x{A93D} @Defop(8u+1) RSHIFTR#MOD
    x{A93E} @Defop(8u+1) RSHIFTC#MOD
    x{A930} @Defop(8u+1) ADDRSHIFT#MOD
    x{A931} @Defop(8u+1) ADDRSHIFTR#MOD
    x{A932} @Defop(8u+1) ADDRSHIFTC#MOD

    x{A984} @Defop MULDIV
    x{A985} @Defop MULDIVR
    x{A986} @Defop MULDIVC
    x{A988} @Defop MULMOD
    x{A989} @Defop MULMODR
    x{A98A} @Defop MULMODC
    x{A98C} @Defop MULDIVMOD
    x{A98D} @Defop MULDIVMODR
    x{A98E} @Defop MULDIVMODC
    x{A980} @Defop MULADDDIVMOD
    x{A981} @Defop MULADDDIVMODR
    x{A982} @Defop MULADDDIVMODC

    x{A9A4} @Defop MULRSHIFT
    x{A9A5} @Defop MULRSHIFTR
    x{A9A6} @Defop MULRSHIFTC
    x{A9A8} @Defop MULMODPOW2
    x{A9A9} @Defop MULMODPOW2R
    x{A9AA} @Defop MULMODPOW2C
    x{A9AC} @Defop MULRSHIFTMOD
    x{A9AD} @Defop MULRSHIFTRMOD
    x{A9AE} @Defop MULRSHIFTCMOD
    x{A9A0} @Defop MULADDRSHIFTMOD
    x{A9A1} @Defop MULADDRSHIFTRMOD
    x{A9A2} @Defop MULADDRSHIFTCMOD

    x{A9B4} @Defop(8u+1) MULRSHIFT#
    x{A9B5} @Defop(8u+1) MULRSHIFTR#
    x{A9B6} @Defop(8u+1) MULRSHIFTC#
    x{A9B8} @Defop(8u+1) MULMODPOW2#
    x{A9B9} @Defop(8u+1) MULMODPOW2R#
    x{A9BA} @Defop(8u+1) MULMODPOW2C#
    x{A9BC} @Defop(8u+1) MULRSHIFT#MOD
    x{A9BD} @Defop(8u+1) MULRSHIFTR#MOD
    x{A9BE} @Defop(8u+1) MULRSHIFTC#MOD
    x{A9B0} @Defop(8u+1) MULADDRSHIFT#MOD
    x{A9B1} @Defop(8u+1) MULADDRSHIFTR#MOD
    x{A9B2} @Defop(8u+1) MULADDRSHIFTC#MOD

    x{A9C4} @Defop LSHIFTDIV
    x{A9C5} @Defop LSHIFTDIVR
    x{A9C6} @Defop LSHIFTDIVC
    x{A9C8} @Defop LSHIFTMOD
    x{A9C9} @Defop LSHIFTMODR
    x{A9CA} @Defop LSHIFTMODC
    x{A9CC} @Defop LSHIFTDIVMOD
    x{A9CD} @Defop LSHIFTDIVMODR
    x{A9CE} @Defop LSHIFTDIVMODC
    x{A9C0} @Defop LSHIFTADDDIVMOD
    x{A9C1} @Defop LSHIFTADDDIVMODR
    x{A9C2} @Defop LSHIFTADDDIVMODC

    x{A9D4} @Defop(8u+1) LSHIFT#DIV
    x{A9D5} @Defop(8u+1) LSHIFT#DIVR
    x{A9D6} @Defop(8u+1) LSHIFT#DIVC
    x{A9D8} @Defop(8u+1) LSHIFT#MOD
    x{A9D9} @Defop(8u+1) LSHIFT#MODR
    x{A9DA} @Defop(8u+1) LSHIFT#MODC
    x{A9DC} @Defop(8u+1) LSHIFT#DIVMOD
    x{A9DD} @Defop(8u+1) LSHIFT#DIVMODR
    x{A9DE} @Defop(8u+1) LSHIFT#DIVMODC
    x{A9D0} @Defop(8u+1) LSHIFT#ADDDIVMOD
    x{A9D1} @Defop(8u+1) LSHIFT#ADDDIVMODR
    x{A9D2} @Defop(8u+1) LSHIFT#ADDDIVMODC

    x{AA} @Defop(8u+1) LSHIFT#
    x{AB} @Defop(8u+1) RSHIFT#
    x{AC} @Defop LSHIFT
    x{AD} @Defop RSHIFT
    x{AE} @Defop POW2
    x{B0} @Defop AND
    x{B1} @Defop OR
    x{B2} @Defop XOR
    x{B3} @Defop NOT
    x{B4} @Defop(8u+1) FITS
    x{B400} @Defop CHKBOOL
    x{B5} @Defop(8u+1) UFITS
    x{B500} @Defop CHKBIT
    x{B600} @Defop FITSX
    x{B601} @Defop UFITSX
    x{B602} @Defop BITSIZE
    x{B603} @Defop UBITSIZE
    x{B608} @Defop MIN
    x{B609} @Defop MAX
    x{B60A} dup @Defop MINMAX @Defop INTSORT2
    x{B60B} @Defop ABS
    x{B7} @Defop QUIET
    x{B7A0} @Defop QADD
    x{B7A1} @Defop QSUB
    x{B7A2} @Defop QSUBR
    x{B7A3} @Defop QNEGATE
    x{B7A4} @Defop QINC
    x{B7A5} @Defop QDEC
    x{B7A8} @Defop QMUL

    x{B7A904} @Defop QDIV
    x{B7A905} @Defop QDIVR
    x{B7A906} @Defop QDIVC
    x{B7A908} @Defop QMOD
    x{B7A909} @Defop QMODR
    x{B7A90A} @Defop QMODC
    x{B7A90C} @Defop QDIVMOD
    x{B7A90D} @Defop QDIVMODR
    x{B7A90E} @Defop QDIVMODC
    x{B7A900} @Defop QADDDIVMOD
    x{B7A901} @Defop QADDDIVMODR
    x{B7A902} @Defop QADDDIVMODC

    x{B7A925} @Defop QRSHIFTR
    x{B7A926} @Defop QRSHIFTC
    x{B7A928} @Defop QMODPOW2
    x{B7A929} @Defop QMODPOW2R
    x{B7A92A} @Defop QMODPOW2C
    x{B7A92C} @Defop QRSHIFTMOD
    x{B7A92D} @Defop QRSHIFTMODR
    x{B7A92E} @Defop QRSHIFTMODC
    x{B7A920} @Defop QADDRSHIFTMOD
    x{B7A921} @Defop QADDRSHIFTMODR
    x{B7A922} @Defop QADDRSHIFTMODC

    x{B7A935} @Defop(8u+1) QRSHIFTR#
    x{B7A936} @Defop(8u+1) QRSHIFTC#
    x{B7A938} @Defop(8u+1) QMODPOW2#
    x{B7A939} @Defop(8u+1) QMODPOW2R#
    x{B7A93A} @Defop(8u+1) QMODPOW2C#
    x{B7A93C} @Defop(8u+1) QRSHIFT#MOD
    x{B7A93D} @Defop(8u+1) QRSHIFTR#MOD
    x{B7A93E} @Defop(8u+1) QRSHIFTC#MOD
    x{B7A930} @Defop(8u+1) QADDRSHIFT#MOD
    x{B7A931} @Defop(8u+1) QADDRSHIFTR#MOD
    x{B7A932} @Defop(8u+1) QADDRSHIFTC#MOD

    x{B7A984} @Defop QMULDIV
    x{B7A985} @Defop QMULDIVR
    x{B7A986} @Defop QMULDIVC
    x{B7A988} @Defop QMULMOD
    x{B7A989} @Defop QMULMODR
    x{B7A98A} @Defop QMULMODC
    x{B7A98C} @Defop QMULDIVMOD
    x{B7A98D} @Defop QMULDIVMODR
    x{B7A98E} @Defop QMULDIVMODC
    x{B7A980} @Defop QMULADDDIVMOD
    x{B7A981} @Defop QMULADDDIVMODR
    x{B7A982} @Defop QMULADDDIVMODC

    x{B7A9A4} @Defop QMULRSHIFT
    x{B7A9A5} @Defop QMULRSHIFTR
    x{B7A9A6} @Defop QMULRSHIFTC
    x{B7A9A8} @Defop QMULMODPOW2
    x{B7A9A9} @Defop QMULMODPOW2R
    x{B7A9AA} @Defop QMULMODPOW2C
    x{B7A9AC} @Defop QMULRSHIFTMOD
    x{B7A9AD} @Defop QMULRSHIFTRMOD
    x{B7A9AE} @Defop QMULRSHIFTCMOD
    x{B7A9A0} @Defop QMULADDRSHIFTMOD
    x{B7A9A1} @Defop QMULADDRSHIFTRMOD
    x{B7A9A2} @Defop QMULADDRSHIFTCMOD

    x{B7A9B4} @Defop(8u+1) QMULRSHIFT#
    x{B7A9B5} @Defop(8u+1) QMULRSHIFTR#
    x{B7A9B6} @Defop(8u+1) QMULRSHIFTC#
    x{B7A9B8} @Defop(8u+1) QMULMODPOW2#
    x{B7A9B9} @Defop(8u+1) QMULMODPOW2R#
    x{B7A9BA} @Defop(8u+1) QMULMODPOW2C#
    x{B7A9BC} @Defop(8u+1) QMULRSHIFT#MOD
    x{B7A9BD} @Defop(8u+1) QMULRSHIFTR#MOD
    x{B7A9BE} @Defop(8u+1) QMULRSHIFTC#MOD
    x{B7A9B0} @Defop(8u+1) QMULADDRSHIFT#MOD
    x{B7A9B1} @Defop(8u+1) QMULADDRSHIFTR#MOD
    x{B7A9B2} @Defop(8u+1) QMULADDRSHIFTC#MOD

    x{B7A9C4} @Defop QLSHIFTDIV
    x{B7A9C5} @Defop QLSHIFTDIVR
    x{B7A9C6} @Defop QLSHIFTDIVC
    x{B7A9C8} @Defop QLSHIFTMOD
    x{B7A9C9} @Defop QLSHIFTMODR
    x{B7A9CA} @Defop QLSHIFTMODC
    x{B7A9CC} @Defop QLSHIFTDIVMOD
    x{B7A9CD} @Defop QLSHIFTDIVMODR
    x{B7A9CE} @Defop QLSHIFTDIVMODC
    x{B7A9C0} @Defop QLSHIFTADDDIVMOD
    x{B7A9C1} @Defop QLSHIFTADDDIVMODR
    x{B7A9C2} @Defop QLSHIFTADDDIVMODC

    x{B7A9D4} @Defop(8u+1) QLSHIFT#DIV
    x{B7A9D5} @Defop(8u+1) QLSHIFT#DIVR
    x{B7A9D6} @Defop(8u+1) QLSHIFT#DIVC
    x{B7A9D8} @Defop(8u+1) QLSHIFT#MOD
    x{B7A9D9} @Defop(8u+1) QLSHIFT#MODR
    x{B7A9DA} @Defop(8u+1) QLSHIFT#MODC
    x{B7A9DC} @Defop(8u+1) QLSHIFT#DIVMOD
    x{B7A9DD} @Defop(8u+1) QLSHIFT#DIVMODR
    x{B7A9DE} @Defop(8u+1) QLSHIFT#DIVMODC
    x{B7A9D0} @Defop(8u+1) QLSHIFT#ADDDIVMOD
    x{B7A9D1} @Defop(8u+1) QLSHIFT#ADDDIVMODR
    x{B7A9D2} @Defop(8u+1) QLSHIFT#ADDDIVMODC

    x{B7AC} @Defop QLSHIFT
    x{B7AD} @Defop QRSHIFT
    x{B7AE} @Defop QPOW2
    x{B7B0} @Defop QAND
    x{B7B1} @Defop QOR
    x{B7B2} @Defop QXOR
    x{B7B3} @Defop QNOT
    x{B7B4} @Defop(8u+1) QFITS
    x{B7B5} @Defop(8u+1) QUFITS
    x{B7B600} @Defop QFITSX
    x{B7B601} @Defop QUFITSX

    // advanced integer constants
    { 0 { over 1 and 0= } { 1+ swap 2/ swap } while } : pow2decomp
    { dup 8 fits { PUSHINT } {
      dup pow2decomp over 1 = { nip nip PUSHPOW2 } {
      over -1 = { nip nip PUSHNEGPOW2 } {
      dup 20 >= { rot drop -rot PUSHINT swap LSHIFT# } {
      { drop PUSHINT } {
      not pow2decomp swap -1 = { nip PUSHPOW2DEC } {
      drop PUSHINT
      } cond } cond } cond } cond } cond } cond
    } dup : PUSHINTX : INTX

    // integer comparison
    x{B8} @Defop SGN
    x{B9} @Defop LESS
    x{BA} @Defop EQUAL
    x{BB} @Defop LEQ
    x{BC} @Defop GREATER
    x{BD} @Defop NEQ
    x{BE} @Defop GEQ
    x{BF} @Defop CMP
    x{C0} x{BA} @Defop(8i,alt) EQINT
    x{C000} @Defop ISZERO
    x{C1} x{B9} @Defop(8i,alt) LESSINT
    { 1+ LESSINT } : LEQINT
    x{C100} @Defop ISNEG
    x{C101} @Defop ISNPOS
    x{C2} x{BC} @Defop(8i,alt) GTINT
    { 1- GTINT } : GEQINT
    x{C200} @Defop ISPOS
    x{C2FF} @Defop ISNNEG
    x{C3} x{BD} @Defop(8i,alt) NEQINT
    x{C300} @Defop ISNZERO
    x{C4} @Defop ISNAN
    x{C5} @Defop CHKNAN

    // other comparison
    x{C700} @Defop SEMPTY
    x{C701} @Defop SDEMPTY
    x{C702} @Defop SREMPTY
    x{C703} @Defop SDFIRST
    x{C704} @Defop SDLEXCMP
    x{C705} @Defop SDEQ
    x{C708} @Defop SDPFX
    x{C709} @Defop SDPFXREV
    x{C70A} @Defop SDPPFX
    x{C70B} @Defop SDPPFXREV
    x{C70C} @Defop SDSFX
    x{C70D} @Defop SDSFXREV
    x{C70E} @Defop SDPSFX
    x{C70F} @Defop SDPSFXREV
    x{C710} @Defop SDCNTLEAD0
    x{C711} @Defop SDCNTLEAD1
    x{C712} @Defop SDCNTTRAIL0
    x{C713} @Defop SDCNTTRAIL1

    // cell serialization (Builder manipulation primitives)
    x{C8} @Defop NEWC
    x{C9} @Defop ENDC
    x{CA} @Defop(8u+1) STI
    x{CB} @Defop(8u+1) STU
    x{CC} @Defop STREF
    x{CD} dup @Defop STBREFR @Defop ENDCST
    x{CE} @Defop STSLICE
    x{CF00} @Defop STIX
    x{CF01} @Defop STUX
    x{CF02} @Defop STIXR
    x{CF03} @Defop STUXR
    x{CF04} @Defop STIXQ
    x{CF05} @Defop STUXQ
    x{CF06} @Defop STIXRQ
    x{CF07} @Defop STUXRQ
    x{CF08} @Defop(8u+1) STI_l
    x{CF09} @Defop(8u+1) STU_l
    x{CF0A} @Defop(8u+1) STIR
    x{CF0B} @Defop(8u+1) STUR
    x{CF0C} @Defop(8u+1) STIQ
    x{CF0D} @Defop(8u+1) STUQ
    x{CF0E} @Defop(8u+1) STIRQ
    x{CF0F} @Defop(8u+1) STURQ
    x{CF10} @Defop STREF_l
    x{CF11} @Defop STBREF
    x{CF12} @Defop STSLICE_l
    x{CF13} @Defop STB
    x{CF14} @Defop STREFR
    x{CF15} @Defop STBREFR_l
    x{CF16} @Defop STSLICER
    x{CF17} dup @Defop STBR @Defop BCONCAT
    x{CF18} @Defop STREFQ
    x{CF19} @Defop STBREFQ
    x{CF1A} @Defop STSLICEQ
    x{CF1B} @Defop STBQ
    x{CF1C} @Defop STREFRQ
    x{CF1D} @Defop STBREFRQ
    x{CF1E} @Defop STSLICERQ
    x{CF1F} dup @Defop STBRQ @Defop BCONCATQ
    x{CF20} @Defop(ref) STREFCONST
    { <b x{CF21} s, rot ref, swap ref, @addopb } : STREF2CONST
    x{CF23} @Defop ENDXC
    x{CF28} @Defop STILE4
    x{CF29} @Defop STULE4
    x{CF2A} @Defop STILE8
    x{CF2B} @Defop STULE8
    x{CF30} @Defop BDEPTH
    x{CF31} @Defop BBITS
    x{CF32} @Defop BREFS
    x{CF33} @Defop BBITREFS
    x{CF35} @Defop BREMBITS
    x{CF36} @Defop BREMREFS
    x{CF37} @Defop BREMBITREFS
    x{CF38} @Defop(8u+1) BCHKBITS#
    x{CF39} @Defop BCHKBITS
    x{CF3A} @Defop BCHKREFS
    x{CF3B} @Defop BCHKBITREFS
    x{CF3C} @Defop(8u+1) BCHKBITSQ#
    x{CF3D} @Defop BCHKBITSQ
    x{CF3E} @Defop BCHKREFSQ
    x{CF3F} @Defop BCHKBITREFSQ
    x{CF40} @Defop STZEROES
    x{CF41} @Defop STONES
    x{CF42} @Defop STSAME
    { tuck sbitrefs swap 22 + swap @havebitrefs not
      { swap PUSHSLICE STSLICER }
      { over sbitrefs 2dup 57 3 2x<=
        { rot x{CFC_} s, swap 2 u, over 6 + 3 >> tuck 3 u, 3 roll s,
          -rot 3 << 2 + swap - @scomplete }
        { 2drop swap PUSHSLICE STSLICER } cond
      } cond
    } : STSLICECONST
    x{CF81} @Defop STZERO
    x{CF83} @Defop STONE

    // cell deserialization (CellSlice primitives)
    x{D0} @Defop CTOS
    x{D1} @Defop ENDS
    x{D2} @Defop(8u+1) LDI
    x{D3} @Defop(8u+1) LDU
    x{D4} @Defop LDREF
    x{D5} @Defop LDREFRTOS
    x{D6} @Defop(8u+1) LDSLICE
    x{D700} @Defop LDIX
    x{D701} @Defop LDUX
    x{D702} @Defop PLDIX
    x{D703} @Defop PLDUX
    x{D704} @Defop LDIXQ
    x{D705} @Defop LDUXQ
    x{D706} @Defop PLDIXQ
    x{D707} @Defop PLDUXQ
    x{D708} @Defop(8u+1) LDI_l
    x{D709} @Defop(8u+1) LDU_l
    x{D70A} @Defop(8u+1) PLDI
    x{D70B} @Defop(8u+1) PLDU
    x{D70C} @Defop(8u+1) LDIQ
    x{D70D} @Defop(8u+1) LDUQ
    x{D70E} @Defop(8u+1) PLDIQ
    x{D70F} @Defop(8u+1) PLDUQ
    { dup 31 and abort"argument must be a multiple of 32" 5 >> 1-
      <b x{D714_} s, swap 3 u, @addopb
    } : PLDUZ
    x{D718} @Defop LDSLICEX
    x{D719} @Defop PLDSLICEX
    x{D71A} @Defop LDSLICEXQ
    x{D71B} @Defop PLDSLICEXQ
    x{D71C} @Defop(8u+1) LDSLICE_l
    x{D71D} @Defop(8u+1) PLDSLICE
    x{D71E} @Defop(8u+1) LDSLICEQ
    x{D71F} @Defop(8u+1) PLDSLICEQ
    x{D720} @Defop SDCUTFIRST
    x{D721} @Defop SDSKIPFIRST
    x{D722} @Defop SDCUTLAST
    x{D723} @Defop SDSKIPLAST
    x{D724} @Defop SDSUBSTR
    x{D726} @Defop SDBEGINSX
    x{D727} @Defop SDBEGINSXQ
    { tuck sbits tuck 5 + 3 >> swap x{D72A_} s, over 7 u, 3 roll s,
      -rot 3 << 3 + swap - @scomplete } : SDBEGINS:imm
    { tuck sbitrefs abort"no references allowed in slice" dup 26 <=
      { drop <b rot SDBEGINS:imm @addopb }
      { @havebits
        { swap SDBEGINS:imm }
        { swap PUSHSLICE SDBEGINSX
        } cond
      } cond
    } : SDBEGINS
    { tuck sbits tuck 5 + 3 >> swap x{D72E_} s, over 7 u, 3 roll s,
      -rot 3 << 3 + swap - @scomplete } : SDBEGINSQ:imm
    { tuck sbitrefs abort"no references allowed in slice" dup 26 <=
      { drop <b rot SDBEGINSQ:imm @addopb }
      { @havebits
        { swap SDBEGINSQ:imm }
        { swap PUSHSLICE SDBEGINSXQ
        } cond
      } cond
    } : SDBEGINSQ
    x{D730} @Defop SCUTFIRST
    x{D731} @Defop SSKIPFIRST
    x{D732} @Defop SCUTLAST
    x{D733} @Defop SSKIPLAST
    x{D734} @Defop SUBSLICE
    x{D736} @Defop SPLIT
    x{D737} @Defop SPLITQ
    x{D739} @Defop XCTOS
    x{D73A} @Defop XLOAD
    x{D73B} @Defop XLOADQ
    x{D741} @Defop SCHKBITS
    x{D742} @Defop SCHKREFS
    x{D743} @Defop SCHKBITREFS
    x{D745} @Defop SCHKBITSQ
    x{D746} @Defop SCHKREFSQ
    x{D747} @Defop SCHKBITREFSQ
    x{D748} @Defop PLDREFVAR
    x{D749} @Defop SBITS
    x{D74A} @Defop SREFS
    x{D74B} @Defop SBITREFS
    { <b x{D74E_} s, swap 2 u, @addopb } : PLDREFIDX
    x{D74C} @Defop PLDREF
    x{D750} @Defop LDILE4
    x{D751} @Defop LDULE4
    x{D752} @Defop LDILE8
    x{D753} @Defop LDULE8
    x{D754} @Defop PLDILE4
    x{D755} @Defop PLDULE4
    x{D756} @Defop PLDILE8
    x{D757} @Defop PLDULE8
    x{D758} @Defop LDILE4Q
    x{D759} @Defop LDULE4Q
    x{D75A} @Defop LDILE8Q
    x{D75B} @Defop LDULE8Q
    x{D75C} @Defop PLDILE4Q
    x{D75D} @Defop PLDULE4Q
    x{D75E} @Defop PLDILE8Q
    x{D75F} @Defop PLDULE8Q
    x{D760} @Defop LDZEROES
    x{D761} @Defop LDONES
    x{D762} @Defop LDSAME
    x{D764} @Defop SDEPTH
    x{D765} @Defop CDEPTH
    x{D766} @Defop CLEVEL
    x{D767} @Defop CLEVELMASK
    { <b x{D76A_} s, swap 2 u, @addopb } : CHASHI
    { <b x{D76E_} s, swap 2 u, @addopb } : CDEPTHI
    x{D770} @Defop CHASHIX
    x{D771} @Defop CDEPTHIX
    //
    // continuation / flow control primitives
    x{D8} dup @Defop EXECUTE @Defop CALLX
    x{D9} @Defop JMPX
    { dup 1+
      { <b x{DA} s, rot 4 u, swap 4 u, }
      { drop <b x{DB0} s, swap 4 u,
      } cond @addopb
    } : CALLXARGS
    x{DB1} @Defop(4u) JMPXARGS
    x{DB2} @Defop(4u) RETARGS
    x{DB30} dup @Defop RET @Defop RETTRUE
    x{DB31} dup @Defop RETALT @Defop RETFALSE
    x{DB32} dup @Defop BRANCH @Defop RETBOOL
    x{DB34} @Defop CALLCC
    x{DB35} @Defop JMPXDATA
    { dup 1+ 0= { 16 + } if
      <b x{DB36} s, rot 4 u, swap 4 u, @addopb
    } : CALLCCARGS
    x{DB38} @Defop CALLXVARARGS
    x{DB39} @Defop RETVARARGS
    x{DB3A} @Defop JMPXVARARGS
    x{DB3B} @Defop CALLCCVARARGS
    x{DB3C} @Defop(ref) CALLREF
    x{DB3D} @Defop(ref) JMPREF
    x{DB3E} @Defop(ref) JMPREFDATA
    x{DB3F} @Defop RETDATA
    x{DB4} @Defop(12u) RUNVM
    x{DB50} @Defop RUNVMX
    // conditional and iterated execution primitives
    x{DC} @Defop IFRET
    x{DD} @Defop IFNOTRET
    x{DE} @Defop IF
    x{DF} @Defop IFNOT
    ' IFNOTRET : IF:
    ' IFRET : IFNOT:
    x{E0} @Defop IFJMP
    x{E1} @Defop IFNOTJMP
    x{E2} @Defop IFELSE

    x{E300} @Defop(ref) IFREF
    x{E301} @Defop(ref) IFNOTREF
    x{E302} @Defop(ref) IFJMPREF
    x{E303} @Defop(ref) IFNOTJMPREF
    x{E30D} @Defop(ref) IFREFELSE
    x{E30E} @Defop(ref) IFELSEREF
    x{E30F} @Defop(ref*2) IFREFELSEREF

    { 16 1 @havebitrefs nip } : @refop-fits?
    // b b1 [e0 e1 e2] -- b'
    { -rot dup @cont-empty? { drop swap 0 } {
      2dup @cont-fits? { rot 1 } {
      over @refop-fits? { b> rot 2 } {
      swap @| swap 2dup @cont-fits? { rot 1 } {
      b> rot 2
      } cond } cond } cond } cond
      [] execute
    } : @run-cont-op
    { triple 1 ' @run-cont-op does create } : @def-cont-op
    { DROP } { PUSHCONT IF } { IFREF } @def-cont-op IF-cont
    { IFRET } { PUSHCONT IFJMP } { IFJMPREF } @def-cont-op IFJMP-cont
    { DROP } { PUSHCONT IFNOT } { IFNOTREF } @def-cont-op IFNOT-cont
    { IFNOTRET } { PUSHCONT IFNOTJMP } { IFNOTJMPREF } @def-cont-op IFNOTJMP-cont
    { dup 2over rot } : 3dup

    recursive IFELSE-cont2 {
      dup @cont-empty? { drop IF-cont } {
      over @cont-empty? { nip IFNOT-cont } {
      3dup @two-cont-fit? { -rot PUSHCONT swap PUSHCONT IFELSE } {
      3dup nip @cont-ref-fit? { rot swap PUSHCONT swap b> IFREFELSE } {
      3dup drop @cont-ref-fit? { -rot PUSHCONT swap b> IFELSEREF } {
      rot 32 2 @havebitrefs { rot b> rot b> IFREFELSEREF } {
      @| -rot IFELSE-cont2
      } cond } cond } cond } cond } cond } cond
    } swap !

    { }> IF-cont } : }>IF
    { }> IFNOT-cont } : }>IFNOT
    { }> IFJMP-cont } : }>IFJMP
    { }> IFNOTJMP-cont } : }>IFNOTJMP
    { { @normal? IFJMP-cont } @doafter<{ } : IFJMP:<{
    { { @normal? IFNOTJMP-cont } @doafter<{ } : IFNOTJMP:<{
    { `else @endblk } : }>ELSE<{
    { `else: @endblk } : }>ELSE:
    { 1 { swap @normal? swap IFELSE-cont2 } does @doafter<{ } : @doifelse
    { 1 { swap @normal? IFELSE-cont2 } does @doafter<{ } : @doifnotelse
    {
      { dup `else eq?
        { drop @doifelse }
        { dup `else: eq?
          { drop IFJMP-cont }
          { @normal? IF-cont
          } cond
        } cond
      } @doafter<{
    } : IF:<{
    {
      { dup `else eq?
        { drop @doifnotelse }
        { dup `else: eq?
          { drop IFNOTJMP-cont }
          { @normal? IFNOT-cont
          } cond
        } cond
      } @doafter<{
    } : IFNOT:<{

    x{E304} @Defop CONDSEL
    x{E305} @Defop CONDSELCHK
    x{E308} @Defop IFRETALT
    x{E309} @Defop IFNOTRETALT
    { <b x{E39_} s, swap 5 u, @addopb } : IFBITJMP
    { <b x{E3B_} s, swap 5 u, @addopb } : IFNBITJMP
    { <b x{E3D_} s, swap 5 u, swap ref, @addopb } : IFBITJMPREF
    { <b x{E3F_} s, swap 5 u, swap ref, @addopb } : IFNBITJMPREF

    x{E4} @Defop REPEAT
    x{E5} dup @Defop REPEATEND @Defop REPEAT:
    x{E6} @Defop UNTIL
    x{E7} dup @Defop UNTILEND @Defop UNTIL:
    x{E8} @Defop WHILE
    x{E9} @Defop WHILEEND
    x{EA} @Defop AGAIN
    x{EB} dup @Defop AGAINEND @Defop AGAIN:

    { `do @endblk } : }>DO<{
    { `do: @endblk } : }>DO:
    { }> PUSHCONT REPEAT } : }>REPEAT
    { { @normal? PUSHCONT REPEAT } @doafter<{ } : REPEAT:<{
    { }> PUSHCONT UNTIL } : }>UNTIL
    { { @normal? PUSHCONT UNTIL } @doafter<{ } : UNTIL:<{
    { PUSHCONT { @normal? PUSHCONT WHILE } @doafter<{ } : @dowhile
    {
      { dup `do eq?
        { drop @dowhile }
        { `do: eq? not abort"`}>DO<{` expected" PUSHCONT WHILEEND
        } cond
      } @doafter<{
    } : WHILE:<{
    { }> PUSHCONT AGAIN } : }>AGAIN
    { { @normal? PUSHCONT AGAIN } @doafter<{ } : AGAIN:<{

    x{E314} @Defop REPEATBRK
    x{E315} @Defop REPEATENDBRK
    x{E316} @Defop UNTILBRK
    x{E317} dup @Defop UNTILENDBRK @Defop UNTILBRK:
    x{E318} @Defop WHILEBRK
    x{E319} @Defop WHILEENDBRK
    x{E31A} @Defop AGAINBRK
    x{E31B} dup @Defop AGAINENDBRK @Defop AGAINBRK:

    { }> PUSHCONT REPEATBRK } : }>REPEATBRK
    { { @normal? PUSHCONT REPEATBRK } @doafter<{ } : REPEATBRK:<{
    { }> PUSHCONT UNTILBRK } : }>UNTILBRK
    { { @normal? PUSHCONT UNTILBRK } @doafter<{ } : UNTILBRK:<{
    { PUSHCONT { @normal? PUSHCONT WHILEBRK } @doafter<{ } : @dowhile
    {
      { dup `do eq?
        { drop @dowhile }
        { `do: eq? not abort"`}>DO<{` expected" PUSHCONT WHILEENDBRK
        } cond
      } @doafter<{
    } : WHILEBRK:<{
    { }> PUSHCONT AGAINBRK } : }>AGAINBRK
    { { @normal? PUSHCONT AGAINBRK } @doafter<{ } : AGAINBRK:<{


    //
    // continuation stack manipulation and continuation creation
    //
    { <b x{EC} s, rot 4 u, swap dup 1+ { 16 + } ifnot 4 u, @addopb } : SETCONTARGS
    { 0 swap SETCONTARGS } : SETNUMARGS
    x{ED0} @Defop(4u) RETURNARGS
    x{ED10} @Defop RETURNVARARGS
    x{ED11} @Defop SETCONTVARARGS
    x{ED12} @Defop SETNUMVARARGS
    x{ED1E} @Defop BLESS
    x{ED1F} @Defop BLESSVARARGS
    { <b x{EE} s, rot 4 u, swap dup 1+ { 16 + } ifnot 4 u, @addopb } : BLESSARGS
    { 0 swap BLESSARGS } : BLESSNUMARGS
    //
    // control register and continuation savelist manipulation
    // x{ED4} Defop(c) PUSHCTR
    // x{ED5} Defop(c) POPCTR
    { c4 PUSHCTR } : PUSHROOT
    { c4 POPCTR } : POPROOT
    x{ED6} dup @Defop(c) SETCONTCTR @Defop(c) SETCONT
    x{ED7} @Defop(c) SETRETCTR
    x{ED8} @Defop(c) SETALTCTR
    x{ED9} dup @Defop(c) POPSAVE @Defop(c) POPCTRSAVE
    x{EDA} dup @Defop(c) SAVE @Defop(c) SAVECTR
    x{EDB} dup @Defop(c) SAVEALT @Defop(c) SAVEALTCTR
    x{EDC} dup @Defop(c) SAVEBOTH @Defop(c) SAVEBOTHCTR
    x{EDE0} @Defop PUSHCTRX
    x{EDE1} @Defop POPCTRX
    x{EDE2} @Defop SETCONTCTRX
    x{EDF0} dup @Defop BOOLAND @Defop COMPOS
    x{EDF1} dup @Defop BOOLOR @Defop COMPOSALT
    x{EDF2} @Defop COMPOSBOTH
    x{EDF3} @Defop ATEXIT
    { }> PUSHCONT ATEXIT } : }>ATEXIT
    { { @normal? PUSHCONT ATEXIT } @doafter<{ } : ATEXIT:<{
    x{EDF4} @Defop ATEXITALT
    { }> PUSHCONT ATEXITALT } : }>ATEXITALT
    { { @normal? PUSHCONT ATEXITALT } @doafter<{ } : ATEXITALT:<{
    x{EDF5} @Defop SETEXITALT
    { }> PUSHCONT SETEXITALT } : }>SETEXITALT
    { { @normal? PUSHCONT SETEXITALT } @doafter<{ } : SETEXITALT:<{
    x{EDF6} @Defop THENRET
    x{EDF7} @Defop THENRETALT
    x{EDF8} @Defop INVERT
    x{EDF9} @Defop BOOLEVAL
    x{EDFA} @Defop SAMEALT
    x{EDFB} @Defop SAMEALTSAVE
    // x{EE} is BLESSARGS
    //
    // dictionary subroutine call/jump primitives
    { c3 PUSH EXECUTE } : CALLVAR
    { c3 PUSH JMPX } : JMPVAR
    { c3 PUSH } : PREPAREVAR
    { dup 14 ufits {
        dup 8 ufits {
          <b x{F0} s, swap 8 u, } {
          <b x{F12_} s, swap 14 u,
        } cond @addopb } {
        PUSHINT CALLVAR
      } cond
    } dup : CALL : CALLDICT
    { dup 14 ufits
      { <b x{F16_} s, swap 14 u, @addopb }
      { PUSHINT JMPVAR } cond
    } dup : JMP : JMPDICT
    { dup 14 ufits
      { <b x{F1A_} s, swap 14 u, @addopb }
      { PUSHINT c3 PREPAREVAR } cond
    } dup : PREPARE : PREPAREDICT
    //
    // inline support
    { dup sbits
       { @addop }
       {
        dup srefs //
          { ref@ CALLREF }
          { drop }
          cond
       }
       cond
    } : INLINE
    //
    // throwing and handling exceptions
    { dup 6 ufits
      { <b x{F22_} s, swap 6 u, }
      { <b x{F2C4_} s, swap 11 u,
      } cond
    @addopb } : THROW
    { dup 6 ufits
      { <b x{F26_} s, swap 6 u, }
      { <b x{F2D4_} s, swap 11 u,
      } cond
    @addopb } : THROWIF
    { dup 6 ufits
      { <b x{F2A_} s, swap 6 u, }
      { <b x{F2E4_} s, swap 11 u,
      } cond
    @addopb } : THROWIFNOT
    { <b x{F2CC_} s, swap 11 u, @addopb } : THROWARG
    { <b x{F2DC_} s, swap 11 u, @addopb } : THROWARGIF
    { <b x{F2EC_} s, swap 11 u, @addopb } : THROWARGIFNOT
    x{F2F0} @Defop THROWANY
    x{F2F1} @Defop THROWARGANY
    x{F2F2} @Defop THROWANYIF
    x{F2F3} @Defop THROWARGANYIF
    x{F2F4} @Defop THROWANYIFNOT
    x{F2F5} @Defop THROWARGANYIFNOT
    x{F2FF} @Defop TRY
    x{F3} @Defop(4u,4u) TRYARGS
    { `catch @endblk } : }>CATCH<{
    { PUSHCONT { @normal? PUSHCONT TRY } @doafter<{ } : @trycatch
    {
      { `catch eq? not abort"`}>CATCH<{` expected" @trycatch
      } @doafter<{
    } : TRY:<{
    //
    // dictionary manipulation
    ' NULL : NEWDICT
    ' ISNULL : DICTEMPTY
    ' STSLICE : STDICTS
    x{F400} dup @Defop STDICT @Defop STOPTREF
    x{F401} dup @Defop SKIPDICT @Defop SKIPOPTREF
    x{F402} @Defop LDDICTS
    x{F403} @Defop PLDDICTS
    x{F404} dup @Defop LDDICT @Defop LDOPTREF
    x{F405} dup @Defop PLDDICT @Defop PLDOPTREF
    x{F406} @Defop LDDICTQ
    x{F407} @Defop PLDDICTQ

    x{F40A} @Defop DICTGET
    x{F40B} @Defop DICTGETREF
    x{F40C} @Defop DICTIGET
    x{F40D} @Defop DICTIGETREF
    x{F40E} @Defop DICTUGET
    x{F40F} @Defop DICTUGETREF

    x{F412} @Defop DICTSET
    x{F413} @Defop DICTSETREF
    x{F414} @Defop DICTISET
    x{F415} @Defop DICTISETREF
    x{F416} @Defop DICTUSET
    x{F417} @Defop DICTUSETREF
    x{F41A} @Defop DICTSETGET
    x{F41B} @Defop DICTSETGETREF
    x{F41C} @Defop DICTISETGET
    x{F41D} @Defop DICTISETGETREF
    x{F41E} @Defop DICTUSETGET
    x{F41F} @Defop DICTUSETGETREF

    x{F422} @Defop DICTREPLACE
    x{F423} @Defop DICTREPLACEREF
    x{F424} @Defop DICTIREPLACE
    x{F425} @Defop DICTIREPLACEREF
    x{F426} @Defop DICTUREPLACE
    x{F427} @Defop DICTUREPLACEREF
    x{F42A} @Defop DICTREPLACEGET
    x{F42B} @Defop DICTREPLACEGETREF
    x{F42C} @Defop DICTIREPLACEGET
    x{F42D} @Defop DICTIREPLACEGETREF
    x{F42E} @Defop DICTUREPLACEGET
    x{F42F} @Defop DICTUREPLACEGETREF

    x{F432} @Defop DICTADD
    x{F433} @Defop DICTADDREF
    x{F434} @Defop DICTIADD
    x{F435} @Defop DICTIADDREF
    x{F436} @Defop DICTUADD
    x{F437} @Defop DICTUADDREF
    x{F43A} @Defop DICTADDGET
    x{F43B} @Defop DICTADDGETREF
    x{F43C} @Defop DICTIADDGET
    x{F43D} @Defop DICTIADDGETREF
    x{F43E} @Defop DICTUADDGET
    x{F43F} @Defop DICTUADDGETREF

    x{F441} @Defop DICTSETB
    x{F442} @Defop DICTISETB
    x{F443} @Defop DICTUSETB
    x{F445} @Defop DICTSETGETB
    x{F446} @Defop DICTISETGETB
    x{F447} @Defop DICTUSETGETB

    x{F449} @Defop DICTREPLACEB
    x{F44A} @Defop DICTIREPLACEB
    x{F44B} @Defop DICTUREPLACEB
    x{F44D} @Defop DICTREPLACEGETB
    x{F44E} @Defop DICTIREPLACEGETB
    x{F44F} @Defop DICTUREPLACEGETB

    x{F451} @Defop DICTADDB
    x{F452} @Defop DICTIADDB
    x{F453} @Defop DICTUADDB
    x{F455} @Defop DICTADDGETB
    x{F456} @Defop DICTIADDGETB
    x{F457} @Defop DICTUADDGETB

    x{F459} @Defop DICTDEL
    x{F45A} @Defop DICTIDEL
    x{F45B} @Defop DICTUDEL

    x{F462} @Defop DICTDELGET
    x{F463} @Defop DICTDELGETREF
    x{F464} @Defop DICTIDELGET
    x{F465} @Defop DICTIDELGETREF
    x{F466} @Defop DICTUDELGET
    x{F467} @Defop DICTUDELGETREF

    x{F469} @Defop DICTGETOPTREF
    x{F46A} @Defop DICTIGETOPTREF
    x{F46B} @Defop DICTUGETOPTREF
    x{F46D} @Defop DICTSETGETOPTREF
    x{F46E} @Defop DICTISETGETOPTREF
    x{F46F} @Defop DICTUSETGETOPTREF

    x{F470} @Defop PFXDICTSET
    x{F471} @Defop PFXDICTREPLACE
    x{F472} @Defop PFXDICTADD
    x{F473} @Defop PFXDICTDEL

    x{F474} @Defop DICTGETNEXT
    x{F475} @Defop DICTGETNEXTEQ
    x{F476} @Defop DICTGETPREV
    x{F477} @Defop DICTGETPREVEQ
    x{F478} @Defop DICTIGETNEXT
    x{F479} @Defop DICTIGETNEXTEQ
    x{F47A} @Defop DICTIGETPREV
    x{F47B} @Defop DICTIGETPREVEQ
    x{F47C} @Defop DICTUGETNEXT
    x{F47D} @Defop DICTUGETNEXTEQ
    x{F47E} @Defop DICTUGETPREV
    x{F47F} @Defop DICTUGETPREVEQ

    x{F482} @Defop DICTMIN
    x{F483} @Defop DICTMINREF
    x{F484} @Defop DICTIMIN
    x{F485} @Defop DICTIMINREF
    x{F486} @Defop DICTUMIN
    x{F487} @Defop DICTUMINREF
    x{F48A} @Defop DICTMAX
    x{F48B} @Defop DICTMAXREF
    x{F48C} @Defop DICTIMAX
    x{F48D} @Defop DICTIMAXREF
    x{F48E} @Defop DICTUMAX
    x{F48F} @Defop DICTUMAXREF

    x{F492} @Defop DICTREMMIN
    x{F493} @Defop DICTREMMINREF
    x{F494} @Defop DICTIREMMIN
    x{F495} @Defop DICTIREMMINREF
    x{F496} @Defop DICTUREMMIN
    x{F497} @Defop DICTUREMMINREF
    x{F49A} @Defop DICTREMMAX
    x{F49B} @Defop DICTREMMAXREF
    x{F49C} @Defop DICTIREMMAX
    x{F49D} @Defop DICTIREMMAXREF
    x{F49E} @Defop DICTUREMMAX
    x{F49F} @Defop DICTUREMMAXREF

    x{F4A0} @Defop DICTIGETJMP
    x{F4A1} @Defop DICTUGETJMP
    x{F4A2} @Defop DICTIGETEXEC
    x{F4A3} @Defop DICTUGETEXEC
    { dup sbitrefs tuck 1 > swap 1 <> or abort"not a dictionary" swap 1 u@ over <> abort"not a dictionary" } : @chkdicts
    { dup null? tuck { <s } ifnot drop not } : @chkdict
    { over @chkdict
      { swap <b x{F4A6_} s, swap ref, swap 10 u, @addopb }
      { nip swap NEWDICT swap PUSHINT }
      cond
    } : DICTPUSHCONST
    x{F4A8} @Defop PFXDICTGETQ
    x{F4A9} @Defop PFXDICTGET
    x{F4AA} @Defop PFXDICTGETJMP
    x{F4AB} @Defop PFXDICTGETEXEC
    { over @chkdict
      { swap <b x{F4AE_} s, swap ref, swap 10 u, @addopb
      } if
    } dup : PFXDICTCONSTGETJMP : PFXDICTSWITCH

    x{F4B1} @Defop SUBDICTGET
    x{F4B2} @Defop SUBDICTIGET
    x{F4B3} @Defop SUBDICTUGET
    x{F4B5} @Defop SUBDICTRPGET
    x{F4B6} @Defop SUBDICTIRPGET
    x{F4B7} @Defop SUBDICTURPGET

    x{F4BC} @Defop DICTIGETJMPZ
    x{F4BD} @Defop DICTUGETJMPZ
    x{F4BE} @Defop DICTIGETEXECZ
    x{F4BF} @Defop DICTUGETEXECZ

    //
    // blockchain-specific primitives

    x{F800} @Defop ACCEPT
    x{F801} @Defop SETGASLIMIT
    x{F807} @Defop GASCONSUMED
    x{F80F} @Defop COMMIT

    x{F810} @Defop RANDU256
    x{F811} @Defop RAND
    x{F814} @Defop SETRAND
    x{F815} dup @Defop ADDRAND @Defop RANDOMIZE

    x{F82} @Defop(4u) GETPARAM
    x{F823} @Defop NOW
    x{F824} @Defop BLOCKLT
    x{F825} @Defop LTIME
    x{F826} @Defop RANDSEED
    x{F827} @Defop BALANCE
    x{F828} @Defop MYADDR
    x{F829} @Defop CONFIGROOT
    x{F82A} @Defop MYCODE
    x{F82B} @Defop INCOMINGVALUE
    x{F82C} @Defop STORAGEFEES
    x{F82D} @Defop PREVBLOCKSINFOTUPLE
    x{F82E} @Defop UNPACKEDCONFIGTUPLE
    x{F82F} @Defop DUEPAYMENT
    x{F830} @Defop CONFIGDICT
    x{F832} @Defop CONFIGPARAM
    x{F833} @Defop CONFIGOPTPARAM
    x{F83400} @Defop PREVMCBLOCKS
    x{F83401} @Defop PREVKEYBLOCK
    x{F835} @Defop GLOBALID
    x{F836} @Defop GETGASFEE
    x{F837} @Defop GETSTORAGEFEE
    x{F838} @Defop GETFORWARDFEE
    x{F839} @Defop GETPRECOMPILEDGAS
    x{F83A} @Defop GETORIGINALFWDFEE
    x{F83B} @Defop GETGASFEESIMPLE
    x{F83C} @Defop GETFORWARDFEESIMPLE

    x{F840} @Defop GETGLOBVAR
    { dup 1 31 @rangechk <b x{F85_} s, swap 5 u, @addopb } : GETGLOB
    x{F860} @Defop SETGLOBVAR
    { dup 1 31 @rangechk <b x{F87_} s, swap 5 u, @addopb } : SETGLOB

    x{F900} @Defop HASHCU
    x{F901} @Defop HASHSU
    x{F902} @Defop SHA256U

    x{F904} @Defop(8u) HASHEXT
    x{F90400} @Defop HASHEXT_SHA256
    x{F90401} @Defop HASHEXT_SHA512
    x{F90402} @Defop HASHEXT_BLAKE2B
    x{F90403} @Defop HASHEXT_KECCAK256
    x{F90404} @Defop HASHEXT_KECCAK512
    x{F905} @Defop(8u) HASHEXTR
    x{F90500} @Defop HASHEXTR_SHA256
    x{F90501} @Defop HASHEXTR_SHA512
    x{F90502} @Defop HASHEXTR_BLAKE2B
    x{F90503} @Defop HASHEXTR_KECCAK256
    x{F90504} @Defop HASHEXTR_KECCAK512
    x{F906} @Defop(8u) HASHEXTA
    x{F90600} @Defop HASHEXTA_SHA256
    x{F90601} @Defop HASHEXTA_SHA512
    x{F90602} @Defop HASHEXTA_BLAKE2B
    x{F90603} @Defop HASHEXTA_KECCAK256
    x{F90604} @Defop HASHEXTA_KECCAK512
    x{F907} @Defop(8u) HASHEXTAR
    x{F90700} @Defop HASHEXTAR_SHA256
    x{F90701} @Defop HASHEXTAR_SHA512
    x{F90702} @Defop HASHEXTAR_BLAKE2B
    x{F90703} @Defop HASHEXTAR_KECCAK256
    x{F90704} @Defop HASHEXTAR_KECCAK512

    x{F910} @Defop CHKSIGNU
    x{F911} @Defop CHKSIGNS
    x{F912} @Defop ECRECOVER
    x{F914} @Defop P256_CHKSIGNU
    x{F915} @Defop P256_CHKSIGNS

    x{F920} @Defop RIST255_FROMHASH
    x{F921} @Defop RIST255_VALIDATE
    x{F922} @Defop RIST255_ADD
    x{F923} @Defop RIST255_SUB
    x{F924} @Defop RIST255_MUL
    x{F925} @Defop RIST255_MULBASE
    x{F926} @Defop RIST255_PUSHL

    x{B7F921} @Defop RIST255_QVALIDATE
    x{B7F922} @Defop RIST255_QADD
    x{B7F923} @Defop RIST255_QSUB
    x{B7F924} @Defop RIST255_QMUL
    x{B7F925} @Defop RIST255_QMULBASE

    x{F93000} @Defop BLS_VERIFY
    x{F93001} @Defop BLS_AGGREGATE
    x{F93002} @Defop BLS_FASTAGGREGATEVERIFY
    x{F93003} @Defop BLS_AGGREGATEVERIFY

    x{F93010} @Defop BLS_G1_ADD
    x{F93011} @Defop BLS_G1_SUB
    x{F93012} @Defop BLS_G1_NEG
    x{F93013} @Defop BLS_G1_MUL
    x{F93014} @Defop BLS_G1_MULTIEXP
    x{F93015} @Defop BLS_G1_ZERO
    x{F93016} @Defop BLS_MAP_TO_G1
    x{F93017} @Defop BLS_G1_INGROUP
    x{F93018} @Defop BLS_G1_ISZERO

    x{F93020} @Defop BLS_G2_ADD
    x{F93021} @Defop BLS_G2_SUB
    x{F93022} @Defop BLS_G2_NEG
    x{F93023} @Defop BLS_G2_MUL
    x{F93024} @Defop BLS_G2_MULTIEXP
    x{F93025} @Defop BLS_G2_ZERO
    x{F93026} @Defop BLS_MAP_TO_G2
    x{F93027} @Defop BLS_G2_INGROUP
    x{F93028} @Defop BLS_G2_ISZERO

    x{F93030} @Defop BLS_PAIRING
    x{F93031} @Defop BLS_PUSHR

    x{F940} @Defop CDATASIZEQ
    x{F941} @Defop CDATASIZE
    x{F942} @Defop SDATASIZEQ
    x{F943} @Defop SDATASIZE

    x{FA00} dup @Defop LDGRAMS @Defop LDVARUINT16
    x{FA01} @Defop LDVARINT16
    x{FA02} dup @Defop STGRAMS @Defop STVARUINT16
    x{FA03} @Defop STVARINT16

    x{FA04} @Defop LDVARUINT32 // (s -- x s')
    x{FA05} @Defop LDVARINT32  // (s -- x s')
    x{FA06} @Defop STVARUINT32 // (b x -- b')
    x{FA07} @Defop STVARINT32  // (b x -- b')

    x{FA40} @Defop LDMSGADDR
    x{FA41} @Defop LDMSGADDRQ
    x{FA42} @Defop PARSEMSGADDR
    x{FA43} @Defop PARSEMSGADDRQ
    x{FA44} @Defop REWRITESTDADDR
    x{FA45} @Defop REWRITESTDADDRQ
    x{FA46} @Defop REWRITEVARADDR
    x{FA47} @Defop REWRITEVARADDRQ

    x{FB00} @Defop SENDRAWMSG
    x{FB02} @Defop RAWRESERVE
    x{FB03} @Defop RAWRESERVEX
    x{FB04} @Defop SETCODE
    x{FB06} @Defop SETLIBCODE
    x{FB07} @Defop CHANGELIB
    x{FB08} @Defop SENDMSG

    //
    // debug primitives

    { dup 0 239 @-range abort"debug selector out of range"
      <b x{FE} s, swap 8 u, @addopb
    } : DEBUG
    { dup $len 1- <b x{FEF} s, swap 4 u, swap $, @addopb
    } : DEBUGSTR
    { over $len <b x{FEF} s, swap 4 u, swap 8 u, swap $, @addopb
    } : DEBUGSTRI

    x{FE00} @Defop DUMPSTK
    { 1 15 @rangechk <b x{FE0} s, swap 4 u, @addopb
    } : DUMPSTKTOP
    x{FE10} @Defop HEXDUMP
    x{FE11} @Defop HEXPRINT
    x{FE12} @Defop BINDUMP
    x{FE13} @Defop BINPRINT
    x{FE14} @Defop STRDUMP
    x{FE15} @Defop STRPRINT
    x{FE1E} @Defop DEBUGOFF
    x{FE1F} @Defop DEBUGON
    x{FE2} @Defop(s) DUMP
    x{FE3} @Defop(s) PRINT
    ' DEBUGSTR : DUMPTOSFMT
    { 0 DEBUGSTRI } : LOGSTR
    { 1 DEBUGSTRI } : PRINTSTR
    x{FEF000} @Defop LOGFLUSH

    //
    // codepage primitives
    x{FF00} @Defop SETCP0
    x{FFF0} @Defop SETCPX
    { dup -14 239 @-range abort"codepage out of range"
      255 and <b x{FF} s, swap 8 u, @addopb
    } : SETCP

    ' @addop : CUSTOMOP

    //
    // provisions for defining programs consisting of several mutually-recursive procedures
    //
    variable @proccnt
    variable @proclist
    variable @procdict
    variable @procinfo
    variable @gvarcnt
    variable @parent-state
    variable asm-mode  1 asm-mode !
    19 constant @procdictkeylen
    32 constant @zcount
    { pair @proclist @ cons @proclist ! } : @proclistadd
    { @procinfo @ @procdictkeylen idict@ { 16 i@ } { 0 } cond } : @procinfo@
    { <b rot 16 i, swap @procinfo @ @procdictkeylen b>idict!
      not abort"cannot add key to procedure info dictionary"
      @procinfo !
    } : @procinfo!
    // ( x v1 v2 -- )
    { not 2 pick @procinfo@ and xor swap @procinfo! } : @procinfo~!
    // ( s i f -- )
    { over @procdictkeylen fits not abort"procedure index out of range"
      over swap dup @procinfo~!  2dup @proclistadd
      1 'nop does swap 0 (create)
    } : @declproc
    { 1 'nop does swap 0 (create) } : @declglobvar
    { @proccnt @ 1+ dup @proccnt ! 1 @declproc } : @newproc
    { @gvarcnt @ 1+ dup @gvarcnt ! @declglobvar } : @newglobvar
    variable @oldcurrent  variable @oldctx
    Fift-wordlist dup @oldcurrent ! @oldctx !
    { current@ @oldcurrent !  context@ @oldctx !  Asm definitions
      @proccnt @ @proclist @ @procdict @ @procinfo @ @gvarcnt @ @parent-state @ current@ @oldcurrent @ @oldctx @
      9 tuple @parent-state !
      hole current!
      0 =: main  @proclist null!  @proccnt 0!  @gvarcnt 0!
      { bl word @newproc } : NEWPROC
      { bl word dup (def?) ' drop ' @newproc cond } : DECLPROC
      { bl word dup find
        { nip execute <> abort"method redefined with different id" }
        { swap 17 @declproc }
      cond } : DECLMETHOD
      { bl word @newglobvar } : DECLGLOBVAR
      "main" 0 @proclistadd
      dictnew dup @procdict !
      @procinfo !  16 0 @procinfo!
    } : PROGRAM{
    { over sbits < { s>c <b swap ref, b> <s } if } : @adj-long-proc
    { // i s l
      dup 0< {
        negate
        @was-split @ { drop 0 } if
      } if
      @adj-long-proc over @procdict @ @procdictkeylen
      idict!+ not abort"cannot define procedure, redefined?"
      @procdict !  2 2 @procinfo~!
    } : @def-proc
    { @procinfo @ null? not } : @have-procinfo?
    { @have-procinfo? { 4 4 @procinfo~! } { drop } cond } : @proc-inlined
    { @have-procinfo? { 8 8 @procinfo~! } { drop } cond } : @proc-called
    { 1000 @def-proc } : PROC
    { 0 @def-proc } : PROCREF
    { -1000 @def-proc } : PROCINLINE
    { @procdict @ @procdictkeylen idict@ abort"procedure already defined"
    } : @fail-ifdef
    { u@?+ { swap abort"first bits are not zeroes" } if } : @cut-zeroes
    { over @fail-ifdef
      2 { rot @normal? rot b> <s @zcount @cut-zeroes swap @def-proc drop } does
      null swap @doafter<{ 0 @zcount u,
    } : @PROC:<{
    { 1000 @PROC:<{ } : PROC:<{
    { 0 @PROC:<{ } : PROCREF:<{
    { -1000 @PROC:<{ } : PROCINLINE:<{
    { dup @proc-called CALLDICT } dup : CALL : CALLDICT
    { dup @proc-called JMPDICT } dup : JMP : JMPDICT
    { dup @proc-called PREPAREDICT } dup : PREPARE : PREPAREDICT
    { dup @procdict @ @procdictkeylen idict@
      { swap @proc-inlined INLINE } { CALLDICT } cond
    } dup : INLINECALL : INLINECALLDICT
    { 0 @procdict @ @procdictkeylen idict@ not abort"`main` procedure not defined" drop
    } : @chkmaindef
    { @procdict @ @procdictkeylen idict- drop @procdict ! } : @remove-proc
    { ."Procedure `" over type ."` index=" 2 pick . ." flags=0x" dup x. cr } : @showprocinfo
    // ( proc_name proc_idx f -- )  f:+1=declared, +2=defined, +4=inlined, +8=called, +16=method
    { // @showprocinfo
      dup 0x1a and 2 = asm-mode @ 3 and and ?dup {
        2 and {
          over ."Warning: removing (inlined) procedure `" type ."` from call dictionary" cr
        } if
        2 pick @remove-proc
      } if  // remove unused procs
      dup 0xc and 0xc = asm-mode @ 4 and and {
        over ."Warning: inline procedure `" type ."` is not always inlined" cr
      } if
      dup 0x1e and 2 = asm-mode @ 8 and and {
        over ."Warning: procedure `" type ."` defined but not used" cr
      } if
      drop 2drop
    } : @chkprocdef
    { @chkmaindef
      @proclist @ { dup null? not } {
        uncons swap unpair over find not
        { drop +": undefined procedure name in list" abort } if
        drop tuck @procdict @ @procdictkeylen idict@ not
        { +": procedure declared but left undefined" abort } if
        drop swap 2dup @procinfo@ @chkprocdef (forget)
      } while
      drop @proclist null! @procinfo null! @proccnt 0!
      @procdict dup @ swap null!
      @parent-state @ dup null? { drop } {
        9 untuple
        @oldctx ! @oldcurrent ! current! @parent-state ! @gvarcnt ! @procinfo ! @procdict ! @proclist ! @proccnt !
      } cond
      @oldctx @ context!  @oldcurrent @ current!
    } : }END
    forget @proclist  forget @proccnt
    { }END <{ SETCP0 swap @procdictkeylen DICTPUSHCONST DICTIGETJMPZ 11 THROWARG }> } : }END>
    { }END> b> } : }END>c
    { }END>c <s } : }END>s

    0 constant recv_internal
    -1 constant recv_external
    -2 constant run_ticktock
    -3 constant split_prepare
    -4 constant split_install

    { asm-mode 0 3 ~! } : asm-no-remove-unused
    { asm-mode 1 1 ~! } : asm-remove-unused   // enabled by default
    { asm-mode 3 3 ~! } : asm-warn-remove-unused
    { asm-mode 4 4 ~! } : asm-warn-inline-mix
    { asm-mode 0 4 ~! } : asm-no-warn-inline-mix  // disabled by default
    { asm-mode 8 8 ~! } : asm-warn-unused
    { asm-mode 0 8 ~! } : asm-no-warn-unused  // disabled by default

    // ( c -- )   add vm library for later use with runvmcode
    { <b over ref, b> <s swap hash vmlibs @ 256 udict! not abort"cannot add library" vmlibs ! } : add-lib
    // ( x -- c ) make library reference cell
    { <b 2 8 u, swap 256 u, b>spec } : hash>libref
    // ( c -- c' )
    { hash hash>libref } : >libref

    { dup "." $pos dup -1 =
         { drop 0 }
         { $| 1 $| nip swap (number) 1- abort"invalid version"
           dup dup 0 < swap 999 > or abort"invalid version"
         }
         cond
    } : parse-version-level

    {
      0 swap
      "." $+
      { swap 1000 * swap parse-version-level rot + swap } 3 times
      "" $= not abort"invalid version"
    } : parse-asm-fif-version

    {
      dup =: required-version parse-asm-fif-version
      asm-fif-version parse-asm-fif-version
      = 1+ {
          "Required Asm.fif version: " @' required-version "; actual Asm.fif version: " asm-fif-version $+ $+ $+ abort
        } if
    } : require-asm-fif-version

    {
      dup =: required-version parse-asm-fif-version
      asm-fif-version parse-asm-fif-version
      swap
      >= 1+ {
          "Required Asm.fif version: " @' required-version "; actual Asm.fif version: " asm-fif-version $+ $+ $+ abort
        } if
    } : require-asm-fif-version>=


    Fift definitions Asm
    ' <{ : <{
    ' PROGRAM{ : PROGRAM{
    ' asm-fif-version : asm-fif-version
    ' require-asm-fif-version : require-asm-fif-version
    ' require-asm-fif-version>= : require-asm-fif-version>=
    Fift
}


## embed-fift-fif.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-asm/embed-fift-fif.tact)
/// Tests parsing of Fift.fif by embedding its contents
asm fun embedFiftFif() {
    { 0 word drop 0 'nop } :: //
    { char " word 1 { swap { abort } if drop } } ::_ abort"
    { { bl word dup "" $= abort"comment extends after end of file" "*/" $= } until 0 'nop } :: /*
    // { bl word 1 2 ' (create) } "::" 1 (create)
    // { bl word 0 2 ' (create) } :: :
    // { bl word 2 2 ' (create) } :: :_
    // { bl word 3 2 ' (create) } :: ::_
    // { bl word 0 (create) } : create
    // { bl word (forget) } : forget
    { bl word 1 ' (forget) } :: [forget]
    { char " word 1 ' type } ::_ ."
    { char } word x>B 1 'nop } ::_ B{
    { swap ({) over 2+ -roll swap (compile) (}) } : does
    { 1 'nop does create } : constant
    { 2 'nop does create } : 2constant
    { hole constant } : variable
    10 constant ten
    { bl word 1 { find 0= abort"word not found" } } :: (')
    { bl word find not abort"-?" 0 swap } :: [compile]
    { bl word 1 {
      dup find { " -?" $+ abort } ifnot nip execute
    } } :: @'
    { bl word 1 { swap 1 'nop does swap 0 (create) }
    } :: =:
    { bl word 1 { -rot 2 'nop does swap 0 (create) }
    } :: 2=:
    { <b swap s, b> } : s>c
    { s>c hashB } : shash
    // to be more efficiently re-implemented in C++ in the future
    { dup 0< ' negate if } : abs
    { 2dup > ' swap if } : minmax
    { minmax drop } : min
    { minmax nip } : max
    "" constant <#
    ' $reverse : #>
    { swap 10 /mod char 0 + rot swap hold } : #
    { { # over 0<= } until } : #s
    { 0< { char - hold } if } : sign
    // { dup abs <# #s rot sign #> nip } : (.)
    // { (.) type } : ._
    // { ._ space } : .
    { dup 10 < { 48 } { 55 } cond + } : Digit
    { dup 10 < { 48 } { 87 } cond + } : digit
    // x s b -- x' s'
    { rot swap /mod Digit rot swap hold } : B#
    { rot swap /mod digit rot swap hold } : b#
    { 16 B# } : X#
    { 16 b# } : x#
    // x s b -- 0 s'
    { -rot { 2 pick B# over 0<= } until rot drop } : B#s
    { -rot { 2 pick b# over 0<= } until rot drop } : b#s
    { 16 B#s } : X#s
    { 16 b#s } : x#s
    variable base
    { 10 base ! } : decimal
    { 16 base ! } : hex
    { 8 base ! } : octal
    { 2 base ! } : binary
    { base @ B# } : Base#
    { base @ b# } : base#
    { base @ B#s } : Base#s
    { base @ b#s } : base#s
    // x w -- s
    { over abs <# rot 1- ' X# swap times X#s rot sign #> nip } : (0X.)
    { over abs <# rot 1- ' x# swap times x#s rot sign #> nip } : (0x.)
    { (0X.) type } : 0X._
    { 0X._ space } : 0X.
    { (0x.) type } : 0x._
    { 0x._ space } : 0x.
    { bl (-trailing) } : -trailing
    { char 0 (-trailing) } : -trailing0
    { char " word 1 ' $+ } ::_ +"
    { find 0<> dup ' nip if } : (def?)
    { bl word 1 ' (def?) } :: def?
    { bl word 1 { (def?) not } } :: undef?
    { def? ' skip-to-eof if } : skip-ifdef
    { bl word dup (def?) { drop skip-to-eof } { 'nop swap 0 (create) } cond } : library
    { bl word dup (def?) { 2drop skip-to-eof } { swap 1 'nop does swap 0 (create) } cond } : library-version
    { hole dup 1 'nop does swap 1 { context! } does bl word tuck 0 (create) +"-wordlist" 0 (create) } : namespace
    { context@ current! } : definitions
    { char ) word "$" swap $+ 1 { find 0= abort"undefined parameter" execute } } ::_ $(
    // b s -- ?
    { sbitrefs rot brembitrefs rot >= -rot <= and } : s-fits?
    // b s x -- ?
    { swap sbitrefs -rot + rot brembitrefs -rot <= -rot <= and } : s-fits-with?
    { 0 swap ! } : 0!
    { tuck @ + swap ! } : +!
    { tuck @ swap - swap ! } : -!
    { 1 swap +! } : 1+!
    { -1 swap +! } : 1-!
    { null swap ! } : null!
    { not 2 pick @ and xor swap ! } : ~!
    0 tuple constant nil
    { 1 tuple } : single
    { 2 tuple } : pair
    { 3 tuple } : triple
    { 1 untuple } : unsingle
    { 2 untuple } : unpair
    { 3 untuple } : untriple
    { over tuple? { swap count = } { 2drop false } cond } : tuple-len?
    { 0 tuple-len? } : nil?
    { 1 tuple-len? } : single?
    { 2 tuple-len? } : pair?
    { 3 tuple-len? } : triple?
    { 0 [] } : first
    { 1 [] } : second
    { 2 [] } : third
    ' pair : cons
    ' unpair : uncons
    { 0 [] } : car
    { 1 [] } : cdr
    { cdr car } : cadr
    { cdr cdr } : cddr
    { cdr cdr car } : caddr
    { null ' cons rot times } : list
    { -rot pair swap ! } : 2!
    { @ unpair } : 2@
    { true (atom) drop } : atom
    { bl word atom 1 'nop } ::_ `
    { hole dup 1 { @ execute } does create } : recursive
    { 0 { 1+ dup 1 ' $() does over (.) "$" swap $+ 0 (create) } rot times drop } : :$1..n
    { 10 hold } : +cr
    { 9 hold } : +tab
    { "" swap { 0 word 2dup $cmp } { rot swap $+ +cr swap } while 2drop } : scan-until-word
    { 0 word -trailing scan-until-word 1 'nop } ::_ $<<
    { 0x40 runvmx } : runvmcode
    { 0x48 runvmx } : gasrunvmcode
    { 0xc8 runvmx } : gas2runvmcode
    { 0x43 runvmx } : runvmdict
    { 0x4b runvmx } : gasrunvmdict
    { 0xcb runvmx } : gas2runvmdict
    { 0x45 runvmx } : runvm
    { 0x4d runvmx } : gasrunvm
    { 0xcd runvmx } : gas2runvm
    { 0x55 runvmx } : runvmctx
    { 0x5d runvmx } : gasrunvmctx
    { 0xdd runvmx } : gas2runvmctx
    { 0x75 runvmx } : runvmctxact
    { 0x7d runvmx } : gasrunvmctxact
    { 0xfd runvmx } : gas2runvmctxact
    { 0x35 runvmx } : runvmctxactq
    { 0x3d runvmx } : gasrunvmctxactq
}

// NOTE: FiftExt.fif isn't added to the test suite, because of two reasons:
// 1. It shadows the most important instructions for parsing: { and }
//    That is, that shadowing uses out-of-place } and {, which cannot be allowed in the current (stackless and non-typechecking) version of the parser
// 2. That file isn't included into any smart contracts in TON monorepo (except for tests). Moreover, in third-party code on Github, it occurs only once — in a test .fif code, not the actual one.


## embed-other-libs-fif.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-asm/embed-other-libs-fif.tact)
//
// Color.fif
//

/// Tests parsing of Color.fif by embedding its contents
asm fun embedColorFif() {
    library Color
    { 27 emit } : esc
    
{ char " word 27 chr swap $+ 1 ' type does create } :_ make-esc"
    
make-esc"[0m" ^reset
    
make-esc"[30m" ^black
    
make-esc"[31m" ^red
    
make-esc"[32m" ^green
    make-esc"[33m" ^yellow
    make-esc"[34m" ^blue
    make-esc"[35m" ^magenta
    make-esc"[36m" ^cyan
    make-esc"[37m" ^white
    
// bold
    make-esc"[30;1m" ^Black
    make-esc"[31;1m" ^Red
    make-esc"[32;1m" ^Green
    make-esc"[33;1m" ^Yellow
    make-esc"[34;1m" ^Blue
    make-esc"[35;1m" ^Magenta
    make-esc"[36;1m" ^Cyan
    make-esc"[37;1m" ^White
}

//
// Disasm.fif
//

/// Tests parsing of Disasm.fif by embedding its contents
asm fun embedDisasmFif() {
    library TVM_Disasm
    // simple TVM Disassembler
    "Lists.fif" include

    variable 'disasm
    { 'disasm @ execute } : disasm  // disassemble a slice
    // usage: x{74B0} disasm

    variable @dismode  @dismode 0!
    { rot over @ and rot xor swap ! } : andxor!
    { -2 0 @dismode andxor! } : stack-disasm  // output 's1 s4 XCHG'
    { -2 1 @dismode andxor! } : std-disasm    // output 'XCHG s1, s4'
    { -3 2 @dismode andxor! } : show-vm-code
    { -3 0 @dismode andxor! } : hide-vm-code
    { @dismode @ 1 and 0= } : stack-disasm?

    variable @indent  @indent 0!
    { ' space @indent @ 2* times } : .indent
    { @indent 1+! } : +indent
    { @indent 1-! } : -indent

    { " " $pos } : spc-pos
    { dup " " $pos swap "," $pos dup 0< { drop } {
      over 0< { nip } { min } cond } cond
    } : spc-comma-pos
    { { dup spc-pos 0= } { 1 $| nip } while } : -leading
    { -leading -trailing dup spc-pos dup 0< {
      drop dup $len { atom single } { drop nil } cond } {
        $| swap atom swap -leading 2 { over spc-comma-pos dup 0>= } {
          swap 1+ -rot $| 1 $| nip -leading rot
        } while drop tuple
      } cond
    } : parse-op
    { dup "s-1" $= { drop "s(-1)" true } {
      dup "s-2" $= { drop "s(-2)" true } {
      dup 1 $| swap "x" $= { nip "x{" swap $+ +"}" true } {
      2drop false } cond } cond } cond
    } : adj-op-arg
    { over count over <= { drop } { 2dup [] adj-op-arg { swap []= } { drop } cond } cond } : adj-arg[]
    { 1 adj-arg[] 2 adj-arg[] 3 adj-arg[]
      dup first
      dup `XCHG eq? {
        drop dup count 2 = { tpop swap "s0" , swap , } if } {
      dup `LSHIFT eq? {
        drop dup count 2 = stack-disasm? and { second `LSHIFT# swap pair } if } {
      dup `RSHIFT eq? {
        drop dup count 2 = stack-disasm? and { second `RSHIFT# swap pair } if } {
      drop
      } cond } cond } cond
    } : adjust-op

    variable @cp  @cp 0!
    variable @curop
    variable @contX  variable @contY  variable @cdict

    { atom>$ type } : .atom
    { dup first .atom dup count 1 > { space 0 over count 2- { 1+ 2dup [] type .", " } swap times 1+ [] type } { drop } cond } : std-show-op
    { 0 over count 1- { 1+ 2dup [] type space } swap times drop first .atom } : stk-show-op
    { @dismode @ 2 and { .indent ."// " @curop @ csr. } if } : .curop?
    { .curop? .indent @dismode @ 1 and ' std-show-op ' stk-show-op cond cr
    } : show-simple-op
    { dup 4 u@ 9 = { 8 u@+ swap 15 and 3 << s@ } {
      dup 7 u@ 0x47 = { 7 u@+ nip 2 u@+ 7 u@+ -rot 3 << swap sr@ } {
      dup 8 u@ 0x8A = { ref@ <s } {
      abort"invalid PUSHCONT"
      } cond } cond } cond
    } : get-cont-body
    { 14 u@+ nip 10 u@+ ref@ dup rot pair swap <s empty? { drop null } if } : get-const-dict
    { @contX @ @contY @ @contX ! @contY ! } : scont-swap
    { .indent swap type type cr @contY @ @contY null! @contX @ @contX null!
      +indent disasm -indent @contY !
    } : show-cont-bodyx
    { ":<{" show-cont-bodyx .indent ."}>" cr } : show-cont-op
    { swap scont-swap ":<{" show-cont-bodyx scont-swap
      "" show-cont-bodyx .indent ."}>" cr } : show-cont2-op

    { @contX @ null? { "CONT" show-cont-op } ifnot
    } : flush-contX
    { @contY @ null? { scont-swap "CONT" show-cont-op scont-swap } ifnot
    } : flush-contY
    { flush-contY flush-contX } : flush-cont
    { @contX @ null? not } : have-cont?
    { @contY @ null? not } : have-cont2?
    { flush-contY @contY ! scont-swap } : save-cont-body

    { @cdict ! } : save-const-dict
    { @cdict null! } : flush-dict
    { @cdict @ null? not } : have-dict?

    { flush-cont .indent type .":<{" cr
      @curop @ ref@ <s +indent disasm -indent .indent ."}>" cr
    } : show-ref-op
    { flush-contY .indent rot type .":<{" cr
      @curop @ ref@ <s @contX @ @contX null! rot ' swap if
      +indent disasm -indent .indent swap type cr
      +indent disasm -indent .indent ."}>" cr
    } : show-cont-ref-op
    { flush-cont .indent swap type .":<{" cr
      @curop @ ref@+ <s +indent disasm -indent .indent swap type cr
      ref@ <s +indent disasm -indent .indent ."}>" cr
    } : show-ref2-op

    { flush-cont first atom>$ dup 5 $| drop "DICTI" $= swap
      .indent type ." {" cr +indent @cdict @ @cdict null! unpair
      rot {
        swap .indent . ."=> <{" cr +indent disasm -indent .indent ."}>" cr true
      } swap ' idictforeach ' dictforeach cond drop
      -indent .indent ."}" cr
    } : show-const-dict-op

    ( `PUSHCONT `PUSHREFCONT ) constant @PushContL
    ( `REPEAT `UNTIL `IF `IFNOT `IFJMP `IFNOTJMP ) constant @CmdC1
    ( `IFREF `IFNOTREF `IFJMPREF `IFNOTJMPREF `CALLREF `JMPREF ) constant @CmdR1
    ( `DICTIGETJMP `DICTIGETJMPZ `DICTUGETJMP `DICTUGETJMPZ `DICTIGETEXEC `DICTUGETEXEC ) constant @JmpDictL
    { dup first `DICTPUSHCONST eq? {
        flush-cont @curop @ get-const-dict save-const-dict show-simple-op } {
      dup first @JmpDictL list-member? have-dict? and {
        flush-cont show-const-dict-op } {
      flush-dict
      dup first @PushContL list-member? {
        drop @curop @ get-cont-body save-cont-body } {
      dup first @CmdC1 list-member? have-cont? and {
        flush-contY first atom>$ .curop? show-cont-op } {
      dup first @CmdR1 list-member? {
        flush-cont first atom>$ dup $len 3 - $| drop .curop? show-ref-op } {
      dup first `WHILE eq? have-cont2? and {
        drop "WHILE" "}>DO<{" .curop? show-cont2-op } {
      dup first `IFELSE eq? have-cont2? and {
        drop "IF" "}>ELSE<{" .curop? show-cont2-op } {
      dup first dup `IFREFELSE eq? swap `IFELSEREF eq? or have-cont? and {
        first `IFREFELSE eq? "IF" "}>ELSE<{" rot .curop? show-cont-ref-op } {
      dup first `IFREFELSEREF eq? {
        drop "IF" "}>ELSE<{" .curop? show-ref2-op } {
        flush-cont show-simple-op
      } cond } cond } cond } cond } cond } cond } cond } cond } cond
    } : show-op
    { dup @cp @ (vmoplen) dup 0> { 65536 /mod swap sr@+ swap dup @cp @ (vmopdump) parse-op swap s> true } { drop false } cond } : fetch-one-op
    { { fetch-one-op } { swap @curop ! adjust-op show-op } while } : disasm-slice
    { { disasm-slice dup sbitrefs 1- or 0= } { ref@ <s } while flush-dict flush-cont } : disasm-chain
    { @curop @ swap disasm-chain dup sbitrefs or { .indent ."Cannot disassemble: " csr. } { drop } cond @curop ! }
    'disasm !
}

//
// Lists.fif
//

/// Tests parsing of Lists.fif by embedding its contents
asm fun embedListsFif() {
    library Lists  // List utilities
    //
    { hole dup 1 { @ execute } does create } : recursive
    // x x' -- ?  recursively compares two S-expressions
    recursive equal? {
      dup tuple? {
        over tuple? {
          over count over count over = { // t t' l ?
            0 { dup 0>= { 2dup [] 3 pick 2 pick [] equal? { 1+ } { drop -1 } cond
                } if } rot times
            nip nip 0>=
          } { drop 2drop false } cond
        } { 2drop false } cond
      } { eqv? } cond
    } swap !
    // (a1 .. an) -- (an .. a1)
    { null swap { dup null? not } { uncons swap rot cons swap } while drop } : list-reverse
    // (a1 .. an) -- an   Computes last element of non-empty list l
    { { uncons dup null? { drop true } { nip false } cond } until } : list-last
    // l l' -- l++l'  Concatenates two lists
    recursive list+ {
      over null? { nip } { swap uncons rot list+ cons } cond
    } swap !
    // l l' -- l'' -1 or 0, where l = l' ++ l''
    // Removes prefix from list
    { { dup null? { drop true true } {
      swap dup null? { 2drop false true } { // l' l
      uncons swap rot uncons -rot equal? { false } {
      2drop false true
      } cond } cond } cond } until
    } : list-
    // (a1 .. an) -- a1 .. an n   Explodes a list
    { 0 { over null? not } { swap uncons rot 1+ } while nip } : explode-list
    // (a1 .. an) x -- a1 .. an n x   Explodes a list under the topmost element
    { swap explode-list dup 1+ roll } : explode-list-1
    // l -- t   Transforms a list into a tuple with the same elements
    { explode-list tuple } : list>tuple
    // a1 ... an n x -- (a1 .. an) x
    { null swap rot { -rot cons swap } swap times } : mklist-1
    // (s1 ... sn) -- s1+...+sn   Concatenates a list of strings
    { "" { over null? not } { swap uncons -rot $+ } while nip
    } : concat-string-list
    // (x1 ... xn) -- x1+...+xn   Sums a list of integers
    { 0 { over null? not } { swap uncons -rot + } while nip
    } : sum-list
    // (a1 ... an) a e -- e(...e(e(a,a1),a2),...),an)
    { -rot { over null? not } { swap uncons -rot 3 pick execute } while nip nip
    } : foldl
    // (a1 ... an) e -- e(...e(e(a1,a2),a3),...),an)
    { swap uncons swap rot foldl } : foldl-ne
    // (a1 ... an) a e -- e(a1,e(a2,...,e(an,a)...))
    recursive foldr {
      rot dup null? { 2drop } {
        uncons -rot 2swap swap 3 pick foldr rot execute
      } cond
    } swap !
    // (a1 ... an) e -- e(a1,e(a2,...,e(a[n-1],an)...))
    recursive foldr-ne {
      over cdr null? { drop car } {
        swap uncons 2 pick foldr-ne rot execute
      } cond
    } swap !
    // (l1 ... ln) -- l1++...++ln   Concatenates a list of lists
    { dup null? { ' list+ foldr-ne } ifnot } : concat-list-lists
    // (a1 .. an . t) n -- t   Computes the n-th tail of a list
    { ' cdr swap times } : list-tail
    // (a0 .. an ..) n -- an   Computes the n-th element of a list
    { list-tail car } : list-ref
    // l -- ?
    { { dup null? { drop true true } {
        dup pair? { cdr false } {
        drop false true
      } cond } cond } until
    } : list?
    // l -- n
    { 0 { over null? not } { 1+ swap uncons nip swap } while nip
    } : list-length
    // l e -- t  // returns tail of l after first member that satisfies e
    { swap {
      dup null? { nip true } {
      tuck car over execute { drop true } {
      swap cdr false
      } cond } cond } until
    } : list-tail-from
    // a l -- t  // tail of l after first occurence of a using eq?
    { swap 1 ' eq? does list-tail-from } : list-member-eq
    { swap 1 ' eqv? does list-tail-from } : list-member-eqv
    { swap 1 ' equal? does list-tail-from } : list-member-equal
    // a l -- ?
    { list-member-eq null? not } : list-member?
    { list-member-eqv null? not } : list-member-eqv?
    // l -- a -1 or 0 // returns car l if l is non-empty
    { dup null? { drop false } { car true } cond
    } : safe-car
    { dup null? { drop false } { car second true } cond
    } : get-first-value
    // l e -- v -1 or 0
    { list-tail-from safe-car } : assoc-gen
    { list-tail-from get-first-value } : assoc-gen-x
    // a l -- (a.v) -1 or 0 -- returns first entry (a . v) in l
    { swap 1 { swap first eq? } does assoc-gen } : assq
    { swap 1 { swap first eqv? } does assoc-gen } : assv
    { swap 1 { swap first equal? } does assoc-gen } : assoc
    // a l -- v -1 or 0 -- returns v from first entry (a . v) in l
    { swap 1 { swap first eq? } does assoc-gen-x } : assq-val
    { swap 1 { swap first eqv? } does assoc-gen-x } : assv-val
    { swap 1 { swap first equal? } does assoc-gen-x } : assoc-val
    // (a1 .. an) e -- (e(a1) .. e(an))
    recursive list-map {
      over null? { drop } {
      swap uncons -rot over execute -rot list-map cons
      } cond
    } swap !

    variable ctxdump  variable curctx
    // (a1 .. an) e -- executes e for a1, ..., an
    { ctxdump @ curctx @ ctxdump 2! curctx 2!
      { curctx 2@ over null? not } { swap uncons rot tuck curctx 2! execute }
      while 2drop ctxdump 2@ curctx ! ctxdump !
    } : list-foreach
    forget ctxdump  forget curctx

    //
    // Experimental implementation of `for` loops with index
    //
    variable loopdump  variable curloop
    { curloop @ loopdump @ loopdump 2! } : push-loop-ctx
    { loopdump 2@ loopdump ! curloop ! } : pop-loop-ctx
    // ilast i0 e -- executes e for i=i0,i0+1,...,ilast-1
    { -rot 2dup > {
        push-loop-ctx {
          triple dup curloop ! first execute curloop @ untriple 1+ 2dup <=
        } until pop-loop-ctx
      } if 2drop drop
    } : for
    // ilast i0 e -- same as 'for', but pushes current index i before executing e
    { -rot 2dup > {
        push-loop-ctx {
          triple dup curloop ! untriple nip swap execute curloop @ untriple 1+ 2dup <=
        } until pop-loop-ctx
      } if 2drop drop
    } : for-i
    // ( -- i )  Returns innermost loop index
    { curloop @ third } : i
    // ( -- j )  Returns outer loop index
    { loopdump @ car third } : j
    { loopdump @ cadr third } : k
    forget curloop  forget loopdump

    //
    // create Lisp-style lists using words "(" and ")"
    //
    variable ')
    'nop box constant ',
    { ") without (" abort } ') !
    { ') @ execute } : )
    anon constant dot-marker
    // m x1 ... xn t m -- (x1 ... xn . t)
    { swap
      { -rot 2dup eq? not }
      { over dot-marker eq? abort"invalid dotted list"
        swap rot cons } while 2drop
    } : list-tail-until-marker
    // m x1 ... xn m -- (x1 ... xn)
    { null swap list-tail-until-marker } : list-until-marker
    { over dot-marker eq? { nip 2dup eq? abort"invalid dotted list" }
      { null swap } cond
      list-tail-until-marker
    } : list-until-marker-ext
    { ') @ ', @ } : ops-get
    { ', ! ') ! } : ops-set
    { anon dup ops-get 3 { ops-set list-until-marker-ext } does ') ! 'nop ', !
    } : (
    // test of Lisp-style lists
    // ( 42 ( `+ 9 ( `* 3 4 ) ) "test" ) .l cr
    // ( `eq? ( `* 3 4 ) 3 4 * ) .l cr
    // `alpha ( `beta `gamma `delta ) cons .l cr
    // { ( `eq? ( `* 3 5 pick ) 3 4 roll * ) } : 3*sample
    // 17 3*sample .l cr

    // similar syntax _( x1 .. xn ) for tuples
    { 2 { 1+ 2dup pick eq? } until 3 - nip } : count-to-marker
    { count-to-marker tuple nip } : tuple-until-marker
    { anon dup ops-get 3 { ops-set tuple-until-marker } does ') ! 'nop ', ! } : _(
    // test of tuples
    // _( _( 2 "two" ) _( 3 "three" ) _( 4 "four" ) ) .dump cr

    // pseudo-Lisp tokenizer
    "()[]'" 34 hold constant lisp-delims
    { lisp-delims 11 (word) } : lisp-token
    { null cons `quote swap cons } : do-quote
    { 1 { ', @ 2 { 2 { ', ! execute ', @ execute } does ', ! }
          does ', ! } does
    } : postpone-prefix
    { ', @ 1 { ', ! } does ', ! } : postpone-',
    ( `( ' ( pair
      `) ' ) pair
      `[ ' _( pair
      `] ' ) pair
      `' ' do-quote postpone-prefix pair
      `. ' dot-marker postpone-prefix pair
      `" { char " word } pair
      `;; { 0 word drop postpone-', } pair
    ) constant lisp-token-dict
    variable eol
    { eol @ eol 0! anon dup ') @ 'nop 3
      { ops-set list-until-marker-ext true eol ! } does ') ! rot ', !
      { lisp-token dup (number) dup { roll drop } {
          drop atom dup lisp-token-dict assq { nip second execute } if
        } cond
        ', @ execute
        eol @
      } until
      -rot eol ! execute
    } :_ List-generic(
    { 'nop 'nop List-generic( } :_ LIST(
    // LIST((lambda (x) (+ x 1)) (* 3 4))
    // LIST('(+ 3 4))
    // LIST(2 3 "test" . 9)
    // LIST((process '[plus 3 4]))
}

//
// TonUtil.fif
//

/// Tests parsing of TonUtil.fif by embedding its contents
asm fun embedTonUtilFif() {
    library TonUtil // TON Blockchain Fift Library
    "Lists.fif" include

    -1 constant Masterchain
    0 constant Basechain

    // parse workchain id
    // ( S -- workchain )
    { (number) 1- abort"workchain id must be an integer"
      dup 32 fits not abort"workchain id must fit in 32 bits"
    } : parse-workchain-id

    { (number) 1- abort"integer expected" } : parse-int

    { over null? ' swap if drop } : replace-if-null

    // Private key load/generate
    // ( fname -- pubkey privkey )
    { dup ."Loading private key from file " type cr
      file>B dup Blen 32 <> abort"Private key must be exactly 32 bytes long"
      dup priv>pub swap
    } : load-keypair
    // ( fname -- pubkey privkey )
    { dup file-exists?
      { load-keypair }
      { dup newkeypair swap rot over swap B>file
        rot ."Saved new private key to file " type cr
      } cond
    } : load-generate-keypair

    // Parse smart-contract address
    // ( S -- workchain addr bounce? )
    { $>smca not abort"invalid smart-contract address"
      1 and 0=
    } : parse-smc-addr

    // ( x -- ) Displays a 64-digit hex number
    { 64 0x. } : 64x.
    { 64 0X. } : 64X.
    // ( wc addr -- )  Show address in <workchain>:<account> form
    { swap ._ .":" 64x. } : .addr
    // ( wc addr flags -- )  Show address in base64url form
    { smca>$ type } : .Addr
    // ( wc addr fname -- )  Save address to file in 36-byte format
    { -rot 256 u>B swap 32 i>B B+ swap B>file } : save-address
    // ( wc addr fname -- )  Save address and print message
    { dup ."(Saving address to file " type .")" cr save-address
    } : save-address-verbose

    // ( fname -- wc addr )  Load address from file
    { file>B 32 B|
      dup Blen { 32 B>i@ } { drop Basechain } cond
      swap 256 B>u@
    } : load-address
    // ( fname -- wc addr )  Load address from file and print message
    { dup ."(Loading address from file " type .")" cr load-address
    } : load-address-verbose
    // Parse string as address or load address from file (if string is prefixed by @)
    // ( S default-bounce -- workchain addr bounce? )
    { over $len 0= abort"empty smart-contract address"
      swap dup 1 $| swap "@" $=
      { nip load-address rot } { drop nip parse-smc-addr } cond
    } : parse-load-address

    // ( hex-str -- addr )  Parses ADNL address
    { dup $len 64 <> abort"ADNL address must consist of exactly 64 hexadecimal characters"
      (hex-number) 1 <> abort"ADNL address must consist of 64 hexadecimal characters"
      dup 256 ufits not abort"invalid ADNL address"
    } : parse-adnl-address

    // ( b wc addr -- b' )  Serializes address into Builder b
    { -rot 8 i, swap 256 u, } : addr,
    { over 8 fits { rot b{100} s, -rot addr, } {
      rot b{110} s, 256 9 u, rot 32 i, swap 256 u, } cond
    } : Addr,

    // Gram utilities
    1000000000 constant Gram
    { Gram swap */r } : Gram*/
    { Gram * } : Gram*
    { (number) dup { 1- ' Gram*/ ' Gram* cond true } if
    } : $>GR?
    // ( S -- nanograms )
    { $>GR? not abort"not a valid Gram amount"
    } : $>GR
    { bl word $>GR 1 'nop } ::_ GR$
    // ( nanograms -- S )
    { dup abs <# ' # 9 times char . hold #s rot sign #>
    nip -trailing0 } : (.GR)
    { (.GR) ."GR$" type } : .GR_
    { .GR_ space } : .GR

    // b x -- b'  ( serializes a Gram amount )
    { -1 { 1+ 2dup 8 * ufits } until
      rot over 4 u, -rot 8 * u, } : Gram,
    // s -- x s'  ( deserializes a Gram amount )
    { 4 u@+ swap 8 * u@+ } : Gram@+
    // s -- x
    { 4 u@+ swap 8 * u@ } : Gram@

    // currency collections
    // b x --> b'  ( serializes a VarUInteger32 )
    { -1 { 1+ 2dup 8 * ufits } until
      rot over 5 u, -rot 8 * u, } : VarUInt32,
    // s --> x  ( deserializes a VarUInteger32 )
    { 5 u@+ swap 8 * u@ } : VarUInt32@
    32 constant cc-key-bits
    ' VarUInt32, : val,
    ' VarUInt32@ : val@
    // d k v -- d'
    { <b swap val, b> <s swap rot cc-key-bits idict!+ not abort"cannot add key-value to CurrencyCollection"
    } : +newccpair
    { dup { -rot tuck swap cc-key-bits idict@- { val@ 2swap -rot + } { swap rot } cond +newccpair
      } { 2drop } cond
    } : +ccpair
    dictnew constant cc0   // zero currency collection
    // ( v k -- d )  Creates currency collection representing v units of currency k
    { cc0 swap rot +ccpair } : of-cc
    { dictnew { over null? not } { swap uncons -rot unpair +ccpair } while nip } : list>cc
    { dup null? { ."(null)" drop } { val@ ._ } cond } dup : .maybeVarUInt32 : .val
    { swap cc-key-bits { rot { ."+" } if .val ."*$" ._ true true } idictforeach drop } : (.cc)
    { false (.cc) { ."0" } ifnot } : .cc_
    { .cc_ space } : .cc
    { true (.cc) drop } : .+cc_
    { .+cc_ space } : .+cc
    { cc-key-bits { rot . ."-> " swap .val .val ."; " true } dictdiff drop cr } : show-cc-diff
    { cc-key-bits { val@ swap val@ + val, true } dictmerge } : cc+
    { null swap cc-key-bits { val@ pair swap cons true } idictforeach drop } : cc>list-rev
    { cc>list-rev list-reverse } : cc>list
    forget val,  forget val@  forget .val

    // ( S -- x -1 or 0 )
    { (number) dup 2 = { -rot 2drop } if 1 = } : int?
    { int? dup { drop dup 0< { drop false } { true } cond } if } : pos-int?
    // ( S -- k v -1 or 0 )  Parses expression <value>*<currency> or <value>*$<currency>
    { dup "*" $pos dup 0< { 2drop false } {
      $| dup $len 2 < { 2drop false } {
      1 $| nip dup 1 $| swap "$" $= { swap } if drop
      int? dup { over 32 fits { 2drop false } ifnot } if
      not { drop false } {
      swap pos-int? not { drop false } {
      true
      } cond } cond } cond } cond
    } : cc-key-value?
    // ( S -- D -1 or 0 )  Parses an extra currency collection
    // e.g. "10000*$3+7777*$-11" means "10000 units of currency #3 and 7777 units of currency #-11"
    { dictnew {  // S D
        swap dup "+" $pos dup 0< { drop null -rot } { $| 1 $| nip -rot } cond
        cc-key-value? { +ccpair over null? dup { rot drop true } if } { 2drop false true } cond
      } until
    } : $>xcc?
    { $>xcc? not abort"invalid extra currency collection" } : $>xcc
    { char } word dup $len { $>xcc } { drop dictnew } cond 1 'nop } ::_ CX{

    // complete currency collections
    { $>xcc? { true } { drop false } cond } : end-parse-cc
    // ( S -- x D -1 or 0 )  Parses a currency collection
    // e.g. "1.2+300*$2" means "1200000000ng plus 300 units of currency #2"
    { 0 swap dup "+" $pos dup 0< { drop dup
          $>GR? { nip nip dictnew true } { end-parse-cc } cond
        } { over swap $| swap $>GR? { 2swap 2drop swap 1 $| nip } { drop
      } cond end-parse-cc } cond
    } : $>cc?
    { $>cc? not abort"invalid currency collection" } : $>cc
    { char } word dup $len { $>cc } { drop 0 dictnew } cond 2 'nop } ::_ CC{
    // ( x D -- )
    { swap ?dup { .GR_ .+cc_ } { .cc_ } cond } : .GR+cc_
    { .GR+cc_ space } : .GR+cc
    { -rot Gram, swap dict, } : Gram+cc,

    // Libraries
    // ( -- D )  New empty library collection
    ' dictnew : Libs{
    // ( D -- D )  Return library collection as dictionary
    'nop : }Libs
    // ( D c x -- D' )  Add a public/private library c to collection D
    { <b swap 1 u, over ref, b> <s swap hash rot 256 udict!+
      0= abort"duplicate library in collection" } : lib+
    // ( D c -- D' )  Add private library c to collection D
    { 0 lib+ } : private_lib
    // ( D c -- D' )  Add public library c to collection D
    { 1 lib+ } : public_lib

    // serialize simple transfers with long comments
    // b B n -- b'
    recursive append-long-bytes {
      over Blen over <= { drop B, } {
        B| <b swap 127 append-long-bytes b> -rot B, swap ref,
      } cond
    } swap !
    // b S n -- b'
    { swap $>B swap append-long-bytes } : append-long-string
    // S -- c
    { <b over $len { 0 32 u, swap 36 append-long-string } { nip } cond b>
    } : simple-transfer-body

    // ( S -- x )  parse public key
    { dup $len 48 <> abort"public key must be 48 characters long"
      base64url>B dup Blen 36 <> abort"public key must be 48 characters long"
      34 B| 16 B>u@ over crc16 <> abort"crc16 mismatch in public key"
      16 B>u@+ 0x3ee6 <> abort"invalid tag in public key"
      256 B>u@
    } : parse-pubkey
    { bl word parse-pubkey 1 'nop } ::_ PK'
    // ( x -- S )  serialize public key
    { 256 u>B B{3ee6} swap B+ dup crc16 16 u>B B+ B>base64 } : pubkey>$
    { pubkey>$ type } : .pubkey

    // ( S -- x )  parse validator-encoded public key
    { base64>B dup Blen 36 <> abort"public key with magic must be 36 bytes long"
      4 B| swap 32 B>u@ 0xC6B41348 <> abort"unknown magic for public key (not Ed25519)"
    } : parse-val-pubkey
    { bl word parse-val-pubkey 1 'nop } ::_ VPK'
    { char } word base64>B 1 'nop } ::_ B64{

    // adnl address parser
    { 256 u>B B{2D} swap B+ dup crc16 16 u>B B+ } : adnl-preconv
    { swap 32 /mod dup 26 < { 65 } { 24 } cond + rot swap hold } : Base32#
    { <# ' Base32# 8 times #> } : Base32#*8
    { "" over Blen 5 / { swap 40 B>u@+ Base32#*8 nip rot swap $+ } swap times nip } : B>Base32

    // ( x -- S )  Converts an adnl-address from a 256-bit integer to a string
    { adnl-preconv B>Base32 1 $| nip } : adnl>$

    { 65 - dup 0>= { -33 and dup 26 < } { 41 + dup 25 > over 32 < and } cond ?dup nip } : Base32-digit?
    { Base32-digit? not abort"not a Base32 digit" } : Base32-digit
    { 0 { over $len } { swap 1 $| -rot (char) Base32-digit swap 5 << + } while nip } : Base32-number
    { B{} { over $len } { swap 8 $| -rot Base32-number 40 u>B B+ } while nip } : Base32>B

    // ( S -- x )  Converts an adnl address from a string to 256-bit integer
    { dup $len 55 <> abort"not 55 alphanumeric characters" "F" swap $+ Base32>B
      33 B| 16 B>u@ over crc16 <> abort"crc16 checksum mismatch"
      8 B>u@+ 0x2D <> abort"not a valid adnl address" 256 B>u@ } : $>adnl

    { 65 - dup 0>= { -33 and 10 + dup 16 < } { 17 + dup 0>= over 10 < and } cond ?dup nip } : hex-digit?
    // ( S -- x -1 or 0 )  Parses a hexadecimal integer
    { dup $len {
        0 {
          4 << swap 1 $| -rot (char) hex-digit?  // S a d -1 or S a 0
          { + over $len 0= } { drop -1 true } cond
        } until
        dup 0< { 2drop false } { nip true } cond
      } { drop false } cond
    } : hex$>u?
    // ( S -- x )
    { hex$>u? not abort"not a hexadecimal number" } : hex$>u

    { dup $len 64 = { hex$>u } {
      dup $len 55 = { $>adnl } {
        true abort"invalid adnl address"
      } cond } cond
    } : parse-adnl-addr
    { adnl>$ type } : .adnl
    { bl word parse-adnl-addr 1 'nop } ::_ adnl:

    // ( x a b -- a<=x<=b )
    { 2 pick >= -rot >= and } : in-range?

    // ( c i -- ? )  Checks whether c is a valid value for config param #i
    def? config-valid? {
      { nip 0>= { ."warning: cannot check validity of configuration parameter value, use create-state instead of fift to check validity" cr } if
        true } : config-valid?
    } ifnot

    { dup -1000 = { drop <s ref@ <s 12 u@ 0xFF0 = } {
      dup -1001 = { drop <s ref@ <s 12 u@ 0xFF0 = } {
      over null? { 2drop true } {
      config-valid?
      } cond } cond } cond
    } : is-valid-config?


    // Get anycast depth / rewrite_pfx or return 0
    // ( S -- x y S )
    {
        // maybe
        1 u@+ swap 0 >
        {
            // anycast_info$_ depth:(#<= 30) { depth >= 1 }
            //    rewrite_pfx:(bits depth) = Anycast;
            30 u@+ swap // get depth

            dup 1 > {
                dup 2 roll swap u@+ // get rewrite_pfx
                // return depth, rewrite_pfx, slice
            }
            {
                drop // drop depth (<=1)
                0 0 2 roll // set anycast to none
            } cond
        }
        {
            0 0 2 roll // set anycast to none
        } cond
    } : maybe-anycast

    // Rewrite first bits of addr with anycast info
    { // input: anycast depth, rewrite_pfx, workchain, slice, address length
        4 -roll
        3 roll dup dup 0 = { 2drop 2 roll drop }
        {
            rot swap u@+ swap drop
            3 roll
            <b swap 3 roll u, b> <s swap |+
        } cond // rewrite first bits of address with rewrite_pfx
        2 roll
        u@+ // get address
    } : parse-address-with-anycast

    // Parse Slice S and return:
    // 0 `addr_none S - if addr_none$00 is parsed
    // addr `addr_extern S - if addr_extern$01 is parsed
    // wc addr `addr_std S - if addr_std$10 is parsed
    // wc addr `addr_var S - if addr_var$11 is parsed
    // ( S -- 0 A S or addr A S or wc addr A S )
    { 2 u@+ swap dup 0>  // Get addr: addr_none$00 / addr_extern$01 / addr_std$10 / addr_var$11
        { // if greater that zero
           dup 1 >
           {
                2 =
                {
                    // if addr_std$10
                    // anycast:(Maybe Anycast)
                    // workchain_id:int8
                    // address:bits256  = MsgAddressInt;
                    maybe-anycast // get anycast depth, bits, slice
                    8 i@+ // get workchain
                    256 parse-address-with-anycast
                    `addr-std swap
                }

                {
                    // if addr_var$11
                    // anycast:(Maybe Anycast)
                    // addr_len:(## 9)
                    // workchain_id:int32
                    // address:(bits addr_len) = MsgAddressInt;
                    maybe-anycast // get anycast depth, bits, slice
                    9 u@+  // get addr_len
                    32 i@+ // get workchain
                    swap 2 -roll // move workchain to neede position
                    swap parse-address-with-anycast
                    `addr-var swap
                } cond

           }
           {
                drop // drop header (dup for statment upper)
                // if addr_extern$01
                // addr_extern$01 len:(## 9)
                // external_address:(bits len)
                9 u@+ swap  // bit len
                u@+ // external_address
                `addr-extern swap
           } cond
        }
        {
            swap
            // if addr_none$00
            `addr-none swap
        } cond
    } : addr@+

    { addr@+ drop } : addr@

    // User-friendly prints output of addr@
    // (0 A or addr A or wc addr A -- )
    {
        dup `addr-none eq?
        { 2drop ."addr_none" }
        {
            `addr-extern eq?
            { (dump) type }
            { (x.) swap (dump) ":" $+ swap $+ type }
            cond
        }
        cond
    } : print-addr // print addr with workchain

    forget maybe-anycast
    forget parse-address-with-anycast
}

//
// Stack.fif
//

/// Tests parsing of Stack.fif by embedding its contents
asm fun embedStackFif() {
    library Stack  // advanced stack manupulation library
    "Lists.fif" include
    // S(a b c - a c 2 a b) would compile to code performing the requested stack manipulation

    // interface to low-level stack manipulation primitives
    { (number) 1- abort"index expected" dup 0 < over 255 > or
      abort"index 0..255 expected"
    } : (idx)
    // push(n) : a0 .. an - a0 .. an a0  equivalent to "n pick"
    // push(0) = dup, push(1) = over
    { 0 char ) word (idx) <push> } ::_ push(
    // pop(n) : a0 a1 .. a(n-1) an - an a1 .. a(n-1)
    // pop(0) = drop, pop(1) = nip
    { 0 char ) word (idx) <pop> } ::_ pop(
    // xchg(i,j) : equivalent to "i j exch2"
    { 0 char , word (idx) char ) word (idx) <xchg> } ::_ xchg(
    // xchg0(i) : equivalent to "i exch" or "xchg(0,i)"
    // xchg0(1) = swap
    { 0 char ) word (idx) 0 <xchg> } ::_ xchg0(
    forget (idx)

    // parser for stack notation expressions
    ")" 34 hold +"  -" constant stk-delims
    anon constant stk-start
    anon constant stk-to
    variable stk-mode
    { stk-delims 11 (word) } : stk-token
    'nop : mk-lit
    // stk-start vn ... v0 -- stk-start ... v0 i  where v[i]=v0
    { 0 {
      1+ 2dup 2+ pick dup stk-start eq? { 2drop drop 0 true } { eqv? } cond
      } until
    } : stk-lookup
    // stk-start a1 .. an stk-to b1 .. bm -- [a1 .. an] [b1 .. bm]
    { stk-mode @ 0= abort"identifier expected" } : chk-lit
    { stk-to list-until-marker stk-mode !
      stk-start list-until-marker stk-mode @
      stk-mode 0!
    } : build-stk-effect
    { stk-start stk-mode 0! {
      stk-token dup ")" $= { drop true } {
      dup "-" $= {
        drop stk-mode @ abort"duplicate -" true stk-mode ! stk-to false } {
      dup 34 chr $= { chk-lit drop char " word mk-lit false } {
      dup (number) ?dup { chk-lit 1- { swap mk-lit -rot } if mk-lit nip false } {
      atom dup `_ eq? { stk-mode @ abort"identifier expected" false } {
      stk-lookup 0= stk-mode @ = {
        stk-mode @ { atom>$ +" -?" } { atom>$ +" redefined" } cond abort } {
      false
      } cond } cond } cond } cond } cond } cond } until
      stk-mode @ 0= abort"'-' expected"
      build-stk-effect
    } :_ parse-stk-list(

    // stack operation list construction
    variable op-rlist
    { op-rlist null! } : clear-op-list
    { op-rlist @ list-reverse } : get-op-list
    { op-rlist @ cons op-rlist ! } : issue-op
    { minmax `xchg -rot triple } : op-xchg
    { `push swap pair } : op-push
    { `lit swap pair } : op-lit
    { `pop swap pair } : op-pop
    0 op-pop constant op-drop
    { 2dup <> { op-xchg issue-op } if } : issue-xchg
    { op-push issue-op } : issue-push
    { op-lit issue-op } : issue-lit
    { op-pop issue-op } : issue-pop
    { op-drop issue-op } : issue-drop
    { ' issue-drop swap times } : issue-drop-#

    // emulated stack contents
    variable emul-stk
    { emul-stk @ count } : emul-depth
    { emul-depth 1- swap - } : adj-i
    { emul-depth 1- tuck swap - swap rot - swap } : adj-ij
    // i j --
    { adj-ij 2dup emul-stk @ tuck swap [] swap rot [] rot // i sj si j
      emul-stk @ -rot []= swap rot []= emul-stk !
    } : emul-xchg
    { emul-stk @ tpop drop emul-stk ! } : emul-drop
    // i --
    { 0 emul-xchg emul-drop } : emul-pop
    // i -- s[i]
    { emul-stk @ swap [] } : emul-stk[]
    // i -- si
    { adj-i emul-stk[] } : emul-get
    { 0 emul-get } : emul-tos
    // v i -- ?   Check whether s[i]=v
    { dup emul-depth < { emul-stk[] eqv? } { 2drop false } cond } : emul[]-eq?
    // v -- i or -1   Returns maximum i with s[i]=v
    { emul-stk @ dup count { // v s i
      ?dup 0= { -1 true } { 1- 2dup [] 3 pick eqv? } cond  // v s i' ?
      } until nip nip
    } : emul-stk-lookup-rev
    // i --
    { emul-get emul-stk @ swap , emul-stk ! } : emul-push
    { emul-stk @ swap , emul-stk ! } : emul-lit
    // show emulated stack contents similarly to .s
    { emul-stk @ explode dup 1 reverse ' .l swap times cr } : .e

    // both issue an operation and emulate it
    { 2dup issue-xchg emul-xchg } : issue-emul-xchg
    { dup issue-push emul-push } : issue-emul-push
    { dup issue-lit emul-lit } : issue-emul-lit
    { dup issue-pop emul-pop } : issue-emul-pop
    { issue-drop emul-drop } : issue-emul-drop
    { ' issue-emul-drop swap times } : issue-emul-drop-#

    // b.. s -- b.. s   moves tos value to stk[s]
    { dup emul-stk[] 2 pick cdr list-member-eqv? {
      dup adj-i 0 issue-emul-xchg } { dup adj-i issue-emul-pop } cond
    } : move-tos-to

    // new s -- ops registered
    { { over null? not } {
      // .sl .e get-op-list .l cr
      // get-op-list list-length 100 > abort"too long"
      emul-depth over >
        { over emul-tos swap list-member-eqv? not } { false } cond {
      // b.. s  tos unneeded
      issue-emul-drop } {
      over car // b.. s b1
      2dup swap emul[]-eq? { drop swap cdr swap 1+ } {
      dup emul-stk-lookup-rev // b.. s b1 i
      dup 0< { // b.. s b1 i  not found, must be a literal
        drop dup atom? abort"unavailable value"
        issue-emul-lit } {
      dup 3 pick < { // b.. s b1 i  found in bottom s stack values
        nip adj-i issue-emul-push  // b.. s
        dup emul-depth 1- < { move-tos-to } if
      } {
      emul-depth 1- over = { // b.. s b1 i  found in tos
        2drop move-tos-to
      } { // b.. s b1 i
        nip over adj-ij issue-emul-xchg
      } cond } cond } cond } cond } cond } while
      nip emul-depth swap - issue-emul-drop-#
    } : generate-reorder-ops

    // old new -- op-list
    { emul-stk @ op-rlist @ 2swap
      swap list>tuple emul-stk ! clear-op-list
      0 generate-reorder-ops get-op-list
      -rot op-rlist ! emul-stk !
    } : generate-reorder
    { parse-stk-list( generate-reorder } :_ SG(

    // op-list rewriting according to a ruleset
    // l f l1 l2 -- l' -1 or l f  with l' = l2 + (l - l1)
    { push(3) rot list- { list+ nip nip true } { drop } cond
    } : try-rule
    // l f ll -- l' -1 or l f
    { { dup null? not } { uncons 3 -roll unpair try-rule rot } while drop
    } : try-ruleset
    // l ll -- l'
    { swap { over false swap try-ruleset 0= } until nip
    } : try-ruleset*
    // l ruleset -- l'
    recursive try-ruleset*-everywhere {
      tuck try-ruleset* dup null? { nip } {
        uncons rot try-ruleset*-everywhere cons } cond
    } swap !
    LIST(
     [([xchg 0 1] [xchg 0 2]) ([rot])]
     [([xchg 0 1] [xchg 1 2]) ([-rot])]
     [([xchg 0 2] [xchg 1 2]) ([rot])]
     [([xchg 0 2] [xchg 0 1]) ([-rot])]
     [([xchg 1 2] [xchg 0 1]) ([rot])]
     [([xchg 1 2] [xchg 0 2]) ([-rot])]
     [([xchg 0 1] [rot]) ([xchg 0 2])]
     [([-rot] [xchg 0 1]) ([xchg 0 2])]
     [([xchg 0 2] [xchg 1 3]) ([2swap])]
     [([xchg 1 3] [xchg 0 2]) ([2swap])]
     [([push 1] [push 1]) ([2dup])]
     [([push 3] [push 3]) ([2over])]
     [([pop 0] [pop 0]) ([2drop])]
     [([pop 1] [pop 0]) ([2drop])]
     [([xchg 0 1] [push 1]) ([tuck])]
     [([rot] [-rot]) ()]
     [([-rot] [rot]) ()]
    ) constant fift-stack-ruleset
    { fift-stack-ruleset try-ruleset*-everywhere } : fift-ops-rewrite
    { SG( fift-ops-rewrite } :_ SGF(

    // helpers for creating Fift source strings for one fift-op
    // i j -- s
    { minmax over { "xchg(" rot (.) $+ +"," swap (.) $+ +")" }
      { nip dup 1 = { drop "swap" } {
        ?dup { "xchg0(" swap (.) $+ +")" } { "" } cond
      } cond } cond
    } : source-<xchg>
    // i -- s
    { dup 1 = { drop "over" } {
      ?dup { "push(" swap (.) $+ +")" } { "dup" } cond
      } cond
    } : source-<push>
    // i -- s
    { dup 1 = { drop "nip" } {
      ?dup { "pop(" swap (.) $+ +")" } { "drop" } cond
      } cond
    } : source-<pop>
    // lit -- s
    { dup string? { char " chr swap $+ char " hold } { (.) } cond
    } : source-<lit>

    // dictionary with all fift op compilation/source creation
    { 0 swap (compile) } : fop-compile
    ( _( `xchg 2 { <xchg> fop-compile } { source-<xchg> swap cons } )
      _( `push 1 { <push> fop-compile } { source-<push> swap cons } )
      _( `pop 1 { <pop> fop-compile } { source-<pop> swap cons } )
      _( `lit 1 { 1 'nop (compile) } { source-<lit> swap cons } )
      _( `rot 0 { ' rot fop-compile } { "rot" swap cons } )
      _( `-rot 0 { ' -rot fop-compile } { "-rot" swap cons } )
      _( `tuck 0 { ' tuck fop-compile } { "tuck" swap cons } )
      _( `2swap 0 { ' 2swap fop-compile } { "2swap" swap cons } )
      _( `2drop 0 { ' 2drop fop-compile } { "2drop" swap cons } )
      _( `2dup 0 { ' 2dup fop-compile } { "2dup" swap cons } )
      _( `2over 0 { ' 2over fop-compile } { "2over" swap cons } )
    ) box constant fift-op-dict

    { dup atom? { atom>$ } { drop "" } cond
      "unknown operation " swap $+ abort
    } : report-unknown-op
    variable 'fop-entry-exec
    // process fift-op according to 'fop-entry-exec
    // ... op - ...
    { dup first dup fift-op-dict @ assq { report-unknown-op } ifnot
      dup second 1+ push(3) count <> abort"incorrect param count"
      nip swap explode dup roll drop 1- roll // o2 .. on entry
      'fop-entry-exec @ execute
    } : process-fift-op

    // compile op-list into Fift wordlist
    // wl op-list -- wl'
    { { third execute } 'fop-entry-exec !
      swap ' process-fift-op foldl } : compile-fift-op*
    // op-list -- e
    { fift-ops-rewrite ({) swap compile-fift-op* (}) } : ops>wdef

    // S(<orig-stack> - <new-stack>) compiles a "word" performing required action
    { SG( ops>wdef 0 swap } ::_ S(
    // 1 2 3 S(a b c - c a b a) .s  would print 3 1 2 1

    // transform op-list into Fift source
    // ls op -- ls'
    { fift-ops-rewrite
      { 3 [] execute } 'fop-entry-exec !
      null ' process-fift-op foldl
      dup null? { drop "" } { { +" " swap $+ } foldr-ne } cond
    } : ops>$
    { SG( ops>$ 1 'nop } ::_ $S(
    { SG( ops>$ type } :_ .$S(
    // $S(a b c - b c a c a c) => string "rot 2dup over"
    // S(a b c - b c a c a c) => compile/execute block { rot 2dup over }
    // $S(_ x y _ - y x) => string "drop pop(2)"
    // .$S(x1 x2 - 17 x1) => print string "drop 17 swap"

    // simplify/transform sequences of stack manipulation operations
    LIST(. [a b c d e f g h i j]) constant std-stack
    { stk-start std-stack explode drop stk-to std-stack explode drop
    } : simplify<{
    { build-stk-effect generate-reorder ops>$ } : }>stack
    // simplify<{ drop drop over over -13 }>stack => string "2drop 2dup -13"
    // simplify<{ 17 rot }>stack => string "swap 17 swap"
    // simplify<{ 5 1 reverse }>stack => string "xchg(1,5) xchg(2,4)"
}

//
// GetOpt.fif
//

/// Tests parsing of GetOpt.fif by embedding its contents
asm fun embedGetOptFif() {
    library GetOpt  // Simple command-line options parser
    "Lists.fif" include

    // May be used as follows:
    // begin-options
    //   "h" { ."Help Message" 0 halt } short-option
    //   "v" { parse-int =: verbosity } short-option-arg
    //   "i" "--interactive" { true =: interactive } short-long-option
    // parse-options

    // ( l -- l')  computes tail of list l if non-empty; else ()
    { dup null? ' cdr ifnot } : safe-cdr
    // ( l c -- l')  deletes first c elements from list l
    { ' safe-cdr swap times } : list-delete-first
    // ( l n c -- l' )  deletes c elements starting from n-th in list l
    recursive list-delete-range {
      dup 0<= { 2drop } {
      over 0<= { nip list-delete-first } {
      swap 1- swap rot uncons 2swap list-delete-range cons
      } cond } cond
    } swap !
    // ( n c -- )  deletes $n .. $(n+c-1) from the argument list $*
    { swap 1- $* @ swap rot list-delete-range $* ! } : $*del..
    // ( s s' -- ? )  checks whether s' is a prefix of s
    { tuck $len over $len over >= { $| drop $= } { 2drop drop false } cond
    } : $pfx?
    // ( s -- ? )  checks whether s is an option (a string beginning with '-')
    { dup $len 1 > { "-" $pfx? } { drop false } cond } : is-opt?
    // ( s -- ? )  checks whether s is a digit option
    { 2 $| drop 1 $| nip $>B 8 B>u@ dup 57 <= swap 48 >= and } : is-digit-opt?
    0 box constant disable-digit-opts
    // ( l -- s i or 0 )  finds first string in l beginning with '-'
    { 0 { 1+ over null? { 2drop 0 true } {
      swap uncons over is-opt?
      { disable-digit-opts @ { over is-digit-opt? not } { true } cond } { false } cond
      { drop swap true } { nip swap false } cond
      } cond } until
    } : list-find-opt
    // ( -- s i or 0 )  finds first option in cmdline args
    { $* @ list-find-opt } : first-opt
    ' second : get-opt-flags
    ' first : get-opt-exec
    // ( s t -- ? )  checks whether short/long option s matches description t
    { third $= } : short-option-matches
    { dup get-opt-flags 4 and 0= 3 + [] $=
    } : long-option-matches
    // ( t -- s -1 or 0 )  extracts help message from description
    { dup get-opt-flags 4 and 0= 4 + over count over >
      { [] true } { 2drop false } cond
    } : get-opt-help
    // ( s l -- t -1 or 0 )  finds short/long option s in list l
    { swap 1 { swap short-option-matches } does assoc-gen
    } : lookup-short-option
    { swap 1 { swap long-option-matches } does assoc-gen
    } : lookup-long-option
    // ( s -- s' null or s' s'' )  Splits long option --opt=arg at '='
    { dup "=" $pos 1+ ?dup { tuck $| swap rot 1- $| drop swap } { null } cond
    } : split-longopt
    // ( l -- f or 0 )  Extracts global option flags from first entry of l
    { dup null? { drop 0 } { car get-opt-flags -256 and } cond
    } : get-global-option-flags
    variable options-list
    // ( l -- i or 0 )
    // parses command line arguments according to option description list l
    // and returns index i of first incorrect option
    { dup options-list ! get-global-option-flags
      256 and disable-digit-opts !
      { first-opt dup 0= { true } {
        swap dup "--" $pfx? {  // i s
          dup $len 2 = { drop dup 1 $*del.. 0 true } {
          split-longopt swap options-list @
          lookup-long-option not { drop true } { // i s' t f
          dup get-opt-exec swap get-opt-flags 3 and // i s' e f'
          2 pick null? { dup 1 = } { dup 0= negate } cond  // i s' e f' f''
          dup 1 = { 2drop 2drop true } {
          { drop nip over 1+ $() swap execute 2 $*del.. false } {
          ' nip ifnot execute 1 $*del.. false
        } cond } cond } cond } cond } { // i s
          1 $| nip {
            dup $len 0= { drop 1 $*del.. false true } {
            1 $| swap options-list @  // i s' s l
            lookup-short-option not { drop true true } { // i s' t
            dup get-opt-exec swap get-opt-flags 3 and  // i s' e f'
            ?dup 0= { execute false } {
            2 pick $len { drop execute "" false } {
            2 = { nip null swap execute "" false } {  // i e
            nip over 1+ $() swap execute 2 $*del.. false true
          } cond } cond } cond } cond } cond } until
        } cond
      } cond } until
    } : getopt
    // ( t -- )  Displays help message for one option
    { dup get-opt-flags dup 4 and 2 pick third swap {
        ."-" type ."/" over 3 [] type } {
        dup $len { dup "--" $pfx? { ."-" } ifnot type } {
        drop ."usage: " $0 type
      } cond } cond
      dup 3 and ?dup {
        2 = { ."[=<optarg>]" } { ."=<optarg>" } cond
      } if
      8 and { 9 emit } ifnot
      get-opt-help { type } { ."No help available" } cond cr
    } : show-opt-help
    // ( -- )  Displays options help message according to options-list
    { options-list @ { dup null? not } {
        uncons swap show-opt-help
      } while drop
    } : show-options-help
    // ( l -- )  Parses options and throws an error on failure
    { getopt ?dup {
      $() "cannot parse command line options near `" swap $+ +"`"
      show-options-help abort } if
    } : run-getopt
    anon constant opt-list-marker
    ' opt-list-marker : begin-options
    { opt-list-marker list-until-marker } : end-options
    { end-options run-getopt } : parse-options
    // ( s e -- o )  Creates short/long option s with execution token e
    { 0 rot triple } dup : short-option : long-option
    // ( s s' e -- o ) Creates a combined short option s and long option s' with execution token e
    { 4 2swap 4 tuple } : short-long-option
    { 1 rot triple } dup : short-option-arg : long-option-arg
    { 2 rot triple } dup : short-option-?arg : long-option-?arg
    { 5 2swap 4 tuple } : short-long-option-arg
    { 6 2swap 4 tuple } : short-long-option-?arg
    // ( o s -- s' )  Adds help message to option
    ' , : option-help
    // ( s f -- o )  Creates a generic help message
    { swap 'nop rot "" 3 roll 4 tuple } : generic-help-setopt
    { 0 generic-help-setopt } : generic-help
    256 constant disable-digit-options
}


## abstract-const-without-modifier.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/abstract-const-without-modifier.tact)
trait t {
    const c: Int;
}


## const-abstract-abstract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/const-abstract-abstract.tact)
primitive Int;
trait BaseTrait { }

abstract abstract const Foo: Int = 42;


## const-override-override.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/const-override-override.tact)
primitive Int;
trait BaseTrait { }

override override const Foo: Int = 42;


## const-override-virtual.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/const-override-virtual.tact)
primitive Int;
trait BaseTrait { }

override virtual const Foo: Int = 42;


## const-override.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/const-override.tact)
primitive Int;
trait BaseTrait { }

override const Foo: Int = 42;


## const-virtual-override.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/const-virtual-override.tact)
primitive Int;
trait BaseTrait { }

virtual override const Foo: Int = 42;


## const-virtual-virtual.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/const-virtual-virtual.tact)
primitive Int;
trait BaseTrait { }

virtual virtual const Foo: Int = 42;


## const-virtual.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/const-virtual.tact)
primitive Int;
trait BaseTrait { }

virtual const Foo: Int = 42;


## contract-const-abstract-abstract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-const-abstract-abstract.tact)
primitive Int;
trait BaseTrait { }

contract TestContract {
  abstract abstract const Foo: Int = 42;
}


## contract-const-abstract-with-initializer.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-const-abstract-with-initializer.tact)
primitive Int;
trait BaseTrait { }

contract TestContract {
  abstract const Foo: Int = 42;
}


## contract-const-abstract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-const-abstract.tact)
primitive Int;
trait BaseTrait { }

contract TestContract {
  abstract const Foo: Int;
}


## contract-const-override-override.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-const-override-override.tact)
primitive Int;
trait BaseTrait { }

contract TestContract {
  override override const Foo: Int = 42;
}


## contract-const-virtual-virtual.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-const-virtual-virtual.tact)
primitive Int;
trait BaseTrait { }

contract TestContract {
  virtual virtual const Foo: Int = 42;
}


## contract-empty-traits-list-with-keyword.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-empty-traits-list-with-keyword.tact)
contract Name with {}


## contract-getter-parens-no-method-id.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-getter-parens-no-method-id.tact)
contract Test {
    get() fun test(): Int {
        return 0
    }
}


## contract-init-trailing-comma-empty-params.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-init-trailing-comma-empty-params.tact)
contract Name {
    init(,) {}
}


## contract-trailing-comma-empty-traits-list.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-trailing-comma-empty-traits-list.tact)
contract Name with, {}


## contract-with-imports.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/contract-with-imports.tact)
import "@stdlib/deploy";

primitive Int;

// all imports must be at the very top of the file
import "@stdlib/not-allowed";

contract Test with Deploy { }


## destructuring-duplicate-source-id.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/destructuring-duplicate-source-id.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a: x, a: y } = s;
    return x + y;
}

## expr-fun-call-trailing-comma-no-args.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/expr-fun-call-trailing-comma-no-args.tact)
fun a(): Int { 
    return 42;
}

fun b(): Int {
    return a(,);
}


## expr-method-call-trailing-comma-no-args.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/expr-method-call-trailing-comma-no-args.tact)
fun another() {
    return 42.toString(,);
}


## funcid-native-fun-arith-operator.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-arith-operator.tact)
@name(/)
native idTest();


## funcid-native-fun-assign-operator.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-assign-operator.tact)
@name(^>>=)
native idTest();


## funcid-native-fun-bitwise-operator.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-bitwise-operator.tact)
@name(~)
native idTest();


## funcid-native-fun-comma.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-comma.tact)
@name(send_message,then_terminate)
native idTest();


## funcid-native-fun-comparison-operator.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-comparison-operator.tact)
@name(<=>)
native idTest();


## funcid-native-fun-control-keyword.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-control-keyword.tact)
@name(elseifnot)
native idTest();


## funcid-native-fun-delimiter.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-delimiter.tact)
@name([)
native idTest();


## funcid-native-fun-directive.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-directive.tact)
@name(#include)
native idTest();


## funcid-native-fun-dot.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-dot.tact)
@name(msg.sender)
native idTest();


## funcid-native-fun-keyword.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-keyword.tact)
@name(global)
native idTest();


## funcid-native-fun-multiline-comments.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-multiline-comments.tact)
@name({-aaa-})
native idTest();


## funcid-native-fun-number-decimal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-number-decimal.tact)
@name(0)
native idTest();


## funcid-native-fun-number-hexadecimal-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-number-hexadecimal-2.tact)
@name(0xDEADBEEF)
native idTest();


## funcid-native-fun-number-hexadecimal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-number-hexadecimal.tact)
@name(0x0)
native idTest();


## funcid-native-fun-number-neg-decimal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-number-neg-decimal.tact)
@name(-1)
native idTest();


## funcid-native-fun-number-neg-hexadecimal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-number-neg-hexadecimal.tact)
@name(-0x0)
native idTest();


## funcid-native-fun-number.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-number.tact)
@name(123)
native idTest();


## funcid-native-fun-only-underscore.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-only-underscore.tact)
@name(_)
native idTest();


## funcid-native-fun-parens.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-parens.tact)
@name(take(first)Entry)
native idTest();


## funcid-native-fun-semicolons.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-semicolons.tact)
@name(pa;;in"`aaa`")
native idTest();


## funcid-native-fun-space.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-space.tact)
@name(foo foo)
native idTest();


## funcid-native-fun-square-brackets.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-square-brackets.tact)
@name(take[some]entry)
native idTest();


## funcid-native-fun-string.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-string.tact)
@name("not_a_string)
native idTest();


## funcid-native-fun-type-keyword.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-type-keyword.tact)
@name(->)
native idTest();


## funcid-native-fun-unclosed-parens.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/funcid-native-fun-unclosed-parens.tact)
@name(aa(bb)
native idTest();


## ident-cannot-be-if-reserved-word.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-cannot-be-if-reserved-word.tact)
fun hello(): Int {
    let if: Int = 0;
}

## ident-contract-cannot-start-with-__gen.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-contract-cannot-start-with-__gen.tact)
contract __gen_a {

}

## ident-fun-cannot-start-with-__gen.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-fun-cannot-start-with-__gen.tact)
fun __gen_hello(): Int {
    
}

## ident-fun-param-cannot-start-with-__gen.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-fun-param-cannot-start-with-__gen.tact)
fun main(__gen: Int): Int {
    return 0;
}

## ident-fun-param-cannot-start-with-__tact.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-fun-param-cannot-start-with-__tact.tact)
contract A {
    fun b(__tact: Int) {
        
    }
}

## ident-init-param-cannot-start-with-__tact.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-init-param-cannot-start-with-__tact.tact)
contract A {
    init(__tact: Int) {
        
    }
}

## ident-let-cannot-start-with-__gen.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-let-cannot-start-with-__gen.tact)
fun hello(): Int {
    let __gen_a: Int = 0;
}

## ident-let-cannot-start-with-__tact.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-let-cannot-start-with-__tact.tact)
fun hello(): Int {
    let __tact_a: Int = 0;
}

## ident-struct-cannot-start-with-__gen.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/ident-struct-cannot-start-with-__gen.tact)
struct __genA {
    a: Int;
}

## item-fun-non-void-trailing-comma-no-params.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/item-fun-non-void-trailing-comma-no-params.tact)
fun function(,) : Int {
    return 42;
}


## item-fun-void-trailing-comma-no-params.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/item-fun-void-trailing-comma-no-params.tact)
fun function(,) {}


## item-fun-without-body.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/item-fun-without-body.tact)
fun testFunc(): Int;

## item-native-fun-not-void-decl-trailing-comma-no-params.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/item-native-fun-not-void-decl-trailing-comma-no-params.tact)
@name(native_name_2)
native testNativeFuncWithType(,): Int;

## item-native-fun-void-decl-trailing-comma-no-params.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/item-native-fun-void-decl-trailing-comma-no-params.tact)
@name(native_name_1)
native testNativeFunc(,);

## items-asm-fun-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/items-asm-fun-1.tact)
asm(1 0) extends fun loadCoins(self: Slice): Int {
    LDVARUINT16
}



## items-asm-fun-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/items-asm-fun-2.tact)
asm(c b 42) extends fun storeDict(b: Builder, c: Cell) {
    STDICT
}



## items-asm-fun-3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/items-asm-fun-3.tact)
asm(s len -> len 1 0) extends fun loadInt(self: Slice, len: Int): Int {
    LDIX
}



## items-asm-fun-4.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/items-asm-fun-4.tact)
asm(->) extends fun loadInt(self: Slice, len: Int): Int {
    LDIX
}


## items-asm-fun-5.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/items-asm-fun-5.tact)
asm fun shadowingAttempt() {
    { INC } : }
    5 }
}


## items-asm-fun-6.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/items-asm-fun-6.tact)
asm fun giganticBinary() {
    b{000000001111111100000000111111110000000011111111000000001111111100000000111111110000000011111111000000001111111100000000111111110}
}


## literal-dec-trailing-underscore.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/literal-dec-trailing-underscore.tact)
fun test_fun(): Int {
    return 123_;
}

## literal-double-underscore.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/literal-double-underscore.tact)
fun test_fun(): Int {
    return 123_123__123;
}

## literal-hex-trailing-underscore.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/literal-hex-trailing-underscore.tact)
fun test_fun(): Int {
    return 0x123_;
}

## literal-no-underscore-after-0b.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/literal-no-underscore-after-0b.tact)
fun test_fun(): Int {
    return 0b_00101010;
}

## literal-no-underscores-if-leading-zero.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/literal-no-underscores-if-leading-zero.tact)
fun test_fun(): Int {
    return 012_3;
}

## literal-non-binary-digits.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/literal-non-binary-digits.tact)
fun test_fun(): Int {
    return 0b123;
}

## literal-underscore-after-leading-zero.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/literal-underscore-after-leading-zero.tact)
fun test_fun(): Int {
    return 0_123;
}

## struct-double-semicolon.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/struct-double-semicolon.tact)
// too many semicolons
struct A { x: Int;; }


## struct-missing-semicolon-between-fields-with-initializer.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/struct-missing-semicolon-between-fields-with-initializer.tact)
// missing ; between fields
struct B { x: Int = 42 y: Int }


## struct-missing-semicolon-between-fields.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/struct-missing-semicolon-between-fields.tact)
// missing ; between fields
struct B { x: Int y: Int }


## trait-const-abstract-with-initializer.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/trait-const-abstract-with-initializer.tact)
primitive Int;
trait BaseTrait { }

trait TestContract {
  abstract const Foo: Int = 42;
}


## trait-empty-traits-list-with-keyword.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/trait-empty-traits-list-with-keyword.tact)
trait Name with {}


## trait-fun-non-void-trailing-comma-no-params.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/trait-fun-non-void-trailing-comma-no-params.tact)
trait Test {
    abstract fun testAbstractWithType(,): Int;
}


## trait-fun-void-trailing-comma-no-params.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/trait-fun-void-trailing-comma-no-params.tact)
trait Test {
    abstract fun testAbstract(,);
}


## trait-trailing-comma-empty-traits-list.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/trait-trailing-comma-empty-traits-list.tact)
trait Name with, {}


## type-ident-msg-should-be-capitalized.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/type-ident-msg-should-be-capitalized.tact)
message(123) foo {
    signature: Slice;
}


## type-ident-struct-should-be-capitalized.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test-failed/type-ident-struct-should-be-capitalized.tact)
struct lowercaseIdForType {
    a: Int;
}


## abstract-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/abstract-const.tact)
trait t {
    abstract const c: Int;
}



## case-35.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/case-35.tact)
contract ReceiveTestContract {
    external() {
        acceptMessage();
    }
}

## contract-getter-with-method-id.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/contract-getter-with-method-id.tact)
contract Test {
    get(crc32("crc32") + 42 & 0x3ffff | 0x4000) fun test(): Int {
        return 0
    }
}


## contract-optional-semicolon-for-last-const-def.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/contract-optional-semicolon-for-last-const-def.tact)
contract Test { const foo: Int = 42 }


## contract-optional-semicolon-for-last-storage-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/contract-optional-semicolon-for-last-storage-var.tact)
contract Test { m: map<Int, Int> }


## contract-with-const-override.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/contract-with-const-override.tact)
contract Contract {
    override const Test: Int = 0;
}

## contract-with-imports.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/contract-with-imports.tact)
import "@stdlib/deploy";

contract Test with Deploy { }


## contract-with-init.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/contract-with-init.tact)
contract Sample {
    a: Int;
    b: Int;
    
    init(a: Int, b: Int) {
        self.a = a;
        self.b = b;
    }
}

## contract-with-trait-string-literal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/contract-with-trait-string-literal.tact)
primitive Int;

trait SomeTrait {
    a: Int;

    virtual fun a(): Int {
        return a;
    }
}

contract Main with SomeTrait {
    b: Int;

    override fun a(): Int {
        return "hello world!";
    }
}

## contract-with-trait.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/contract-with-trait.tact)
primitive Int;

trait SomeTrait {
    a: Int;

    virtual fun a(): Int {
        return a;
    }
}

contract Main with SomeTrait {
    b: Int;

    override fun a(): Int {
        return b;
    }
}

## expr-arith-and-cmp.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-arith-and-cmp.tact)
fun testFunc(): Int {
    return (0 + 1) * 10 / 20 != 10;
}

## expr-arith-bool-cmp-method-call.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-arith-bool-cmp-method-call.tact)
fun testFunc(): Int {
    return (0 + 1) * 10 / 20 != 10 * someId || some2 > 10 && some3 < 123.add(10);
}

## expr-arith-bool-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-arith-bool-var.tact)
fun testFunc(): Int {
    return (0 + 1) * 10 / 20 != 10 * someId || some2 > 10 && some3 < 10;
}

## expr-arith.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-arith.tact)
fun testFunc(): Int {
    return (0 + 1) * 10 / 20;
}

## expr-chaining-unbox.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-chaining-unbox.tact)
fun testFunc(m: map<Int, Int>): Int {
    return m.asCell()!!.hash();
}

## expr-condition-with-or.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-condition-with-or.tact)
fun testFunc(a: Int): Int {
    return a == 123 || a == 456 ? a + 1 : a + 2;
}

## expr-conditional-with-let.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-conditional-with-let.tact)
fun testFunc(a: Int): Int {
    let b: Int = a == 123 ? 1 : 2;
    return b;
}

## expr-conditional.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-conditional.tact)
fun testFunc(a: Int): Int {
    return a == 123 ? 1 : 2;
}

## expr-equality.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-equality.spec.ts)
import { eqExpressions, getAstFactory } from "../ast";
import { getParser } from "../";

type Test = { expr1: string; expr2: string; equality: boolean };

const valueExpressions: Test[] = [
    { expr1: "1", expr2: "1", equality: true },
    { expr1: "1", expr2: "true", equality: false },
    { expr1: "1", expr2: '"one"', equality: false },
    { expr1: "1", expr2: "null", equality: false },
    { expr1: "1", expr2: "g", equality: false },
    { expr1: "false", expr2: "true", equality: false },
    { expr1: "false", expr2: '"false"', equality: false },
    { expr1: "false", expr2: "false", equality: true },
    { expr1: "false", expr2: "null", equality: false },
    { expr1: "false", expr2: "g", equality: false },
    { expr1: '"one"', expr2: '"one"', equality: true },
    { expr1: '"one"', expr2: '"onw"', equality: false },
    { expr1: '"one"', expr2: "null", equality: false },
    { expr1: '"one"', expr2: "g", equality: false },
    { expr1: "null", expr2: "null", equality: true },
    { expr1: "null", expr2: "g", equality: false },
];

const functionCallExpressions: Test[] = [
    { expr1: "f(1,4)", expr2: "f(1)", equality: false },
    { expr1: "f(1,4)", expr2: "f(1,4)", equality: true },
    { expr1: "f(1,4)", expr2: "1", equality: false },
    { expr1: "f(1,4)", expr2: "g(1,4)", equality: false },
    { expr1: "f(1,4)", expr2: "true", equality: false },
    { expr1: "f(1,4)", expr2: "null", equality: false },
    { expr1: "f(1,4)", expr2: "f", equality: false },
    { expr1: 'f("a",0)', expr2: 'f("a",0)', equality: true },
    { expr1: 'f("a",0)', expr2: 'f("a",null)', equality: false },
    { expr1: "f(true,0)", expr2: "f(0,true)", equality: false },
    { expr1: "f(true,0)", expr2: "f(true,0)", equality: true },
    { expr1: "f(g(1))", expr2: "g(f(1))", equality: false },

    { expr1: "s.f(1,4)", expr2: "s.f(1)", equality: false },
    { expr1: "s.f(1,4)", expr2: "s.f(1,4)", equality: true },
    { expr1: "s.f(1,4)", expr2: "1", equality: false },
    { expr1: "s.f(1,4)", expr2: "s.g(1,4)", equality: false },
    { expr1: "s.f(1,4)", expr2: "true", equality: false },
    { expr1: "s.f(1,4)", expr2: "null", equality: false },
    { expr1: 's.f("a",0)', expr2: 's.f("a",0)', equality: true },
    { expr1: 's.f("a",0)', expr2: 's.f("a",null)', equality: false },
    { expr1: "s.f(true,0)", expr2: "s.f(0,true)", equality: false },
    { expr1: "s.f(true,0)", expr2: "s.f(true,0)", equality: true },
    { expr1: "s.f(s.g(1))", expr2: "s.g(s.f(1))", equality: false },

    { expr1: "s.f(0)", expr2: "f(0)", equality: false },
];

const unaryOpExpressions: Test[] = [
    { expr1: "+4", expr2: "+4", equality: true },
    { expr1: "+4", expr2: "-4", equality: false },
    { expr1: "+4", expr2: "!g", equality: false },
    { expr1: "+4", expr2: "!!g", equality: false },
    { expr1: "+4", expr2: "g!!", equality: false },
    { expr1: "+4", expr2: "~g", equality: false },
    { expr1: "-4", expr2: "-4", equality: true },
    { expr1: "-4", expr2: "!g", equality: false },
    { expr1: "-4", expr2: "!!g", equality: false },
    { expr1: "-4", expr2: "g!!", equality: false },
    { expr1: "-4", expr2: "~g", equality: false },
    { expr1: "!g", expr2: "!g", equality: true },
    { expr1: "!g", expr2: "!!g", equality: false },
    { expr1: "!g", expr2: "g!!", equality: false },
    { expr1: "!g", expr2: "~g", equality: false },
    { expr1: "g!!", expr2: "g!!", equality: true },
    { expr1: "g!!", expr2: "~g", equality: false },
    { expr1: "~g", expr2: "~g", equality: true },
];

const binaryOpExpressions: Test[] = [
    { expr1: "g + r", expr2: "g + r", equality: true },
    { expr1: "g + r", expr2: "r + g", equality: false },
    { expr1: "g + r", expr2: "+r", equality: false },
    { expr1: "g + r", expr2: "g - r", equality: false },
    { expr1: "g + r", expr2: "g * r", equality: false },
    { expr1: "g + r", expr2: "g / r", equality: false },
    { expr1: "g + r", expr2: "g % r", equality: false },
    { expr1: "g + r", expr2: "g >> r", equality: false },
    { expr1: "g + r", expr2: "g << r", equality: false },
    { expr1: "g + r", expr2: "g & r", equality: false },
    { expr1: "g + r", expr2: "g | r", equality: false },
    { expr1: "g + r", expr2: "g ^ r", equality: false },
    { expr1: "g + r", expr2: "g != r", equality: false },
    { expr1: "g + r", expr2: "g > r", equality: false },
    { expr1: "g + r", expr2: "g < r", equality: false },
    { expr1: "g + r", expr2: "g >= r", equality: false },
    { expr1: "g + r", expr2: "g <= r", equality: false },
    { expr1: "g + r", expr2: "g == r", equality: false },
    { expr1: "g + r", expr2: "g && r", equality: false },
    { expr1: "g + r", expr2: "g || r", equality: false },
    { expr1: "g - r", expr2: "g - r", equality: true },
    { expr1: "g - r", expr2: "-r", equality: false },
    { expr1: "g - r", expr2: "r - g", equality: false },
    { expr1: "g - r", expr2: "g * r", equality: false },
    { expr1: "g - r", expr2: "g / r", equality: false },
    { expr1: "g - r", expr2: "g % r", equality: false },
    { expr1: "g - r", expr2: "g >> r", equality: false },
    { expr1: "g - r", expr2: "g << r", equality: false },
    { expr1: "g - r", expr2: "g & r", equality: false },
    { expr1: "g - r", expr2: "g | r", equality: false },
    { expr1: "g - r", expr2: "g ^ r", equality: false },
    { expr1: "g - r", expr2: "g != r", equality: false },
    { expr1: "g - r", expr2: "g > r", equality: false },
    { expr1: "g - r", expr2: "g < r", equality: false },
    { expr1: "g - r", expr2: "g >= r", equality: false },
    { expr1: "g - r", expr2: "g <= r", equality: false },
    { expr1: "g - r", expr2: "g == r", equality: false },
    { expr1: "g - r", expr2: "g && r", equality: false },
    { expr1: "g - r", expr2: "g || r", equality: false },
    { expr1: "g * r", expr2: "g * r", equality: true },
    { expr1: "g * r", expr2: "r * g", equality: false },
    { expr1: "g * r", expr2: "g / r", equality: false },
    { expr1: "g * r", expr2: "g % r", equality: false },
    { expr1: "g * r", expr2: "g >> r", equality: false },
    { expr1: "g * r", expr2: "g << r", equality: false },
    { expr1: "g * r", expr2: "g & r", equality: false },
    { expr1: "g * r", expr2: "g | r", equality: false },
    { expr1: "g * r", expr2: "g ^ r", equality: false },
    { expr1: "g * r", expr2: "g != r", equality: false },
    { expr1: "g * r", expr2: "g > r", equality: false },
    { expr1: "g * r", expr2: "g < r", equality: false },
    { expr1: "g * r", expr2: "g >= r", equality: false },
    { expr1: "g * r", expr2: "g <= r", equality: false },
    { expr1: "g * r", expr2: "g == r", equality: false },
    { expr1: "g * r", expr2: "g && r", equality: false },
    { expr1: "g * r", expr2: "g || r", equality: false },
    { expr1: "g / r", expr2: "g / r", equality: true },
    { expr1: "g / r", expr2: "r / g", equality: false },
    { expr1: "g / r", expr2: "g % r", equality: false },
    { expr1: "g / r", expr2: "g >> r", equality: false },
    { expr1: "g / r", expr2: "g << r", equality: false },
    { expr1: "g / r", expr2: "g & r", equality: false },
    { expr1: "g / r", expr2: "g | r", equality: false },
    { expr1: "g / r", expr2: "g ^ r", equality: false },
    { expr1: "g / r", expr2: "g != r", equality: false },
    { expr1: "g / r", expr2: "g > r", equality: false },
    { expr1: "g / r", expr2: "g < r", equality: false },
    { expr1: "g / r", expr2: "g >= r", equality: false },
    { expr1: "g / r", expr2: "g <= r", equality: false },
    { expr1: "g / r", expr2: "g == r", equality: false },
    { expr1: "g / r", expr2: "g && r", equality: false },
    { expr1: "g / r", expr2: "g || r", equality: false },
    { expr1: "g % r", expr2: "g % r", equality: true },
    { expr1: "g % r", expr2: "r % g", equality: false },
    { expr1: "g % r", expr2: "g >> r", equality: false },
    { expr1: "g % r", expr2: "g << r", equality: false },
    { expr1: "g % r", expr2: "g & r", equality: false },
    { expr1: "g % r", expr2: "g | r", equality: false },
    { expr1: "g % r", expr2: "g ^ r", equality: false },
    { expr1: "g % r", expr2: "g != r", equality: false },
    { expr1: "g % r", expr2: "g > r", equality: false },
    { expr1: "g % r", expr2: "g < r", equality: false },
    { expr1: "g % r", expr2: "g >= r", equality: false },
    { expr1: "g % r", expr2: "g <= r", equality: false },
    { expr1: "g % r", expr2: "g == r", equality: false },
    { expr1: "g % r", expr2: "g && r", equality: false },
    { expr1: "g % r", expr2: "g || r", equality: false },
    { expr1: "g >> r", expr2: "g >> r", equality: true },
    { expr1: "g >> r", expr2: "r >> g", equality: false },
    { expr1: "g >> r", expr2: "g << r", equality: false },
    { expr1: "g >> r", expr2: "g & r", equality: false },
    { expr1: "g >> r", expr2: "g | r", equality: false },
    { expr1: "g >> r", expr2: "g ^ r", equality: false },
    { expr1: "g >> r", expr2: "g != r", equality: false },
    { expr1: "g >> r", expr2: "g > r", equality: false },
    { expr1: "g >> r", expr2: "g < r", equality: false },
    { expr1: "g >> r", expr2: "g >= r", equality: false },
    { expr1: "g >> r", expr2: "g <= r", equality: false },
    { expr1: "g >> r", expr2: "g == r", equality: false },
    { expr1: "g >> r", expr2: "g && r", equality: false },
    { expr1: "g >> r", expr2: "g || r", equality: false },
    { expr1: "g << r", expr2: "g << r", equality: true },
    { expr1: "g << r", expr2: "r << g", equality: false },
    { expr1: "g << r", expr2: "g & r", equality: false },
    { expr1: "g << r", expr2: "g | r", equality: false },
    { expr1: "g << r", expr2: "g ^ r", equality: false },
    { expr1: "g << r", expr2: "g != r", equality: false },
    { expr1: "g << r", expr2: "g > r", equality: false },
    { expr1: "g << r", expr2: "g < r", equality: false },
    { expr1: "g << r", expr2: "g >= r", equality: false },
    { expr1: "g << r", expr2: "g <= r", equality: false },
    { expr1: "g << r", expr2: "g == r", equality: false },
    { expr1: "g << r", expr2: "g && r", equality: false },
    { expr1: "g << r", expr2: "g || r", equality: false },
    { expr1: "g & r", expr2: "g & r", equality: true },
    { expr1: "g & r", expr2: "r & g", equality: false },
    { expr1: "g & r", expr2: "g | r", equality: false },
    { expr1: "g & r", expr2: "g ^ r", equality: false },
    { expr1: "g & r", expr2: "g != r", equality: false },
    { expr1: "g & r", expr2: "g > r", equality: false },
    { expr1: "g & r", expr2: "g < r", equality: false },
    { expr1: "g & r", expr2: "g >= r", equality: false },
    { expr1: "g & r", expr2: "g <= r", equality: false },
    { expr1: "g & r", expr2: "g == r", equality: false },
    { expr1: "g & r", expr2: "g && r", equality: false },
    { expr1: "g & r", expr2: "g || r", equality: false },
    { expr1: "g | r", expr2: "g | r", equality: true },
    { expr1: "g | r", expr2: "r | g", equality: false },
    { expr1: "g | r", expr2: "g ^ r", equality: false },
    { expr1: "g | r", expr2: "g != r", equality: false },
    { expr1: "g | r", expr2: "g > r", equality: false },
    { expr1: "g | r", expr2: "g < r", equality: false },
    { expr1: "g | r", expr2: "g >= r", equality: false },
    { expr1: "g | r", expr2: "g <= r", equality: false },
    { expr1: "g | r", expr2: "g == r", equality: false },
    { expr1: "g | r", expr2: "g && r", equality: false },
    { expr1: "g | r", expr2: "g || r", equality: false },
    { expr1: "g ^ r", expr2: "g ^ r", equality: true },
    { expr1: "g ^ r", expr2: "r ^ g", equality: false },
    { expr1: "g ^ r", expr2: "g != r", equality: false },
    { expr1: "g ^ r", expr2: "g > r", equality: false },
    { expr1: "g ^ r", expr2: "g < r", equality: false },
    { expr1: "g ^ r", expr2: "g >= r", equality: false },
    { expr1: "g ^ r", expr2: "g <= r", equality: false },
    { expr1: "g ^ r", expr2: "g == r", equality: false },
    { expr1: "g ^ r", expr2: "g && r", equality: false },
    { expr1: "g ^ r", expr2: "g || r", equality: false },
    { expr1: "g != r", expr2: "g != r", equality: true },
    { expr1: "g != r", expr2: "r != g", equality: false },
    { expr1: "g != r", expr2: "g > r", equality: false },
    { expr1: "g != r", expr2: "g < r", equality: false },
    { expr1: "g != r", expr2: "g >= r", equality: false },
    { expr1: "g != r", expr2: "g <= r", equality: false },
    { expr1: "g != r", expr2: "g == r", equality: false },
    { expr1: "g != r", expr2: "g && r", equality: false },
    { expr1: "g != r", expr2: "g || r", equality: false },
    { expr1: "g > r", expr2: "g > r", equality: true },
    { expr1: "g > r", expr2: "r > g", equality: false },
    { expr1: "g > r", expr2: "g < r", equality: false },
    { expr1: "g > r", expr2: "g >= r", equality: false },
    { expr1: "g > r", expr2: "g <= r", equality: false },
    { expr1: "g > r", expr2: "g == r", equality: false },
    { expr1: "g > r", expr2: "g && r", equality: false },
    { expr1: "g > r", expr2: "g || r", equality: false },
    { expr1: "g < r", expr2: "g < r", equality: true },
    { expr1: "g < r", expr2: "r < g", equality: false },
    { expr1: "g < r", expr2: "g >= r", equality: false },
    { expr1: "g < r", expr2: "g <= r", equality: false },
    { expr1: "g < r", expr2: "g == r", equality: false },
    { expr1: "g < r", expr2: "g && r", equality: false },
    { expr1: "g < r", expr2: "g || r", equality: false },
    { expr1: "g >= r", expr2: "g >= r", equality: true },
    { expr1: "g >= r", expr2: "r >= g", equality: false },
    { expr1: "g >= r", expr2: "g <= r", equality: false },
    { expr1: "g >= r", expr2: "g == r", equality: false },
    { expr1: "g >= r", expr2: "g && r", equality: false },
    { expr1: "g >= r", expr2: "g || r", equality: false },
    { expr1: "g <= r", expr2: "g <= r", equality: true },
    { expr1: "g <= r", expr2: "r <= g", equality: false },
    { expr1: "g <= r", expr2: "g == r", equality: false },
    { expr1: "g <= r", expr2: "g && r", equality: false },
    { expr1: "g <= r", expr2: "g || r", equality: false },
    { expr1: "g == r", expr2: "g == r", equality: true },
    { expr1: "g == r", expr2: "r == g", equality: false },
    { expr1: "g == r", expr2: "g && r", equality: false },
    { expr1: "g == r", expr2: "g || r", equality: false },
    { expr1: "g && r", expr2: "g && r", equality: true },
    { expr1: "g && r", expr2: "r && g", equality: false },
    { expr1: "g && r", expr2: "g || r", equality: false },
    { expr1: "g || r", expr2: "g || r", equality: true },
    { expr1: "g || r", expr2: "r || g", equality: false },
];

const conditionalExpressions: Test[] = [
    { expr1: "g ? a : b", expr2: "g ? a : b", equality: true },
    { expr1: "g ? a : b", expr2: "g ? b : a", equality: false },
    { expr1: "g ? a : b", expr2: "b ? g : a", equality: false },
    { expr1: "g ? a : b", expr2: "b ? a : g", equality: false },
    { expr1: "g ? a : b", expr2: "a ? b : g", equality: false },
    { expr1: "g ? a : b", expr2: "a ? g : b", equality: false },
    { expr1: "g ? a : b", expr2: "g", equality: false },
    { expr1: "g ? a : b", expr2: "b", equality: false },
    { expr1: "g ? a : b", expr2: "a", equality: false },
];

const structExpressions: Test[] = [
    {
        expr1: "Test {f1: a, f2: b}",
        expr2: "Test {f1: a, f2: b}",
        equality: true,
    },
    {
        expr1: "Test {f1: a, f2: b}",
        expr2: "Test2 {f1: a, f2: b}",
        equality: false,
    },
    {
        expr1: "Test {f1: a, f2: b}",
        expr2: "Test {f3: a, f2: b}",
        equality: false,
    },
    {
        expr1: "Test {f1: a, f2: b}",
        expr2: "Test {f1: a, f3: b}",
        equality: false,
    },
    {
        expr1: "Test {f1: a, f2: b}",
        expr2: "Test {f1: c, f2: b}",
        equality: false,
    },
    {
        expr1: "Test {f1: a, f2: b}",
        expr2: "Test {f1: a, f2: c}",
        equality: false,
    },
    { expr1: "Test {f1: a, f2: b}", expr2: "Test {f1: a}", equality: false },
    {
        expr1: "Test {f1: a, f2: b}",
        expr2: "Test {f1: a, f2: b, f3: c}",
        equality: false,
    },
    { expr1: "Test {f1: a, f2: b}", expr2: "Test", equality: false },
    { expr1: "Test {f1: a, f2: b}", expr2: "f1", equality: false },
    { expr1: "Test {f1: a, f2: b}", expr2: "f2", equality: false },
    { expr1: "Test {f1: a, f2: b}", expr2: "a", equality: false },
    { expr1: "Test {f1: a, f2: b}", expr2: "b", equality: false },
];

const fieldAccessExpressions: Test[] = [
    { expr1: "s.a", expr2: "s.a", equality: true },
    { expr1: "s.a", expr2: "s.a(0)", equality: false },
    { expr1: "s.a", expr2: "a(0)", equality: false },
    { expr1: "s.a", expr2: "a", equality: false },
    { expr1: "s.a", expr2: "s.a.a", equality: false },
    { expr1: "s.a", expr2: "Test {a: e1, b: e2}.a", equality: false },
    { expr1: "s.a.a", expr2: "s.a.a", equality: true },
    { expr1: "s.a.a", expr2: "s.a.a(0)", equality: false },
    { expr1: "s.a.a", expr2: "s.a(0)", equality: false },
    { expr1: "s.a.a", expr2: "a(0)", equality: false },
    { expr1: "s.a.a", expr2: "a", equality: false },
    { expr1: "s.a.a", expr2: "Test {a: e1, b: e2}.a", equality: false },
    {
        expr1: "Test {a: e1, b: e2}.a",
        expr2: "Test {a: e1, b: e2}.a",
        equality: true,
    },
    { expr1: "Test {a: e1, b: e2}.a", expr2: "a", equality: false },
    { expr1: "Test {a: e1, b: e2}.a", expr2: "s.a", equality: false },
    { expr1: "Test {a: e1, b: e2}.a", expr2: "s.a(0)", equality: false },
    { expr1: "Test {a: e1, b: e2}.a", expr2: "a(0)", equality: false },
    { expr1: "Test {a: e1, b: e2}.a", expr2: "s.a.a", equality: false },
    {
        expr1: "Test {a: e1, b: e2}.a",
        expr2: "Test {a: e1, b: e2}.b",
        equality: false,
    },
];

const initOfExpressions: Test[] = [
    { expr1: "initOf a(b,c,d)", expr2: "initOf a(b,c,d)", equality: true },
    { expr1: "initOf a(b,c,d)", expr2: "initOf g(b,c,d)", equality: false },
    { expr1: "initOf a(b,c,d)", expr2: "initOf a(f,c,d)", equality: false },
    { expr1: "initOf a(b,c,d)", expr2: "initOf a(b,f,d)", equality: false },
    { expr1: "initOf a(b,c,d)", expr2: "initOf a(b,c,f)", equality: false },
    { expr1: "initOf a(b,c,d)", expr2: "initOf a(b)", equality: false },
    { expr1: "initOf a(b,c,d)", expr2: "initOf a(b,c)", equality: false },
    { expr1: "initOf a(b,c,d)", expr2: "initOf a(b,c,d,e)", equality: false },
    { expr1: "initOf a(b,c,d)", expr2: "a(b,c,d)", equality: false },
    { expr1: "initOf a(b,c,d)", expr2: "s.a(b,c,d)", equality: false },
];

function testEquality(expr1: string, expr2: string, equal: boolean) {
    const ast = getAstFactory();
    const { parseExpression } = getParser(ast);
    expect(eqExpressions(parseExpression(expr1), parseExpression(expr2))).toBe(
        equal,
    );
}

describe("expression-equality", () => {
    it("should correctly determine if two expressions involving values are equal or not.", () => {
        valueExpressions.forEach((test) => {
            testEquality(test.expr1, test.expr2, test.equality);
        });
    });
    it("should correctly determine if two expressions involving function calls are equal or not.", () => {
        functionCallExpressions.forEach((test) => {
            testEquality(test.expr1, test.expr2, test.equality);
        });
    });
    it("should correctly determine if two expressions involving unary operators are equal or not.", () => {
        unaryOpExpressions.forEach((test) => {
            testEquality(test.expr1, test.expr2, test.equality);
        });
    });
    it("should correctly determine if two expressions involving binary operators are equal or not.", () => {
        binaryOpExpressions.forEach((test) => {
            testEquality(test.expr1, test.expr2, test.equality);
        });
    });
    it("should correctly determine if two expressions involving conditionals are equal or not.", () => {
        conditionalExpressions.forEach((test) => {
            testEquality(test.expr1, test.expr2, test.equality);
        });
    });
    it("should correctly determine if two expressions involving structs are equal or not.", () => {
        structExpressions.forEach((test) => {
            testEquality(test.expr1, test.expr2, test.equality);
        });
    });
    it("should correctly determine if two expressions involving field accesses are equal or not.", () => {
        fieldAccessExpressions.forEach((test) => {
            testEquality(test.expr1, test.expr2, test.equality);
        });
    });
    it("should correctly determine if two expressions involving initOf are equal or not.", () => {
        initOfExpressions.forEach((test) => {
            testEquality(test.expr1, test.expr2, test.equality);
        });
    });
});


## expr-fun-call.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-fun-call.tact)
fun testFunc(): Int {
    return (0 + 1) * 10 / 20 != 10 * someId || some2 > 10 && some3 < abs(123.add(10));
}

## expr-int-literal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-int-literal.tact)
fun testFunc(): Int {
    return 0;
}

## expr-is-value.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-is-value.spec.ts)
//type Test = { expr: string; isValue: boolean };

import { getAstFactory, isValue } from "../ast";
import { getParser } from "../";

const valueExpressions: string[] = [
    "1",
    "true",
    "false",
    '"one"',
    "null",
    "Test {f1: 0, f2: true}",
    "Test {f1: 0, f2: true, f3: null}",
    "Test {f1: Test2 {c:0}, f2: true}",
];

const notValueExpressions: string[] = [
    "g",
    "Test {f1: 0, f2: b}",
    "Test {f1: a, f2: true}",
    "f(1)",
    "f(1,4)",
    "s.f(1,4)",
    "+4",
    "-4",
    "!true",
    "g!!",
    "~6",
    "0 + 1",
    "0 - 1",
    "0 * 2",
    "1 / 3",
    "2 % 4",
    "10 >> 2",
    "10 << 2",
    "10 & 4",
    "10 | 4",
    "10 ^ 4",
    "10 != 4",
    "10 > 3",
    "10 < 3",
    "10 >= 5",
    "10 <= 2",
    "10 == 7",
    "true && false",
    "true || false",
    "true ? 0 : 1",
    "s.a",
    "s.a.a",
    "Test {a: 0, b: 1}.a",
    "initOf a(0,1,null)",
];

function testIsValue(expr: string, testResult: boolean) {
    const ast = getAstFactory();
    const { parseExpression } = getParser(ast);
    expect(isValue(parseExpression(expr))).toBe(testResult);
}

describe("expression-is-value", () => {
    valueExpressions.forEach((test) => {
        it(`should correctly determine that '${test}' is a value expression.`, () => {
            testIsValue(test, true);
        });
    });
    notValueExpressions.forEach((test) => {
        it(`should correctly determine that '${test}' is NOT a value expression.`, () => {
            testIsValue(test, false);
        });
    });
});


## expr-nested-conditional.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-nested-conditional.tact)
fun testFunc(a: Int): Int {
    return a == 123 || a == 456 ? (a == 10 ? a : a * 2) : a + 2;
}

## expr-parens.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-parens.tact)
fun testFunc(): Int {
    return 1 + 2 + (123 + 3)!! > 123;
}

## expr-with-unbox.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-with-unbox.tact)
fun testFunc(): Int {
    return 1 + 2 + 3!! > 123;
}

## expr-with-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/expr-with-var.tact)
fun testFunc(): Int {
    return (0 + 1) * 10 / 20 != 10 * someId;
}

## items-asm-funs.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/items-asm-funs.tact)
asm fun keccak256(s: Slice): Int {
    1
    INT
    HASHEXT_KECCAK256
}

asm( -> 1 0) extends fun loadCoins(self: Slice): Int {
    LDVARUINT16
}

asm(c b) extends fun storeDict(b: Builder, c: Cell) {
    STDICT
}

asm(s len -> 1 0) extends fun loadInt(self: Slice, len: Int): Int {
    LDIX
}

asm fun checkAndRemoveAddExtensionPrefix(self: Slice): Int {
    x{02} SDBEGINSQ
}

asm fun checkAndRemoveAddExtensionPrefix() {
    -ROT
}

asm fun debugStr1() {
    "Works!" DEBUGSTR
}

asm fun debugStr2() { "Works!" }

asm fun createWord() {
    { INC }
}

/// Tests list and binding to a new regular word
asm fun createAndUseWord1(): Int {
    { INC } : incinc
    41 incinc
}

/// Tests weird formatting
asm fun createAndUseWord2(): Int { { INC
}
: incinc 41 incinc
}

/// Tests weird formatting
asm fun createAndUseWord3(): Int {
{
INC
}
:
incinc
41
incinc
}

/// Tests words with } inside of them
asm fun isIntAnInt(x: Int): Int {
    <{
        TRY:<{
            0 PUSHINT ADD DROP -1 PUSHINT
        }>CATCH<{
            2DROP 0 PUSHINT
        }>
    }>CONT 1 1 CALLXARGS
}


## items-method-def-initof-trailing-comma-shifts.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/items-method-def-initof-trailing-comma-shifts.tact)
fun function(a: Int, b: Int): Int {
    return (a >> b) || (a << (32 - b));
}

fun anotherFunction(
    a: Int,
    b: Int,
    ): Int {
    return (a >> b) || (a << (32 - b));
}

extends fun extension(self: Int, c: Int, d: Int) {
    return self + c + d;
}

fun coverage(a: Int, b: Int) {
    let k: Int = a.extension(
        b,
        4,
    );

    let c: Int = anotherFunction(
        a,
        b,
    );
}

fun oneMoreFunction(
    a: Int,
    b: Int,
    ): Int {
    return anotherFunction(
        a,
        b,
    );
}

contract TestContract {
    init(
        arg1: Int,
        arg2: Int,
    ) {}
}

fun test() {
    let k: StateInit = initOf TestContract(
        2,
        3,
    );
}


## items-multi-funs.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/items-multi-funs.tact)
fun testFunc() {
    return 0;
}

fun testFunc(): Int {
    return 0;
}

fun testFunc(): Bool {
    return 0;
}

## items-native-fun-decls.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/items-native-fun-decls.tact)
@name(native_name_1)
native testFunc();

@name(native_name_2)
native testFunc(): Int;

@name(native_name_3)
native testFunc(): Bool;


## items-native-fun-funcid.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/items-native-fun-funcid.tact)
@name(query')
native idTest1();

@name(query'')
native idTest2();

@name(CHECK)
native idTest3();

@name(_internal_val)
native idTest4();

@name(message_found?)
native idTest5();

@name(get_pubkeys&signatures)
native idTest6();

@name(dict::udict_set_builder)
native idTest7();

@name(_+_)
native idTest8();

@name(__)
native idTest9();

@name(fatal!)
native idTest10();

@name(123validname)
native idTest11();

@name(2+2=2*2)
native idTest12();

@name(-alsovalidname)
native idTest13();

@name(0xefefefhahaha)
native idTest14();

@name({hehehe})
native idTest15();

@name(pa{--}in"`aaa`")
native idTest16();

@name(`I'm a function too`)
native idTest17();

@name(`any symbols ; ~ () are allowed here...`)
native idTest18();

@name(C4)
native idTest19();

@name(C4g)
native idTest20();

@name(4C)
native idTest21();

// Fun fact:
// Individually, _0x0 and _0 are totally valid identifiers in FunC, and the resulting Fift works fine too.
// But if they're together, FunC still compiles, but Fift interpreter cannot deal with that and crashes.
// Same goes for identifiers using hashes # or emojis.
// I.e., you can have a function with any of those combinations of characters, but only one.

@name(_0x0)
native idTest22();

@name(_0)
native idTest23();

@name(0x_)
native idTest24();

@name(0x0_)
native idTest25();

@name(0_)
native idTest26();

@name(hash#256)
native idTest27();

@name(💀💀💀0xDEADBEEF💀💀💀)
native idTest28();

@name(__tact_verify_address)
native idTest29();

@name(__tact_pow2)
native idTest30();

@name(randomize_lt)
native idTest31();

@name(fixed248::asin)
native idTest32();

@name(fixed248::nrand_fast)
native idTest33();

@name(atan_f261_inlined)
native idTest34();

@name(~impure_touch)
native idTest35();

@name(~udict::delete_get_min)
native idTest36();

@name(.something)
native idTest37();

@name(f̷̨͈͚́͌̀i̵̩͔̭̐͐̊n̸̟̝̻̩̎̓͋̕e̸̝̙̒̿͒̾̕)
native idTest38();

@name(❤️❤️❤️thanks❤️❤️❤️)
native idTest39();

@name(intslice)
native idTest40();

@name(int2)
native idTest40();


## items-struct-msg-fun-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/items-struct-msg-fun-const.tact)
struct A {
    x: Int;
    y: Int;
}

const a: A = A { x: 1 };

fun getA(): A {
    return A {
        x: 1,
        y: 2,
    };
}

message B {
    x: Int;
    y: Int;
}

const b: B = B {
    x: 2,
    y: 3,
};

fun getB(): B {
    return B { x: 1, y: 5, };
}


## literals-int-underscores-bin-dec-hex-oct.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/literals-int-underscores-bin-dec-hex-oct.tact)
fun test_fun(): Int {
    let a: Int = 123;
    let b: Int = -123;
    let c: Int = 1_0123_00_000;
    let d: Int = 0x123;
    let e: Int = -0x123;
    let f: Int = 0x1_0123_00_000;
    let g: Int = 0b101010;
    let h: Int = -0b101010;
    let i: Int = 0b1_0101_00_000;
    let j: Int = 0o123;
    let k: Int = -0o123;
    let l: Int = 0o1_0123_00_000;
    return a + b + c + d + e + f + g + h + i + j + k + l;
}

## stmt-augmented-assign-arith.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-augmented-assign-arith.tact)
fun testFunc(): Int {
    let a: Int = 1;
    let b: Int = 2;
    a += b;
    b += a;
    a += 3;
    a += b + 4;
    b -= 1;
    a -= b;
    a -= b - 1;
    b *= 2;
    a *= b;
    a *= b * 2;
    b /= 2;
    a /= b;
    a /= b / 2;
    a %= 2;
    a %= b;
    a %= b % 2;
    a <<= 2;
    a <<= b;
    a <<= b << 2;
    a >>= 2;
    a >>= b;
    a >>= b >> 2;
    return a;
}

## stmt-augmented-assign-bitwise.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-augmented-assign-bitwise.tact)
fun testFunc(): Int {
    let a: Int = 1;
    let b: Int = 2;
    a |= b;
    b |= a;
    a |= 3;
    a |= b | 4;
    b &= 1;
    a &= b;
    b &= a;
    a &= b & 1;
    b ^= 2;
    a ^= b;
    b ^= a;
    a ^= b ^ 2;
    return a;
}


## stmt-augmented-assign-logic.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-augmented-assign-logic.tact)
fun testFunc(): Bool {
    let a: Bool = true;
    let b: Bool = false;
    a ||= true;
    a ||= b;
    a ||= b || true;
    a &&= true;
    a &&= b;
    a &&= b && true;
    return a;
}

## stmt-destructuring.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-destructuring.tact)
struct S {
    a: Int;
    b: Int;
    c: Int;
}

message M {
    a: Int;
    b: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a, b, c } = s;
    let S { a: a1, .. } = s;
    let S { b: b1, .. } = s;
    let S { c: c1, .. } = s;
    let S { a: a2, b: b2, .. } = s;
    let S { a: a3, c: c3, .. } = s;
    let S { b: b4, c: c4, .. } = s;

    let m = M{ a: 1, b: 2 };
    let M { a: a_m, b: b_m } = m;

    return a + b + c + a1 + b1 + c1 + a2 + b2 + a3 + c3 + b4 + c4 + a_m + b_m;
}

## stmt-if-else.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-if-else.tact)
fun testFunc(src: Int?): Int {
    if (src != null) {
        return src;
    } else {
        return 10;
    }
}

## stmt-if.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-if.tact)
fun testFunc(src: Int?): Int {
    if (src != null) {
        return src;
    }
    return 0;
}

## stmt-optional-semicolon-for-last-statement.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-optional-semicolon-for-last-statement.tact)
// what is covered: assignment, let
fun test1() {
    let i: Int = 1;
    while(i >= 10 || i <= 100) { i += 1 }
    let i = 42
}

// what is covered: return without expression
fun test2() { return }

// what is covered: return with expression
fun test3(): Int { return 42 }

// what is covered: do-until, expression statement
fun test4(): Int {
    do { 21 + 21 } until (true && true)
}

## stmt-while-loop.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-while-loop.tact)
fun main() {
    let i: Int = 1;
    while(i >= 10 || i <= 100) {
        i = i + 1;
    }
}

## stmt-while-repeat-do-loops.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/stmt-while-repeat-do-loops.tact)
fun main() {
    let i: Int = 1;
    while(true) {
        i = i + 1;
    }
    repeat(10) {
        i = i * 10;
    }
    do {
        i = i - 1;
    } until(false);
}

## struct-field-punning.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/struct-field-punning.tact)
struct A {
    x: Int;
    y: Int;
}

const x: Int = 5;
const y: Int = 6;

const D: A = A { x, y };


## struct-msg-as.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/struct-msg-as.tact)
struct A {
    x: Int;
}

message B {
    x: Int as coin;
}

## struct-msg-initializers.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/struct-msg-initializers.tact)
struct A {
    x: Int = 1000;
}

message B {
    x: Int as coins = 1000;
    y: Bool = true;
}

## struct-msg-trailing-semicolon.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/struct-msg-trailing-semicolon.tact)
// optional trailing semicolon
struct A { x: Int }

struct B { x: Int; y: Int }

struct C { x: Int; y: Int = 42 }

struct D { x: Int = 42; y: Int }

message E { x: Int }

message F { x: Int; y: Int }

message G { x: Int; y: Int = 42 }

message G { x: Int = 42; y: Int }


## trait-optional-semicolon-for-last-const-decl.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/trait-optional-semicolon-for-last-const-decl.tact)
trait Test { abstract const foo: Int }


## trait-optional-semicolon-for-last-fun-decl.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/trait-optional-semicolon-for-last-fun-decl.tact)
trait Test { abstract fun foo() }


## traits-inheritance-trailing-comma.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/traits-inheritance-trailing-comma.tact)
primitive Int;

trait OtherTrait {
    c: Int;
}

trait SomeTrait with OtherTrait, {
    a: Int;
}

contract Main with SomeTrait, {
    b: Int;
}


## type-struct-with-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/type-struct-with-map.tact)
struct A {
    y: map<Int, Int>;
}

message B {
    x: map<Int, Int>;
}

## types-optional.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/grammar/test/types-optional.tact)
fun testFunc(src: Int?): Int {
    return 1 + 2 + (123 + 3)!! > 123;
}

## parseImportPath.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/parseImportPath.spec.ts)
import { parseImportPath } from "./parseImportPath";

describe("parseImportPath", () => {
    it("should reject non-relative imports", () => {
        const res = parseImportPath("some_name");
        expect(res).toBeNull();
    });
    it("should reject non-file imports", () => {
        const res = parseImportPath("./some_name/");
        expect(res).toBeNull();
    });
    it("should parse single imports", () => {
        const res = parseImportPath("./import");
        expect(res).toMatchObject(["import"]);
    });
    it("should parse multiple imports", () => {
        const res = parseImportPath("./import/second");
        expect(res).toMatchObject(["import", "second"]);
    });
});


## parseImportPath.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/parseImportPath.ts)
import normalize from "path-normalize";

export function parseImportPath(src: string) {
    if (!(src.startsWith("./") || src.startsWith("../"))) {
        return null;
    }
    if (src.endsWith("/")) {
        return null;
    }
    return normalize(src).split("/");
}


## resolveImports.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/resolveImports.spec.ts)
import { resolveImports } from "./resolveImports";
import { createNodeFileSystem } from "../vfs/createNodeFileSystem";
import path from "path";
import { getParser } from "../grammar";
import { getAstFactory } from "../grammar/ast";

describe("resolveImports", () => {
    it("should resolve imports", () => {
        const project = createNodeFileSystem(
            path.resolve(__dirname, "__testdata", "project"),
        );
        const stdlib = createNodeFileSystem(
            path.resolve(__dirname, "__testdata", "stdlib"),
        );
        const ast = getAstFactory();
        const resolved = resolveImports({
            project,
            stdlib,
            entrypoint: "./main.tact",
            parser: getParser(ast),
        });
        expect(resolved).toMatchObject({
            func: [
                {
                    code: "",
                    path: path.resolve(
                        __dirname,
                        "__testdata",
                        "stdlib",
                        "stdlib2.fc",
                    ),
                },
            ],
            tact: [
                {
                    code: 'import "./stdlib2.fc";',
                    path: path.resolve(
                        __dirname,
                        "__testdata",
                        "stdlib",
                        "stdlib.tact",
                    ),
                },
                {
                    code: "",
                    path: path.resolve(
                        __dirname,
                        "__testdata",
                        "project",
                        "imported.tact",
                    ),
                },
                {
                    code: 'import "../imported_from_subfolder";',
                    path: path.resolve(
                        __dirname,
                        "__testdata",
                        "project",
                        "subfolder",
                        "import_from_parent.tact",
                    ),
                },
                {
                    code: "",
                    path: path.resolve(
                        __dirname,
                        "__testdata",
                        "project",
                        "imported_from_subfolder.tact",
                    ),
                },
                {
                    code: 'import "./imported"; import "./subfolder/import_from_parent";',
                    path: path.resolve(
                        __dirname,
                        "__testdata",
                        "project",
                        "main.tact",
                    ),
                },
            ],
        });
    });
});


## resolveImports.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/resolveImports.ts)
import { ItemOrigin, Parser } from "../grammar";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
import { throwCompilationError } from "../errors";
import { resolveLibrary } from "./resolveLibrary";

export function resolveImports(args: {
    entrypoint: string;
    project: VirtualFileSystem;
    stdlib: VirtualFileSystem;
    parser: Parser;
}) {
    //
    // Load stdlib and entrypoint
    //

    // const stdlibFuncPath = args.stdlib.resolve('./stdlib.fc');
    // const stdlibFunc = args.stdlib.readFile(stdlibFuncPath).toString();

    const stdlibTactPath = args.stdlib.resolve("stdlib.tact");
    if (!args.stdlib.exists(stdlibTactPath)) {
        throwCompilationError(
            `Could not find stdlib.tact at ${stdlibTactPath}`,
        );
    }
    const stdlibTact = args.stdlib.readFile(stdlibTactPath).toString();

    const codePath = args.project.resolve(args.entrypoint);
    if (!args.project.exists(codePath)) {
        throwCompilationError(`Could not find entrypoint ${args.entrypoint}`);
    }
    const code = args.project.readFile(codePath).toString();

    //
    // Resolve all imports
    //

    const importedTact: { code: string; path: string; origin: ItemOrigin }[] =
        [];
    const importedFunc: { code: string; path: string; origin: ItemOrigin }[] =
        [];
    const processed: Set<string> = new Set();
    const pending: { code: string; path: string; origin: ItemOrigin }[] = [];
    function processImports(source: string, path: string, origin: ItemOrigin) {
        const imp = args.parser.parseImports(source, path, origin);
        for (const i of imp) {
            const importPath = i.path.value;
            // Resolve library
            const resolved = resolveLibrary({
                path: path,
                name: importPath,
                project: args.project,
                stdlib: args.stdlib,
            });
            if (!resolved.ok) {
                throwCompilationError(
                    `Could not resolve import "${importPath}" in ${path}`,
                );
            }

            // Check if already imported
            if (resolved.kind === "func") {
                if (importedFunc.find((v) => v.path === resolved.path)) {
                    continue;
                }
            } else {
                if (importedTact.find((v) => v.path === resolved.path)) {
                    continue;
                }
            }

            // Load code
            const vfs =
                resolved.source === "project" ? args.project : args.stdlib;
            if (!vfs.exists(resolved.path)) {
                throwCompilationError(
                    `Could not find source file ${resolved.path}`,
                );
            }
            const code: string = vfs.readFile(resolved.path).toString();

            // Add to imports
            if (resolved.kind === "func") {
                importedFunc.push({ code, path: resolved.path, origin });
            } else {
                if (!processed.has(resolved.path)) {
                    processed.add(resolved.path);
                    pending.push({ path: resolved.path, code, origin });
                }
            }
        }
    }

    // Run resolve
    importedTact.push({
        code: stdlibTact,
        path: stdlibTactPath,
        origin: "stdlib",
    });
    processImports(stdlibTact, stdlibTactPath, "stdlib");
    processImports(code, codePath, "user");
    while (pending.length > 0) {
        const p = pending.shift()!;
        importedTact.push(p);
        processImports(p.code, p.path, p.origin);
    }
    importedTact.push({ code: code, path: codePath, origin: "user" }); // To keep order same as before refactoring

    // Assemble result
    return {
        tact: [...importedTact],
        func: [
            // { code: stdlibFunc, path: stdlibFuncPath },
            ...importedFunc,
        ],
    };
}


## resolveLibrary.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/resolveLibrary.spec.ts)
import { createVirtualFileSystem } from "../vfs/createVirtualFileSystem";
import { resolveLibrary } from "./resolveLibrary";

describe("resolveLibrary", () => {
    it("should resolve imports", () => {
        const project = createVirtualFileSystem("/project", {
            ["main.tact"]: "",
            ["import.tact"]: "",
            ["main.fc"]: "",
        });
        const stdlib = createVirtualFileSystem("@stdlib", {
            ["libs/config.tact"]: "",
            ["libs/config/import.tact"]: "",
        });

        // Resolve stdlib import
        let resolved = resolveLibrary({
            path: "/project/main.tact",
            name: "@stdlib/config",
            project,
            stdlib,
        });
        if (!resolved.ok) {
            throw Error("Unable to resolve library");
        }
        expect(resolved.path).toBe("@stdlib/libs/config.tact");
        expect(resolved.source).toBe("stdlib");
        expect(resolved.kind).toBe("tact");

        // Resolve import func file
        resolved = resolveLibrary({
            path: "/project/main.tact",
            name: "./main.fc",
            project,
            stdlib,
        });
        if (!resolved.ok) {
            throw Error("Unable to resolve library");
        }
        expect(resolved.path).toBe("/project/main.fc");
        expect(resolved.source).toBe("project");
        expect(resolved.kind).toBe("func");

        // Resolve import tact file
        resolved = resolveLibrary({
            path: "/project/main.tact",
            name: "./import",
            project,
            stdlib,
        });
        if (!resolved.ok) {
            throw Error("Unable to resolve library");
        }
        expect(resolved.path).toBe("/project/import.tact");
        expect(resolved.source).toBe("project");
        expect(resolved.kind).toBe("tact");

        // Resolve import tact file
        resolved = resolveLibrary({
            path: "/project/main.tact",
            name: "./import.tact",
            project,
            stdlib,
        });
        if (!resolved.ok) {
            throw Error("Unable to resolve library");
        }
        expect(resolved.path).toBe("/project/import.tact");
        expect(resolved.source).toBe("project");
        expect(resolved.kind).toBe("tact");

        // Resolve import internal stdlib file
        resolved = resolveLibrary({
            path: "@stdlib/libs/import.tact",
            name: "./config/import",
            project,
            stdlib,
        });
        if (!resolved.ok) {
            throw Error("Unable to resolve library");
        }
        expect(resolved.path).toBe("@stdlib/libs/config/import.tact");
        expect(resolved.source).toBe("stdlib");
        expect(resolved.kind).toBe("tact");
    });
});


## resolveLibrary.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/resolveLibrary.ts)
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
import { parseImportPath } from "./parseImportPath";

type ResolveLibraryArgs = {
    path: string;
    name: string;
    project: VirtualFileSystem;
    stdlib: VirtualFileSystem;
};

type ResolveLibraryResult =
    | {
          ok: true;
          path: string;
          kind: "func" | "tact";
          source: "project" | "stdlib";
      }
    | {
          ok: false;
      };

export function resolveLibrary(args: ResolveLibraryArgs): ResolveLibraryResult {
    // Stdlib resolving
    // NOTE: We are handling stdlib resolving here, because we need to enforce the stdlib import before anything else
    //       to avoid hijacking the stdlib imports
    if (args.name.startsWith("@stdlib/")) {
        const libraryName = args.name.substring("@stdlib/".length);
        const libraryPath = parseImportPath("./" + libraryName + ".tact");
        if (!libraryPath) {
            return { ok: false };
        }
        const tactFile = args.stdlib.resolve("libs", ...libraryPath);
        if (args.stdlib.exists(tactFile)) {
            return { ok: true, path: tactFile, source: "stdlib", kind: "tact" };
        } else {
            return { ok: false };
        }
    }

    // Resolve vfs
    let vfs: VirtualFileSystem;
    let source: "project" | "stdlib";
    if (args.path.startsWith(args.stdlib.root)) {
        // NOTE: stdlib checked first to avoid hijacking stdlib imports
        vfs = args.stdlib;
        source = "stdlib";
    } else if (args.path.startsWith(args.project.root)) {
        vfs = args.project;
        source = "project";
    } else {
        return { ok: false };
    }
    const workingDirectory = args.path.slice(vfs.root.length);

    // Resolving relative file
    let importName = args.name;
    const kind: "tact" | "func" = importName.endsWith(".fc") ? "func" : "tact";
    if (!importName.endsWith(".tact") && !importName.endsWith(".fc")) {
        importName = importName + ".tact";
    }

    // Resolve import
    const parsedImport = parseImportPath(importName);
    if (!parsedImport) {
        return { ok: false };
    }
    const resolvedPath = vfs.resolve(workingDirectory, "..", ...parsedImport);
    if (vfs.exists(resolvedPath)) {
        return { ok: true, path: resolvedPath, source, kind };
    }

    // Nothing matched
    return { ok: false };
}


## stdlib.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/stdlib.ts)
const files: Record<string, string> = {};
files['libs/config.tact'] =
    'ZnVuIGdldENvbmZpZ0FkZHJlc3MoKTogQWRkcmVzcyB7CiAgICBsZXQgY2VsbDogQ2VsbCA9IGdldENvbmZpZ1BhcmFtKDApISE7CiAgICBsZXQgc2M6IFNsaWNlID0g' +
    'Y2VsbC5iZWdpblBhcnNlKCk7CiAgICByZXR1cm4gbmV3QWRkcmVzcygtMSwgc2MubG9hZFVpbnQoMjU2KSk7Cn0KCmZ1biBnZXRFbGVjdG9yQWRkcmVzcygpOiBBZGRy' +
    'ZXNzIHsKICAgIGxldCBjZWxsOiBDZWxsID0gZ2V0Q29uZmlnUGFyYW0oMSkhITsKICAgIGxldCBzYzogU2xpY2UgPSBjZWxsLmJlZ2luUGFyc2UoKTsKICAgIHJldHVy' +
    'biBuZXdBZGRyZXNzKC0xLCBzYy5sb2FkVWludCgyNTYpKTsKfQ==';
files['libs/content.tact'] =
    'ZnVuIGNyZWF0ZU9mZmNoYWluQ29udGVudChsaW5rOiBTdHJpbmcpOiBDZWxsIHsKICAgIGxldCBidWlsZGVyOiBTdHJpbmdCdWlsZGVyID0gYmVnaW5TdHJpbmdGcm9t' +
    'QnVpbGRlcihiZWdpbkNlbGwoKS5zdG9yZVVpbnQoMHgwMSwgOCkpOwogICAgYnVpbGRlci5hcHBlbmQobGluayk7CiAgICByZXR1cm4gYnVpbGRlci50b0NlbGwoKTsK' +
    'fQ==';
files['libs/deploy.tact'] =
    'Cm1lc3NhZ2UgRGVwbG95IHsKICAgIHF1ZXJ5SWQ6IEludCBhcyB1aW50NjQ7Cn0KCm1lc3NhZ2UgRGVwbG95T2sgewogICAgcXVlcnlJZDogSW50IGFzIHVpbnQ2NDsK' +
    'fQoKdHJhaXQgRGVwbG95YWJsZSB7CiAgICByZWNlaXZlKGRlcGxveTogRGVwbG95KSB7CiAgICAgICAgc2VsZi5ub3RpZnkoRGVwbG95T2t7cXVlcnlJZDogZGVwbG95' +
    'LnF1ZXJ5SWR9LnRvQ2VsbCgpKTsKICAgIH0KfQoKbWVzc2FnZSBGYWN0b3J5RGVwbG95IHsKICAgIHF1ZXJ5SWQ6IEludCBhcyB1aW50NjQ7CiAgICBjYXNoYmFjazog' +
    'QWRkcmVzczsKfQoKdHJhaXQgRmFjdG9yeURlcGxveWFibGUgIHsKICAgIHJlY2VpdmUoZGVwbG95OiBGYWN0b3J5RGVwbG95KSB7CiAgICAgICAgc2VsZi5mb3J3YXJk' +
    'KGRlcGxveS5jYXNoYmFjaywgRGVwbG95T2t7cXVlcnlJZDogZGVwbG95LnF1ZXJ5SWR9LnRvQ2VsbCgpLCBmYWxzZSwgbnVsbCk7CiAgICB9Cn0=';
files['libs/dns.fc'] =
    'c2xpY2UgZG5zX3N0cmluZ190b19pbnRlcm5hbChzbGljZSBkb21haW4pIGlubGluZV9yZWYgewoKICAgIDs7IFNwZWNpYWwgY2FzZSBmb3Igcm9vdCBkb21haW4KICAg' +
    'IGlmICgoZG9tYWluLnNsaWNlX2JpdHMoKSA9PSA4KSAmIChkb21haW4uc2xpY2VfcmVmcygpID09IDApKSB7CiAgICAgICAgaWYgKGRvbWFpbi5wcmVsb2FkX3VpbnQo' +
    'OCkgPT0gNDYpIHsKICAgICAgICAgICAgcmV0dXJuIGJlZ2luX2NlbGwoKS5zdG9yZV91aW50KDAsIDgpLmVuZF9jZWxsKCkuYmVnaW5fcGFyc2UoKTsKICAgICAgICB9' +
    'CiAgICB9CiAgICAKICAgIDs7IFNwbGl0IGRvbWFpbiBpbnRvIHNlZ21lbnRzCiAgICB0dXBsZSBzZWdtZW50cyA9IG51bGwoKTsKICAgIGJ1aWxkZXIgY3VycmVudCA9' +
    'IGJlZ2luX2NlbGwoKTsKICAgIGludCBpc0N1cnJlbnRFbXB0eSA9IHRydWU7CiAgICBpbnQgaXNGaXJzdCA9IHRydWU7CiAgICBpbnQgaXNIeXBoZW4gPSBmYWxzZTsK' +
    'ICAgIHNsaWNlIGNzID0gZG9tYWluOwogICAgaW50IGNvbnRpbnVlID0gdHJ1ZTsKICAgIGRvIHsKCiAgICAgICAgOzsgUHJlcGFyZSBmb3IgbG9hZGluZyBuZXh0IGNo' +
    'YXJhY3RlcgogICAgICAgIGlmIChjcy5zbGljZV9iaXRzKCkgPT0gMCkgewogICAgICAgICAgICBpbnQgcmVmcyA9IGNzLnNsaWNlX3JlZnMoKTsKICAgICAgICAgICAg' +
    'aWYgKHJlZnMgPT0gMSkgewogICAgICAgICAgICAgICAgY3MgPSBjc35sb2FkX3JlZigpLmJlZ2luX3BhcnNlKCk7CiAgICAgICAgICAgIH0gZWxzZWlmIChyZWZzID4g' +
    'MSkgewogICAgICAgICAgICAgICAgcmV0dXJuIG51bGwoKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNvbnRpbnVlID0gZmFsc2U7CiAgICAg' +
    'ICAgICAgIH0KICAgICAgICAgICAgY29udGludWUgPSBmYWxzZTsKICAgICAgICB9CgogICAgICAgIDs7IENvbnRpbnVlIGxvYWRpbmcgbmV4dCBjaGFyYWN0ZXIKICAg' +
    'ICAgICBpZiAoY29udGludWUpIHsKICAgICAgICAgICAgaW50IGNoYXIgPSBjc35sb2FkX3VpbnQoOCk7CiAgICAgICAgICAgIDs7IHdlIGNhbiBkbyBpdCBiZWNhdXNl' +
    'IGFkZGl0aW9uYWwgVVRGLTggY2hhcmFjdGVyJ3Mgb2N0ZXRzID49IDEyOCAtLSBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzYyOS50eHQKICAgICAgICAgICAg' +
    'aW50IGlzX2h5cGhlbiA9IChjaGFyID09IDQ1KTsKICAgICAgICAgICAgaW50IGlzX2RvdCAgPSAoY2hhciA9PSA0Nik7CiAgICAgICAgICAgIGludCB2YWxpZF9jaGFy' +
    'ID0gaXNfaHlwaGVuIHwgaXNfZG90IHwgKChjaGFyID49IDQ4KSAmIChjaGFyIDw9IDU3KSkgfCAoKGNoYXIgPj0gOTcpICYgKGNoYXIgPD0gMTIyKSk7IDs7ICctJyBv' +
    'ciAwLTkgb3IgYS16CiAgICAgICAgICAgIGlmICh+IHZhbGlkX2NoYXIgfCAoaXNGaXJzdCAmIGlzX2h5cGhlbikpIHsKICAgICAgICAgICAgICAgIHJldHVybiBudWxs' +
    'KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaXNIeXBoZW4gPSBpc19oeXBoZW47CiAgICAgICAgICAgIGlmIChpc19kb3QpIHsKICAgICAgICAgICAgICAgIGlm' +
    'IChpc0ZpcnN0IHwgaXNIeXBoZW4pIHsgOzsgRW1wdHkgb3IgZW5kcyB3aXRoIGh5cGhlbgogICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsKCk7CiAgICAgICAg' +
    'ICAgICAgICB9CiAgICAgICAgICAgICAgICBzZWdtZW50cyA9IGNvbnMoY3VycmVudCwgc2VnbWVudHMpOwogICAgICAgICAgICAgICAgY3VycmVudCA9IGJlZ2luX2Nl' +
    'bGwoKTsKICAgICAgICAgICAgICAgIGlzSHlwaGVuID0gZmFsc2U7CiAgICAgICAgICAgICAgICBpc0ZpcnN0ID0gdHJ1ZTsKICAgICAgICAgICAgICAgIGlzQ3VycmVu' +
    'dEVtcHR5ID0gdHJ1ZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlzRmlyc3QgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGlzQ3VycmVudEVt' +
    'cHR5ID0gZmFsc2U7CiAgICAgICAgICAgICAgICBjdXJyZW50fnN0b3JlX3VpbnQoY2hhciwgOCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgfSB1bnRpbCAo' +
    'fiBjb250aW51ZSk7CiAgICBpZiAoaXNIeXBoZW4pIHsgOzsgZW5kcyB3aXRoIGh5cGhlbgogICAgICAgIHJldHVybiBudWxsKCk7CiAgICB9CiAgICBpZiAofiBpc0N1' +
    'cnJlbnRFbXB0eSkgewogICAgICAgIHNlZ21lbnRzID0gY29ucyhjdXJyZW50LCBzZWdtZW50cyk7CiAgICB9CgogICAgOzsgQ29uY2F0ZW5hdGUgc2VnbWVudHMKICAg' +
    'IGJ1aWxkZXIgcmVzID0gYmVnaW5fY2VsbCgpOwogICAgKGJ1aWxkZXIgYiwgdHVwbGUgdGFpbCkgPSB1bmNvbnMoc2VnbWVudHMpOwogICAgcmVzID0gcmVzLnN0b3Jl' +
    'X2J1aWxkZXIoYik7CiAgICB3aGlsZSh+IG51bGw/KHRhaWwpKSB7CiAgICAgICAgKGIsIHRhaWwpID0gdW5jb25zKHRhaWwpOwogICAgICAgIHJlcyA9IHJlcy5zdG9y' +
    'ZV91aW50KDAsIDgpOyA7OyBBZGQgXDAgc2VwYXJhdG9yCiAgICAgICAgcmVzID0gcmVzLnN0b3JlX2J1aWxkZXIoYik7CiAgICB9CiAgICByZXMgPSByZXMuc3RvcmVf' +
    'dWludCgwLCA4KTsgOzsgQWRkIFwwIHNlcGFyYXRvcgogICAgcmV0dXJuIHJlcy5lbmRfY2VsbCgpLmJlZ2luX3BhcnNlKCk7Cn0KCmludCBkbnNfaW50ZXJuYWxfdmVy' +
    'aWZ5KHNsaWNlIHNjKSBpbmxpbmVfcmVmIHsKICAgIGlmIChzYy5zbGljZV9yZWZzKCkgIT0gMCkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIGludCBi' +
    'aXRzID0gc2Muc2xpY2VfYml0cygpOwogICAgaWYgKGJpdHMgJSA4ICE9IDApIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBpZiAoYml0cyA9PSAwKSB7' +
    'IDs7IENhc2UgZm9yIHJvb3QgZG9tYWluCiAgICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgICBpbnQgbGVuID0gYml0cyAvIDg7CiAgICBpbnQgY291bnRlciA9IDA7' +
    'CiAgICBpbnQgaXNGaXJzdCA9IHRydWU7CiAgICBpbnQgaXNIeXBoZW4gPSBmYWxzZTsKICAgIHJlcGVhdChsZW4pIHsKICAgICAgICBpbnQgY2hhciA9IHNjfmxvYWRf' +
    'dWludCg4KTsKICAgICAgICBpZiAoY2hhciA9PSAwKSB7CiAgICAgICAgICAgIGlmIChjb3VudGVyID09IDApIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsK' +
    'ICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoaXNIeXBoZW4pIHsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAg' +
    'ICBjb3VudGVyID0gMDsKICAgICAgICAgICAgaXNIeXBoZW4gPSBmYWxzZTsKICAgICAgICAgICAgaXNGaXJzdCA9IHRydWU7CiAgICAgICAgfSBlbHNlIHsKICAgICAg' +
    'ICAgICAgaW50IGNoYXJJc0h5cGhlbiA9IChjaGFyID09IDQ1KTsKICAgICAgICAgICAgaW50IGlzVmFsaWQgPSBjaGFySXNIeXBoZW4gfCAoKGNoYXIgPj0gNDgpICYg' +
    'KGNoYXIgPD0gNTcpKSB8ICgoY2hhciA+PSA5NykgJiAoY2hhciA8PSAxMjIpKTsKICAgICAgICAgICAgaWYgKH4gaXNWYWxpZCkgewogICAgICAgICAgICAgICAgcmV0' +
    'dXJuIGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChjaGFySXNIeXBoZW4gJiBpc0ZpcnN0KSAgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNl' +
    'OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlzSHlwaGVuID0gY2hhcklzSHlwaGVuOwogICAgICAgICAgICBpc0ZpcnN0ID0gZmFsc2U7CiAgICAgICAgICAgIGNv' +
    'dW50ZXIgPSBjb3VudGVyICsgMTsKICAgICAgICB9CiAgICB9CiAgICByZXR1cm4gY291bnRlciA9PSAwICYgfiBpc0h5cGhlbjsKfQoKc2xpY2UgZG5zX2ludGVybmFs' +
    'X25vcm1hbGl6ZShzbGljZSBzcmMpIGltcHVyZSBpbmxpbmVfcmVmIHsKICAgIHRocm93X3VubGVzcygxMzQsIHNyYy5zbGljZV9yZWZzKCkgPT0gMCk7IDs7IEludmFs' +
    'aWQgYXJndW1lbnQgZXJyb3IKICAgIGJ1aWxkZXIgdGFyZ2V0ID0gYmVnaW5fY2VsbCgpOwogICAgcmVwZWF0KHNyYy5zbGljZV9iaXRzKCkgLyA4KSB7CiAgICAgICAg' +
    'aW50IGNoYXIgPSBzcmN+bG9hZF91aW50KDgpOwoKICAgICAgICA7OyBiID0+IDYKICAgICAgICBpZiAoY2hhciA9PSA5OCkgewogICAgICAgICAgICBjaGFyID0gNTQ7' +
    'CiAgICAgICAgfQoKICAgICAgICA7OyBnLCBxID0+IDkKICAgICAgICBpZiAoKGNoYXIgPT0gMTAzKSB8IChjaGFyID09IDExMykpIHsKICAgICAgICAgICAgY2hhciA9' +
    'IDU3OyAgICAKICAgICAgICB9CgogICAgICAgIDs7IGwgPT4gMQogICAgICAgIGlmIChjaGFyID09IDEwOCkgewogICAgICAgICAgICBjaGFyID0gNDk7CiAgICAgICAg' +
    'fQoKICAgICAgICA7OyBvID0+IDAKICAgICAgICBpZiAoY2hhciA9PSAxMTEpIHsKICAgICAgICAgICAgY2hhciA9IDQ4OwogICAgICAgIH0KCiAgICAgICAgOzsgcyA9' +
    'PiA1CiAgICAgICAgaWYgKGNoYXIgPT0gMTE1KSB7CiAgICAgICAgICAgIGNoYXIgPSA1MzsKICAgICAgICB9CgogICAgICAgIDs7IHUgPT4gdgogICAgICAgIGlmIChj' +
    'aGFyID09IDExNykgewogICAgICAgICAgICBjaGFyID0gMTE4OwogICAgICAgIH0KCiAgICAgICAgOzsgeiA9PiAyCiAgICAgICAgaWYgKGNoYXIgPT0gMTIyKSB7CiAg' +
    'ICAgICAgICAgIGNoYXIgPSA1MDsKICAgICAgICB9CgogICAgICAgIHRhcmdldCA9IHRhcmdldC5zdG9yZV91aW50KGNoYXIsIDgpOwogICAgfQogICAgcmV0dXJuIHRh' +
    'cmdldC5lbmRfY2VsbCgpLmJlZ2luX3BhcnNlKCk7Cn0K';
files['libs/dns.tact'] =
    'aW1wb3J0ICIuL2Rucy5mYyI7CgpzdHJ1Y3QgRE5TUmVzb2x2ZVJlc3VsdCB7CiAgICBwcmVmaXg6IEludDsgCiAgICByZWNvcmQ6IENlbGw/OyAKfQoKQG5hbWUoZG5z' +
    'X3N0cmluZ190b19pbnRlcm5hbCkKbmF0aXZlIGRuc1N0cmluZ1RvSW50ZXJuYWwoc3RyOiBTdHJpbmcpOiBTbGljZT87CgpAbmFtZShkbnNfaW50ZXJuYWxfbm9ybWFs' +
    'aXplKQpuYXRpdmUgZG5zSW50ZXJuYWxOb3JtYWxpemUoc3JjOiBTbGljZSk6IFNsaWNlOwoKQG5hbWUoZG5zX2ludGVybmFsX3ZlcmlmeSkKbmF0aXZlIGRuc0ludGVy' +
    'bmFsVmVyaWZ5KHN1YmRvbWFpbjogU2xpY2UpOiBCb29sOwoKZnVuIGRuc0V4dHJhY3RUb3BEb21haW5MZW5ndGgoc3ViZG9tYWluOiBTbGljZSk6IEludCB7CiAgICBs' +
    'ZXQgaTogSW50ID0gMDsKICAgIGxldCBuZWVkQnJlYWs6IEJvb2wgPSBmYWxzZTsKICAgIGRvIHsKICAgICAgICBsZXQgY2hhcjogSW50ID0gc3ViZG9tYWluLmxvYWRV' +
    'aW50KDgpOyAvLyB3ZSBkbyBub3QgY2hlY2sgZG9tYWluLmxlbmd0aCBiZWNhdXNlIGl0IE1VU1QgY29udGFpbnMgXDAgY2hhcmFjdGVyCiAgICAgICAgbmVlZEJyZWFr' +
    'ID0gY2hhciA9PSAwOwogICAgICAgIGlmICghbmVlZEJyZWFrKSB7CiAgICAgICAgICAgIGkgPSBpICsgODsKICAgICAgICB9CiAgICB9IHVudGlsIChuZWVkQnJlYWsp' +
    'OwogICAgcmVxdWlyZShpICE9IDAsICJJbnZhbGlkIEROUyBuYW1lIik7CiAgICByZXR1cm4gaTsKfQoKZnVuIGRuc0V4dHJhY3RUb3BEb21haW4oc3ViZG9tYWluOiBT' +
    'bGljZSk6IFNsaWNlIHsKICAgIGxldCBsZW46IEludCA9IGRuc0V4dHJhY3RUb3BEb21haW5MZW5ndGgoc3ViZG9tYWluKTsKICAgIHJldHVybiBzdWJkb21haW4ubG9h' +
    'ZEJpdHMobGVuKTsKfQoKZnVuIGRuc1Jlc29sdmVOZXh0KGFkZHJlc3M6IEFkZHJlc3MpOiBDZWxsIHsKICAgIHJldHVybiBiZWdpbkNlbGwoKQogICAgICAgIC5zdG9y' +
    'ZVVpbnQoMHhiYTkzLCAxNikKICAgICAgICAuc3RvcmVBZGRyZXNzKGFkZHJlc3MpCiAgICAgICAgLmVuZENlbGwoKTsKfQoKZnVuIGRuc1Jlc29sdmVXYWxsZXQoYWRk' +
    'cmVzczogQWRkcmVzcyk6IENlbGwgewogICAgcmV0dXJuIGJlZ2luQ2VsbCgpCiAgICAgICAgLnN0b3JlVWludCgweDlmZDMsIDE2KQogICAgICAgIC5zdG9yZUFkZHJl' +
    'c3MoYWRkcmVzcykKICAgICAgICAuc3RvcmVVaW50KDAsIDgpCiAgICAgICAgLmVuZENlbGwoKTsKfQoKdHJhaXQgRE5TUmVzb2x2ZXIgewoKICAgIGdldCBmdW4gZG5z' +
    'cmVzb2x2ZShzdWJkb21haW46IFNsaWNlLCBjYXRlZ29yeTogSW50KTogRE5TUmVzb2x2ZVJlc3VsdCB7CgogICAgICAgIC8vIE5vcm1hbGl6ZQogICAgICAgIGxldCBk' +
    'ZWx0YTogSW50ID0gMDsKICAgICAgICBpZiAoc3ViZG9tYWluLnByZWxvYWRVaW50KDgpID09IDApIHsKICAgICAgICAgICAgc3ViZG9tYWluLmxvYWRVaW50KDgpOyAv' +
    'LyBTa2lwIGZpcnN0IGJ5dGUKICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSArIDg7CiAgICAgICAgfQoKICAgICAgICAvLyBDaGVja3MgY29ycmVjdG5lc3MKICAgICAg' +
    'ICByZXF1aXJlKGRuc0ludGVybmFsVmVyaWZ5KHN1YmRvbWFpbiksICJJbnZhbGlkIEROUyBuYW1lIik7CgogICAgICAgIC8vIFJlc29sdmUKICAgICAgICBsZXQgcmVz' +
    'OiBETlNSZXNvbHZlUmVzdWx0ID0gc2VsZi5kb1Jlc29sdmVETlMoc3ViZG9tYWluLCBjYXRlZ29yeSk7CiAgICAgICAgcmV0dXJuIEROU1Jlc29sdmVSZXN1bHR7cHJl' +
    'Zml4OiByZXMucHJlZml4ICsgZGVsdGEsIHJlY29yZDogcmVzLnJlY29yZH07CiAgICB9CgogICAgdmlydHVhbCBmdW4gZG9SZXNvbHZlRE5TKHN1YmRvbWFpbjogU2xp' +
    'Y2UsIGNhdGVnb3J5OiBJbnQpOiBETlNSZXNvbHZlUmVzdWx0IHsKICAgICAgICByZXR1cm4gRE5TUmVzb2x2ZVJlc3VsdHtwcmVmaXg6IHN1YmRvbWFpbi5iaXRzKCks' +
    'IHJlY29yZDogbnVsbH07CiAgICB9Cn0=';
files['libs/ownable.tact'] =
    'bWVzc2FnZSBDaGFuZ2VPd25lciB7CiAgICBxdWVyeUlkOiBJbnQgYXMgdWludDY0OwogICAgbmV3T3duZXI6IEFkZHJlc3M7Cn0KCm1lc3NhZ2UgQ2hhbmdlT3duZXJP' +
    'ayB7CiAgICBxdWVyeUlkOiBJbnQgYXMgdWludDY0OwogICAgbmV3T3duZXI6IEFkZHJlc3M7Cn0KCkBpbnRlcmZhY2UoIm9yZy50b24ub3duYWJsZSIpCnRyYWl0IE93' +
    'bmFibGUgewogICAgb3duZXI6IEFkZHJlc3M7CgogICAgZnVuIHJlcXVpcmVPd25lcigpIHsKICAgICAgICBuYXRpdmVUaHJvd1VubGVzcygxMzIsIHNlbmRlcigpID09' +
    'IHNlbGYub3duZXIpOwogICAgfQoKICAgIGdldCBmdW4gb3duZXIoKTogQWRkcmVzcyB7CiAgICAgICAgcmV0dXJuIHNlbGYub3duZXI7CiAgICB9Cn0KCkBpbnRlcmZh' +
    'Y2UoIm9yZy50b24ub3duYWJsZS50cmFuc2ZlcmFibGUudjIiKQp0cmFpdCBPd25hYmxlVHJhbnNmZXJhYmxlIHdpdGggT3duYWJsZSB7CgogICAgb3duZXI6IEFkZHJl' +
    'c3M7CgogICAgcmVjZWl2ZShtc2c6IENoYW5nZU93bmVyKSB7CiAgICAgICAgCiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNlbmRlciBpcyB0aGUgb3duZXIKICAgICAg' +
    'ICBzZWxmLnJlcXVpcmVPd25lcigpOwoKICAgICAgICAvLyBVcGRhdGUgb3duZXIKICAgICAgICBzZWxmLm93bmVyID0gbXNnLm5ld093bmVyOwoKICAgICAgICAvLyBS' +
    'ZXBseSByZXN1bHQKICAgICAgICBzZWxmLnJlcGx5KENoYW5nZU93bmVyT2t7IHF1ZXJ5SWQ6IG1zZy5xdWVyeUlkLCBuZXdPd25lcjptc2cubmV3T3duZXIgfS50b0Nl' +
    'bGwoKSk7CiAgICB9Cn0=';
files['libs/stoppable.tact'] =
    'aW1wb3J0ICIuL293bmFibGUiOwoKQGludGVyZmFjZSgib3JnLnRvbi5zdG9wcGFibGUiKQp0cmFpdCBTdG9wcGFibGUgd2l0aCBPd25hYmxlIHsKICAgIAogICAgc3Rv' +
    'cHBlZDogQm9vbDsKICAgIG93bmVyOiBBZGRyZXNzOwoKICAgIGZ1biByZXF1aXJlTm90U3RvcHBlZCgpIHsKICAgICAgICByZXF1aXJlKCFzZWxmLnN0b3BwZWQsICJD' +
    'b250cmFjdCBzdG9wcGVkIik7CiAgICB9CgogICAgZnVuIHJlcXVpcmVTdG9wcGVkKCkgewogICAgICAgIHJlcXVpcmUoc2VsZi5zdG9wcGVkLCAiQ29udHJhY3Qgbm90' +
    'IHN0b3BwZWQiKTsKICAgIH0KCiAgICByZWNlaXZlKCJTdG9wIikgewogICAgICAgIHNlbGYucmVxdWlyZU93bmVyKCk7CiAgICAgICAgc2VsZi5yZXF1aXJlTm90U3Rv' +
    'cHBlZCgpOwogICAgICAgIHNlbGYuc3RvcHBlZCA9IHRydWU7CiAgICAgICAgc2VsZi5yZXBseSgiU3RvcHBlZCIuYXNDb21tZW50KCkpOwogICAgfQoKICAgIGdldCBm' +
    'dW4gc3RvcHBlZCgpOiBCb29sIHsKICAgICAgICByZXR1cm4gc2VsZi5zdG9wcGVkOwogICAgfQp9CgpAaW50ZXJmYWNlKCJvcmcudG9uLnJlc3VtYWJsZSIpCnRyYWl0' +
    'IFJlc3VtYWJsZSB3aXRoIFN0b3BwYWJsZSB7CiAgICBzdG9wcGVkOiBCb29sOwogICAgb3duZXI6IEFkZHJlc3M7CgogICAgcmVjZWl2ZSgiUmVzdW1lIikgewogICAg' +
    'ICAgIHNlbGYucmVxdWlyZU93bmVyKCk7CiAgICAgICAgc2VsZi5yZXF1aXJlU3RvcHBlZCgpOwogICAgICAgIHNlbGYuc3RvcHBlZCA9IGZhbHNlOwogICAgICAgIHNl' +
    'bGYucmVwbHkoIlJlc3VtZWQiLmFzQ29tbWVudCgpKTsKICAgIH0KfQ==';
files['std/base.tact'] =
    'dHJhaXQgQmFzZVRyYWl0IHsKICAgIHZpcnR1YWwgY29uc3Qgc3RvcmFnZVJlc2VydmU6IEludCA9IDA7CiAgICAKICAgIHZpcnR1YWwgaW5saW5lIGZ1biByZXBseShi' +
    'b2R5OiBDZWxsPykgewogICAgICAgIHNlbGYuZm9yd2FyZChzZW5kZXIoKSwgYm9keSwgdHJ1ZSwgbnVsbCk7CiAgICB9CgogICAgdmlydHVhbCBpbmxpbmUgZnVuIG5v' +
    'dGlmeShib2R5OiBDZWxsPykgewogICAgICAgIHNlbGYuZm9yd2FyZChzZW5kZXIoKSwgYm9keSwgZmFsc2UsIG51bGwpOwogICAgfQoKICAgIHZpcnR1YWwgZnVuIGZv' +
    'cndhcmQodG86IEFkZHJlc3MsIGJvZHk6IENlbGw/LCBib3VuY2U6IEJvb2wsIGluaXQ6IFN0YXRlSW5pdD8pIHsKCiAgICAgICAgbGV0IGNvZGU6IENlbGw/ID0gbnVs' +
    'bDsKICAgICAgICBsZXQgZGF0YTogQ2VsbD8gPSBudWxsOwogICAgICAgIGlmIChpbml0ICE9IG51bGwpIHsKICAgICAgICAgICAgbGV0IGluaXQyOiBTdGF0ZUluaXQg' +
    'PSBpbml0ISE7CiAgICAgICAgICAgIGNvZGUgPSBpbml0Mi5jb2RlOwogICAgICAgICAgICBkYXRhID0gaW5pdDIuZGF0YTsKICAgICAgICB9CgogICAgICAgIC8vIExv' +
    'Y2sgc3RvcmFnZSBpZiBuZWVkZWQKICAgICAgICBpZiAoc2VsZi5zdG9yYWdlUmVzZXJ2ZSA+IDApIHsgLy8gT3B0aW1pemVkIGluIGNvbXBpbGUtdGltZQogICAgICAg' +
    'ICAgICBsZXQgY3R4OiBDb250ZXh0ID0gY29udGV4dCgpOwogICAgICAgICAgICBsZXQgYmFsYW5jZTogSW50ID0gbXlCYWxhbmNlKCk7CiAgICAgICAgICAgIGxldCBi' +
    'YWxhbmNlQmVmb3JlTWVzc2FnZTogSW50ID0gYmFsYW5jZSAtIGN0eC52YWx1ZTsKICAgICAgICAgICAgaWYgKGJhbGFuY2VCZWZvcmVNZXNzYWdlIDwgc2VsZi5zdG9y' +
    'YWdlUmVzZXJ2ZSkgewogICAgICAgICAgICAgICAgbmF0aXZlUmVzZXJ2ZShzZWxmLnN0b3JhZ2VSZXNlcnZlLCBSZXNlcnZlRXhhY3QpOwogICAgICAgICAgICAgICAg' +
    'c2VuZChTZW5kUGFyYW1ldGVyc3tib3VuY2U6IGJvdW5jZSwgdG86IHRvLCB2YWx1ZTogMCwgbW9kZTogU2VuZFJlbWFpbmluZ0JhbGFuY2UgfCBTZW5kSWdub3JlRXJy' +
    'b3JzLCBib2R5OiBib2R5LCBjb2RlOiBjb2RlLCBkYXRhOiBkYXRhIH0pOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAg' +
    'ICAgICAvLyBKdXN0IHNlbmQgd2l0aCByZW1haW5pbmcgYmFsYW5jZQogICAgICAgIHNlbmQoU2VuZFBhcmFtZXRlcnN7Ym91bmNlOiBib3VuY2UsIHRvOiB0bywgdmFs' +
    'dWU6IDAsIG1vZGU6IFNlbmRSZW1haW5pbmdWYWx1ZSB8IFNlbmRJZ25vcmVFcnJvcnMsIGJvZHk6IGJvZHksIGNvZGU6IGNvZGUsIGRhdGE6IGRhdGEgfSk7CiAgICB9' +
    'Cn0=';
files['std/cells.tact'] =
    'Ly8KLy8gQnVpbGRlcgovLwoKYXNtIGZ1biBiZWdpbkNlbGwoKTogQnVpbGRlciB7IE5FV0MgfQoKLy8gc3BlY2lhbCB0cmVhdG1lbnQgaW4gRnVuYyBjb21waWxlciwg' +
    'c28gbm90IHJlcGxhY2VkIHdpdGggYXNtICJTVElYIgpAbmFtZShzdG9yZV9pbnQpCmV4dGVuZHMgbmF0aXZlIHN0b3JlSW50KHNlbGY6IEJ1aWxkZXIsIHZhbHVlOiBJ' +
    'bnQsIGJpdHM6IEludCk6IEJ1aWxkZXI7CgovLyBzcGVjaWFsIHRyZWF0bWVudCBpbiBGdW5jIGNvbXBpbGVyLCBzbyBub3QgcmVwbGFjZWQgd2l0aCBhc20gIlNUVVgi' +
    'CkBuYW1lKHN0b3JlX3VpbnQpCmV4dGVuZHMgbmF0aXZlIHN0b3JlVWludChzZWxmOiBCdWlsZGVyLCB2YWx1ZTogSW50LCBiaXRzOiBJbnQpOiBCdWlsZGVyOwoKQG5h' +
    'bWUoX190YWN0X3N0b3JlX2Jvb2wpCmV4dGVuZHMgbmF0aXZlIHN0b3JlQm9vbChzZWxmOiBCdWlsZGVyLCB2YWx1ZTogQm9vbCk6IEJ1aWxkZXI7CgovLy8gRXh0ZW5z' +
    'aW9uIGZ1bmN0aW9uIGZvciB0aGUgYEJ1aWxkZXJgLiBBbGlhcyB0byBgQnVpbGRlci5zdG9yZUJvb2woKWAuIEF2YWlsYWJsZSBzaW5jZSBUYWN0IDEuNS4wLgovLy8K' +
    'Ly8vIGBgYHRhY3QKLy8vIGZ1biBleGFtcGxlKCkgewovLy8gICAgIGxldCBiOiBCdWlsZGVyID0gYmVnaW5DZWxsKCk7Ci8vLyAgICAgbGV0IGZpeno6IEJ1aWxkZXIg' +
    'PSBiLnN0b3JlQml0KHRydWUpOyAgLy8gd3JpdGVzIDEKLy8vICAgICBsZXQgYnV6ejogQnVpbGRlciA9IGIuc3RvcmVCaXQoZmFsc2UpOyAvLyB3cml0ZXMgMAovLy8g' +
    'fQovLy8gYGBgCi8vLwovLy8gU2VlOiBodHRwczovL2RvY3MudGFjdC1sYW5nLm9yZy9yZWYvY29yZS1jZWxscyNidWlsZGVyc3RvcmViaXQKLy8vCkBuYW1lKF9fdGFj' +
    'dF9zdG9yZV9ib29sKQpleHRlbmRzIG5hdGl2ZSBzdG9yZUJpdChzZWxmOiBCdWlsZGVyLCB2YWx1ZTogQm9vbCk6IEJ1aWxkZXI7Cgphc20gZXh0ZW5kcyBmdW4gc3Rv' +
    'cmVDb2lucyhzZWxmOiBCdWlsZGVyLCB2YWx1ZTogSW50KTogQnVpbGRlciB7IFNUVkFSVUlOVDE2IH0KCmFzbShjZWxsIHNlbGYpIGV4dGVuZHMgZnVuIHN0b3JlUmVm' +
    'KHNlbGY6IEJ1aWxkZXIsIGNlbGw6IENlbGwpOiBCdWlsZGVyIHsgU1RSRUYgfQoKYXNtIGV4dGVuZHMgZnVuIHN0b3JlU2xpY2Uoc2VsZjogQnVpbGRlciwgY2VsbDog' +
    'U2xpY2UpOiBCdWlsZGVyIHsgU1RTTElDRVIgfQoKLy8vIEV4dGVuc2lvbiBmdW5jdGlvbiBmb3IgdGhlIGBCdWlsZGVyYC4gQXZhaWxhYmxlIHNpbmNlIFRhY3QgMS41' +
    'LjAuCi8vLwovLy8gQXBwZW5kcyBhbGwgZGF0YSBmcm9tIGEgYEJ1aWxkZXJgIGBjZWxsYCB0byB0aGUgY29weSBvZiB0aGUgYEJ1aWxkZXJgLiBSZXR1cm5zIHRoYXQg' +
    'Y29weS4KLy8vCi8vLyBgYGB0YWN0Ci8vLyBmdW4gZXhhbXBsZSgpIHsKLy8vICAgICBsZXQgYjogQnVpbGRlciA9IGJlZ2luQ2VsbCgpLnN0b3JlQ29pbnMoNDIpOwov' +
    'Ly8gICAgIGxldCBmaXp6OiBCdWlsZGVyID0gYmVnaW5DZWxsKCkuc3RvcmVCdWlsZGVyKGIpOwovLy8gICAgIGIuZW5kQ2VsbCgpID09IGZpenouZW5kQ2VsbCgpOyAv' +
    'LyB0cnVlCi8vLyB9Ci8vLyBgYGAKLy8vCi8vLyBTZWU6IGh0dHBzOi8vZG9jcy50YWN0LWxhbmcub3JnL3JlZi9jb3JlLWNlbGxzI2J1aWxkZXJzdG9yZWJ1aWxkZXIK' +
    'Ly8vCmFzbSBleHRlbmRzIGZ1biBzdG9yZUJ1aWxkZXIoc2VsZjogQnVpbGRlciwgY2VsbDogQnVpbGRlcik6IEJ1aWxkZXIgeyBTVEJSIH0KCkBuYW1lKF9fdGFjdF9z' +
    'dG9yZV9hZGRyZXNzKQpleHRlbmRzIG5hdGl2ZSBzdG9yZUFkZHJlc3Moc2VsZjogQnVpbGRlciwgYWRkcmVzczogQWRkcmVzcyk6IEJ1aWxkZXI7CgovLy8gRXh0ZW5z' +
    'aW9uIGZ1bmN0aW9uIGZvciB0aGUgYEJ1aWxkZXJgLiBBdmFpbGFibGUgc2luY2UgVGFjdCAxLjUuMC4KLy8vCi8vLyBJZiB0aGUgYGNlbGxgIGlzIG5vdCBgbnVsbGAs' +
    'IHN0b3JlcyAxIGFzIGEgc2luZ2xlIGJpdCBhbmQgdGhlbiByZWZlcmVuY2UgYGNlbGxgIGludG8gdGhlIGNvcHkgb2YgdGhlIGBCdWlsZGVyYC4gUmV0dXJucyB0aGF0' +
    'IGNvcHkuCi8vLwovLy8gSWYgdGhlIGBjZWxsYCBpcyBgbnVsbGAsIG9ubHkgc3RvcmVzIDAgYXMgYSBzaW5nbGUgYml0IGludG8gdGhlIGNvcHkgb2YgdGhlIGBCdWls' +
    'ZGVyYC4gUmV0dXJucyB0aGF0IGNvcHkuCi8vLwovLy8gQXMgYSBzaW5nbGUgYENlbGxgIGNhbiBzdG9yZSB1cCB0byA0IHJlZmVyZW5jZXMsIGF0dGVtcHRzIHRvIHN0' +
    'b3JlIG1vcmUgdGhyb3cgYW4gZXhjZXB0aW9uIHdpdGggZXhpdCBjb2RlIDg6IGBDZWxsIG92ZXJmbG93YC4KLy8vCi8vLyBgYGB0YWN0Ci8vLyBmdW4gZXhhbXBsZSgp' +
    'IHsKLy8vICAgICBsZXQgYjogQnVpbGRlciA9IGJlZ2luQ2VsbCgpOwovLy8gICAgIGxldCBmaXp6OiBCdWlsZGVyID0gYgovLy8gICAgICAgICAuc3RvcmVNYXliZVJl' +
    'ZihlbXB0eUNlbGwoKSkgLy8gMSwgdGhlbiBlbXB0eSBjZWxsCi8vLyAgICAgICAgIC5zdG9yZU1heWJlUmVmKG51bGwpOyAgICAgICAvLyAwCi8vLyB9Ci8vLyBgYGAK' +
    'Ly8vCi8vLyBTZWU6IGh0dHBzOi8vZG9jcy50YWN0LWxhbmcub3JnL3JlZi9jb3JlLWNlbGxzI2J1aWxkZXJzdG9yZW1heWJlcmVmCi8vLwphc20oY2VsbCBzZWxmKSBl' +
    'eHRlbmRzIGZ1biBzdG9yZU1heWJlUmVmKHNlbGY6IEJ1aWxkZXIsIGNlbGw6IENlbGw/KTogQnVpbGRlciB7IFNUT1BUUkVGIH0KCmFzbSBleHRlbmRzIGZ1biBlbmRD' +
    'ZWxsKHNlbGY6IEJ1aWxkZXIpOiBDZWxsIHsgRU5EQyB9Cgphc20gZXh0ZW5kcyBmdW4gcmVmcyhzZWxmOiBCdWlsZGVyKTogSW50IHsgQlJFRlMgfQoKYXNtIGV4dGVu' +
    'ZHMgZnVuIGJpdHMoc2VsZjogQnVpbGRlcik6IEludCB7IEJCSVRTIH0KCi8vCi8vIFNsaWNlCi8vCgphc20gZXh0ZW5kcyBmdW4gYmVnaW5QYXJzZShzZWxmOiBDZWxs' +
    'KTogU2xpY2UgeyBDVE9TIH0KCmFzbSgtPiAxIDApIGV4dGVuZHMgbXV0YXRlcyBmdW4gbG9hZFJlZihzZWxmOiBTbGljZSk6IENlbGwgeyBMRFJFRiB9CgovLy8gRXh0' +
    'ZW5zaW9uIGZ1bmN0aW9uIGZvciB0aGUgYFNsaWNlYC4gQXZhaWxhYmxlIHNpbmNlIFRhY3QgMS41LjAuCi8vLwovLy8gUHJlbG9hZHMgdGhlIG5leHQgcmVmZXJlbmNl' +
    'IGZyb20gdGhlIGBTbGljZWAgYXMgYSBgQ2VsbGAuIERvZXNuJ3QgbW9kaWZ5IHRoZSBvcmlnaW5hbCBgU2xpY2VgLgovLy8KLy8vIEF0dGVtcHRzIHRvIHByZWxvYWQg' +
    'c3VjaCByZWZlcmVuY2UgYENlbGxgIHdoZW4gYFNsaWNlYCBkb2Vzbid0IGNvbnRhaW4gaXQgdGhyb3cgYW4gZXhjZXB0aW9uIHdpdGggZXhpdCBjb2RlIDg6IGBDZWxs' +
    'IG92ZXJmbG93YC4KLy8vCi8vLyBBdHRlbXB0cyB0byBwcmVsb2FkIG1vcmUgZGF0YSB0aGFuIGBTbGljZWAgY29udGFpbnMgdGhyb3cgYW4gZXhjZXB0aW9uIHdpdGgg' +
    'ZXhpdCBjb2RlIDk6IGBDZWxsIHVuZGVyZmxvd2AuCi8vLwovLy8gYGBgdGFjdAovLy8gZnVuIGV4YW1wbGVzKCkgewovLy8gICAgIGxldCBzMTogU2xpY2UgPSBiZWdp' +
    'bkNlbGwoKS5zdG9yZVJlZihlbXB0eUNlbGwoKSkuYXNTbGljZSgpOwovLy8gICAgIGxldCBmaXp6OiBDZWxsID0gczEucHJlbG9hZFJlZigpOyAvLyBkaWRuJ3QgbW9k' +
    'aWZ5IHMxCi8vLwovLy8gICAgIGxldCBzMjogU2xpY2UgPSBiZWdpbkNlbGwoKQovLy8gICAgICAgICAuc3RvcmVSZWYoZW1wdHlDZWxsKCkpCi8vLyAgICAgICAgIC5z' +
    'dG9yZVJlZihzMS5hc0NlbGwoKSkKLy8vICAgICAgICAgLmFzU2xpY2UoKTsKLy8vICAgICBsZXQgcmVmMTogQ2VsbCA9IHMyLnByZWxvYWRSZWYoKTsKLy8vICAgICBs' +
    'ZXQgcmVmMjogQ2VsbCA9IHMyLnByZWxvYWRSZWYoKTsKLy8vICAgICByZWYxID09IHJlZjI7IC8vIHRydWUKLy8vIH0KLy8vIGBgYAovLy8KLy8vIFNlZToKLy8vICog' +
    'aHR0cHM6Ly9kb2NzLnRhY3QtbGFuZy5vcmcvcmVmL2NvcmUtY2VsbHMjc2xpY2VwcmVsb2FkcmVmCi8vLyAqIGh0dHBzOi8vZG9jcy50YWN0LWxhbmcub3JnL2Jvb2sv' +
    'ZXhpdC1jb2RlcwovLy8KYXNtIGV4dGVuZHMgZnVuIHByZWxvYWRSZWYoc2VsZjogU2xpY2UpOiBDZWxsIHsgUExEUkVGIH0KCi8vIHNwZWNpYWwgdHJlYXRtZW50IGlu' +
    'IEZ1bmMgY29tcGlsZXIsIHNvIG5vdCByZXBsYWNlZCB3aXRoIGFzbSAiTERTTElDRVgiCkBuYW1lKGxvYWRfYml0cykKZXh0ZW5kcyBtdXRhdGVzIG5hdGl2ZSBsb2Fk' +
    'Qml0cyhzZWxmOiBTbGljZSwgbDogSW50KTogU2xpY2U7CgovLyBzcGVjaWFsIHRyZWF0bWVudCBpbiBGdW5jIGNvbXBpbGVyLCBzbyBub3QgcmVwbGFjZWQgd2l0aCBh' +
    'c20gIlBMRFNMSUNFWCIKQG5hbWUocHJlbG9hZF9iaXRzKQpleHRlbmRzIG5hdGl2ZSBwcmVsb2FkQml0cyhzZWxmOiBTbGljZSwgbDogSW50KTogU2xpY2U7CgovLyBz' +
    'cGVjaWFsIHRyZWF0bWVudCBpbiBGdW5jIGNvbXBpbGVyLCBzbyBub3QgcmVwbGFjZWQgd2l0aCBhc20gIkxESVgiCkBuYW1lKGxvYWRfaW50KQpleHRlbmRzIG11dGF0' +
    'ZXMgbmF0aXZlIGxvYWRJbnQoc2VsZjogU2xpY2UsIGw6IEludCk6IEludDsKCi8vIHNwZWNpYWwgdHJlYXRtZW50IGluIEZ1bmMgY29tcGlsZXIsIHNvIG5vdCByZXBs' +
    'YWNlZCB3aXRoIGFzbSAiUExESVgiCkBuYW1lKHByZWxvYWRfaW50KQpleHRlbmRzIG5hdGl2ZSBwcmVsb2FkSW50KHNlbGY6IFNsaWNlLCBsOiBJbnQpOiBJbnQ7Cgov' +
    'LyBzcGVjaWFsIHRyZWF0bWVudCBpbiBGdW5jIGNvbXBpbGVyLCBzbyBub3QgcmVwbGFjZWQgd2l0aCBhc20gIkxEVVgiCkBuYW1lKGxvYWRfdWludCkKZXh0ZW5kcyBt' +
    'dXRhdGVzIG5hdGl2ZSBsb2FkVWludChzZWxmOiBTbGljZSwgbDogSW50KTogSW50OwoKLy8gc3BlY2lhbCB0cmVhdG1lbnQgaW4gRnVuYyBjb21waWxlciwgc28gbm90' +
    'IHJlcGxhY2VkIHdpdGggYXNtICJQTERVWCIKQG5hbWUocHJlbG9hZF91aW50KQpleHRlbmRzIG5hdGl2ZSBwcmVsb2FkVWludChzZWxmOiBTbGljZSwgbDogSW50KTog' +
    'SW50OwoKYXNtKC0+IDEgMCkgZXh0ZW5kcyBtdXRhdGVzIGZ1biBsb2FkQm9vbChzZWxmOiBTbGljZSk6IEJvb2wgeyAxIExESSB9CgovLy8gRXh0ZW5zaW9uIG11dGF0' +
    'aW9uIGZ1bmN0aW9uIGZvciB0aGUgYFNsaWNlYC4gQWxpYXMgdG8gYFNsaWNlLmxvYWRCb29sKClgLiBBdmFpbGFibGUgc2luY2UgVGFjdCAxLjUuMC4KLy8vCi8vLyBg' +
    'YGB0YWN0Ci8vLyBmdW4gZXhhbXBsZSgpIHsKLy8vICAgICBsZXQgczogU2xpY2UgPSBiZWdpbkNlbGwoKS5zdG9yZUJvb2wodHJ1ZSkuYXNTbGljZSgpOwovLy8gICAg' +
    'IGxldCBmaXp6OiBCb29sID0gcy5sb2FkQml0KCk7IC8vIHRydWUKLy8vIH0KLy8vIGBgYAovLy8KLy8vIFNlZTogaHR0cHM6Ly9kb2NzLnRhY3QtbGFuZy5vcmcvcmVm' +
    'L2NvcmUtY2VsbHMjc2xpY2Vsb2FkYml0Ci8vLwphc20oLT4gMSAwKSBleHRlbmRzIG11dGF0ZXMgZnVuIGxvYWRCaXQoc2VsZjogU2xpY2UpOiBCb29sIHsgMSBMREkg' +
    'fQoKYXNtKCAtPiAxIDApIGV4dGVuZHMgbXV0YXRlcyBmdW4gbG9hZENvaW5zKHNlbGY6IFNsaWNlKTogSW50IHsgTERWQVJVSU5UMTYgfQoKQG5hbWUoX190YWN0X2xv' +
    'YWRfYWRkcmVzcykKZXh0ZW5kcyBtdXRhdGVzIG5hdGl2ZSBsb2FkQWRkcmVzcyhzZWxmOiBTbGljZSk6IEFkZHJlc3M7Cgphc20gZXh0ZW5kcyBtdXRhdGVzIGZ1biBz' +
    'a2lwQml0cyhzZWxmOiBTbGljZSwgbDogSW50KSB7IFNEU0tJUEZJUlNUIH0KCmFzbSBleHRlbmRzIGZ1biBlbmRQYXJzZShzZWxmOiBTbGljZSkgeyBFTkRTIH0KCi8v' +
    'Ci8vIFNsaWNlIHNpemUKLy8KCmFzbSBleHRlbmRzIGZ1biByZWZzKHNlbGY6IFNsaWNlKTogSW50IHsgU1JFRlMgfQoKYXNtIGV4dGVuZHMgZnVuIGJpdHMoc2VsZjog' +
    'U2xpY2UpOiBJbnQgeyBTQklUUyB9Cgphc20gZXh0ZW5kcyBmdW4gZW1wdHkoc2VsZjogU2xpY2UpOiBCb29sIHsgU0VNUFRZIH0KCmFzbSBleHRlbmRzIGZ1biBkYXRh' +
    'RW1wdHkoc2VsZjogU2xpY2UpOiBCb29sIHsgU0RFTVBUWSB9Cgphc20gZXh0ZW5kcyBmdW4gcmVmc0VtcHR5KHNlbGY6IFNsaWNlKTogQm9vbCB7IFNSRU1QVFkgfQoK' +
    'Ly8KLy8gQ29udmVyc2lvbnMKLy8KCmlubGluZSBleHRlbmRzIGZ1biBhc1NsaWNlKHNlbGY6IEJ1aWxkZXIpOiBTbGljZSB7CiAgICByZXR1cm4gc2VsZi5lbmRDZWxs' +
    'KCkuYmVnaW5QYXJzZSgpOwp9CgppbmxpbmUgZXh0ZW5kcyBmdW4gYXNTbGljZShzZWxmOiBDZWxsKTogU2xpY2UgewogICAgcmV0dXJuIHNlbGYuYmVnaW5QYXJzZSgp' +
    'Owp9CgppbmxpbmUgZXh0ZW5kcyBmdW4gYXNDZWxsKHNlbGY6IFNsaWNlKTogQ2VsbCB7CiAgICByZXR1cm4gYmVnaW5DZWxsKCkKICAgICAgICAuc3RvcmVTbGljZShz' +
    'ZWxmKQogICAgICAgIC5lbmRDZWxsKCk7Cn0KCmlubGluZSBleHRlbmRzIGZ1biBhc0NlbGwoc2VsZjogQnVpbGRlcik6IENlbGwgewogICAgcmV0dXJuIHNlbGYuZW5k' +
    'Q2VsbCgpOwp9CgppbmxpbmUgZnVuIGVtcHR5Q2VsbCgpOiBDZWxsIHsKICAgIHJldHVybiBiZWdpbkNlbGwoKS5lbmRDZWxsKCk7Cn0KCmlubGluZSBmdW4gZW1wdHlT' +
    'bGljZSgpOiBTbGljZSB7CiAgICByZXR1cm4gZW1wdHlDZWxsKCkuYXNTbGljZSgpOwp9Cg==';
files['std/config.tact'] =
    'YXNtIGZ1biBnZXRDb25maWdQYXJhbShpZDogSW50KTogQ2VsbD8geyBDT05GSUdPUFRQQVJBTSB9Cg==';
files['std/context.tact'] =
    'c3RydWN0IENvbnRleHQgewogICAgYm91bmNlZDogQm9vbDsKICAgIHNlbmRlcjogQWRkcmVzczsKICAgIHZhbHVlOiBJbnQ7CiAgICByYXc6IFNsaWNlOwp9CgpAbmFt' +
    'ZShfX3RhY3RfY29udGV4dF9nZXQpCm5hdGl2ZSBjb250ZXh0KCk6IENvbnRleHQ7CgpAbmFtZShfX3RhY3RfY29udGV4dF9nZXRfc2VuZGVyKQpuYXRpdmUgc2VuZGVy' +
    'KCk6IEFkZHJlc3M7CgpleHRlbmRzIGZ1biByZWFkRm9yd2FyZEZlZShzZWxmOiBDb250ZXh0KTogSW50IHsKICAgIGxldCBzYzogU2xpY2UgPSBzZWxmLnJhdzsKICAg' +
    'IHNjLmxvYWRBZGRyZXNzKCk7IC8vIFNraXAgZGVzdGluYXRpb24KICAgIHNjLmxvYWRDb2lucygpOyAvLyBTa2lwIHZhbHVlCiAgICBzYy5za2lwQml0cygxKTsgLy8g' +
    'U2tpcCBleHRyYSBjdXJyZW5jeSBjb2xsZWN0aW9uCiAgICBzYy5sb2FkQ29pbnMoKTsgLy8gU2tpcCBpaHJfZmVlCiAgICByZXR1cm4gKHNjLmxvYWRDb2lucygpICog' +
    'MykgLyAyOwp9';
files['std/contract.tact'] =
    'c3RydWN0IFN0YXRlSW5pdCB7CiAgICBjb2RlOiBDZWxsOwogICAgZGF0YTogQ2VsbDsKfQoKQG5hbWUoX190YWN0X2NvbXB1dGVfY29udHJhY3RfYWRkcmVzcykKbmF0' +
    'aXZlIGNvbnRyYWN0QWRkcmVzc0V4dChjaGFpbjogSW50LCBjb2RlOiBDZWxsLCBkYXRhOiBDZWxsKTogQWRkcmVzczsKCmlubGluZSBmdW4gY29udHJhY3RBZGRyZXNz' +
    'KHM6IFN0YXRlSW5pdCk6IEFkZHJlc3MgewogICAgcmV0dXJuIGNvbnRyYWN0QWRkcmVzc0V4dCgwLCBzLmNvZGUsIHMuZGF0YSk7Cn0KCkBuYW1lKF9fdGFjdF9hZGRy' +
    'ZXNzX3RvX3NsaWNlKQpleHRlbmRzIG5hdGl2ZSBhc1NsaWNlKHNlbGY6IEFkZHJlc3MpOiBTbGljZTsKCkBuYW1lKF9fdGFjdF9jcmVhdGVfYWRkcmVzcykKbmF0aXZl' +
    'IG5ld0FkZHJlc3MoY2hhaW46IEludCwgaGFzaDogSW50KTogQWRkcmVzczsKCmFzbSBmdW4gbXlBZGRyZXNzKCk6IEFkZHJlc3MgeyBNWUFERFIgfQoKYXNtIGZ1biBt' +
    'eUJhbGFuY2UoKTogSW50IHsgQkFMQU5DRSBGSVJTVCB9CgovLy8gR2xvYmFsIGZ1bmN0aW9uLiBBdmFpbGFibGUgc2luY2UgVGFjdCAxLjUuMC4KLy8vCi8vLyBSZXR1' +
    'cm5zIHRoZSBuYW5vVG9uY29pbiBgSW50YCBhbW91bnQgb2YgZ2FzIGNvbnN1bWVkIGJ5IFRWTSBpbiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBzbyBmYXIuIFRoZSBy' +
    'ZXN1bHRpbmcgdmFsdWUgaW5jbHVkZXMgdGhlIGNvc3Qgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLgovLy8KLy8vIGBgYHRhY3QKLy8vIGZ1biBleGFtcGxlKCkgewov' +
    'Ly8gICAgIGxldCBnYXM6IEludCA9IGdhc0NvbnN1bWVkKCk7Ci8vLyB9Ci8vLyBgYGAKLy8vCi8vLyBTZWU6IGh0dHBzOi8vZG9jcy50YWN0LWxhbmcub3JnL3JlZi9j' +
    'b3JlLWFkdmFuY2VkI2dhc2NvbnN1bWVkCi8vLwphc20gZnVuIGdhc0NvbnN1bWVkKCk6IEludCB7IEdBU0NPTlNVTUVEIH0KCi8vLyBHbG9iYWwgZnVuY3Rpb24uIEF2' +
    'YWlsYWJsZSBzaW5jZSBUYWN0IDEuNS4wLgovLy8KLy8vIFJldHVybnMgdGhlIG5hbm9Ub25jb2luIGBJbnRgIGFtb3VudCBvZiB0aGUgYWNjdW11bGF0ZWQgc3RvcmFn' +
    'ZSBmZWUgZGVidC4gU3RvcmFnZSBmZWVzIGFyZSBkZWR1Y3RlZCBmcm9tIHRoZSBpbmNvbWluZyBtZXNzYWdlIHZhbHVlIGJlZm9yZSB0aGUgbmV3IGNvbnRyYWN0IGJh' +
    'bGFuY2UgaXMgY2FsY3VsYXRlZC4KLy8vCi8vLyBgYGB0YWN0Ci8vLyBmdW4gZXhhbXBsZSgpIHsKLy8vICAgICBsZXQgZGVidDogSW50ID0gbXlTdG9yYWdlRHVlKCk7' +
    'Ci8vLyB9Ci8vLyBgYGAKLy8vCi8vLyBTZWU6IGh0dHBzOi8vZG9jcy50YWN0LWxhbmcub3JnL3JlZi9jb3JlLWFkdmFuY2VkI215c3RvcmFnZWR1ZQovLy8KYXNtIGZ1' +
    'biBteVN0b3JhZ2VEdWUoKTogSW50IHsgRFVFUEFZTUVOVCB9CgovLy8gR2xvYmFsIGZ1bmN0aW9uLiBBdmFpbGFibGUgc2luY2UgVGFjdCAxLjUuMC4KLy8vCi8vLyBD' +
    'YWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBzdG9yYWdlIGZlZSBpbiBuYW5vVG9uY29pbnMgYEludGAgZm9yIHN0b3JpbmcgYSBjb250cmFjdCB3aXRoIGEgZ2l2ZW4g' +
    'bnVtYmVyIG9mIGBjZWxsc2AgYW5kIGBiaXRzYCBmb3IgYSBudW1iZXIgb2YgYHNlY29uZHNgLiBVc2VzIHRoZSBwcmljZXMgb2YgdGhlIG1hc3RlcmNoYWluIGlmIGBp' +
    'c01hc3RlcmNoYWluYCBpcyBgdHJ1ZWAsIG90aGVyd2lzZSB0aGUgcHJpY2VzIG9mIHRoZSBiYXNlY2hhaW4uIFRoZSBjdXJyZW50IHByaWNlcyBhcmUgb2J0YWluZWQg' +
    'ZnJvbSB0aGUgY29uZmlnIHBhcmFtIDE4IG9mIFRPTiBCbG9ja2NoYWluLgovLy8KLy8vIE5vdGUsIHRoYXQgdGhlIHZhbHVlcyBvZiBgY2VsbHNgIGFuZCBgYml0c2Ag' +
    'YXJlIHRha2VuIG1vZHVsbyB0aGVpciBtYXhpbXVtIHZhbHVlcyBwbHVzIDEuIFRoYXQgaXMsIHNwZWNpZnlpbmcgdmFsdWVzIGhpZ2hlciB0aGFuIHRob3NlIGxpc3Rl' +
    'ZCBpbiBhY2NvdW50IHN0YXRlIGxpbWl0cyAoYG1heF9hY2Nfc3RhdGVfY2VsbHNgIGFuZCBgbWF4X2FjY19zdGF0ZV9iaXRzYCkgd2lsbCBoYXZlIHRoZSBzYW1lIHJl' +
    'c3VsdCBhcyB3aXRoIHNwZWNpZnlpbmcgdGhlIGV4YWN0IGxpbWl0cy4gSW4gYWRkaXRpb24sIG1ha2Ugc3VyZSB5b3UgdGFrZSBpbnRvIGFjY291bnQgdGhlIGRlZHVw' +
    'bGljYXRpb24gb2YgY2VsbHMgd2l0aCB0aGUgc2FtZSBoYXNoLgovLy8KLy8vIEF0dGVtcHRzIHRvIHNwZWNpZnkgbmVnYXRpdmUgbnVtYmVyIG9mIGBjZWxsc2AsIGBi' +
    'aXRzYCBvciBgc2Vjb25kc2AgdGhyb3cgYW4gZXhjZXB0aW9uIHdpdGggZXhpdCBjb2RlIDU6IGBJbnRlZ2VyIG91dCBvZiBleHBlY3RlZCByYW5nZWAuCi8vLwovLy8g' +
    'YGBgdGFjdAovLy8gZnVuIGV4YW1wbGUoKSB7Ci8vLyAgICAgbGV0IGZlZTogSW50ID0gZ2V0U3RvcmFnZUZlZSgxXzAwMCwgMV8wMDAsIDFfMDAwLCBmYWxzZSk7Ci8v' +
    'LyB9Ci8vLyBgYGAKLy8vCi8vLyBTZWU6Ci8vLyAqIGh0dHBzOi8vZG9jcy50YWN0LWxhbmcub3JnL3JlZi9jb3JlLWFkdmFuY2VkI2dldHN0b3JhZ2VmZWUKLy8vICog' +
    'aHR0cHM6Ly9kb2NzLnRhY3QtbGFuZy5vcmcvcmVmL2NvcmUtYWR2YW5jZWQjZ2V0c2ltcGxlc3RvcmFnZWZlZQovLy8KYXNtIGZ1biBnZXRTdG9yYWdlRmVlKGNlbGxz' +
    'OiBJbnQsIGJpdHM6IEludCwgc2Vjb25kczogSW50LCBpc01hc3RlcmNoYWluOiBCb29sKTogSW50IHsgR0VUU1RPUkFHRUZFRSB9CgovLy8gR2xvYmFsIGZ1bmN0aW9u' +
    'LiBBdmFpbGFibGUgc2luY2UgVGFjdCAxLjUuMC4KLy8vCi8vLyBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBjb21wdXRlIGZlZSBpbiBuYW5vVG9uY29pbnMgYElu' +
    'dGAgZm9yIGEgdHJhbnNhY3Rpb24gdGhhdCBjb25zdW1lZCBgZ2FzVXNlZGAgYW1vdW50IG9mIGdhcy4gVXNlcyB0aGUgcHJpY2VzIG9mIHRoZSBtYXN0ZXJjaGFpbiBp' +
    'ZiBgaXNNYXN0ZXJjaGFpbmAgaXMgYHRydWVgLCBvdGhlcndpc2UgdGhlIHByaWNlcyBvZiB0aGUgYmFzZWNoYWluLiBUaGUgY3VycmVudCBwcmljZXMgYXJlIG9idGFp' +
    'bmVkIGZyb20gdGhlIGNvbmZpZyBwYXJhbSAyMCBmb3IgdGhlIG1hc3RlcmNoYWluIGFuZCBjb25maWcgcGFyYW0gMjEgZm9yIHRoZSBiYXNlY2hhaW4gb2YgVE9OIEJs' +
    'b2NrY2hhaW4uCi8vLwovLy8gV2hlbiB0aGUgYGdhc1VzZWRgIGlzIGxlc3MgdGhhbiBhIGNlcnRhaW4gdGhyZXNob2xkIGNhbGxlZCBgZmxhdF9nYXNfbGltaXRgLCB0' +
    'aGVyZSdzIGEgbWluaW11bSBwcmljZSB0byBwYXkgYmFzZWQgb24gdGhlIHZhbHVlIG9mIGBmbGF0X2dhc19wcmljZWAuIFRoZSBsZXNzIGdhcyBpcyB1c2VkIGJlbG93' +
    'IHRoaXMgdGhyZXNob2xkLCB0aGUgaGlnaGVyIHRoZSBtaW5pbXVtIHByaWNlIHdpbGwgYmUuIFNlZSB0aGUgZXhhbXBsZSBmb3IgYGdldFNpbXBsZUNvbXB1dGVGZWUo' +
    'KWAgdG8gZGVyaXZlIHRoYXQgdGhyZXNob2xkLgovLy8KLy8vIEF0dGVtcHRzIHRvIHNwZWNpZnkgbmVnYXRpdmUgdmFsdWUgb2YgYGdhc1VzZWRgIHRocm93IGFuIGV4' +
    'Y2VwdGlvbiB3aXRoIGV4aXQgY29kZSA1OiBgSW50ZWdlciBvdXQgb2YgZXhwZWN0ZWQgcmFuZ2VgLgovLy8KLy8vIGBgYHRhY3QKLy8vIGZ1biBleGFtcGxlKCkgewov' +
    'Ly8gICAgIGxldCBmZWU6IEludCA9IGdldENvbXB1dGVGZWUoMV8wMDAsIGZhbHNlKTsKLy8vIH0KLy8vIGBgYAovLy8KLy8vIFNlZTogaHR0cHM6Ly9kb2NzLnRhY3Qt' +
    'bGFuZy5vcmcvcmVmL2NvcmUtYWR2YW5jZWQjZ2V0Y29tcHV0ZWZlZQovLy8KYXNtIGZ1biBnZXRDb21wdXRlRmVlKGdhc1VzZWQ6IEludCwgaXNNYXN0ZXJjaGFpbjog' +
    'Qm9vbCk6IEludCB7IEdFVEdBU0ZFRSB9CgovLy8gR2xvYmFsIGZ1bmN0aW9uLiBBdmFpbGFibGUgc2luY2UgVGFjdCAxLjUuMC4KLy8vCi8vLyBTaW1pbGFyIHRvIGBn' +
    'ZXRDb21wdXRlRmVlKClgLCBidXQgd2l0aG91dCB0aGUgYGZsYXRfZ2FzX3ByaWNlYCwgaS5lLiB3aXRob3V0IGEgbWluaW11bSBwcmljZSB0byBwYXkgaWYgdGhlIGBn' +
    'YXNVc2VkYCBpcyBsZXNzIHRoYW4gYSBjZXJ0YWluIHRocmVzaG9sZCBjYWxsZWQgYGZsYXRfZ2FzX2xpbWl0YC4gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyBvbmx5IHRo' +
    'ZSBgZ2FzVXNlZGAgdGltZXMgdGhlIGN1cnJlbnQgZ2FzIHByaWNlLgovLy8KLy8vIEF0dGVtcHRzIHRvIHNwZWNpZnkgbmVnYXRpdmUgbnVtYmVyIG9mIGBjZWxsc2As' +
    'IGBiaXRzYCBvciBgc2Vjb25kc2AgdGhyb3cgYW4gZXhjZXB0aW9uIHdpdGggZXhpdCBjb2RlIDU6IGBJbnRlZ2VyIG91dCBvZiBleHBlY3RlZCByYW5nZWAuCi8vLwov' +
    'Ly8gYGBgdGFjdAovLy8gZnVuIGV4YW1wbGUoKSB7Ci8vLyAgICAgbGV0IGZlZSA9IGdldENvbXB1dGVGZWUoMCwgZmFsc2UpOwovLy8gICAgIGxldCBmZWVOb0ZsYXQg' +
    'PSBnZXRTaW1wbGVDb21wdXRlRmVlKDAsIGZhbHNlKTsKLy8vICAgICBsZXQgbWF4RmxhdFByaWNlID0gZmVlIC0gZmVlTm9GbGF0OwovLy8gfQovLy8gYGBgCi8vLwov' +
    'Ly8gU2VlOgovLy8gKiBodHRwczovL2RvY3MudGFjdC1sYW5nLm9yZy9yZWYvY29yZS1hZHZhbmNlZCNnZXRzaW1wbGVzdG9yYWdlZmVlCi8vLyAqIGh0dHBzOi8vZG9j' +
    'cy50YWN0LWxhbmcub3JnL3JlZi9jb3JlLWFkdmFuY2VkI2dldHN0b3JhZ2VmZWUKLy8vCmFzbSBmdW4gZ2V0U2ltcGxlQ29tcHV0ZUZlZShnYXNVc2VkOiBJbnQsIGlz' +
    'TWFzdGVyY2hhaW46IEJvb2wpOiBJbnQgeyBHRVRHQVNGRUVTSU1QTEUgfQoKLy8vIEdsb2JhbCBmdW5jdGlvbi4gQXZhaWxhYmxlIHNpbmNlIFRhY3QgMS41LjAuCi8v' +
    'LwovLy8gQ2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgZm9yd2FyZCBmZWUgaW4gbmFub1RvbmNvaW5zIGBJbnRgIGZvciBhbiBvdXRnb2luZyBtZXNzYWdlIGNvbnNp' +
    'c3Rpbmcgb2YgYSBnaXZlbiBudW1iZXIgb2YgYGNlbGxzYCBhbmQgYGJpdHNgLiBVc2VzIHRoZSBwcmljZXMgb2YgdGhlIG1hc3RlcmNoYWluIGlmIGBpc01hc3RlcmNo' +
    'YWluYCBpcyBgdHJ1ZXs6dGFjdH1gLCBvdGhlcndpc2UgdGhlIHByaWNlcyBvZiB0aGUgYmFzZWNoYWluLiBUaGUgY3VycmVudCBwcmljZXMgYXJlIG9idGFpbmVkIGZy' +
    'b20gdGhlIGNvbmZpZyBwYXJhbSAyNCBmb3IgdGhlIG1hc3RlcmNoYWluIGFuZCBjb25maWcgcGFyYW0gMjUgZm9yIHRoZSBiYXNlY2hhaW4gb2YgVE9OIEJsb2NrY2hh' +
    'aW4uCi8vLwovLy8gSWYgYm90aCB0aGUgc291cmNlIGFuZCB0aGUgZGVzdGluYXRpb24gYWRkcmVzc2VzIGFyZSBpbiB0aGUgYmFzZWNoYWluLCB0aGVuIHNwZWNpZnkg' +
    'YGlzTWFzdGVyY2hhaW5gIGFzIGBmYWxzZWAuIE90aGVyd2lzZSwgc3BlY2lmeSBgdHJ1ZWAuCi8vLwovLy8gTm90ZSwgdGhhdCB0aGUgdmFsdWVzIG9mIGBjZWxsc2Ag' +
    'YW5kIGBiaXRzYCBhcmUgdGFrZW4gbW9kdWxvIHRoZWlyIG1heGltdW0gdmFsdWVzIHBsdXMgMS4gVGhhdCBpcywgc3BlY2lmeWluZyB2YWx1ZXMgaGlnaGVyIHRoYW4g' +
    'dGhvc2UgbGlzdGVkIGluIGFjY291bnQgc3RhdGUgbGltaXRzIChgbWF4X21zZ19jZWxsc2AgYW5kIGBtYXhfbXNnX2JpdHNgKSB3aWxsIGhhdmUgdGhlIHNhbWUgcmVz' +
    'dWx0IGFzIHdpdGggc3BlY2lmeWluZyB0aGUgZXhhY3QgbGltaXRzLgovLy8KLy8vIEhvd2V2ZXIsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlcyBvZiBgY2VsbHNgIGFu' +
    'ZCBgYml0c2AsIHRoaXMgZnVuY3Rpb24gYWx3YXlzIGFkZHMgdGhlIG1pbmltdW0gcHJpY2UgYmFzZWQgb24gdGhlIHZhbHVlIG9mIGBsdW1wX3ByaWNlYC4gU2VlIHRo' +
    'ZSBleGFtcGxlIGZvciBbYGdldFNpbXBsZUZvcndhcmRGZWUoKXs6dGFjdH1gXSgjZ2V0c2ltcGxlZm9yd2FyZGZlZSkgdG8gZGVyaXZlIGl0LiBJbiBhZGRpdGlvbiwg' +
    'bWFrZSBzdXJlIHlvdSB0YWtlIGludG8gYWNjb3VudCB0aGUgZGVkdXBsaWNhdGlvbiBvZiBjZWxscyB3aXRoIHRoZSBzYW1lIGhhc2gsIHNpbmNlIGZvciBleGFtcGxl' +
    'IHRoZSByb290IGNlbGwgYW5kIGl0cyBkYXRhIGJpdHMgZG9uJ3QgY291bnQgdG93YXJkcyB0aGUgZm9yd2FyZCBmZWUgYW5kIGFyZSBjb3ZlcmVkIGJ5IHRoZSBgbHVt' +
    'cF9wcmljZWAuCi8vLwovLy8gQXR0ZW1wdHMgdG8gc3BlY2lmeSBuZWdhdGl2ZSBudW1iZXIgb2YgYGNlbGxzYCBvciBgYml0c2AgdGhyb3cgYW4gZXhjZXB0aW9uIHdp' +
    'dGggZXhpdCBjb2RlIDU6IGBJbnRlZ2VyIG91dCBvZiBleHBlY3RlZCByYW5nZWAuCi8vLwovLy8gYGBgdGFjdAovLy8gZnVuIGV4YW1wbGUoKSB7Ci8vLyAgICAgbGV0' +
    'IGZlZTogSW50ID0gZ2V0Rm9yd2FyZEZlZSgxXzAwMCwgMV8wMDAsIGZhbHNlKTsKLy8vIH0KLy8vIGBgYAovLy8KLy8vIFNlZToKLy8vICogaHR0cHM6Ly9kb2NzLnRh' +
    'Y3QtbGFuZy5vcmcvcmVmL2NvcmUtYWR2YW5jZWQjZ2V0Zm9yd2FyZGZlZQovLy8gKiBodHRwczovL2RvY3MudGFjdC1sYW5nLm9yZy9yZWYvY29yZS1hZHZhbmNlZCNn' +
    'ZXRzaW1wbGVmb3J3YXJkZmVlCi8vLyAqIGh0dHBzOi8vZG9jcy50YWN0LWxhbmcub3JnL3JlZi9jb3JlLWFkdmFuY2VkI2dldG9yaWdpbmFsZndkZmVlCi8vLwphc20g' +
    'ZnVuIGdldEZvcndhcmRGZWUoY2VsbHM6IEludCwgYml0czogSW50LCBpc01hc3RlcmNoYWluOiBCb29sKTogSW50IHsgR0VURk9SV0FSREZFRSB9CgovLy8gR2xvYmFs' +
    'IGZ1bmN0aW9uLiBBdmFpbGFibGUgc2luY2UgVGFjdCAxLjUuMC4KLy8vCi8vLyBTaW1pbGFyIHRvIGBnZXRGb3J3YXJkRmVlKClgLCBidXQgd2l0aG91dCB0aGUgYGx1' +
    'bXBfcHJpY2VgLCBpLmUuIHdpdGhvdXQgdGhlIG1pbmltdW0gcHJpY2UgdG8gcGF5IHJlZ2FyZGxlc3Mgb2YgdGhlIGFtb3VudCBvZiBgY2VsbHNgIG9yIGBiaXRzYC4g' +
    'Q2FsY3VsYXRlcyBhbmQgcmV0dXJucyBvbmx5IHRoZSBgY2VsbHNgIHRpbWVzIHRoZSBjdXJyZW50IGNlbGwgcHJpY2UgcGx1cyBgYml0c2AgdGltZXMgdGhlIGN1cnJl' +
    'bnQgYml0IHByaWNlLgovLy8KLy8vIEF0dGVtcHRzIHRvIHNwZWNpZnkgbmVnYXRpdmUgbnVtYmVyIG9mIGBjZWxsc2Agb3IgYGJpdHNgIHRocm93IGFuIGV4Y2VwdGlv' +
    'biB3aXRoIGV4aXQgY29kZSA1OiBgSW50ZWdlciBvdXQgb2YgZXhwZWN0ZWQgcmFuZ2VgLgovLy8KLy8vIGBgYHRhY3QKLy8vIGZ1biBleGFtcGxlKCkgewovLy8gICAg' +
    'IGxldCBmZWUgPSBnZXRGb3J3YXJkRmVlKDFfMDAwLCAxXzAwMCwgZmFsc2UpOwovLy8gICAgIGxldCBmZWVOb0x1bXAgPSBnZXRTaW1wbGVGb3J3YXJkRmVlKDFfMDAw' +
    'LCAxXzAwMCwgZmFsc2UpOwovLy8gICAgIGxldCBsdW1wUHJpY2UgPSBmZWUgLSBmZWVOb0x1bXA7Ci8vLyB9Ci8vLyBgYGAKLy8vCi8vLyBTZWU6Ci8vLyAqIGh0dHBz' +
    'Oi8vZG9jcy50YWN0LWxhbmcub3JnL3JlZi9jb3JlLWFkdmFuY2VkI2dldHNpbXBsZWZvcndhcmRmZWUKLy8vICogaHR0cHM6Ly9kb2NzLnRhY3QtbGFuZy5vcmcvcmVm' +
    'L2NvcmUtYWR2YW5jZWQjZ2V0Zm9yd2FyZGZlZQovLy8KYXNtIGZ1biBnZXRTaW1wbGVGb3J3YXJkRmVlKGNlbGxzOiBJbnQsIGJpdHM6IEludCwgaXNNYXN0ZXJjaGFp' +
    'bjogQm9vbCk6IEludCB7IEdFVEZPUldBUkRGRUVTSU1QTEUgfQoKLy8vIEdsb2JhbCBmdW5jdGlvbi4gQXZhaWxhYmxlIHNpbmNlIFRhY3QgMS41LjAuCi8vLwovLy8g' +
    'Q2FsY3VsYXRlcyBhbmQgcmV0dXJucyB0aGUgc28tY2FsbGVkIF9vcmlnaW5hbF8gZm9yd2FyZCBmZWUgaW4gbmFub1RvbmNvaW5zIGBJbnRgIGZvciBhbiBvdXRnb2lu' +
    'ZyBtZXNzYWdlIGJhc2VkIG9uIHRoZSBgZndkRmVlYCBvYnRhaW5lZCBmcm9tIHRoZSBpbmNvbWluZyBtZXNzYWdlLiBJZiBib3RoIHRoZSBzb3VyY2UgYW5kIHRoZSBk' +
    'ZXN0aW5hdGlvbiBhZGRyZXNzZXMgYXJlIGluIHRoZSBiYXNlY2hhaW4sIHRoZW4gc3BlY2lmeSBgaXNNYXN0ZXJjaGFpbmAgYXMgYGZhbHNlYC4gT3RoZXJ3aXNlLCBz' +
    'cGVjaWZ5IGB0cnVlYC4KLy8vCi8vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuIHRoZSBvdXRnb2luZyBtZXNzYWdlIGRlcGVuZHMgaGVhdmlseSBvbiB0aGUg' +
    'c3RydWN0dXJlIG9mIHRoZSBpbmNvbWluZyBtZXNzYWdlLCBzbyBtdWNoIHNvIHRoYXQgeW91IGNhbm5vdCBmdWxseSBwcmVkaWN0IHRoZSBmZWUgdXNpbmcgYGdldEZv' +
    'cndhcmRGZWUoKWAgYWxvbmUuIEV2ZW4gaWYgeW91IGNvdWxkLCBjYWxjdWxhdGluZyB0aGUgZXhhY3QgZmVlIHdpdGggbmFub1RvbmNvaW4tbGV2ZWwgcHJlY2lzaW9u' +
    'IGNhbiBiZSB2ZXJ5IGV4cGVuc2l2ZSwgc28gdGhlIGFwcHJveGltYXRlIHZhbHVlIGdpdmVuIGJ5IHRoaXMgZnVuY3Rpb24gaXMgb2Z0ZW4gZ29vZCBlbm91Z2guCi8v' +
    'LwovLy8gQXR0ZW1wdHMgdG8gc3BlY2lmeSBhIG5lZ2F0aXZlIHZhbHVlIG9mIGBmd2RGZWVgIHRocm93IGFuIGV4Y2VwdGlvbiB3aXRoIGV4aXQgY29kZSA1OiBgSW50' +
    'ZWdlciBvdXQgb2YgZXhwZWN0ZWQgcmFuZ2VgLgovLy8KLy8vIGBgYHRhY3QKLy8vIGZ1biBleGFtcGxlKCkgewovLy8gICAgIGxldCBmd2RGZWU6IEludCA9IGNvbnRl' +
    'eHQoKS5yZWFkRm9yd2FyZEZlZSgpOwovLy8gICAgIGxldCBvcmlnRmVlOiBJbnQgPSBnZXRPcmlnaW5hbEZ3ZEZlZShmZWUsIGZhbHNlKTsKLy8vIH0KLy8vIGBgYAov' +
    'Ly8KLy8vIFNlZToKLy8vICogaHR0cHM6Ly9kb2NzLnRhY3QtbGFuZy5vcmcvcmVmL2NvcmUtYWR2YW5jZWQjZ2V0b3JpZ2luYWxmd2RmZWUKLy8vICogaHR0cHM6Ly9k' +
    'b2NzLnRhY3QtbGFuZy5vcmcvcmVmL2NvcmUtYWR2YW5jZWQjZ2V0Zm9yd2FyZGZlZQovLy8gKiBodHRwczovL2RvY3MudGFjdC1sYW5nLm9yZy9yZWYvY29yZS1hZHZh' +
    'bmNlZCNjb250ZXh0cmVhZGZvcndhcmRmZWUKLy8vCmFzbSBmdW4gZ2V0T3JpZ2luYWxGd2RGZWUoZndkRmVlOiBJbnQsIGlzTWFzdGVyY2hhaW46IEJvb2wpOiBJbnQg' +
    'eyBHRVRPUklHSU5BTEZXREZFRSB9CgovLy8gU3RydWN0IHJlcHJlc2VudGluZyB0aGUgc3RhbmRhcmQgYWRkcmVzcyBvbiBUT04gQmxvY2tjaGFpbiB3aXRoIHNpZ25l' +
    'ZCA4LWJpdCBgd29ya2NoYWluYCBJRCBhbmQgYW4gdW5zaWduZWQgMjU2LWJpdCBgYWRkcmVzc2AgaW4gdGhlIHNwZWNpZmllZCBgd29ya2NoYWluYC4gQXZhaWxhYmxl' +
    'IHNpbmNlIFRhY3QgMS41LjAuCi8vLwovLy8gQXQgdGhlIG1vbWVudCwgb25seSBgd29ya2NoYWluYCBJRHMgdXNlZCBvbiBUT04gYXJlIDAgb2YgdGhlIGJhc2VjaGFp' +
    'biBhbmQgLTEgb2YgdGhlIG1hc3RlcmNoYWluLgovLy8KLy8vIFNlZToKLy8vICogaHR0cHM6Ly9kb2NzLnRhY3QtbGFuZy5vcmcvcmVmL2NvcmUtYWR2YW5jZWQjcGFy' +
    'c2VzdGRhZGRyZXNzCi8vLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS90b24tYmxvY2tjaGFpbi90b24vYmxvYi9tYXN0ZXIvY3J5cHRvL2Jsb2NrL2Jsb2NrLnRsYiNMMTA1' +
    'LUwxMDYKLy8vCnN0cnVjdCBTdGRBZGRyZXNzIHsKICAgIHdvcmtjaGFpbjogSW50IGFzIGludDg7CiAgICBhZGRyZXNzOiBJbnQgYXMgdWludDI1NjsKfQoKLy8vIFN0' +
    'cnVjdCByZXByZXNlbnRpbmcgdGhlIGFkZHJlc3Mgb2YgdmFyaWFibGUgbGVuZ3RoIHdpdGggc2lnbmVkIDMyLWJpdCBgd29ya2NoYWluYCBJRCBhbmQgYSBgU2xpY2Vg' +
    'IGNvbnRhaW5pbmcgdW5zaWduZWQgYGFkZHJlc3NgIGluIHRoZSBzcGVjaWZpZWQgYHdvcmtjaGFpbmAuIEF2YWlsYWJsZSBzaW5jZSBUYWN0IDEuNS4wLgovLy8KLy8v' +
    'IFZhcmlhYmxlLWxlbmd0aCBhZGRyZXNzZXMgYXJlIGludGVuZGVkIGZvciBmdXR1cmUgZXh0ZW5zaW9ucywgYW5kIHdoaWxlIHZhbGlkYXRvcnMgbXVzdCBiZSByZWFk' +
    'eSB0byBhY2NlcHQgdGhlbSBpbiBpbmJvdW5kIG1lc3NhZ2VzLCB0aGUgc3RhbmRhcmQgKG5vbi12YXJpYWJsZSkgYWRkcmVzc2VzIGFyZSB1c2VkIHdoZW5ldmVyIHBv' +
    'c3NpYmxlLgovLy8KLy8vIFNlZToKLy8vICogaHR0cHM6Ly9kb2NzLnRhY3QtbGFuZy5vcmcvcmVmL2NvcmUtYWR2YW5jZWQjcGFyc2V2YXJhZGRyZXNzCi8vLyAqIGh0' +
    'dHBzOi8vZ2l0aHViLmNvbS90b24tYmxvY2tjaGFpbi90b24vYmxvYi9tYXN0ZXIvY3J5cHRvL2Jsb2NrL2Jsb2NrLnRsYiNMMTA3LUwxMDgKLy8vCnN0cnVjdCBWYXJB' +
    'ZGRyZXNzIHsKICAgIHdvcmtjaGFpbjogSW50IGFzIGludDMyOwogICAgYWRkcmVzczogU2xpY2U7Cn0KCi8vLyBBc3NlbWJseSBmdW5jdGlvbi4gQXZhaWxhYmxlIHNp' +
    'bmNlIFRhY3QgMS41LjAuCi8vLwovLy8gQ29udmVydHMgYSBgU2xpY2VgIGNvbnRhaW5pbmcgYW4gYWRkcmVzcyBpbnRvIHRoZSBgU3RkQWRkcmVzc2AgU3RydWN0IGFu' +
    'ZCByZXR1cm5zIGl0LgovLy8KLy8vIGBgYHRhY3QKLy8vIGZ1biBleGFtcGxlKCkgewovLy8gICAgIGxldCBhZGRyID0gYWRkcmVzcygiRVFEdEZwRXdjRkFFY1JlNW1M' +
    'VmgyTjZDMHgtX2hKRU03VzYxX0pMblNGNzRwNHEyIik7Ci8vLyAgICAgbGV0IHBhcnNlZEFkZHIgPSBwYXJzZVN0ZEFkZHJlc3MoYWRkci5hc1NsaWNlKCkpOwovLy8K' +
    'Ly8vICAgICBwYXJzZWRBZGRyLndvcmtjaGFpbjsgLy8gMAovLy8gICAgIHBhcnNlZEFkZHIuYWRkcmVzczsgICAvLyAxMDcuLi4yODcKLy8vIH0KLy8vIGBgYAovLy8K' +
    'Ly8vIFNlZTogaHR0cHM6Ly9kb2NzLnRhY3QtbGFuZy5vcmcvcmVmL2NvcmUtYWR2YW5jZWQjcGFyc2VzdGRhZGRyZXNzCi8vLwphc20gZnVuIHBhcnNlU3RkQWRkcmVz' +
    'cyhzbGljZTogU2xpY2UpOiBTdGRBZGRyZXNzIHsgUkVXUklURVNUREFERFIgfQoKLy8vIEFzc2VtYmx5IGZ1bmN0aW9uLiBBdmFpbGFibGUgc2luY2UgVGFjdCAxLjUu' +
    'MC4KLy8vCi8vLyBDb252ZXJ0cyBhIGBTbGljZWAgY29udGFpbmluZyBhbiBhZGRyZXNzIG9mIHZhcmlhYmxlIGxlbmd0aCBpbnRvIHRoZSBgVmFyQWRkcmVzc2AgU3Ry' +
    'dWN0IGFuZCByZXR1cm5zIGl0LgovLy8KLy8vIGBgYHRhY3QKLy8vIGZ1biBleGFtcGxlKCkgewovLy8gICAgIGxldCB2YXJBZGRyU2xpY2UgPSBiZWdpbkNlbGwoKQov' +
    'Ly8gICAgICAgICAuc3RvcmVVaW50KDYsIDMpICAgICAvLyB0byByZWNvZ25pemUgdGhlIGZvbGxvd2luZyBhcyBhIFZhckFkZHJlc3MKLy8vICAgICAgICAgLnN0b3Jl' +
    'VWludCgxMjMsIDkpICAgLy8gbWFrZSBhZGRyZXNzIG9jY3VweSAxMjMgYml0cwovLy8gICAgICAgICAuc3RvcmVVaW50KDIzNCwgMzIpICAvLyBzcGVjaWZ5IHdvcmtj' +
    'aGFpbiBJRCBvZiAyMzQKLy8vICAgICAgICAgLnN0b3JlVWludCgzNDUsIDEyMykgLy8gc3BlY2lmeSBhZGRyZXNzIG9mIDM0NQovLy8gICAgICAgICAuYXNTbGljZSgp' +
    'OwovLy8gICAgIGxldCBwYXJzZWRWYXJBZGRyID0gcGFyc2VWYXJBZGRyZXNzKHZhckFkZHJTbGljZSk7Ci8vLwovLy8gICAgIHBhcnNlZFZhckFkZHIud29ya2NoYWlu' +
    'OyAgICAgICAgICAgICAvLyAyMzQKLy8vICAgICBwYXJzZWRWYXJBZGRyLmFkZHJlc3M7ICAgICAgICAgICAgICAgLy8gQ1N7Q2VsbHswMDIuLi4yYjN9IGJpdHM6IDQ0' +
    'Li4xNjc7IHJlZnM6IDAuLjB9Ci8vLyAgICAgcGFyc2VkVmFyQWRkci5hZGRyZXNzLmxvYWRVaW50KDEyMyk7IC8vIDM0NQovLy8gfQovLy8gYGBgCi8vLwovLy8gU2Vl' +
    'OiBodHRwczovL2RvY3MudGFjdC1sYW5nLm9yZy9yZWYvY29yZS1hZHZhbmNlZCNwYXJzZXZhcmFkZHJlc3MKLy8vCmFzbSBmdW4gcGFyc2VWYXJBZGRyZXNzKHNsaWNl' +
    'OiBTbGljZSk6IFZhckFkZHJlc3MgeyBSRVdSSVRFVkFSQUREUiB9Cg==';
files['std/crypto.tact'] =
    'YXNtIGV4dGVuZHMgZnVuIGhhc2goc2VsZjogQ2VsbCk6IEludCB7IEhBU0hDVSB9Cgphc20gZXh0ZW5kcyBmdW4gaGFzaChzZWxmOiBTbGljZSk6IEludCB7IEhBU0hT' +
    'VSB9Cgphc20gZnVuIGNoZWNrU2lnbmF0dXJlKGhhc2g6IEludCwgc2lnbmF0dXJlOiBTbGljZSwgcHVibGljX2tleTogSW50KTogQm9vbCB7IENIS1NJR05VIH0KCmFz' +
    'bSBmdW4gY2hlY2tEYXRhU2lnbmF0dXJlKGRhdGE6IFNsaWNlLCBzaWduYXR1cmU6IFNsaWNlLCBwdWJsaWNfa2V5OiBJbnQpOiBCb29sIHsgQ0hLU0lHTlMgfQo=';
files['std/debug.tact'] =
    'Ly8gdGhlc2UgYXJlIGJ1aWx0aW4gZnVuY3Rpb25zLCB0aGVzZSBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgZnJvbSBGdW5DCi8vIGhlbmNlLCBubyBhc20gaGVyZQoKQG5h' +
    'bWUodGhyb3cpCm5hdGl2ZSBuYXRpdmVUaHJvdyhjb2RlOiBJbnQpOwoKQG5hbWUodGhyb3dfaWYpCm5hdGl2ZSBuYXRpdmVUaHJvd0lmKGNvZGU6IEludCwgY29uZGl0' +
    'aW9uOiBCb29sKTsKCkBuYW1lKHRocm93KQpuYXRpdmUgdGhyb3coY29kZTogSW50KTsKCkBuYW1lKHRocm93X3VubGVzcykKbmF0aXZlIG5hdGl2ZVRocm93VW5sZXNz' +
    'KGNvZGU6IEludCwgY29uZGl0aW9uOiBCb29sKTs=';
files['std/math.tact'] =
    'Ly8gUHJlcGFyZSByYW5kb20KCi8vIE1peGVzIHVuc2lnbmVkIDI1Ni1iaXQgaW50ZWdlciB4IGludG8gdGhlIHJhbmRvbSBzZWVkIHIgYnkgc2V0dGluZyB0aGUgcmFu' +
    'ZG9tIHNlZWQKLy8gdG8gc2hhMjU2IG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHR3byAzMi1ieXRlIHN0cmluZ3M6Ci8vIHRoZSBmaXJzdCB3aXRoIHRoZSBiaWctZW5k' +
    'aWFuIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvbGQgc2VlZCByLCBhbmQKLy8gdGhlIHNlY29uZCB3aXRoIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uIG9mIHgu' +
    'CmFzbSBmdW4gbmF0aXZlUmFuZG9taXplKHg6IEludCkgeyBBRERSQU5EIH0KCi8vLyBFcXVpdmFsZW50IHRvIGBuYXRpdmVSYW5kb21pemUoY3VyX2x0KCkpYCwKLy8v' +
    'IHdoZXJlIGBjdXJfbHQoKWAgaXMgdGhlIGxvZ2ljYWwgdGltZSBvZiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbgphc20gZnVuIG5hdGl2ZVJhbmRvbWl6ZUx0KCkgeyBM' +
    'VElNRSBBRERSQU5EIH0KCkBuYW1lKF9fdGFjdF9wcmVwYXJlX3JhbmRvbSkKbmF0aXZlIG5hdGl2ZVByZXBhcmVSYW5kb20oKTsKCi8vIFJhbmRvbQoKLy8gR2VuZXJh' +
    'dGVzIGEgbmV3IHBzZXVkby1yYW5kb20gdW5zaWduZWQgMjU2LWJpdCBpbnRlZ2VyIHguCi8vIFRoZSBhbGdvcml0aG0gaXMgYXMgZm9sbG93czogaWYgciBpcyB0aGUg' +
    'b2xkIHZhbHVlIG9mIHRoZSByYW5kb20gc2VlZCwKLy8gY29uc2lkZXJlZCBhcyBhIDMyLWJ5dGUgYXJyYXkgKGJ5IGNvbnN0cnVjdGluZyB0aGUgYmlnLWVuZGlhbiBy' +
    'ZXByZXNlbnRhdGlvbgovLyBvZiBhbiB1bnNpZ25lZCAyNTYtYml0IGludGVnZXIpLCB0aGVuIGl0cyBzaGE1MTIocikgaXMgY29tcHV0ZWQ7Ci8vIHRoZSBmaXJzdCAz' +
    'MiBieXRlcyBvZiB0aGlzIGhhc2ggYXJlIHN0b3JlZCBhcyB0aGUgbmV3IHZhbHVlIHInIG9mIHRoZSByYW5kb20gc2VlZCwKLy8gYW5kIHRoZSByZW1haW5pbmcgMzIg' +
    'Ynl0ZXMgYXJlIHJldHVybmVkIGFzIHRoZSBuZXh0IHJhbmRvbSB2YWx1ZSB4Lgphc20gZnVuIG5hdGl2ZVJhbmRvbSgpOiBJbnQgeyBSQU5EVTI1NiB9CgovLyBHZW5l' +
    'cmF0ZXMgYSBuZXcgcHNldWRvLXJhbmRvbSBpbnRlZ2VyIHogaW4gdGhlIHJhbmdlIDAuLnJhbmdl4oiSMQovLyAob3IgcmFuZ2UuLuKIkjEsIGlmIHJhbmdlIDwgMCku' +
    'Ci8vIE1vcmUgcHJlY2lzZWx5LCBhbiB1bnNpZ25lZCByYW5kb20gdmFsdWUgeCBpcyBnZW5lcmF0ZWQgYXMgaW4gYG5hdGl2ZVJhbmRvbWA7Ci8vIHRoZW4geiA6PSB4' +
    'ICogcmFuZ2UgLyAyXjI1NiBpcyBjb21wdXRlZC4KYXNtIGZ1biBuYXRpdmVSYW5kb21JbnRlcnZhbChtYXg6IEludCk6IEludCB7IFJBTkQgfQoKaW5saW5lIGZ1biBy' +
    'YW5kb21JbnQoKTogSW50IHsKICAgIG5hdGl2ZVByZXBhcmVSYW5kb20oKTsKICAgIHJldHVybiBuYXRpdmVSYW5kb20oKTsKfQoKaW5saW5lIGZ1biByYW5kb20obWlu' +
    'OiBJbnQsIG1heDogSW50KTogSW50IHsKICAgIG5hdGl2ZVByZXBhcmVSYW5kb20oKTsKICAgIHJldHVybiBtaW4gKyBuYXRpdmVSYW5kb21JbnRlcnZhbChtYXggLSBt' +
    'aW4pOwp9CgovLyBNYXRoCgphc20gZnVuIG1pbih4OiBJbnQsIHk6IEludCk6IEludCB7IE1JTiB9Cgphc20gZnVuIG1heCh4OiBJbnQsIHk6IEludCk6IEludCB7IE1B' +
    'WCB9Cgphc20gZnVuIGFicyh4OiBJbnQpOiBJbnQgeyBBQlMgfQoKYXNtIGZ1biBub3coKTogSW50IHsgTk9XIH0KCmFzbSBmdW4gbG9nMihudW06IEludCk6IEludCB7' +
    'CiAgICBEVVAgNSBUSFJPV0lGTk9UIFVCSVRTSVpFIERFQwp9CgpAbmFtZShfX3RhY3RfbG9nKQpuYXRpdmUgbG9nKG51bTogSW50LCBiYXNlOiBJbnQpOiBJbnQ7CgpA' +
    'bmFtZShfX3RhY3RfcG93KQpuYXRpdmUgcG93KGJhc2U6IEludCwgZXhwOiBJbnQpOiBJbnQ7Cgphc20gZnVuIHBvdzIoZXhwOiBJbnQpOiBJbnQgeyBQT1cyIH0=';
files['std/primitives.tact'] =
    'cHJpbWl0aXZlIEludDsKcHJpbWl0aXZlIEJvb2w7CnByaW1pdGl2ZSBCdWlsZGVyOwpwcmltaXRpdmUgU2xpY2U7CnByaW1pdGl2ZSBDZWxsOwpwcmltaXRpdmUgQWRk' +
    'cmVzczsKcHJpbWl0aXZlIFN0cmluZzsKcHJpbWl0aXZlIFN0cmluZ0J1aWxkZXI7';
files['std/reserve.tact'] =
    'YXNtIGZ1biBuYXRpdmVSZXNlcnZlKGFtb3VudDogSW50LCBtb2RlOiBJbnQpIHsgUkFXUkVTRVJWRSB9Cgpjb25zdCBSZXNlcnZlRXhhY3Q6IEludCA9IDA7CmNvbnN0' +
    'IFJlc2VydmVBbGxFeGNlcHQ6IEludCA9IDE7CmNvbnN0IFJlc2VydmVBdE1vc3Q6IEludCA9IDI7CmNvbnN0IFJlc2VydmVBZGRPcmlnaW5hbEJhbGFuY2U6IEludCA9' +
    'IDQ7CmNvbnN0IFJlc2VydmVJbnZlcnRTaWduOiBJbnQgPSA4Owpjb25zdCBSZXNlcnZlQm91bmNlSWZBY3Rpb25GYWlsOiBJbnQgPSAxNjs=';
files['std/send.tact'] =
    'YXNtIGZ1biBuYXRpdmVTZW5kTWVzc2FnZShjZWxsOiBDZWxsLCBtb2RlOiBJbnQpIHsgU0VORFJBV01TRyB9Cgphc20gZnVuIG5hdGl2ZVNlbmRNZXNzYWdlUmV0dXJu' +
    'Rm9yd2FyZEZlZShtc2c6IENlbGwsIG1vZGU6IEludCk6IEludCB7IFNFTkRNU0cgfQoKY29uc3QgU2VuZFJlbWFpbmluZ0JhbGFuY2U6IEludCA9IDEyODsKY29uc3Qg' +
    'U2VuZFJlbWFpbmluZ1ZhbHVlOiBJbnQgPSA2NDsKY29uc3QgU2VuZERlZmF1bHRNb2RlOiBJbnQgPSAwOwpjb25zdCBTZW5kSWdub3JlRXJyb3JzOiBJbnQgPSAyOwpj' +
    'b25zdCBTZW5kUGF5R2FzU2VwYXJhdGVseTogSW50ID0gMTsKY29uc3QgU2VuZERlc3Ryb3lJZlplcm86IEludCA9IDMyOwpjb25zdCBTZW5kQm91bmNlSWZBY3Rpb25G' +
    'YWlsOiBJbnQgPSAxNjsKY29uc3QgU2VuZE9ubHlFc3RpbWF0ZUZlZTogSW50ID0gMTAyNDsKCnN0cnVjdCBTZW5kUGFyYW1ldGVycyB7CiAgICBib3VuY2U6IEJvb2wg' +
    'PSB0cnVlOwogICAgdG86IEFkZHJlc3M7CiAgICB2YWx1ZTogSW50OwogICAgbW9kZTogSW50ID0gMDsKICAgIGJvZHk6IENlbGw/ID0gbnVsbDsKICAgIGNvZGU6IENl' +
    'bGw/ID0gbnVsbDsKICAgIGRhdGE6IENlbGw/ID0gbnVsbDsKfQoKZnVuIHNlbmQocGFyYW1zOiBTZW5kUGFyYW1ldGVycyk6IEludCB7IC8vIHJldHVybnMgZm9yd2Fy' +
    'ZCBmZWUKICAgIGxldCBiOiBCdWlsZGVyID0gYmVnaW5DZWxsKCk7CiAgICBiID0gYi5zdG9yZUludCgxLCAyKTsgLy8gaW50ZXJuYWxfbWVzc2FnZSArIGloZF9kaXNh' +
    'YmxlZAogICAgYiA9IGIuc3RvcmVCb29sKHBhcmFtcy5ib3VuY2UpOyAvLyBib3VuY2UKICAgIGIgPSBiLnN0b3JlSW50KDAsIDMpOyAvLyBib3VuY2VkICsgZnJvbQog' +
    'ICAgYiA9IGIuc3RvcmVBZGRyZXNzKHBhcmFtcy50byk7IC8vIFRvCiAgICBiID0gYi5zdG9yZUNvaW5zKHBhcmFtcy52YWx1ZSk7IC8vIFZhbHVlCiAgICBiID0gYi5z' +
    'dG9yZUludCgwLCAxICsgNCArIDQgKyA2NCArIDMyKTsgLy8gY3VycmVuY3lfY29sbGVjdGlvbiArIElIUiBmZWVzICsgRndkIGZlZXMgKyBDcmVhdGVkTFQgKyBDcmVh' +
    'dGVkQXQKCiAgICAvLyBTdGF0ZWluaXQKICAgIGlmIChwYXJhbXMuY29kZSAhPSBudWxsIHx8IHBhcmFtcy5kYXRhICE9IG51bGwpIHsKICAgICAgICBiID0gYi5zdG9y' +
    'ZUJvb2wodHJ1ZSk7IC8vIFN0YXRlIGluaXQKCiAgICAgICAgLy8gQXNzZW1ibGUgc3RhdGUgaW5pdCBjZWxsCiAgICAgICAgbGV0IGJjOiBCdWlsZGVyID0gYmVnaW5D' +
    'ZWxsKCk7CiAgICAgICAgYmMgPSBiYy5zdG9yZUJvb2woZmFsc2UpOyAvLyBTcGxpdERlcHRoCiAgICAgICAgYmMgPSBiYy5zdG9yZUJvb2woZmFsc2UpOyAvLyBUaWNr' +
    'VG9jawogICAgICAgIGlmIChwYXJhbXMuY29kZSAhPSBudWxsKSB7CiAgICAgICAgICAgIGJjID0gYmMuc3RvcmVCb29sKHRydWUpOyAvLyBDb2RlIHByZXNlbmNlCiAg' +
    'ICAgICAgICAgIGJjID0gYmMuc3RvcmVSZWYocGFyYW1zLmNvZGUhISk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgYmMgPSBiYy5zdG9yZUJvb2woZmFsc2Up' +
    'OyAvLyBDb2RlIHByZXNlbmNlCiAgICAgICAgfQogICAgICAgIGlmIChwYXJhbXMuZGF0YSAhPSBudWxsKSB7CiAgICAgICAgICAgIGJjID0gYmMuc3RvcmVCb29sKHRy' +
    'dWUpOyAvLyBEYXRhIHByZXNlbmNlCiAgICAgICAgICAgIGJjID0gYmMuc3RvcmVSZWYocGFyYW1zLmRhdGEhISk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAg' +
    'YmMgPSBiYy5zdG9yZUJvb2woZmFsc2UpOyAvLyBEYXRhIHByZXNlbmNlCiAgICAgICAgfQogICAgICAgIGJjID0gYmMuc3RvcmVCb29sKGZhbHNlKTsgLy8gTGlicmFy' +
    'eQoKICAgICAgICBiID0gYi5zdG9yZUJvb2wodHJ1ZSk7IC8vIFN0b3JlIGFzIHJlZgogICAgICAgIGIgPSBiLnN0b3JlUmVmKGJjLmVuZENlbGwoKSk7CiAgICB9IGVs' +
    'c2UgewogICAgICAgIGIgPSBiLnN0b3JlQm9vbChmYWxzZSk7IC8vIE5vIHN0YXRlIGluaXQKICAgIH0KCiAgICAvLyBCb2R5CiAgICBsZXQgYm9keTogQ2VsbD8gPSBw' +
    'YXJhbXMuYm9keTsKICAgIGlmIChib2R5ICE9IG51bGwpIHsKICAgICAgICBiID0gYi5zdG9yZUJvb2wodHJ1ZSk7CiAgICAgICAgYiA9IGIuc3RvcmVSZWYoYm9keSEh' +
    'KTsKICAgIH0gZWxzZSB7CiAgICAgICAgYiA9IGIuc3RvcmVCb29sKGZhbHNlKTsgLy8gTm8gYm9keQogICAgfQoKICAgIC8vIFNlbmQKICAgIGxldCBjOiBDZWxsID0g' +
    'Yi5lbmRDZWxsKCk7CiAgICByZXR1cm4gbmF0aXZlU2VuZE1lc3NhZ2VSZXR1cm5Gb3J3YXJkRmVlKGMsIHBhcmFtcy5tb2RlKTsKfQoKaW5saW5lIGZ1biBlbWl0KGJv' +
    'ZHk6IENlbGwpIHsKICAgIC8vIGV4dF9vdXRfbXNnX2luZm8kMTEgc3JjOk1zZ0FkZHJlc3NJbnQgZGVzdDpNc2dBZGRyZXNzRXh0IGNyZWF0ZWRfbHQ6dWludDY0IGNy' +
    'ZWF0ZWRfYXQ6dWludDMyCiAgICAvLyAgICAgICAgICAgICAgICAgICAgIG1heWJlOiBzdGF0ZUluaXQgKGZhbHNlKSBib2R5UmVmOiBib29sICh0cnVlKQogICAgbGV0' +
    'IGM6IENlbGwgPSBiZWdpbkNlbGwoKQogICAgICAgIC5zdG9yZVVpbnQoMTUyMTE4MDcyMDI3Mzg3NTI4MTc5NjA0Mzg0NjQ1MTMsIDEwNCkKICAgICAgICAuc3RvcmVS' +
    'ZWYoYm9keSkKICAgICAgICAuZW5kQ2VsbCgpOwogICAgbmF0aXZlU2VuZE1lc3NhZ2UoYywgMCk7Cn0KCmFzbSBmdW4gYWNjZXB0TWVzc2FnZSgpIHsgQUNDRVBUIH0K' +
    'CmFzbSBmdW4gY29tbWl0KCkgeyBDT01NSVQgfQo=';
files['std/text.tact'] =
    'Ly8KLy8gU3RyaW5nIGJ1aWxkZXIKLy8KCkBuYW1lKF9fdGFjdF9zdHJpbmdfYnVpbGRlcl9zdGFydF9zdHJpbmcpCm5hdGl2ZSBiZWdpblN0cmluZygpOiBTdHJpbmdC' +
    'dWlsZGVyOwoKQG5hbWUoX190YWN0X3N0cmluZ19idWlsZGVyX3N0YXJ0X2NvbW1lbnQpCm5hdGl2ZSBiZWdpbkNvbW1lbnQoKTogU3RyaW5nQnVpbGRlcjsKCkBuYW1l' +
    'KF9fdGFjdF9zdHJpbmdfYnVpbGRlcl9zdGFydF90YWlsX3N0cmluZykKbmF0aXZlIGJlZ2luVGFpbFN0cmluZygpOiBTdHJpbmdCdWlsZGVyOwoKQG5hbWUoX190YWN0' +
    'X3N0cmluZ19idWlsZGVyX3N0YXJ0KQpuYXRpdmUgYmVnaW5TdHJpbmdGcm9tQnVpbGRlcihiOiBCdWlsZGVyKTogU3RyaW5nQnVpbGRlcjsKCkBuYW1lKF9fdGFjdF9z' +
    'dHJpbmdfYnVpbGRlcl9hcHBlbmQpCmV4dGVuZHMgbXV0YXRlcyBuYXRpdmUgYXBwZW5kKHNlbGY6IFN0cmluZ0J1aWxkZXIsIHM6IFN0cmluZyk7CgpAbmFtZShfX3Rh' +
    'Y3Rfc3RyaW5nX2J1aWxkZXJfYXBwZW5kX25vdF9tdXQpCmV4dGVuZHMgbmF0aXZlIGNvbmNhdChzZWxmOiBTdHJpbmdCdWlsZGVyLCBzOiBTdHJpbmcpOiBTdHJpbmdC' +
    'dWlsZGVyOwoKQG5hbWUoX190YWN0X3N0cmluZ19idWlsZGVyX2VuZCkKZXh0ZW5kcyBuYXRpdmUgdG9DZWxsKHNlbGY6IFN0cmluZ0J1aWxkZXIpOiBDZWxsOwoKQG5h' +
    'bWUoX190YWN0X3N0cmluZ19idWlsZGVyX2VuZF9zbGljZSkKZXh0ZW5kcyBuYXRpdmUgdG9TdHJpbmcoc2VsZjogU3RyaW5nQnVpbGRlcik6IFN0cmluZzsKCkBuYW1l' +
    'KF9fdGFjdF9zdHJpbmdfYnVpbGRlcl9lbmRfc2xpY2UpCmV4dGVuZHMgbmF0aXZlIHRvU2xpY2Uoc2VsZjogU3RyaW5nQnVpbGRlcik6IFNsaWNlOwoKLy8KLy8gU3Ry' +
    'aW5nIGNvbnZlcnNpb24KLy8KCkBuYW1lKF9fdGFjdF9pbnRfdG9fc3RyaW5nKQpleHRlbmRzIG5hdGl2ZSB0b1N0cmluZyhzZWxmOiBJbnQpOiBTdHJpbmc7CgpAbmFt' +
    'ZShfX3RhY3RfZmxvYXRfdG9fc3RyaW5nKQpleHRlbmRzIG5hdGl2ZSB0b0Zsb2F0U3RyaW5nKHNlbGY6IEludCwgZGlnaXRzOiBJbnQpOiBTdHJpbmc7CgppbmxpbmUg' +
    'ZXh0ZW5kcyBmdW4gdG9Db2luc1N0cmluZyhzZWxmOiBJbnQpOiBTdHJpbmcgewogICAgcmV0dXJuIHNlbGYudG9GbG9hdFN0cmluZyg5KTsKfQoKZXh0ZW5kcyBmdW4g' +
    'YXNDb21tZW50KHNlbGY6IFN0cmluZyk6IENlbGwgewogICAgbGV0IGI6IFN0cmluZ0J1aWxkZXIgPSBiZWdpbkNvbW1lbnQoKTsKICAgIGIuYXBwZW5kKHNlbGYpOwog' +
    'ICAgcmV0dXJuIGIudG9DZWxsKCk7Cn0KCkBuYW1lKF9fdGFjdF9zdHJfdG9fc2xpY2UpCmV4dGVuZHMgbmF0aXZlIGFzU2xpY2Uoc2VsZjogU3RyaW5nKTogU2xpY2U7' +
    'CgpAbmFtZShfX3RhY3Rfc2xpY2VfdG9fc3RyKQpleHRlbmRzIG5hdGl2ZSBhc1N0cmluZyhzZWxmOiBTbGljZSk6IFN0cmluZzsKCmlubGluZSBleHRlbmRzIGZ1biBm' +
    'cm9tQmFzZTY0KHNlbGY6IFN0cmluZyk6IFNsaWNlIHsKICAgIHJldHVybiBzZWxmLmFzU2xpY2UoKS5mcm9tQmFzZTY0KCk7Cn0KCmV4dGVuZHMgZnVuIGZyb21CYXNl' +
    'NjQoc2VsZjogU2xpY2UpOiBTbGljZSB7CiAgICBsZXQgc2l6ZTogSW50ID0gc2VsZi5iaXRzKCkgLyA4OwogICAgbGV0IHJlc3VsdDogQnVpbGRlciA9IGJlZ2luQ2Vs' +
    'bCgpOwoKICAgIHJlcGVhdCAoc2l6ZSkgewogICAgICAgIGxldCBjb2RlOiBJbnQgPSBzZWxmLmxvYWRVaW50KDgpOwogICAgICAgIGlmIChjb2RlID49IDY1ICYmIGNv' +
    'ZGUgPD0gOTApIHsgLy8gQS1aCiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdG9yZVVpbnQoY29kZSAtIDY1LCA2KTsKICAgICAgICB9IGVsc2UgaWYgKGNvZGUg' +
    'Pj0gOTcgJiYgY29kZSA8PSAxMjIpIHsgLy8gYS16CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdG9yZVVpbnQoY29kZSAtICg5NyAtIDI2KSwgNik7CiAgICAg' +
    'ICAgfSBlbHNlIGlmIChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHsgLy8gMC05CiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdG9yZVVpbnQoY29kZSArICg1' +
    'MiAtIDQ4KSwgNik7CiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09IDQ1IHx8IGNvZGUgPT0gNDMpIHsgLy8gLSBvciArCiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3Vs' +
    'dC5zdG9yZVVpbnQoNjIsIDYpOwogICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PSA5NSB8fCBjb2RlID09IDQ3KSB7IC8vIF8gb3IgLwogICAgICAgICAgICByZXN1bHQg' +
    'PSByZXN1bHQuc3RvcmVVaW50KDYzLCA2KTsKICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT0gNjEpIHsgLy8gPQogICAgICAgICAgICAvLyBTa2lwCiAgICAgICAgfSBl' +
    'bHNlIHsKICAgICAgICAgICAgdGhyb3coMTM0KTsKICAgICAgICB9CiAgICB9CgogICAgLy8gUGFkZGluZwogICAgbGV0IHRvdGFsOiBJbnQgPSByZXN1bHQuYml0cygp' +
    'OwogICAgbGV0IHBhZGRpbmc6IEludCA9IHRvdGFsICUgODsKICAgIGlmIChwYWRkaW5nICE9IDApIHsKICAgICAgICBsZXQgczogU2xpY2UgPSByZXN1bHQuYXNTbGlj' +
    'ZSgpOwogICAgICAgIHJldHVybiBzLmxvYWRCaXRzKHRvdGFsIC0gcGFkZGluZyk7CiAgICB9IGVsc2UgewogICAgICAgIHJldHVybiByZXN1bHQuYXNTbGljZSgpOwog' +
    'ICAgfQp9CgovLwovLyBBZGRyZXNzIGNvbnZlcnNpb24KLy8KCkBuYW1lKF9fdGFjdF9hZGRyZXNzX3RvX3VzZXJfZnJpZW5kbHkpCmV4dGVuZHMgbmF0aXZlIHRvU3Ry' +
    'aW5nKHNlbGY6IEFkZHJlc3MpOiBTdHJpbmc7';
files['stdlib_ex.fc'] =
    'Zm9yYWxsIFggLT4gdHVwbGUgX190YWN0X3NldCh0dXBsZSB4LCBYIHYsIGludCBpKSBhc20gIlNFVElOREVYVkFSUSI7CigpIF9fdGFjdF9ub3AoKSBhc20gIk5PUCI7' +
    'CnNsaWNlIF9fdGFjdF9zdHJfdG9fc2xpY2Uoc2xpY2UgcykgYXNtICJOT1AiOwpzbGljZSBfX3RhY3Rfc2xpY2VfdG9fc3RyKHNsaWNlIHMpIGFzbSAiTk9QIjsKc2xp' +
    'Y2UgX190YWN0X2FkZHJlc3NfdG9fc2xpY2Uoc2xpY2UgcykgYXNtICJOT1AiOw==';
files['stdlib.fc'] =
    'OzsgU3RhbmRhcmQgbGlicmFyeSBmb3IgZnVuQwo7OwoKey0KICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIFRPTiBGdW5DIFN0YW5kYXJkIExpYnJhcnkuCgogICAgRnVu' +
    'QyBTdGFuZGFyZCBMaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkKICAgIGl0IHVuZGVyIHRoZSB0ZXJt' +
    'cyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieQogICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0' +
    'aGVyIHZlcnNpb24gMiBvZiB0aGUgTGljZW5zZSwgb3IKICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uCgogICAgRnVuQyBTdGFuZGFyZCBMaWJy' +
    'YXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsCiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZl' +
    'biB0aGUgaW1wbGllZCB3YXJyYW50eSBvZgogICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZQogICAg' +
    'R05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuCgotfQoKey0KICAjIFR1cGxlIG1hbmlwdWxhdGlvbiBwcmltaXRpdmVzCiAg' +
    'VGhlIG5hbWVzIGFuZCB0aGUgdHlwZXMgYXJlIG1vc3RseSBzZWxmLWV4cGxhaW5pbmcuCiAgU2VlIFtwb2x5bW9yaGlzbSB3aXRoIGZvcmFsbF0oaHR0cHM6Ly90b24u' +
    'b3JnL2RvY3MvIy9mdW5jL2Z1bmN0aW9ucz9pZD1wb2x5bW9ycGhpc20td2l0aC1mb3JhbGwpCiAgZm9yIG1vcmUgaW5mbyBvbiB0aGUgcG9seW1vcnBoaWMgZnVuY3Rp' +
    'b25zLgoKICBOb3RlIHRoYXQgY3VycmVudGx5IHZhbHVlcyBvZiBhdG9taWMgdHlwZSBgdHVwbGVgIGNhbid0IGJlIGNhc3QgdG8gY29tcG9zaXRlIHR1cGxlIHR5cGUg' +
    'KGUuZy4gYFtpbnQsIGNlbGxdYCkKICBhbmQgdmlzZSB2ZXJzYS4KLX0KCnstCiAgIyBMaXNwLXN0eWxlIGxpc3RzCgogIExpc3RzIGNhbiBiZSByZXByZXNlbnRlZCBh' +
    'cyBuZXN0ZWQgMi1lbGVtZW50cyB0dXBsZXMuCiAgRW1wdHkgbGlzdCBpcyBjb252ZW50aW9uYWxseSByZXByZXNlbnRlZCBhcyBUVk0gYG51bGxgIHZhbHVlIChpdCBj' +
    'YW4gYmUgb2J0YWluZWQgYnkgY2FsbGluZyBbbnVsbCgpXSkuCiAgRm9yIGV4YW1wbGUsIHR1cGxlIGAoMSwgKDIsICgzLCBudWxsKSkpYCByZXByZXNlbnRzIGxpc3Qg' +
    'YFsxLCAyLCAzXWAuIEVsZW1lbnRzIG9mIGEgbGlzdCBjYW4gYmUgb2YgZGlmZmVyZW50IHR5cGVzLgotfQoKOzs7IEFkZHMgYW4gZWxlbWVudCB0byB0aGUgYmVnaW5u' +
    'aW5nIG9mIGxpc3Atc3R5bGUgbGlzdC4KZm9yYWxsIFggLT4gdHVwbGUgY29ucyhYIGhlYWQsIHR1cGxlIHRhaWwpIGFzbSAiQ09OUyI7Cgo7OzsgRXh0cmFjdHMgdGhl' +
    'IGhlYWQgYW5kIHRoZSB0YWlsIG9mIGxpc3Atc3R5bGUgbGlzdC4KZm9yYWxsIFggLT4gKFgsIHR1cGxlKSB1bmNvbnModHVwbGUgbGlzdCkgYXNtICJVTkNPTlMiOwoK' +
    'Ozs7IEV4dHJhY3RzIHRoZSB0YWlsIGFuZCB0aGUgaGVhZCBvZiBsaXNwLXN0eWxlIGxpc3QuCmZvcmFsbCBYIC0+ICh0dXBsZSwgWCkgbGlzdF9uZXh0KHR1cGxlIGxp' +
    'c3QpIGFzbSgtPiAxIDApICJVTkNPTlMiOwoKOzs7IFJldHVybnMgdGhlIGhlYWQgb2YgbGlzcC1zdHlsZSBsaXN0Lgpmb3JhbGwgWCAtPiBYIGNhcih0dXBsZSBsaXN0' +
    'KSBhc20gIkNBUiI7Cgo7OzsgUmV0dXJucyB0aGUgdGFpbCBvZiBsaXNwLXN0eWxlIGxpc3QuCnR1cGxlIGNkcih0dXBsZSBsaXN0KSBhc20gIkNEUiI7Cgo7OzsgQ3Jl' +
    'YXRlcyB0dXBsZSB3aXRoIHplcm8gZWxlbWVudHMuCnR1cGxlIGVtcHR5X3R1cGxlKCkgYXNtICJOSUwiOwoKOzs7IEFwcGVuZHMgYSB2YWx1ZSBgeGAgdG8gYSBgVHVw' +
    'bGUgdCA9ICh4MSwgLi4uLCB4bilgLCBidXQgb25seSBpZiB0aGUgcmVzdWx0aW5nIGBUdXBsZSB0JyA9ICh4MSwgLi4uLCB4biwgeClgCjs7OyBpcyBvZiBsZW5ndGgg' +
    'YXQgbW9zdCAyNTUuIE90aGVyd2lzZSB0aHJvd3MgYSB0eXBlIGNoZWNrIGV4Y2VwdGlvbi4KZm9yYWxsIFggLT4gdHVwbGUgdHB1c2godHVwbGUgdCwgWCB2YWx1ZSkg' +
    'YXNtICJUUFVTSCI7CmZvcmFsbCBYIC0+ICh0dXBsZSwgKCkpIH50cHVzaCh0dXBsZSB0LCBYIHZhbHVlKSBhc20gIlRQVVNIIjsKCjs7OyBDcmVhdGVzIGEgdHVwbGUg' +
    'b2YgbGVuZ3RoIG9uZSB3aXRoIGdpdmVuIGFyZ3VtZW50IGFzIGVsZW1lbnQuCmZvcmFsbCBYIC0+IFtYXSBzaW5nbGUoWCB4KSBhc20gIlNJTkdMRSI7Cgo7OzsgVW5w' +
    'YWNrcyBhIHR1cGxlIG9mIGxlbmd0aCBvbmUKZm9yYWxsIFggLT4gWCB1bnNpbmdsZShbWF0gdCkgYXNtICJVTlNJTkdMRSI7Cgo7OzsgQ3JlYXRlcyBhIHR1cGxlIG9m' +
    'IGxlbmd0aCB0d28gd2l0aCBnaXZlbiBhcmd1bWVudHMgYXMgZWxlbWVudHMuCmZvcmFsbCBYLCBZIC0+IFtYLCBZXSBwYWlyKFggeCwgWSB5KSBhc20gIlBBSVIiOwoK' +
    'Ozs7IFVucGFja3MgYSB0dXBsZSBvZiBsZW5ndGggdHdvCmZvcmFsbCBYLCBZIC0+IChYLCBZKSB1bnBhaXIoW1gsIFldIHQpIGFzbSAiVU5QQUlSIjsKCjs7OyBDcmVh' +
    'dGVzIGEgdHVwbGUgb2YgbGVuZ3RoIHRocmVlIHdpdGggZ2l2ZW4gYXJndW1lbnRzIGFzIGVsZW1lbnRzLgpmb3JhbGwgWCwgWSwgWiAtPiBbWCwgWSwgWl0gdHJpcGxl' +
    'KFggeCwgWSB5LCBaIHopIGFzbSAiVFJJUExFIjsKCjs7OyBVbnBhY2tzIGEgdHVwbGUgb2YgbGVuZ3RoIHRocmVlCmZvcmFsbCBYLCBZLCBaIC0+IChYLCBZLCBaKSB1' +
    'bnRyaXBsZShbWCwgWSwgWl0gdCkgYXNtICJVTlRSSVBMRSI7Cgo7OzsgQ3JlYXRlcyBhIHR1cGxlIG9mIGxlbmd0aCBmb3VyIHdpdGggZ2l2ZW4gYXJndW1lbnRzIGFz' +
    'IGVsZW1lbnRzLgpmb3JhbGwgWCwgWSwgWiwgVyAtPiBbWCwgWSwgWiwgV10gdHVwbGU0KFggeCwgWSB5LCBaIHosIFcgdykgYXNtICI0IFRVUExFIjsKCjs7OyBVbnBh' +
    'Y2tzIGEgdHVwbGUgb2YgbGVuZ3RoIGZvdXIKZm9yYWxsIFgsIFksIFosIFcgLT4gKFgsIFksIFosIFcpIHVudHVwbGU0KFtYLCBZLCBaLCBXXSB0KSBhc20gIjQgVU5U' +
    'VVBMRSI7Cgo7OzsgUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBhIHR1cGxlICh3aXRoIHVua25vd24gZWxlbWVudCB0eXBlcykuCmZvcmFsbCBYIC0+IFggZmly' +
    'c3QodHVwbGUgdCkgYXNtICJGSVJTVCI7Cgo7OzsgUmV0dXJucyB0aGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0dXBsZSAod2l0aCB1bmtub3duIGVsZW1lbnQgdHlwZXMp' +
    'Lgpmb3JhbGwgWCAtPiBYIHNlY29uZCh0dXBsZSB0KSBhc20gIlNFQ09ORCI7Cgo7OzsgUmV0dXJucyB0aGUgdGhpcmQgZWxlbWVudCBvZiBhIHR1cGxlICh3aXRoIHVu' +
    'a25vd24gZWxlbWVudCB0eXBlcykuCmZvcmFsbCBYIC0+IFggdGhpcmQodHVwbGUgdCkgYXNtICJUSElSRCI7Cgo7OzsgUmV0dXJucyB0aGUgZm91cnRoIGVsZW1lbnQg' +
    'b2YgYSB0dXBsZSAod2l0aCB1bmtub3duIGVsZW1lbnQgdHlwZXMpLgpmb3JhbGwgWCAtPiBYIGZvdXJ0aCh0dXBsZSB0KSBhc20gIjMgSU5ERVgiOwoKOzs7IFJldHVy' +
    'bnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYSBwYWlyIHR1cGxlLgpmb3JhbGwgWCwgWSAtPiBYIHBhaXJfZmlyc3QoW1gsIFldIHApIGFzbSAiRklSU1QiOwoKOzs7IFJl' +
    'dHVybnMgdGhlIHNlY29uZCBlbGVtZW50IG9mIGEgcGFpciB0dXBsZS4KZm9yYWxsIFgsIFkgLT4gWSBwYWlyX3NlY29uZChbWCwgWV0gcCkgYXNtICJTRUNPTkQiOwoK' +
    'Ozs7IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYSB0cmlwbGUgdHVwbGUuCmZvcmFsbCBYLCBZLCBaIC0+IFggdHJpcGxlX2ZpcnN0KFtYLCBZLCBaXSBwKSBh' +
    'c20gIkZJUlNUIjsKCjs7OyBSZXR1cm5zIHRoZSBzZWNvbmQgZWxlbWVudCBvZiBhIHRyaXBsZSB0dXBsZS4KZm9yYWxsIFgsIFksIFogLT4gWSB0cmlwbGVfc2Vjb25k' +
    'KFtYLCBZLCBaXSBwKSBhc20gIlNFQ09ORCI7Cgo7OzsgUmV0dXJucyB0aGUgdGhpcmQgZWxlbWVudCBvZiBhIHRyaXBsZSB0dXBsZS4KZm9yYWxsIFgsIFksIFogLT4g' +
    'WiB0cmlwbGVfdGhpcmQoW1gsIFksIFpdIHApIGFzbSAiVEhJUkQiOwoKCjs7OyBQdXNoIG51bGwgZWxlbWVudCAoY2FzdGVkIHRvIGdpdmVuIHR5cGUpCjs7OyBCeSB0' +
    'aGUgVFZNIHR5cGUgYE51bGxgIEZ1bkMgcmVwcmVzZW50cyBhYnNlbmNlIG9mIGEgdmFsdWUgb2Ygc29tZSBhdG9taWMgdHlwZS4KOzs7IFNvIGBudWxsYCBjYW4gYWN0' +
    'dWFsbHkgaGF2ZSBhbnkgYXRvbWljIHR5cGUuCmZvcmFsbCBYIC0+IFggbnVsbCgpIGFzbSAiUFVTSE5VTEwiOwoKOzs7IE1vdmVzIGEgdmFyaWFibGUgW3hdIHRvIHRo' +
    'ZSB0b3Agb2YgdGhlIHN0YWNrCmZvcmFsbCBYIC0+IChYLCAoKSkgfmltcHVyZV90b3VjaChYIHgpIGltcHVyZSBhc20gIk5PUCI7CgoKCjs7OyBSZXR1cm5zIHRoZSBj' +
    'dXJyZW50IFVuaXggdGltZSBhcyBhbiBJbnRlZ2VyCmludCBub3coKSBhc20gIk5PVyI7Cgo7OzsgUmV0dXJucyB0aGUgaW50ZXJuYWwgYWRkcmVzcyBvZiB0aGUgY3Vy' +
    'cmVudCBzbWFydCBjb250cmFjdCBhcyBhIFNsaWNlIHdpdGggYSBgTXNnQWRkcmVzc0ludGAuCjs7OyBJZiBuZWNlc3NhcnksIGl0IGNhbiBiZSBwYXJzZWQgZnVydGhl' +
    'ciB1c2luZyBwcmltaXRpdmVzIHN1Y2ggYXMgW3BhcnNlX3N0ZF9hZGRyXS4Kc2xpY2UgbXlfYWRkcmVzcygpIGFzbSAiTVlBRERSIjsKCjs7OyBSZXR1cm5zIHRoZSBi' +
    'YWxhbmNlIG9mIHRoZSBzbWFydCBjb250cmFjdCBhcyBhIHR1cGxlIGNvbnNpc3Rpbmcgb2YgYW4gaW50Cjs7OyAoYmFsYW5jZSBpbiBuYW5vdG9uY29pbnMpIGFuZCBh' +
    'IGBjZWxsYAo7OzsgKGEgZGljdGlvbmFyeSB3aXRoIDMyLWJpdCBrZXlzIHJlcHJlc2VudGluZyB0aGUgYmFsYW5jZSBvZiAiZXh0cmEgY3VycmVuY2llcyIpCjs7OyBh' +
    'dCB0aGUgc3RhcnQgb2YgQ29tcHV0YXRpb24gUGhhc2UuCjs7OyBOb3RlIHRoYXQgUkFXIHByaW1pdGl2ZXMgc3VjaCBhcyBbc2VuZF9yYXdfbWVzc2FnZV0gZG8gbm90' +
    'IHVwZGF0ZSB0aGlzIGZpZWxkLgpbaW50LCBjZWxsXSBnZXRfYmFsYW5jZSgpIGFzbSAiQkFMQU5DRSI7Cgo7OzsgUmV0dXJucyB0aGUgbG9naWNhbCB0aW1lIG9mIHRo' +
    'ZSBjdXJyZW50IHRyYW5zYWN0aW9uLgppbnQgY3VyX2x0KCkgYXNtICJMVElNRSI7Cgo7OzsgUmV0dXJucyB0aGUgc3RhcnRpbmcgbG9naWNhbCB0aW1lIG9mIHRoZSBj' +
    'dXJyZW50IGJsb2NrLgppbnQgYmxvY2tfbHQoKSBhc20gIkJMT0NLTFQiOwoKOzs7IENvbXB1dGVzIHRoZSByZXByZXNlbnRhdGlvbiBoYXNoIG9mIGEgYGNlbGxgIFtj' +
    'XSBhbmQgcmV0dXJucyBpdCBhcyBhIDI1Ni1iaXQgdW5zaWduZWQgaW50ZWdlciBgeGAuCjs7OyBVc2VmdWwgZm9yIHNpZ25pbmcgYW5kIGNoZWNraW5nIHNpZ25hdHVy' +
    'ZXMgb2YgYXJiaXRyYXJ5IGVudGl0aWVzIHJlcHJlc2VudGVkIGJ5IGEgdHJlZSBvZiBjZWxscy4KaW50IGNlbGxfaGFzaChjZWxsIGMpIGFzbSAiSEFTSENVIjsKCjs7' +
    'OyBDb21wdXRlcyB0aGUgaGFzaCBvZiBhIGBzbGljZSBzYCBhbmQgcmV0dXJucyBpdCBhcyBhIDI1Ni1iaXQgdW5zaWduZWQgaW50ZWdlciBgeGAuCjs7OyBUaGUgcmVz' +
    'dWx0IGlzIHRoZSBzYW1lIGFzIGlmIGFuIG9yZGluYXJ5IGNlbGwgY29udGFpbmluZyBvbmx5IGRhdGEgYW5kIHJlZmVyZW5jZXMgZnJvbSBgc2AgaGFkIGJlZW4gY3Jl' +
    'YXRlZAo7OzsgYW5kIGl0cyBoYXNoIGNvbXB1dGVkIGJ5IFtjZWxsX2hhc2hdLgppbnQgc2xpY2VfaGFzaChzbGljZSBzKSBhc20gIkhBU0hTVSI7Cgo7OzsgQ29tcHV0' +
    'ZXMgc2hhMjU2IG9mIHRoZSBkYXRhIGJpdHMgb2YgYHNsaWNlYCBbc10uIElmIHRoZSBiaXQgbGVuZ3RoIG9mIGBzYCBpcyBub3QgZGl2aXNpYmxlIGJ5IGVpZ2h0LAo7' +
    'OzsgdGhyb3dzIGEgY2VsbCB1bmRlcmZsb3cgZXhjZXB0aW9uLiBUaGUgaGFzaCB2YWx1ZSBpcyByZXR1cm5lZCBhcyBhIDI1Ni1iaXQgdW5zaWduZWQgaW50ZWdlciBg' +
    'eGAuCmludCBzdHJpbmdfaGFzaChzbGljZSBzKSBhc20gIlNIQTI1NlUiOwoKey0KICAjIFNpZ25hdHVyZSBjaGVja3MKLX0KCjs7OyBDaGVja3MgdGhlIEVkMjU1MTkt' +
    'YHNpZ25hdHVyZWAgb2YgYSBgaGFzaGAgKGEgMjU2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyLCB1c3VhbGx5IGNvbXB1dGVkIGFzIHRoZSBoYXNoIG9mIHNvbWUgZGF0YSkK' +
    'Ozs7IHVzaW5nIFtwdWJsaWNfa2V5XSAoYWxzbyByZXByZXNlbnRlZCBieSBhIDI1Ni1iaXQgdW5zaWduZWQgaW50ZWdlcikuCjs7OyBUaGUgc2lnbmF0dXJlIG11c3Qg' +
    'Y29udGFpbiBhdCBsZWFzdCA1MTIgZGF0YSBiaXRzOyBvbmx5IHRoZSBmaXJzdCA1MTIgYml0cyBhcmUgdXNlZC4KOzs7IFRoZSByZXN1bHQgaXMgYOKIkjFgIGlmIHRo' +
    'ZSBzaWduYXR1cmUgaXMgdmFsaWQsIGAwYCBvdGhlcndpc2UuCjs7OyBOb3RlIHRoYXQgYENIS1NJR05VYCBjcmVhdGVzIGEgMjU2LWJpdCBzbGljZSB3aXRoIHRoZSBo' +
    'YXNoIGFuZCBjYWxscyBgQ0hLU0lHTlNgLgo7OzsgVGhhdCBpcywgaWYgW2hhc2hdIGlzIGNvbXB1dGVkIGFzIHRoZSBoYXNoIG9mIHNvbWUgZGF0YSwgdGhlc2UgZGF0' +
    'YSBhcmUgaGFzaGVkIHR3aWNlLAo7OzsgdGhlIHNlY29uZCBoYXNoaW5nIG9jY3VycmluZyBpbnNpZGUgYENIS1NJR05TYC4KaW50IGNoZWNrX3NpZ25hdHVyZShpbnQg' +
    'aGFzaCwgc2xpY2Ugc2lnbmF0dXJlLCBpbnQgcHVibGljX2tleSkgYXNtICJDSEtTSUdOVSI7Cgo7OzsgQ2hlY2tzIHdoZXRoZXIgW3NpZ25hdHVyZV0gaXMgYSB2YWxp' +
    'ZCBFZDI1NTE5LXNpZ25hdHVyZSBvZiB0aGUgZGF0YSBwb3J0aW9uIG9mIGBzbGljZSBkYXRhYCB1c2luZyBgcHVibGljX2tleWAsCjs7OyBzaW1pbGFybHkgdG8gW2No' +
    'ZWNrX3NpZ25hdHVyZV0uCjs7OyBJZiB0aGUgYml0IGxlbmd0aCBvZiBbZGF0YV0gaXMgbm90IGRpdmlzaWJsZSBieSBlaWdodCwgdGhyb3dzIGEgY2VsbCB1bmRlcmZs' +
    'b3cgZXhjZXB0aW9uLgo7OzsgVGhlIHZlcmlmaWNhdGlvbiBvZiBFZDI1NTE5IHNpZ25hdHVyZXMgaXMgdGhlIHN0YW5kYXJkIG9uZSwKOzs7IHdpdGggc2hhMjU2IHVz' +
    'ZWQgdG8gcmVkdWNlIFtkYXRhXSB0byB0aGUgMjU2LWJpdCBudW1iZXIgdGhhdCBpcyBhY3R1YWxseSBzaWduZWQuCmludCBjaGVja19kYXRhX3NpZ25hdHVyZShzbGlj' +
    'ZSBkYXRhLCBzbGljZSBzaWduYXR1cmUsIGludCBwdWJsaWNfa2V5KSBhc20gIkNIS1NJR05TIjsKCnstLS0KICAjIENvbXB1dGF0aW9uIG9mIGJvYyBzaXplCiAgVGhl' +
    'IHByaW1pdGl2ZXMgYmVsb3cgbWF5IGJlIHVzZWZ1bCBmb3IgY29tcHV0aW5nIHN0b3JhZ2UgZmVlcyBvZiB1c2VyLXByb3ZpZGVkIGRhdGEuCi19Cgo7OzsgUmV0dXJu' +
    'cyBgKHgsIHksIHosIC0xKWAgb3IgYChudWxsLCBudWxsLCBudWxsLCAwKWAuCjs7OyBSZWN1cnNpdmVseSBjb21wdXRlcyB0aGUgY291bnQgb2YgZGlzdGluY3QgY2Vs' +
    'bHMgYHhgLCBkYXRhIGJpdHMgYHlgLCBhbmQgY2VsbCByZWZlcmVuY2VzIGB6YAo7OzsgaW4gdGhlIERBRyByb290ZWQgYXQgYGNlbGxgIFtjXSwgZWZmZWN0aXZlbHkg' +
    'cmV0dXJuaW5nIHRoZSB0b3RhbCBzdG9yYWdlIHVzZWQgYnkgdGhpcyBEQUcgdGFraW5nIGludG8gYWNjb3VudAo7OzsgdGhlIGlkZW50aWZpY2F0aW9uIG9mIGVxdWFs' +
    'IGNlbGxzLgo7OzsgVGhlIHZhbHVlcyBvZiBgeGAsIGB5YCwgYW5kIGB6YCBhcmUgY29tcHV0ZWQgYnkgYSBkZXB0aC1maXJzdCB0cmF2ZXJzYWwgb2YgdGhpcyBEQUcs' +
    'Cjs7OyB3aXRoIGEgaGFzaCB0YWJsZSBvZiB2aXNpdGVkIGNlbGwgaGFzaGVzIHVzZWQgdG8gcHJldmVudCB2aXNpdHMgb2YgYWxyZWFkeS12aXNpdGVkIGNlbGxzLgo7' +
    'OzsgVGhlIHRvdGFsIGNvdW50IG9mIHZpc2l0ZWQgY2VsbHMgYHhgIGNhbm5vdCBleGNlZWQgbm9uLW5lZ2F0aXZlIFttYXhfY2VsbHNdOwo7Ozsgb3RoZXJ3aXNlIHRo' +
    'ZSBjb21wdXRhdGlvbiBpcyBhYm9ydGVkIGJlZm9yZSB2aXNpdGluZyB0aGUgYChtYXhfY2VsbHMgKyAxKWAtc3QgY2VsbCBhbmQKOzs7IGEgemVybyBmbGFnIGlzIHJl' +
    'dHVybmVkIHRvIGluZGljYXRlIGZhaWx1cmUuIElmIFtjXSBpcyBgbnVsbGAsIHJldHVybnMgYHggPSB5ID0geiA9IDBgLgooaW50LCBpbnQsIGludCkgY29tcHV0ZV9k' +
    'YXRhX3NpemUoY2VsbCBjLCBpbnQgbWF4X2NlbGxzKSBpbXB1cmUgYXNtICJDREFUQVNJWkUiOwoKOzs7IFNpbWlsYXIgdG8gW2NvbXB1dGVfZGF0YV9zaXplP10sIGJ1' +
    'dCBhY2NlcHRpbmcgYSBgc2xpY2VgIFtzXSBpbnN0ZWFkIG9mIGEgYGNlbGxgLgo7OzsgVGhlIHJldHVybmVkIHZhbHVlIG9mIGB4YCBkb2VzIG5vdCB0YWtlIGludG8g' +
    'YWNjb3VudCB0aGUgY2VsbCB0aGF0IGNvbnRhaW5zIHRoZSBgc2xpY2VgIFtzXSBpdHNlbGY7Cjs7OyBob3dldmVyLCB0aGUgZGF0YSBiaXRzIGFuZCB0aGUgY2VsbCBy' +
    'ZWZlcmVuY2VzIG9mIFtzXSBhcmUgYWNjb3VudGVkIGZvciBpbiBgeWAgYW5kIGB6YC4KKGludCwgaW50LCBpbnQpIHNsaWNlX2NvbXB1dGVfZGF0YV9zaXplKHNsaWNl' +
    'IHMsIGludCBtYXhfY2VsbHMpIGltcHVyZSBhc20gIlNEQVRBU0laRSI7Cgo7OzsgQSBub24tcXVpZXQgdmVyc2lvbiBvZiBbY29tcHV0ZV9kYXRhX3NpemU/XSB0aGF0' +
    'IHRocm93cyBhIGNlbGwgb3ZlcmZsb3cgZXhjZXB0aW9uIChgOGApIG9uIGZhaWx1cmUuCihpbnQsIGludCwgaW50LCBpbnQpIGNvbXB1dGVfZGF0YV9zaXplPyhjZWxs' +
    'IGMsIGludCBtYXhfY2VsbHMpIGFzbSAiQ0RBVEFTSVpFUSBOVUxMU1dBUElGTk9UMiBOVUxMU1dBUElGTk9UIjsKCjs7OyBBIG5vbi1xdWlldCB2ZXJzaW9uIG9mIFtz' +
    'bGljZV9jb21wdXRlX2RhdGFfc2l6ZT9dIHRoYXQgdGhyb3dzIGEgY2VsbCBvdmVyZmxvdyBleGNlcHRpb24gKDgpIG9uIGZhaWx1cmUuCihpbnQsIGludCwgaW50LCBp' +
    'bnQpIHNsaWNlX2NvbXB1dGVfZGF0YV9zaXplPyhjZWxsIGMsIGludCBtYXhfY2VsbHMpIGFzbSAiU0RBVEFTSVpFUSBOVUxMU1dBUElGTk9UMiBOVUxMU1dBUElGTk9U' +
    'IjsKCjs7OyBUaHJvd3MgYW4gZXhjZXB0aW9uIHdpdGggZXhpdF9jb2RlIGV4Y25vIGlmIGNvbmQgaXMgbm90IDAgKGNvbW1lbnRlZCBzaW5jZSBpbXBsZW1lbnRlZCBp' +
    'biBjb21waWxhdG9yKQo7OyAoKSB0aHJvd19pZihpbnQgZXhjbm8sIGludCBjb25kKSBpbXB1cmUgYXNtICJUSFJPV0FSR0lGIjsKCnstLQogICMgRGVidWcgcHJpbWl0' +
    'aXZlcwogIE9ubHkgd29ya3MgZm9yIGxvY2FsIFRWTSBleGVjdXRpb24gd2l0aCBkZWJ1ZyBsZXZlbCB2ZXJib3NpdHkKLX0KOzs7IER1bXBzIHRoZSBzdGFjayAoYXQg' +
    'bW9zdCB0aGUgdG9wIDI1NSB2YWx1ZXMpIGFuZCBzaG93cyB0aGUgdG90YWwgc3RhY2sgZGVwdGguCigpIGR1bXBfc3RhY2soKSBpbXB1cmUgYXNtICJEVU1QU1RLIjsK' +
    'CnstCiAgIyBQZXJzaXN0ZW50IHN0b3JhZ2Ugc2F2ZSBhbmQgbG9hZAotfQoKOzs7IFJldHVybnMgdGhlIHBlcnNpc3RlbnQgY29udHJhY3Qgc3RvcmFnZSBjZWxsLiBJ' +
    'dCBjYW4gYmUgcGFyc2VkIG9yIG1vZGlmaWVkIHdpdGggc2xpY2UgYW5kIGJ1aWxkZXIgcHJpbWl0aXZlcyBsYXRlci4KY2VsbCBnZXRfZGF0YSgpIGFzbSAiYzQgUFVT' +
    'SCI7Cgo7OzsgU2V0cyBgY2VsbGAgW2NdIGFzIHBlcnNpc3RlbnQgY29udHJhY3QgZGF0YS4gWW91IGNhbiB1cGRhdGUgcGVyc2lzdGVudCBjb250cmFjdCBzdG9yYWdl' +
    'IHdpdGggdGhpcyBwcmltaXRpdmUuCigpIHNldF9kYXRhKGNlbGwgYykgaW1wdXJlIGFzbSAiYzQgUE9QIjsKCnstCiAgIyBDb250aW51YXRpb24gcHJpbWl0aXZlcwot' +
    'fQo7OzsgVXN1YWxseSBgYzNgIGhhcyBhIGNvbnRpbnVhdGlvbiBpbml0aWFsaXplZCBieSB0aGUgd2hvbGUgY29kZSBvZiB0aGUgY29udHJhY3QuIEl0IGlzIHVzZWQg' +
    'Zm9yIGZ1bmN0aW9uIGNhbGxzLgo7OzsgVGhlIHByaW1pdGl2ZSByZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGBjM2AuCmNvbnQgZ2V0X2MzKCkgaW1wdXJlIGFz' +
    'bSAiYzMgUFVTSCI7Cgo7OzsgVXBkYXRlcyB0aGUgY3VycmVudCB2YWx1ZSBvZiBgYzNgLiBVc3VhbGx5LCBpdCBpcyB1c2VkIGZvciB1cGRhdGluZyBzbWFydCBjb250' +
    'cmFjdCBjb2RlIGluIHJ1bi10aW1lLgo7OzsgTm90ZSB0aGF0IGFmdGVyIGV4ZWN1dGlvbiBvZiB0aGlzIHByaW1pdGl2ZSB0aGUgY3VycmVudCBjb2RlCjs7OyAoYW5k' +
    'IHRoZSBzdGFjayBvZiByZWN1cnNpdmUgZnVuY3Rpb24gY2FsbHMpIHdvbid0IGNoYW5nZSwKOzs7IGJ1dCBhbnkgb3RoZXIgZnVuY3Rpb24gY2FsbCB3aWxsIHVzZSBh' +
    'IGZ1bmN0aW9uIGZyb20gdGhlIG5ldyBjb2RlLgooKSBzZXRfYzMoY29udCBjKSBpbXB1cmUgYXNtICJjMyBQT1AiOwoKOzs7IFRyYW5zZm9ybXMgYSBgc2xpY2VgIFtz' +
    'XSBpbnRvIGEgc2ltcGxlIG9yZGluYXJ5IGNvbnRpbnVhdGlvbiBgY2AsIHdpdGggYGMuY29kZSA9IHNgIGFuZCBhbiBlbXB0eSBzdGFjayBhbmQgc2F2ZWxpc3QuCmNv' +
    'bnQgYmxlc3Moc2xpY2UgcykgaW1wdXJlIGFzbSAiQkxFU1MiOwoKey0tLQogICMgR2FzIHJlbGF0ZWQgcHJpbWl0aXZlcwotfQoKOzs7IFNldHMgY3VycmVudCBnYXMg' +
    'bGltaXQgYGdsYCB0byBpdHMgbWF4aW1hbCBhbGxvd2VkIHZhbHVlIGBnbWAsIGFuZCByZXNldHMgdGhlIGdhcyBjcmVkaXQgYGdjYCB0byB6ZXJvLAo7OzsgZGVjcmVh' +
    'c2luZyB0aGUgdmFsdWUgb2YgYGdyYCBieSBgZ2NgIGluIHRoZSBwcm9jZXNzLgo7OzsgSW4gb3RoZXIgd29yZHMsIHRoZSBjdXJyZW50IHNtYXJ0IGNvbnRyYWN0IGFn' +
    'cmVlcyB0byBidXkgc29tZSBnYXMgdG8gZmluaXNoIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uLgo7OzsgVGhpcyBhY3Rpb24gaXMgcmVxdWlyZWQgdG8gcHJvY2VzcyBl' +
    'eHRlcm5hbCBtZXNzYWdlcywgd2hpY2ggYnJpbmcgbm8gdmFsdWUgKGhlbmNlIG5vIGdhcykgd2l0aCB0aGVtc2VsdmVzLgo7OzsKOzs7IEZvciBtb3JlIGRldGFpbHMg' +
    'Y2hlY2sgW2FjY2VwdF9tZXNzYWdlIGVmZmVjdHNdKGh0dHBzOi8vdG9uLm9yZy9kb2NzLyMvc21hcnQtY29udHJhY3RzL2FjY2VwdCkuCigpIGFjY2VwdF9tZXNzYWdl' +
    'KCkgaW1wdXJlIGFzbSAiQUNDRVBUIjsKCjs7OyBTZXRzIGN1cnJlbnQgZ2FzIGxpbWl0IGBnbGAgdG8gdGhlIG1pbmltdW0gb2YgbGltaXQgYW5kIGBnbWAsIGFuZCBy' +
    'ZXNldHMgdGhlIGdhcyBjcmVkaXQgYGdjYCB0byB6ZXJvLgo7OzsgSWYgdGhlIGdhcyBjb25zdW1lZCBzbyBmYXIgKGluY2x1ZGluZyB0aGUgcHJlc2VudCBpbnN0cnVj' +
    'dGlvbikgZXhjZWVkcyB0aGUgcmVzdWx0aW5nIHZhbHVlIG9mIGBnbGAsCjs7OyBhbiAodW5oYW5kbGVkKSBvdXQgb2YgZ2FzIGV4Y2VwdGlvbiBpcyB0aHJvd24gYmVm' +
    'b3JlIHNldHRpbmcgbmV3IGdhcyBsaW1pdHMuCjs7OyBOb3RpY2UgdGhhdCBbc2V0X2dhc19saW1pdF0gd2l0aCBhbiBhcmd1bWVudCBgbGltaXQg4omlIDJeNjMg4oiS' +
    'IDFgIGlzIGVxdWl2YWxlbnQgdG8gW2FjY2VwdF9tZXNzYWdlXS4KKCkgc2V0X2dhc19saW1pdChpbnQgbGltaXQpIGltcHVyZSBhc20gIlNFVEdBU0xJTUlUIjsKCjs7' +
    'OyBDb21taXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHJlZ2lzdGVycyBgYzRgICjigJxwZXJzaXN0ZW50IGRhdGHigJ0pIGFuZCBgYzVgICjigJxhY3Rpb25z4oCdKQo7' +
    'Ozsgc28gdGhhdCB0aGUgY3VycmVudCBleGVjdXRpb24gaXMgY29uc2lkZXJlZCDigJxzdWNjZXNzZnVs4oCdIHdpdGggdGhlIHNhdmVkIHZhbHVlcyBldmVuIGlmIGFu' +
    'IGV4Y2VwdGlvbgo7OzsgaW4gQ29tcHV0YXRpb24gUGhhc2UgaXMgdGhyb3duIGxhdGVyLgooKSBjb21taXQoKSBpbXB1cmUgYXNtICJDT01NSVQiOwoKOzs7IE5vdCBp' +
    'bXBsZW1lbnRlZAo7OzsgQ29tcHV0ZXMgdGhlIGFtb3VudCBvZiBnYXMgdGhhdCBjYW4gYmUgYm91Z2h0IGZvciBgYW1vdW50YCBuYW5vVE9OcywKOzs7IGFuZCBzZXRz' +
    'IGBnbGAgYWNjb3JkaW5nbHkgaW4gdGhlIHNhbWUgd2F5IGFzIFtzZXRfZ2FzX2xpbWl0XS4KOzsoKSBidXlfZ2FzKGludCBhbW91bnQpIGltcHVyZSBhc20gIkJVWUdB' +
    'UyI7Cgo7OzsgQ29tcHV0ZXMgdGhlIG1pbmltdW0gb2YgdHdvIGludGVnZXJzIFt4XSBhbmQgW3ldLgppbnQgbWluKGludCB4LCBpbnQgeSkgYXNtICJNSU4iOwoKOzs7' +
    'IENvbXB1dGVzIHRoZSBtYXhpbXVtIG9mIHR3byBpbnRlZ2VycyBbeF0gYW5kIFt5XS4KaW50IG1heChpbnQgeCwgaW50IHkpIGFzbSAiTUFYIjsKCjs7OyBTb3J0cyB0' +
    'd28gaW50ZWdlcnMuCihpbnQsIGludCkgbWlubWF4KGludCB4LCBpbnQgeSkgYXNtICJNSU5NQVgiOwoKOzs7IENvbXB1dGVzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBh' +
    'biBpbnRlZ2VyIFt4XS4KaW50IGFicyhpbnQgeCkgYXNtICJBQlMiOwoKey0KICAjIFNsaWNlIHByaW1pdGl2ZXMKCiAgSXQgaXMgc2FpZCB0aGF0IGEgcHJpbWl0aXZl' +
    'IF9sb2Fkc18gc29tZSBkYXRhLAogIGlmIGl0IHJldHVybnMgdGhlIGRhdGEgYW5kIHRoZSByZW1haW5kZXIgb2YgdGhlIHNsaWNlCiAgKHNvIGl0IGNhbiBhbHNvIGJl' +
    'IHVzZWQgYXMgW21vZGlmeWluZyBtZXRob2RdKGh0dHBzOi8vdG9uLm9yZy9kb2NzLyMvZnVuYy9zdGF0ZW1lbnRzP2lkPW1vZGlmeWluZy1tZXRob2RzKSkuCgogIEl0' +
    'IGlzIHNhaWQgdGhhdCBhIHByaW1pdGl2ZSBfcHJlbG9hZHNfIHNvbWUgZGF0YSwgaWYgaXQgcmV0dXJucyBvbmx5IHRoZSBkYXRhCiAgKGl0IGNhbiBiZSB1c2VkIGFz' +
    'IFtub24tbW9kaWZ5aW5nIG1ldGhvZF0oaHR0cHM6Ly90b24ub3JnL2RvY3MvIy9mdW5jL3N0YXRlbWVudHM/aWQ9bm9uLW1vZGlmeWluZy1tZXRob2RzKSkuCgogIFVu' +
    'bGVzcyBvdGhlcndpc2Ugc3RhdGVkLCBsb2FkaW5nIGFuZCBwcmVsb2FkaW5nIHByaW1pdGl2ZXMgcmVhZCB0aGUgZGF0YSBmcm9tIGEgcHJlZml4IG9mIHRoZSBzbGlj' +
    'ZS4KLX0KCgo7OzsgQ29udmVydHMgYSBgY2VsbGAgW2NdIGludG8gYSBgc2xpY2VgLiBOb3RpY2UgdGhhdCBbY10gbXVzdCBiZSBlaXRoZXIgYW4gb3JkaW5hcnkgY2Vs' +
    'bCwKOzs7IG9yIGFuIGV4b3RpYyBjZWxsIChzZWUgW1RWTS5wZGZdKGh0dHBzOi8vdG9uLWJsb2NrY2hhaW4uZ2l0aHViLmlvL2RvY3MvdHZtLnBkZiksIDMuMS4yKQo7' +
    'Ozsgd2hpY2ggaXMgYXV0b21hdGljYWxseSBsb2FkZWQgdG8geWllbGQgYW4gb3JkaW5hcnkgY2VsbCBgYydgLCBjb252ZXJ0ZWQgaW50byBhIGBzbGljZWAgYWZ0ZXJ3' +
    'YXJkcy4Kc2xpY2UgYmVnaW5fcGFyc2UoY2VsbCBjKSBhc20gIkNUT1MiOwoKOzs7IENoZWNrcyBpZiBbc10gaXMgZW1wdHkuIElmIG5vdCwgdGhyb3dzIGFuIGV4Y2Vw' +
    'dGlvbi4KKCkgZW5kX3BhcnNlKHNsaWNlIHMpIGltcHVyZSBhc20gIkVORFMiOwoKOzs7IExvYWRzIHRoZSBmaXJzdCByZWZlcmVuY2UgZnJvbSB0aGUgc2xpY2UuCihz' +
    'bGljZSwgY2VsbCkgbG9hZF9yZWYoc2xpY2UgcykgYXNtKC0+IDEgMCkgIkxEUkVGIjsKCjs7OyBQcmVsb2FkcyB0aGUgZmlyc3QgcmVmZXJlbmNlIGZyb20gdGhlIHNs' +
    'aWNlLgpjZWxsIHByZWxvYWRfcmVmKHNsaWNlIHMpIGFzbSAiUExEUkVGIjsKCnstIEZ1bmN0aW9ucyBiZWxvdyBhcmUgY29tbWVudGVkIGJlY2F1c2UgYXJlIGltcGxl' +
    'bWVudGVkIG9uIGNvbXBpbGF0b3IgbGV2ZWwgZm9yIG9wdGltaXNhdGlvbiAtfQoKOzs7IExvYWRzIGEgc2lnbmVkIFtsZW5dLWJpdCBpbnRlZ2VyIGZyb20gYSBzbGlj' +
    'ZSBbc10uCjs7IChzbGljZSwgaW50KSB+bG9hZF9pbnQoc2xpY2UgcywgaW50IGxlbikgYXNtKHMgbGVuIC0+IDEgMCkgIkxESVgiOwoKOzs7IExvYWRzIGFuIHVuc2ln' +
    'bmVkIFtsZW5dLWJpdCBpbnRlZ2VyIGZyb20gYSBzbGljZSBbc10uCjs7IChzbGljZSwgaW50KSB+bG9hZF91aW50KHNsaWNlIHMsIGludCBsZW4pIGFzbSggLT4gMSAw' +
    'KSAiTERVWCI7Cgo7OzsgUHJlbG9hZHMgYSBzaWduZWQgW2xlbl0tYml0IGludGVnZXIgZnJvbSBhIHNsaWNlIFtzXS4KOzsgaW50IHByZWxvYWRfaW50KHNsaWNlIHMs' +
    'IGludCBsZW4pIGFzbSAiUExESVgiOwoKOzs7IFByZWxvYWRzIGFuIHVuc2lnbmVkIFtsZW5dLWJpdCBpbnRlZ2VyIGZyb20gYSBzbGljZSBbc10uCjs7IGludCBwcmVs' +
    'b2FkX3VpbnQoc2xpY2UgcywgaW50IGxlbikgYXNtICJQTERVWCI7Cgo7OzsgTG9hZHMgdGhlIGZpcnN0IGAwIOKJpCBsZW4g4omkIDEwMjNgIGJpdHMgZnJvbSBzbGlj' +
    'ZSBbc10gaW50byBhIHNlcGFyYXRlIGBzbGljZSBzJydgLgo7OyAoc2xpY2UsIHNsaWNlKSBsb2FkX2JpdHMoc2xpY2UgcywgaW50IGxlbikgYXNtKHMgbGVuIC0+IDEg' +
    'MCkgIkxEU0xJQ0VYIjsKCjs7OyBQcmVsb2FkcyB0aGUgZmlyc3QgYDAg4omkIGxlbiDiiaQgMTAyM2AgYml0cyBmcm9tIHNsaWNlIFtzXSBpbnRvIGEgc2VwYXJhdGUg' +
    'YHNsaWNlIHMnJ2AuCjs7IHNsaWNlIHByZWxvYWRfYml0cyhzbGljZSBzLCBpbnQgbGVuKSBhc20gIlBMRFNMSUNFWCI7Cgo7OzsgTG9hZHMgc2VyaWFsaXplZCBhbW91' +
    'bnQgb2YgVG9uQ29pbnMgKGFueSB1bnNpZ25lZCBpbnRlZ2VyIHVwIHRvIGAyXjEyMCAtIDFgKS4KKHNsaWNlLCBpbnQpIGxvYWRfZ3JhbXMoc2xpY2UgcykgYXNtKC0+' +
    'IDEgMCkgIkxER1JBTVMiOwooc2xpY2UsIGludCkgbG9hZF9jb2lucyhzbGljZSBzKSBhc20oLT4gMSAwKSAiTERWQVJVSU5UMTYiOwoKOzs7IFJldHVybnMgYWxsIGJ1' +
    'dCB0aGUgZmlyc3QgYDAg4omkIGxlbiDiiaQgMTAyM2AgYml0cyBvZiBgc2xpY2VgIFtzXS4Kc2xpY2Ugc2tpcF9iaXRzKHNsaWNlIHMsIGludCBsZW4pIGFzbSAiU0RT' +
    'S0lQRklSU1QiOwooc2xpY2UsICgpKSB+c2tpcF9iaXRzKHNsaWNlIHMsIGludCBsZW4pIGFzbSAiU0RTS0lQRklSU1QiOwoKOzs7IFJldHVybnMgdGhlIGZpcnN0IGAw' +
    'IOKJpCBsZW4g4omkIDEwMjNgIGJpdHMgb2YgYHNsaWNlYCBbc10uCnNsaWNlIGZpcnN0X2JpdHMoc2xpY2UgcywgaW50IGxlbikgYXNtICJTRENVVEZJUlNUIjsKCjs7' +
    'OyBSZXR1cm5zIGFsbCBidXQgdGhlIGxhc3QgYDAg4omkIGxlbiDiiaQgMTAyM2AgYml0cyBvZiBgc2xpY2VgIFtzXS4Kc2xpY2Ugc2tpcF9sYXN0X2JpdHMoc2xpY2Ug' +
    'cywgaW50IGxlbikgYXNtICJTRFNLSVBMQVNUIjsKKHNsaWNlLCAoKSkgfnNraXBfbGFzdF9iaXRzKHNsaWNlIHMsIGludCBsZW4pIGFzbSAiU0RTS0lQTEFTVCI7Cgo7' +
    'OzsgUmV0dXJucyB0aGUgbGFzdCBgMCDiiaQgbGVuIOKJpCAxMDIzYCBiaXRzIG9mIGBzbGljZWAgW3NdLgpzbGljZSBzbGljZV9sYXN0KHNsaWNlIHMsIGludCBsZW4p' +
    'IGFzbSAiU0RDVVRMQVNUIjsKCjs7OyBMb2FkcyBhIGRpY3Rpb25hcnkgYERgIChIYXNoTWFwRSkgZnJvbSBgc2xpY2VgIFtzXS4KOzs7IChyZXR1cm5zIGBudWxsYCBp' +
    'ZiBgbm90aGluZ2AgY29uc3RydWN0b3IgaXMgdXNlZCkuCihzbGljZSwgY2VsbCkgbG9hZF9kaWN0KHNsaWNlIHMpIGFzbSgtPiAxIDApICJMRERJQ1QiOwoKOzs7IFBy' +
    'ZWxvYWRzIGEgZGljdGlvbmFyeSBgRGAgZnJvbSBgc2xpY2VgIFtzXS4KY2VsbCBwcmVsb2FkX2RpY3Qoc2xpY2UgcykgYXNtICJQTERESUNUIjsKCjs7OyBMb2FkcyBh' +
    'IGRpY3Rpb25hcnkgYXMgW2xvYWRfZGljdF0sIGJ1dCByZXR1cm5zIG9ubHkgdGhlIHJlbWFpbmRlciBvZiB0aGUgc2xpY2UuCnNsaWNlIHNraXBfZGljdChzbGljZSBz' +
    'KSBhc20gIlNLSVBESUNUIjsKKHNsaWNlLCAoKSkgfnNraXBfZGljdChzbGljZSBzKSBhc20gIlNLSVBESUNUIjsKCjs7OyBMb2FkcyAoTWF5YmUgXkNlbGwpIGZyb20g' +
    'YHNsaWNlYCBbc10uCjs7OyBJbiBvdGhlciB3b3JkcyBsb2FkcyAxIGJpdCBhbmQgaWYgaXQgaXMgdHJ1ZQo7OzsgbG9hZHMgZmlyc3QgcmVmIGFuZCByZXR1cm4gaXQg' +
    'd2l0aCBzbGljZSByZW1haW5kZXIKOzs7IG90aGVyd2lzZSByZXR1cm5zIGBudWxsYCBhbmQgc2xpY2UgcmVtYWluZGVyCihzbGljZSwgY2VsbCkgbG9hZF9tYXliZV9y' +
    'ZWYoc2xpY2UgcykgYXNtKC0+IDEgMCkgIkxET1BUUkVGIjsKCjs7OyBQcmVsb2FkcyAoTWF5YmUgXkNlbGwpIGZyb20gYHNsaWNlYCBbc10uCmNlbGwgcHJlbG9hZF9t' +
    'YXliZV9yZWYoc2xpY2UgcykgYXNtICJQTERPUFRSRUYiOwoKCjs7OyBSZXR1cm5zIHRoZSBkZXB0aCBvZiBgY2VsbGAgW2NdLgo7OzsgSWYgW2NdIGhhcyBubyByZWZl' +
    'cmVuY2VzLCB0aGVuIHJldHVybiBgMGA7Cjs7OyBvdGhlcndpc2UgdGhlIHJldHVybmVkIHZhbHVlIGlzIG9uZSBwbHVzIHRoZSBtYXhpbXVtIG9mIGRlcHRocyBvZiBj' +
    'ZWxscyByZWZlcnJlZCB0byBmcm9tIFtjXS4KOzs7IElmIFtjXSBpcyBhIGBudWxsYCBpbnN0ZWFkIG9mIGEgY2VsbCwgcmV0dXJucyB6ZXJvLgppbnQgY2VsbF9kZXB0' +
    'aChjZWxsIGMpIGFzbSAiQ0RFUFRIIjsKCgp7LQogICMgU2xpY2Ugc2l6ZSBwcmltaXRpdmVzCi19Cgo7OzsgUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJlZmVyZW5jZXMg' +
    'aW4gYHNsaWNlYCBbc10uCmludCBzbGljZV9yZWZzKHNsaWNlIHMpIGFzbSAiU1JFRlMiOwoKOzs7IFJldHVybnMgdGhlIG51bWJlciBvZiBkYXRhIGJpdHMgaW4gYHNs' +
    'aWNlYCBbc10uCmludCBzbGljZV9iaXRzKHNsaWNlIHMpIGFzbSAiU0JJVFMiOwoKOzs7IFJldHVybnMgYm90aCB0aGUgbnVtYmVyIG9mIGRhdGEgYml0cyBhbmQgdGhl' +
    'IG51bWJlciBvZiByZWZlcmVuY2VzIGluIGBzbGljZWAgW3NdLgooaW50LCBpbnQpIHNsaWNlX2JpdHNfcmVmcyhzbGljZSBzKSBhc20gIlNCSVRSRUZTIjsKCjs7OyBD' +
    'aGVja3Mgd2hldGhlciBhIGBzbGljZWAgW3NdIGlzIGVtcHR5IChpLmUuLCBjb250YWlucyBubyBiaXRzIG9mIGRhdGEgYW5kIG5vIGNlbGwgcmVmZXJlbmNlcykuCmlu' +
    'dCBzbGljZV9lbXB0eT8oc2xpY2UgcykgYXNtICJTRU1QVFkiOwoKOzs7IENoZWNrcyB3aGV0aGVyIGBzbGljZWAgW3NdIGhhcyBubyBiaXRzIG9mIGRhdGEuCmludCBz' +
    'bGljZV9kYXRhX2VtcHR5PyhzbGljZSBzKSBhc20gIlNERU1QVFkiOwoKOzs7IENoZWNrcyB3aGV0aGVyIGBzbGljZWAgW3NdIGhhcyBubyByZWZlcmVuY2VzLgppbnQg' +
    'c2xpY2VfcmVmc19lbXB0eT8oc2xpY2UgcykgYXNtICJTUkVNUFRZIjsKCjs7OyBSZXR1cm5zIHRoZSBkZXB0aCBvZiBgc2xpY2VgIFtzXS4KOzs7IElmIFtzXSBoYXMg' +
    'bm8gcmVmZXJlbmNlcywgdGhlbiByZXR1cm5zIGAwYDsKOzs7IG90aGVyd2lzZSB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgb25lIHBsdXMgdGhlIG1heGltdW0gb2YgZGVw' +
    'dGhzIG9mIGNlbGxzIHJlZmVycmVkIHRvIGZyb20gW3NdLgppbnQgc2xpY2VfZGVwdGgoc2xpY2UgcykgYXNtICJTREVQVEgiOwoKey0KICAjIEJ1aWxkZXIgc2l6ZSBw' +
    'cmltaXRpdmVzCi19Cgo7OzsgUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNlbGwgcmVmZXJlbmNlcyBhbHJlYWR5IHN0b3JlZCBpbiBgYnVpbGRlcmAgW2JdCmludCBidWls' +
    'ZGVyX3JlZnMoYnVpbGRlciBiKSBhc20gIkJSRUZTIjsKCjs7OyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF0YSBiaXRzIGFscmVhZHkgc3RvcmVkIGluIGBidWlsZGVy' +
    'YCBbYl0uCmludCBidWlsZGVyX2JpdHMoYnVpbGRlciBiKSBhc20gIkJCSVRTIjsKCjs7OyBSZXR1cm5zIHRoZSBkZXB0aCBvZiBgYnVpbGRlcmAgW2JdLgo7OzsgSWYg' +
    'bm8gY2VsbCByZWZlcmVuY2VzIGFyZSBzdG9yZWQgaW4gW2JdLCB0aGVuIHJldHVybnMgMDsKOzs7IG90aGVyd2lzZSB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgb25lIHBs' +
    'dXMgdGhlIG1heGltdW0gb2YgZGVwdGhzIG9mIGNlbGxzIHJlZmVycmVkIHRvIGZyb20gW2JdLgppbnQgYnVpbGRlcl9kZXB0aChidWlsZGVyIGIpIGFzbSAiQkRFUFRI' +
    'IjsKCnstCiAgIyBCdWlsZGVyIHByaW1pdGl2ZXMKICBJdCBpcyBzYWlkIHRoYXQgYSBwcmltaXRpdmUgX3N0b3Jlc18gYSB2YWx1ZSBgeGAgaW50byBhIGJ1aWxkZXIg' +
    'YGJgCiAgaWYgaXQgcmV0dXJucyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIGJ1aWxkZXIgYGInYCB3aXRoIHRoZSB2YWx1ZSBgeGAgc3RvcmVkIGF0IHRoZSBlbmQg' +
    'b2YgaXQuCiAgSXQgY2FuIGJlIHVzZWQgYXMgW25vbi1tb2RpZnlpbmcgbWV0aG9kXShodHRwczovL3Rvbi5vcmcvZG9jcy8jL2Z1bmMvc3RhdGVtZW50cz9pZD1ub24t' +
    'bW9kaWZ5aW5nLW1ldGhvZHMpLgoKICBBbGwgdGhlIHByaW1pdGl2ZXMgYmVsb3cgZmlyc3QgY2hlY2sgd2hldGhlciB0aGVyZSBpcyBlbm91Z2ggc3BhY2UgaW4gdGhl' +
    'IGBidWlsZGVyYCwKICBhbmQgb25seSB0aGVuIGNoZWNrIHRoZSByYW5nZSBvZiB0aGUgdmFsdWUgYmVpbmcgc2VyaWFsaXplZC4KLX0KCjs7OyBDcmVhdGVzIGEgbmV3' +
    'IGVtcHR5IGBidWlsZGVyYC4KYnVpbGRlciBiZWdpbl9jZWxsKCkgYXNtICJORVdDIjsKCjs7OyBDb252ZXJ0cyBhIGBidWlsZGVyYCBpbnRvIGFuIG9yZGluYXJ5IGBj' +
    'ZWxsYC4KY2VsbCBlbmRfY2VsbChidWlsZGVyIGIpIGFzbSAiRU5EQyI7Cgo7OzsgU3RvcmVzIGEgcmVmZXJlbmNlIHRvIGBjZWxsYCBbY10gaW50byBgYnVpbGRlcmAg' +
    'W2JdLgpidWlsZGVyIHN0b3JlX3JlZihidWlsZGVyIGIsIGNlbGwgYykgYXNtKGMgYikgIlNUUkVGIjsKCjs7OyBTdG9yZXMgYW4gdW5zaWduZWQgW2xlbl0tYml0IGlu' +
    'dGVnZXIgYHhgIGludG8gYGJgIGZvciBgMCDiiaQgbGVuIOKJpCAyNTZgLgo7OyBidWlsZGVyIHN0b3JlX3VpbnQoYnVpbGRlciBiLCBpbnQgeCwgaW50IGxlbikgYXNt' +
    'KHggYiBsZW4pICJTVFVYIjsKCjs7OyBTdG9yZXMgYSBzaWduZWQgW2xlbl0tYml0IGludGVnZXIgYHhgIGludG8gYGJgIGZvcmAgMCDiiaQgbGVuIOKJpCAyNTdgLgo7' +
    'OyBidWlsZGVyIHN0b3JlX2ludChidWlsZGVyIGIsIGludCB4LCBpbnQgbGVuKSBhc20oeCBiIGxlbikgIlNUSVgiOwoKCjs7OyBTdG9yZXMgYHNsaWNlYCBbc10gaW50' +
    'byBgYnVpbGRlcmAgW2JdCmJ1aWxkZXIgc3RvcmVfc2xpY2UoYnVpbGRlciBiLCBzbGljZSBzKSBhc20gIlNUU0xJQ0VSIjsKCjs7OyBTdG9yZXMgKHNlcmlhbGl6ZXMp' +
    'IGFuIGludGVnZXIgW3hdIGluIHRoZSByYW5nZSBgMC4uMl4xMjAg4oiSIDFgIGludG8gYGJ1aWxkZXJgIFtiXS4KOzs7IFRoZSBzZXJpYWxpemF0aW9uIG9mIFt4XSBj' +
    'b25zaXN0cyBvZiBhIDQtYml0IHVuc2lnbmVkIGJpZy1lbmRpYW4gaW50ZWdlciBgbGAsCjs7OyB3aGljaCBpcyB0aGUgc21hbGxlc3QgaW50ZWdlciBgbCDiiaUgMGAs' +
    'IHN1Y2ggdGhhdCBgeCA8IDJeOGxgLAo7OzsgZm9sbG93ZWQgYnkgYW4gYDhsYC1iaXQgdW5zaWduZWQgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiBbeF0uCjs7' +
    'OyBJZiBbeF0gZG9lcyBub3QgYmVsb25nIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UsIGEgcmFuZ2UgY2hlY2sgZXhjZXB0aW9uIGlzIHRocm93bi4KOzs7Cjs7OyBTdG9y' +
    'ZSBhbW91bnRzIG9mIFRvbkNvaW5zIHRvIHRoZSBidWlsZGVyIGFzIFZhclVJbnRlZ2VyIDE2CmJ1aWxkZXIgc3RvcmVfZ3JhbXMoYnVpbGRlciBiLCBpbnQgeCkgYXNt' +
    'ICJTVEdSQU1TIjsKYnVpbGRlciBzdG9yZV9jb2lucyhidWlsZGVyIGIsIGludCB4KSBhc20gIlNUVkFSVUlOVDE2IjsKCjs7OyBTdG9yZXMgZGljdGlvbmFyeSBgRGAg' +
    'cmVwcmVzZW50ZWQgYnkgYGNlbGxgIFtjXSBvciBgbnVsbGAgaW50byBgYnVpbGRlcmAgW2JdLgo7OzsgSW4gb3RoZXIgd29yZHMsIHN0b3JlcyBhIGAxYC1iaXQgYW5k' +
    'IGEgcmVmZXJlbmNlIHRvIFtjXSBpZiBbY10gaXMgbm90IGBudWxsYCBhbmQgYDBgLWJpdCBvdGhlcndpc2UuCmJ1aWxkZXIgc3RvcmVfZGljdChidWlsZGVyIGIsIGNl' +
    'bGwgYykgYXNtKGMgYikgIlNURElDVCI7Cgo7OzsgU3RvcmVzIChNYXliZSBeQ2VsbCkgdG8gYnVpbGRlcjoKOzs7IGlmIGNlbGwgaXMgbnVsbCBzdG9yZSAxIHplcm8g' +
    'Yml0Cjs7OyBvdGhlcndpc2Ugc3RvcmUgMSB0cnVlIGJpdCBhbmQgcmVmIHRvIGNlbGwKYnVpbGRlciBzdG9yZV9tYXliZV9yZWYoYnVpbGRlciBiLCBjZWxsIGMpIGFz' +
    'bShjIGIpICJTVE9QVFJFRiI7CgoKey0KICAjIEFkZHJlc3MgbWFuaXB1bGF0aW9uIHByaW1pdGl2ZXMKICBUaGUgYWRkcmVzcyBtYW5pcHVsYXRpb24gcHJpbWl0aXZl' +
    'cyBsaXN0ZWQgYmVsb3cgc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZSB2YWx1ZXMgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgVEwtQiBzY2hlbWU6CiAgYGBgVEwt' +
    'QgogIGFkZHJfbm9uZSQwMCA9IE1zZ0FkZHJlc3NFeHQ7CiAgYWRkcl9leHRlcm4kMDEgbGVuOigjIyA4KSBleHRlcm5hbF9hZGRyZXNzOihiaXRzIGxlbikKICAgICAg' +
    'ICAgICAgICAgPSBNc2dBZGRyZXNzRXh0OwogIGFueWNhc3RfaW5mbyRfIGRlcHRoOigjPD0gMzApIHsgZGVwdGggPj0gMSB9CiAgICByZXdyaXRlX3BmeDooYml0cyBk' +
    'ZXB0aCkgPSBBbnljYXN0OwogIGFkZHJfc3RkJDEwIGFueWNhc3Q6KE1heWJlIEFueWNhc3QpCiAgICB3b3JrY2hhaW5faWQ6aW50OCBhZGRyZXNzOmJpdHMyNTYgPSBN' +
    'c2dBZGRyZXNzSW50OwogIGFkZHJfdmFyJDExIGFueWNhc3Q6KE1heWJlIEFueWNhc3QpIGFkZHJfbGVuOigjIyA5KQogICAgd29ya2NoYWluX2lkOmludDMyIGFkZHJl' +
    'c3M6KGJpdHMgYWRkcl9sZW4pID0gTXNnQWRkcmVzc0ludDsKICBfIF86TXNnQWRkcmVzc0ludCA9IE1zZ0FkZHJlc3M7CiAgXyBfOk1zZ0FkZHJlc3NFeHQgPSBNc2dB' +
    'ZGRyZXNzOwoKICBpbnRfbXNnX2luZm8kMCBpaHJfZGlzYWJsZWQ6Qm9vbCBib3VuY2U6Qm9vbCBib3VuY2VkOkJvb2wKICAgIHNyYzpNc2dBZGRyZXNzIGRlc3Q6TXNn' +
    'QWRkcmVzc0ludAogICAgdmFsdWU6Q3VycmVuY3lDb2xsZWN0aW9uIGlocl9mZWU6R3JhbXMgZndkX2ZlZTpHcmFtcwogICAgY3JlYXRlZF9sdDp1aW50NjQgY3JlYXRl' +
    'ZF9hdDp1aW50MzIgPSBDb21tb25Nc2dJbmZvUmVsYXhlZDsKICBleHRfb3V0X21zZ19pbmZvJDExIHNyYzpNc2dBZGRyZXNzIGRlc3Q6TXNnQWRkcmVzc0V4dAogICAg' +
    'Y3JlYXRlZF9sdDp1aW50NjQgY3JlYXRlZF9hdDp1aW50MzIgPSBDb21tb25Nc2dJbmZvUmVsYXhlZDsKICBgYGAKICBBIGRlc2VyaWFsaXplZCBgTXNnQWRkcmVzc2Ag' +
    'aXMgcmVwcmVzZW50ZWQgYnkgYSB0dXBsZSBgdGAgYXMgZm9sbG93czoKCiAgLSBgYWRkcl9ub25lYCBpcyByZXByZXNlbnRlZCBieSBgdCA9ICgwKWAsCiAgICBpLmUu' +
    'LCBhIHR1cGxlIGNvbnRhaW5pbmcgZXhhY3RseSBvbmUgaW50ZWdlciBlcXVhbCB0byB6ZXJvLgogIC0gYGFkZHJfZXh0ZXJuYCBpcyByZXByZXNlbnRlZCBieSBgdCA9' +
    'ICgxLCBzKWAsCiAgICB3aGVyZSBzbGljZSBgc2AgY29udGFpbnMgdGhlIGZpZWxkIGBleHRlcm5hbF9hZGRyZXNzYC4gSW4gb3RoZXIgd29yZHMsIGAKICAgIHRgIGlz' +
    'IGEgcGFpciAoYSB0dXBsZSBjb25zaXN0aW5nIG9mIHR3byBlbnRyaWVzKSwgY29udGFpbmluZyBhbiBpbnRlZ2VyIGVxdWFsIHRvIG9uZSBhbmQgc2xpY2UgYHNgLgog' +
    'IC0gYGFkZHJfc3RkYCBpcyByZXByZXNlbnRlZCBieSBgdCA9ICgyLCB1LCB4LCBzKWAsCiAgICB3aGVyZSBgdWAgaXMgZWl0aGVyIGEgYG51bGxgIChpZiBgYW55Y2Fz' +
    'dGAgaXMgYWJzZW50KSBvciBhIHNsaWNlIGBzJ2AgY29udGFpbmluZyBgcmV3cml0ZV9wZnhgIChpZiBhbnljYXN0IGlzIHByZXNlbnQpLgogICAgTmV4dCwgaW50ZWdl' +
    'ciBgeGAgaXMgdGhlIGB3b3JrY2hhaW5faWRgLCBhbmQgc2xpY2UgYHNgIGNvbnRhaW5zIHRoZSBhZGRyZXNzLgogIC0gYGFkZHJfdmFyYCBpcyByZXByZXNlbnRlZCBi' +
    'eSBgdCA9ICgzLCB1LCB4LCBzKWAsCiAgICB3aGVyZSBgdWAsIGB4YCwgYW5kIGBzYCBoYXZlIHRoZSBzYW1lIG1lYW5pbmcgYXMgZm9yIGBhZGRyX3N0ZGAuCi19Cgo7' +
    'OzsgTG9hZHMgZnJvbSBzbGljZSBbc10gdGhlIG9ubHkgcHJlZml4IHRoYXQgaXMgYSB2YWxpZCBgTXNnQWRkcmVzc2AsCjs7OyBhbmQgcmV0dXJucyBib3RoIHRoaXMg' +
    'cHJlZml4IGBzJ2AgYW5kIHRoZSByZW1haW5kZXIgYHMnJ2Agb2YgW3NdIGFzIHNsaWNlcy4KKHNsaWNlLCBzbGljZSkgbG9hZF9tc2dfYWRkcihzbGljZSBzKSBhc20o' +
    'LT4gMSAwKSAiTERNU0dBRERSIjsKCjs7OyBEZWNvbXBvc2VzIHNsaWNlIFtzXSBjb250YWluaW5nIGEgdmFsaWQgYE1zZ0FkZHJlc3NgIGludG8gYSBgdHVwbGUgdGAg' +
    'd2l0aCBzZXBhcmF0ZSBmaWVsZHMgb2YgdGhpcyBgTXNnQWRkcmVzc2AuCjs7OyBJZiBbc10gaXMgbm90IGEgdmFsaWQgYE1zZ0FkZHJlc3NgLCBhIGNlbGwgZGVzZXJp' +
    'YWxpemF0aW9uIGV4Y2VwdGlvbiBpcyB0aHJvd24uCnR1cGxlIHBhcnNlX2FkZHIoc2xpY2UgcykgYXNtICJQQVJTRU1TR0FERFIiOwoKOzs7IFBhcnNlcyBzbGljZSBb' +
    'c10gY29udGFpbmluZyBhIHZhbGlkIGBNc2dBZGRyZXNzSW50YCAodXN1YWxseSBhIGBtc2dfYWRkcl9zdGRgKSwKOzs7IGFwcGxpZXMgcmV3cml0aW5nIGZyb20gdGhl' +
    'IGFueWNhc3QgKGlmIHByZXNlbnQpIHRvIHRoZSBzYW1lLWxlbmd0aCBwcmVmaXggb2YgdGhlIGFkZHJlc3MsCjs7OyBhbmQgcmV0dXJucyBib3RoIHRoZSB3b3JrY2hh' +
    'aW4gYW5kIHRoZSAyNTYtYml0IGFkZHJlc3MgYXMgaW50ZWdlcnMuCjs7OyBJZiB0aGUgYWRkcmVzcyBpcyBub3QgMjU2LWJpdCwgb3IgaWYgW3NdIGlzIG5vdCBhIHZh' +
    'bGlkIHNlcmlhbGl6YXRpb24gb2YgYE1zZ0FkZHJlc3NJbnRgLAo7OzsgdGhyb3dzIGEgY2VsbCBkZXNlcmlhbGl6YXRpb24gZXhjZXB0aW9uLgooaW50LCBpbnQpIHBh' +
    'cnNlX3N0ZF9hZGRyKHNsaWNlIHMpIGFzbSAiUkVXUklURVNUREFERFIiOwoKOzs7IEEgdmFyaWFudCBvZiBbcGFyc2Vfc3RkX2FkZHJdIHRoYXQgcmV0dXJucyB0aGUg' +
    'KHJld3JpdHRlbikgYWRkcmVzcyBhcyBhIHNsaWNlIFtzXSwKOzs7IGV2ZW4gaWYgaXQgaXMgbm90IGV4YWN0bHkgMjU2IGJpdCBsb25nIChyZXByZXNlbnRlZCBieSBh' +
    'IGBtc2dfYWRkcl92YXJgKS4KKGludCwgc2xpY2UpIHBhcnNlX3Zhcl9hZGRyKHNsaWNlIHMpIGFzbSAiUkVXUklURVZBUkFERFIiOwoKey0KICAjIERpY3Rpb25hcnkg' +
    'cHJpbWl0aXZlcwotfQoKCjs7OyBTZXRzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggW2tleV9sZW5dLWJpdCBrZXkgc2lnbmVkIGluZGV4IGluIGRpY3Rpb25hcnkg' +
    'W2RpY3RdIHRvIFt2YWx1ZV0gKGNlbGwpLAo7OzsgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBkaWN0aW9uYXJ5LgpjZWxsIGlkaWN0X3NldF9yZWYoY2VsbCBkaWN0' +
    'LCBpbnQga2V5X2xlbiwgaW50IGluZGV4LCBjZWxsIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVElTRVRSRUYiOwooY2VsbCwgKCkpIH5p' +
    'ZGljdF9zZXRfcmVmKGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCwgY2VsbCB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RJ' +
    'U0VUUkVGIjsKCjs7OyBTZXRzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggW2tleV9sZW5dLWJpdCBrZXkgdW5zaWduZWQgaW5kZXggaW4gZGljdGlvbmFyeSBbZGlj' +
    'dF0gdG8gW3ZhbHVlXSAoY2VsbCksCjs7OyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIGRpY3Rpb25hcnkuCmNlbGwgdWRpY3Rfc2V0X3JlZihjZWxsIGRpY3QsIGlu' +
    'dCBrZXlfbGVuLCBpbnQgaW5kZXgsIGNlbGwgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUVVNFVFJFRiI7CihjZWxsLCAoKSkgfnVkaWN0' +
    'X3NldF9yZWYoY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4LCBjZWxsIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVFVTRVRS' +
    'RUYiOwoKY2VsbCBpZGljdF9nZXRfcmVmKGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCkgYXNtKGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RJR0VUT1BU' +
    'UkVGIjsKKGNlbGwsIGludCkgaWRpY3RfZ2V0X3JlZj8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4KSBhc20oaW5kZXggZGljdCBrZXlfbGVuKSAiRElD' +
    'VElHRVRSRUYiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIGludCkgdWRpY3RfZ2V0X3JlZj8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4KSBhc20oaW5k' +
    'ZXggZGljdCBrZXlfbGVuKSAiRElDVFVHRVRSRUYiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIGNlbGwpIGlkaWN0X3NldF9nZXRfcmVmKGNlbGwgZGljdCwgaW50IGtl' +
    'eV9sZW4sIGludCBpbmRleCwgY2VsbCB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RJU0VUR0VUT1BUUkVGIjsKKGNlbGwsIGNlbGwpIHVk' +
    'aWN0X3NldF9nZXRfcmVmKGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCwgY2VsbCB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJ' +
    'Q1RVU0VUR0VUT1BUUkVGIjsKKGNlbGwsIGludCkgaWRpY3RfZGVsZXRlPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgpIGFzbShpbmRleCBkaWN0IGtl' +
    'eV9sZW4pICJESUNUSURFTCI7CihjZWxsLCBpbnQpIHVkaWN0X2RlbGV0ZT8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4KSBhc20oaW5kZXggZGljdCBr' +
    'ZXlfbGVuKSAiRElDVFVERUwiOwooc2xpY2UsIGludCkgaWRpY3RfZ2V0PyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgpIGFzbShpbmRleCBkaWN0IGtl' +
    'eV9sZW4pICJESUNUSUdFVCIgIk5VTExTV0FQSUZOT1QiOwooc2xpY2UsIGludCkgdWRpY3RfZ2V0PyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgpIGFz' +
    'bShpbmRleCBkaWN0IGtleV9sZW4pICJESUNUVUdFVCIgIk5VTExTV0FQSUZOT1QiOwooY2VsbCwgc2xpY2UsIGludCkgaWRpY3RfZGVsZXRlX2dldD8oY2VsbCBkaWN0' +
    'LCBpbnQga2V5X2xlbiwgaW50IGluZGV4KSBhc20oaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVElERUxHRVQiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIHNsaWNlLCBp' +
    'bnQpIHVkaWN0X2RlbGV0ZV9nZXQ/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCkgYXNtKGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RVREVMR0VUIiAi' +
    'TlVMTFNXQVBJRk5PVCI7CihjZWxsLCAoc2xpY2UsIGludCkpIH5pZGljdF9kZWxldGVfZ2V0PyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgpIGFzbShp' +
    'bmRleCBkaWN0IGtleV9sZW4pICJESUNUSURFTEdFVCIgIk5VTExTV0FQSUZOT1QiOwooY2VsbCwgKHNsaWNlLCBpbnQpKSB+dWRpY3RfZGVsZXRlX2dldD8oY2VsbCBk' +
    'aWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4KSBhc20oaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVFVERUxHRVQiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIGNlbGws' +
    'IGludCkgaWRpY3RfZGVsZXRlX2dldF9yZWY/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCkgYXNtKGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RJREVM' +
    'R0VUUkVGIiAiTlVMTFNXQVBJRk5PVCI7CihjZWxsLCBjZWxsLCBpbnQpIHVkaWN0X2RlbGV0ZV9nZXRfcmVmPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5k' +
    'ZXgpIGFzbShpbmRleCBkaWN0IGtleV9sZW4pICJESUNUVURFTEdFVFJFRiIgIk5VTExTV0FQSUZOT1QiOwooY2VsbCwgKGNlbGwsIGludCkpIH5pZGljdF9kZWxldGVf' +
    'Z2V0X3JlZj8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4KSBhc20oaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVElERUxHRVRSRUYiICJOVUxMU1dBUElG' +
    'Tk9UIjsKKGNlbGwsIChjZWxsLCBpbnQpKSB+dWRpY3RfZGVsZXRlX2dldF9yZWY/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCkgYXNtKGluZGV4IGRp' +
    'Y3Qga2V5X2xlbikgIkRJQ1RVREVMR0VUUkVGIiAiTlVMTFNXQVBJRk5PVCI7CmNlbGwgdWRpY3Rfc2V0KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCwg' +
    'c2xpY2UgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUVVNFVCI7CihjZWxsLCAoKSkgfnVkaWN0X3NldChjZWxsIGRpY3QsIGludCBrZXlf' +
    'bGVuLCBpbnQgaW5kZXgsIHNsaWNlIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVFVTRVQiOwpjZWxsIGlkaWN0X3NldChjZWxsIGRpY3Qs' +
    'IGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIHNsaWNlIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVElTRVQiOwooY2VsbCwgKCkpIH5pZGlj' +
    'dF9zZXQoY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4LCBzbGljZSB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RJU0VUIjsK' +
    'Y2VsbCBkaWN0X3NldChjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBzbGljZSBpbmRleCwgc2xpY2UgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJE' +
    'SUNUU0VUIjsKKGNlbGwsICgpKSB+ZGljdF9zZXQoY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgc2xpY2UgaW5kZXgsIHNsaWNlIHZhbHVlKSBhc20odmFsdWUgaW5kZXgg' +
    'ZGljdCBrZXlfbGVuKSAiRElDVFNFVCI7CihjZWxsLCBpbnQpIHVkaWN0X2FkZD8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4LCBzbGljZSB2YWx1ZSkg' +
    'YXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RVQUREIjsKKGNlbGwsIGludCkgdWRpY3RfcmVwbGFjZT8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50' +
    'IGluZGV4LCBzbGljZSB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RVUkVQTEFDRSI7CihjZWxsLCBpbnQpIHVkaWN0X3JlcGxhY2VfcmVm' +
    'PyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIGNlbGwgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUVVJFUExBQ0VSRUYi' +
    'OwooY2VsbCwgc2xpY2UsIGludCkgdWRpY3RfcmVwbGFjZWdldD8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4LCBzbGljZSB2YWx1ZSkgYXNtKHZhbHVl' +
    'IGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RVUkVQTEFDRUdFVCIgIk5VTExTV0FQSUZOT1QiOwooY2VsbCwgY2VsbCwgaW50KSB1ZGljdF9yZXBsYWNlZ2V0X3JlZj8o' +
    'Y2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4LCBjZWxsIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVFVSRVBMQUNFR0VUUkVG' +
    'IiAiTlVMTFNXQVBJRk5PVCI7CihjZWxsLCAoc2xpY2UsIGludCkpIH51ZGljdF9yZXBsYWNlZ2V0PyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIHNs' +
    'aWNlIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVFVSRVBMQUNFR0VUIiAiTlVMTFNXQVBJRk5PVCI7CihjZWxsLCAoY2VsbCwgaW50KSkg' +
    'fnVkaWN0X3JlcGxhY2VnZXRfcmVmPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIGNlbGwgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9s' +
    'ZW4pICJESUNUVVJFUExBQ0VHRVRSRUYiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIGludCkgaWRpY3RfYWRkPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5k' +
    'ZXgsIHNsaWNlIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVElBREQiOwooY2VsbCwgaW50KSBpZGljdF9yZXBsYWNlPyhjZWxsIGRpY3Qs' +
    'IGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIHNsaWNlIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVElSRVBMQUNFIjsKKGNlbGwsIGludCkg' +
    'aWRpY3RfcmVwbGFjZV9yZWY/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCwgY2VsbCB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikg' +
    'IkRJQ1RJUkVQTEFDRVJFRiI7CihjZWxsLCBzbGljZSwgaW50KSBpZGljdF9yZXBsYWNlZ2V0PyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIHNsaWNl' +
    'IHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVElSRVBMQUNFR0VUIiAiTlVMTFNXQVBJRk5PVCI7CihjZWxsLCBjZWxsLCBpbnQpIGlkaWN0' +
    'X3JlcGxhY2VnZXRfcmVmPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIGNlbGwgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJE' +
    'SUNUSVJFUExBQ0VHRVRSRUYiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIChzbGljZSwgaW50KSkgfmlkaWN0X3JlcGxhY2VnZXQ/KGNlbGwgZGljdCwgaW50IGtleV9s' +
    'ZW4sIGludCBpbmRleCwgc2xpY2UgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUSVJFUExBQ0VHRVQiICJOVUxMU1dBUElGTk9UIjsKKGNl' +
    'bGwsIChjZWxsLCBpbnQpKSB+aWRpY3RfcmVwbGFjZWdldF9yZWY/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCwgY2VsbCB2YWx1ZSkgYXNtKHZhbHVl' +
    'IGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RJUkVQTEFDRUdFVFJFRiIgIk5VTExTV0FQSUZOT1QiOwpjZWxsIHVkaWN0X3NldF9idWlsZGVyKGNlbGwgZGljdCwgaW50' +
    'IGtleV9sZW4sIGludCBpbmRleCwgYnVpbGRlciB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RVU0VUQiI7CihjZWxsLCAoKSkgfnVkaWN0' +
    'X3NldF9idWlsZGVyKGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCwgYnVpbGRlciB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJ' +
    'Q1RVU0VUQiI7CmNlbGwgaWRpY3Rfc2V0X2J1aWxkZXIoY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4LCBidWlsZGVyIHZhbHVlKSBhc20odmFsdWUgaW5k' +
    'ZXggZGljdCBrZXlfbGVuKSAiRElDVElTRVRCIjsKKGNlbGwsICgpKSB+aWRpY3Rfc2V0X2J1aWxkZXIoY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IGluZGV4LCBi' +
    'dWlsZGVyIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVElTRVRCIjsKY2VsbCBkaWN0X3NldF9idWlsZGVyKGNlbGwgZGljdCwgaW50IGtl' +
    'eV9sZW4sIHNsaWNlIGluZGV4LCBidWlsZGVyIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVFNFVEIiOwooY2VsbCwgKCkpIH5kaWN0X3Nl' +
    'dF9idWlsZGVyKGNlbGwgZGljdCwgaW50IGtleV9sZW4sIHNsaWNlIGluZGV4LCBidWlsZGVyIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElD' +
    'VFNFVEIiOwooY2VsbCwgaW50KSBkaWN0X3JlcGxhY2VfYnVpbGRlcj8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgc2xpY2UgaW5kZXgsIGJ1aWxkZXIgdmFsdWUpIGFz' +
    'bSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUUkVQTEFDRUIiOwooY2VsbCwgYnVpbGRlciwgaW50KSBkaWN0X3JlcGxhY2VnZXRfYnVpbGRlcj8oY2VsbCBk' +
    'aWN0LCBpbnQga2V5X2xlbiwgc2xpY2UgaW5kZXgsIGJ1aWxkZXIgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUUkVQTEFDRUdFVEIiICJO' +
    'VUxMU1dBUElGTk9UIjsKKGNlbGwsIHNsaWNlLCBpbnQpIGRpY3RfcmVwbGFjZWdldD8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgc2xpY2UgaW5kZXgsIHNsaWNlIHZh' +
    'bHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBrZXlfbGVuKSAiRElDVFJFUExBQ0VHRVQiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIChidWlsZGVyLCBpbnQpKSB+ZGlj' +
    'dF9yZXBsYWNlZ2V0X2J1aWxkZXI/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIHNsaWNlIGluZGV4LCBidWlsZGVyIHZhbHVlKSBhc20odmFsdWUgaW5kZXggZGljdCBr' +
    'ZXlfbGVuKSAiRElDVFJFUExBQ0VHRVRCIiAiTlVMTFNXQVBJRk5PVCI7CihjZWxsLCAoc2xpY2UsIGludCkpIH5kaWN0X3JlcGxhY2VnZXQ/KGNlbGwgZGljdCwgaW50' +
    'IGtleV9sZW4sIHNsaWNlIGluZGV4LCBzbGljZSB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RSRVBMQUNFR0VUIiAiTlVMTFNXQVBJRk5P' +
    'VCI7CihjZWxsLCBpbnQpIHVkaWN0X2FkZF9idWlsZGVyPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIGJ1aWxkZXIgdmFsdWUpIGFzbSh2YWx1ZSBp' +
    'bmRleCBkaWN0IGtleV9sZW4pICJESUNUVUFEREIiOwooY2VsbCwgaW50KSB1ZGljdF9yZXBsYWNlX2J1aWxkZXI/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBp' +
    'bmRleCwgYnVpbGRlciB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RVUkVQTEFDRUIiOwooY2VsbCwgYnVpbGRlciwgaW50KSB1ZGljdF9y' +
    'ZXBsYWNlZ2V0X2J1aWxkZXI/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCwgYnVpbGRlciB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xl' +
    'bikgIkRJQ1RVUkVQTEFDRUdFVEIiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIChidWlsZGVyLCBpbnQpKSB+dWRpY3RfcmVwbGFjZWdldF9idWlsZGVyPyhjZWxsIGRp' +
    'Y3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIGJ1aWxkZXIgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUVVJFUExBQ0VHRVRCIiAiTlVM' +
    'TFNXQVBJRk5PVCI7CihjZWxsLCBpbnQpIGlkaWN0X2FkZF9idWlsZGVyPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIGJ1aWxkZXIgdmFsdWUpIGFz' +
    'bSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUSUFEREIiOwooY2VsbCwgaW50KSBpZGljdF9yZXBsYWNlX2J1aWxkZXI/KGNlbGwgZGljdCwgaW50IGtleV9s' +
    'ZW4sIGludCBpbmRleCwgYnVpbGRlciB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRpY3Qga2V5X2xlbikgIkRJQ1RJUkVQTEFDRUIiOwooY2VsbCwgYnVpbGRlciwgaW50' +
    'KSBpZGljdF9yZXBsYWNlZ2V0X2J1aWxkZXI/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBpbmRleCwgYnVpbGRlciB2YWx1ZSkgYXNtKHZhbHVlIGluZGV4IGRp' +
    'Y3Qga2V5X2xlbikgIkRJQ1RJUkVQTEFDRUdFVEIiICJOVUxMU1dBUElGTk9UIjsKKGNlbGwsIChidWlsZGVyLCBpbnQpKSB+aWRpY3RfcmVwbGFjZWdldF9idWlsZGVy' +
    'PyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgaW5kZXgsIGJ1aWxkZXIgdmFsdWUpIGFzbSh2YWx1ZSBpbmRleCBkaWN0IGtleV9sZW4pICJESUNUSVJFUExBQ0VH' +
    'RVRCIiAiTlVMTFNXQVBJRk5PVCI7CihjZWxsLCBpbnQsIHNsaWNlLCBpbnQpIHVkaWN0X2RlbGV0ZV9nZXRfbWluKGNlbGwgZGljdCwgaW50IGtleV9sZW4pIGFzbSgt' +
    'PiAwIDIgMSAzKSAiRElDVFVSRU1NSU4iICJOVUxMU1dBUElGTk9UMiI7CihjZWxsLCAoaW50LCBzbGljZSwgaW50KSkgfnVkaWN0OjpkZWxldGVfZ2V0X21pbihjZWxs' +
    'IGRpY3QsIGludCBrZXlfbGVuKSBhc20oLT4gMCAyIDEgMykgIkRJQ1RVUkVNTUlOIiAiTlVMTFNXQVBJRk5PVDIiOwooY2VsbCwgaW50LCBzbGljZSwgaW50KSBpZGlj' +
    'dF9kZWxldGVfZ2V0X21pbihjZWxsIGRpY3QsIGludCBrZXlfbGVuKSBhc20oLT4gMCAyIDEgMykgIkRJQ1RJUkVNTUlOIiAiTlVMTFNXQVBJRk5PVDIiOwooY2VsbCwg' +
    'KGludCwgc2xpY2UsIGludCkpIH5pZGljdDo6ZGVsZXRlX2dldF9taW4oY2VsbCBkaWN0LCBpbnQga2V5X2xlbikgYXNtKC0+IDAgMiAxIDMpICJESUNUSVJFTU1JTiIg' +
    'Ik5VTExTV0FQSUZOT1QyIjsKKGNlbGwsIHNsaWNlLCBzbGljZSwgaW50KSBkaWN0X2RlbGV0ZV9nZXRfbWluKGNlbGwgZGljdCwgaW50IGtleV9sZW4pIGFzbSgtPiAw' +
    'IDIgMSAzKSAiRElDVFJFTU1JTiIgIk5VTExTV0FQSUZOT1QyIjsKKGNlbGwsIChzbGljZSwgc2xpY2UsIGludCkpIH5kaWN0OjpkZWxldGVfZ2V0X21pbihjZWxsIGRp' +
    'Y3QsIGludCBrZXlfbGVuKSBhc20oLT4gMCAyIDEgMykgIkRJQ1RSRU1NSU4iICJOVUxMU1dBUElGTk9UMiI7CihjZWxsLCBpbnQsIHNsaWNlLCBpbnQpIHVkaWN0X2Rl' +
    'bGV0ZV9nZXRfbWF4KGNlbGwgZGljdCwgaW50IGtleV9sZW4pIGFzbSgtPiAwIDIgMSAzKSAiRElDVFVSRU1NQVgiICJOVUxMU1dBUElGTk9UMiI7CihjZWxsLCAoaW50' +
    'LCBzbGljZSwgaW50KSkgfnVkaWN0OjpkZWxldGVfZ2V0X21heChjZWxsIGRpY3QsIGludCBrZXlfbGVuKSBhc20oLT4gMCAyIDEgMykgIkRJQ1RVUkVNTUFYIiAiTlVM' +
    'TFNXQVBJRk5PVDIiOwooY2VsbCwgaW50LCBzbGljZSwgaW50KSBpZGljdF9kZWxldGVfZ2V0X21heChjZWxsIGRpY3QsIGludCBrZXlfbGVuKSBhc20oLT4gMCAyIDEg' +
    'MykgIkRJQ1RJUkVNTUFYIiAiTlVMTFNXQVBJRk5PVDIiOwooY2VsbCwgKGludCwgc2xpY2UsIGludCkpIH5pZGljdDo6ZGVsZXRlX2dldF9tYXgoY2VsbCBkaWN0LCBp' +
    'bnQga2V5X2xlbikgYXNtKC0+IDAgMiAxIDMpICJESUNUSVJFTU1BWCIgIk5VTExTV0FQSUZOT1QyIjsKKGNlbGwsIHNsaWNlLCBzbGljZSwgaW50KSBkaWN0X2RlbGV0' +
    'ZV9nZXRfbWF4KGNlbGwgZGljdCwgaW50IGtleV9sZW4pIGFzbSgtPiAwIDIgMSAzKSAiRElDVFJFTU1BWCIgIk5VTExTV0FQSUZOT1QyIjsKKGNlbGwsIChzbGljZSwg' +
    'c2xpY2UsIGludCkpIH5kaWN0OjpkZWxldGVfZ2V0X21heChjZWxsIGRpY3QsIGludCBrZXlfbGVuKSBhc20oLT4gMCAyIDEgMykgIkRJQ1RSRU1NQVgiICJOVUxMU1dB' +
    'UElGTk9UMiI7CihpbnQsIHNsaWNlLCBpbnQpIHVkaWN0X2dldF9taW4/KGNlbGwgZGljdCwgaW50IGtleV9sZW4pIGFzbSAoLT4gMSAwIDIpICJESUNUVU1JTiIgIk5V' +
    'TExTV0FQSUZOT1QyIjsKKGludCwgc2xpY2UsIGludCkgdWRpY3RfZ2V0X21heD8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbikgYXNtICgtPiAxIDAgMikgIkRJQ1RVTUFY' +
    'IiAiTlVMTFNXQVBJRk5PVDIiOwooaW50LCBjZWxsLCBpbnQpIHVkaWN0X2dldF9taW5fcmVmPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuKSBhc20gKC0+IDEgMCAyKSAi' +
    'RElDVFVNSU5SRUYiICJOVUxMU1dBUElGTk9UMiI7CihpbnQsIGNlbGwsIGludCkgdWRpY3RfZ2V0X21heF9yZWY/KGNlbGwgZGljdCwgaW50IGtleV9sZW4pIGFzbSAo' +
    'LT4gMSAwIDIpICJESUNUVU1BWFJFRiIgIk5VTExTV0FQSUZOT1QyIjsKKGludCwgc2xpY2UsIGludCkgaWRpY3RfZ2V0X21pbj8oY2VsbCBkaWN0LCBpbnQga2V5X2xl' +
    'bikgYXNtICgtPiAxIDAgMikgIkRJQ1RJTUlOIiAiTlVMTFNXQVBJRk5PVDIiOwooaW50LCBzbGljZSwgaW50KSBpZGljdF9nZXRfbWF4PyhjZWxsIGRpY3QsIGludCBr' +
    'ZXlfbGVuKSBhc20gKC0+IDEgMCAyKSAiRElDVElNQVgiICJOVUxMU1dBUElGTk9UMiI7CihpbnQsIGNlbGwsIGludCkgaWRpY3RfZ2V0X21pbl9yZWY/KGNlbGwgZGlj' +
    'dCwgaW50IGtleV9sZW4pIGFzbSAoLT4gMSAwIDIpICJESUNUSU1JTlJFRiIgIk5VTExTV0FQSUZOT1QyIjsKKGludCwgY2VsbCwgaW50KSBpZGljdF9nZXRfbWF4X3Jl' +
    'Zj8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbikgYXNtICgtPiAxIDAgMikgIkRJQ1RJTUFYUkVGIiAiTlVMTFNXQVBJRk5PVDIiOwooaW50LCBzbGljZSwgaW50KSB1ZGlj' +
    'dF9nZXRfbmV4dD8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IHBpdm90KSBhc20ocGl2b3QgZGljdCBrZXlfbGVuIC0+IDEgMCAyKSAiRElDVFVHRVRORVhUIiAi' +
    'TlVMTFNXQVBJRk5PVDIiOwooaW50LCBzbGljZSwgaW50KSB1ZGljdF9nZXRfbmV4dGVxPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgcGl2b3QpIGFzbShwaXZv' +
    'dCBkaWN0IGtleV9sZW4gLT4gMSAwIDIpICJESUNUVUdFVE5FWFRFUSIgIk5VTExTV0FQSUZOT1QyIjsKKGludCwgc2xpY2UsIGludCkgdWRpY3RfZ2V0X3ByZXY/KGNl' +
    'bGwgZGljdCwgaW50IGtleV9sZW4sIGludCBwaXZvdCkgYXNtKHBpdm90IGRpY3Qga2V5X2xlbiAtPiAxIDAgMikgIkRJQ1RVR0VUUFJFViIgIk5VTExTV0FQSUZOT1Qy' +
    'IjsKKGludCwgc2xpY2UsIGludCkgdWRpY3RfZ2V0X3ByZXZlcT8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IHBpdm90KSBhc20ocGl2b3QgZGljdCBrZXlfbGVu' +
    'IC0+IDEgMCAyKSAiRElDVFVHRVRQUkVWRVEiICJOVUxMU1dBUElGTk9UMiI7CihpbnQsIHNsaWNlLCBpbnQpIGlkaWN0X2dldF9uZXh0PyhjZWxsIGRpY3QsIGludCBr' +
    'ZXlfbGVuLCBpbnQgcGl2b3QpIGFzbShwaXZvdCBkaWN0IGtleV9sZW4gLT4gMSAwIDIpICJESUNUSUdFVE5FWFQiICJOVUxMU1dBUElGTk9UMiI7CihpbnQsIHNsaWNl' +
    'LCBpbnQpIGlkaWN0X2dldF9uZXh0ZXE/KGNlbGwgZGljdCwgaW50IGtleV9sZW4sIGludCBwaXZvdCkgYXNtKHBpdm90IGRpY3Qga2V5X2xlbiAtPiAxIDAgMikgIkRJ' +
    'Q1RJR0VUTkVYVEVRIiAiTlVMTFNXQVBJRk5PVDIiOwooaW50LCBzbGljZSwgaW50KSBpZGljdF9nZXRfcHJldj8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgaW50IHBp' +
    'dm90KSBhc20ocGl2b3QgZGljdCBrZXlfbGVuIC0+IDEgMCAyKSAiRElDVElHRVRQUkVWIiAiTlVMTFNXQVBJRk5PVDIiOwooaW50LCBzbGljZSwgaW50KSBpZGljdF9n' +
    'ZXRfcHJldmVxPyhjZWxsIGRpY3QsIGludCBrZXlfbGVuLCBpbnQgcGl2b3QpIGFzbShwaXZvdCBkaWN0IGtleV9sZW4gLT4gMSAwIDIpICJESUNUSUdFVFBSRVZFUSIg' +
    'Ik5VTExTV0FQSUZOT1QyIjsKCjs7OyBDcmVhdGVzIGFuIGVtcHR5IGRpY3Rpb25hcnksIHdoaWNoIGlzIGFjdHVhbGx5IGEgbnVsbCB2YWx1ZS4gRXF1aXZhbGVudCB0' +
    'byBQVVNITlVMTApjZWxsIG5ld19kaWN0KCkgYXNtICJORVdESUNUIjsKOzs7IENoZWNrcyB3aGV0aGVyIGEgZGljdGlvbmFyeSBpcyBlbXB0eS4gRXF1aXZhbGVudCB0' +
    'byBjZWxsX251bGw/LgppbnQgZGljdF9lbXB0eT8oY2VsbCBjKSBhc20gIkRJQ1RFTVBUWSI7CgoKey0gUHJlZml4IGRpY3Rpb25hcnkgcHJpbWl0aXZlcyAtfQooc2xp' +
    'Y2UsIHNsaWNlLCBzbGljZSwgaW50KSBwZnhkaWN0X2dldD8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgc2xpY2Uga2V5KSBhc20oa2V5IGRpY3Qga2V5X2xlbikgIlBG' +
    'WERJQ1RHRVRRIiAiTlVMTFNXQVBJRk5PVDIiOwooY2VsbCwgaW50KSBwZnhkaWN0X3NldD8oY2VsbCBkaWN0LCBpbnQga2V5X2xlbiwgc2xpY2Uga2V5LCBzbGljZSB2' +
    'YWx1ZSkgYXNtKHZhbHVlIGtleSBkaWN0IGtleV9sZW4pICJQRlhESUNUU0VUIjsKKGNlbGwsIGludCkgcGZ4ZGljdF9kZWxldGU/KGNlbGwgZGljdCwgaW50IGtleV9s' +
    'ZW4sIHNsaWNlIGtleSkgYXNtKGtleSBkaWN0IGtleV9sZW4pICJQRlhESUNUREVMIjsKCjs7OyBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGNvbmZpZ3Vy' +
    'YXRpb24gcGFyYW1ldGVyIHdpdGggaW50ZWdlciBpbmRleCBgaWAgYXMgYSBgY2VsbGAgb3IgYG51bGxgIHZhbHVlLgpjZWxsIGNvbmZpZ19wYXJhbShpbnQgeCkgYXNt' +
    'ICJDT05GSUdPUFRQQVJBTSI7Cjs7OyBDaGVja3Mgd2hldGhlciBjIGlzIGEgbnVsbC4gTm90ZSwgdGhhdCBGdW5DIGFsc28gaGFzIHBvbHltb3JwaGljIG51bGw/IGJ1' +
    'aWx0LWluLgppbnQgY2VsbF9udWxsPyhjZWxsIGMpIGFzbSAiSVNOVUxMIjsKCjs7OyBDcmVhdGVzIGFuIG91dHB1dCBhY3Rpb24gd2hpY2ggd291bGQgcmVzZXJ2ZSBl' +
    'eGFjdGx5IGFtb3VudCBuYW5vdG9uY29pbnMgKGlmIG1vZGUgPSAwKSwgYXQgbW9zdCBhbW91bnQgbmFub3RvbmNvaW5zIChpZiBtb2RlID0gMiksIG9yIGFsbCBidXQg' +
    'YW1vdW50IG5hbm90b25jb2lucyAoaWYgbW9kZSA9IDEgb3IgbW9kZSA9IDMpLCBmcm9tIHRoZSByZW1haW5pbmcgYmFsYW5jZSBvZiB0aGUgYWNjb3VudC4gSXQgaXMg' +
    'cm91Z2hseSBlcXVpdmFsZW50IHRvIGNyZWF0aW5nIGFuIG91dGJvdW5kIG1lc3NhZ2UgY2FycnlpbmcgYW1vdW50IG5hbm90b25jb2lucyAob3IgYiDiiJIgYW1vdW50' +
    'IG5hbm90b25jb2lucywgd2hlcmUgYiBpcyB0aGUgcmVtYWluaW5nIGJhbGFuY2UpIHRvIG9uZXNlbGYsIHNvIHRoYXQgdGhlIHN1YnNlcXVlbnQgb3V0cHV0IGFjdGlv' +
    'bnMgd291bGQgbm90IGJlIGFibGUgdG8gc3BlbmQgbW9yZSBtb25leSB0aGFuIHRoZSByZW1haW5kZXIuIEJpdCArMiBpbiBtb2RlIG1lYW5zIHRoYXQgdGhlIGV4dGVy' +
    'bmFsIGFjdGlvbiBkb2VzIG5vdCBmYWlsIGlmIHRoZSBzcGVjaWZpZWQgYW1vdW50IGNhbm5vdCBiZSByZXNlcnZlZDsgaW5zdGVhZCwgYWxsIHJlbWFpbmluZyBiYWxh' +
    'bmNlIGlzIHJlc2VydmVkLiBCaXQgKzggaW4gbW9kZSBtZWFucyBgYW1vdW50IDwtIC1hbW91bnRgIGJlZm9yZSBwZXJmb3JtaW5nIGFueSBmdXJ0aGVyIGFjdGlvbnMu' +
    'IEJpdCArNCBpbiBtb2RlIG1lYW5zIHRoYXQgYW1vdW50IGlzIGluY3JlYXNlZCBieSB0aGUgb3JpZ2luYWwgYmFsYW5jZSBvZiB0aGUgY3VycmVudCBhY2NvdW50IChi' +
    'ZWZvcmUgdGhlIGNvbXB1dGUgcGhhc2UpLCBpbmNsdWRpbmcgYWxsIGV4dHJhIGN1cnJlbmNpZXMsIGJlZm9yZSBwZXJmb3JtaW5nIGFueSBvdGhlciBjaGVja3MgYW5k' +
    'IGFjdGlvbnMuIEN1cnJlbnRseSwgYW1vdW50IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgYW5kIG1vZGUgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgMC4uMTUu' +
    'CigpIHJhd19yZXNlcnZlKGludCBhbW91bnQsIGludCBtb2RlKSBpbXB1cmUgYXNtICJSQVdSRVNFUlZFIjsKOzs7IFNpbWlsYXIgdG8gcmF3X3Jlc2VydmUsIGJ1dCBh' +
    'bHNvIGFjY2VwdHMgYSBkaWN0aW9uYXJ5IGV4dHJhX2Ftb3VudCAocmVwcmVzZW50ZWQgYnkgYSBjZWxsIG9yIG51bGwpIHdpdGggZXh0cmEgY3VycmVuY2llcy4gSW4g' +
    'dGhpcyB3YXkgY3VycmVuY2llcyBvdGhlciB0aGFuIFRvbkNvaW4gY2FuIGJlIHJlc2VydmVkLgooKSByYXdfcmVzZXJ2ZV9leHRyYShpbnQgYW1vdW50LCBjZWxsIGV4' +
    'dHJhX2Ftb3VudCwgaW50IG1vZGUpIGltcHVyZSBhc20gIlJBV1JFU0VSVkVYIjsKOzs7IFNlbmRzIGEgcmF3IG1lc3NhZ2UgY29udGFpbmVkIGluIG1zZywgd2hpY2gg' +
    'c2hvdWxkIGNvbnRhaW4gYSBjb3JyZWN0bHkgc2VyaWFsaXplZCBvYmplY3QgTWVzc2FnZSBYLCB3aXRoIHRoZSBvbmx5IGV4Y2VwdGlvbiB0aGF0IHRoZSBzb3VyY2Ug' +
    'YWRkcmVzcyBpcyBhbGxvd2VkIHRvIGhhdmUgZHVtbXkgdmFsdWUgYWRkcl9ub25lICh0byBiZSBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHdpdGggdGhlIGN1cnJlbnQg' +
    'c21hcnQgY29udHJhY3QgYWRkcmVzcyksIGFuZCBpaHJfZmVlLCBmd2RfZmVlLCBjcmVhdGVkX2x0IGFuZCBjcmVhdGVkX2F0IGZpZWxkcyBjYW4gaGF2ZSBhcmJpdHJh' +
    'cnkgdmFsdWVzICh0byBiZSByZXdyaXR0ZW4gd2l0aCBjb3JyZWN0IHZhbHVlcyBkdXJpbmcgdGhlIGFjdGlvbiBwaGFzZSBvZiB0aGUgY3VycmVudCB0cmFuc2FjdGlv' +
    'bikuIEludGVnZXIgcGFyYW1ldGVyIG1vZGUgY29udGFpbnMgdGhlIGZsYWdzLiBDdXJyZW50bHkgbW9kZSA9IDAgaXMgdXNlZCBmb3Igb3JkaW5hcnkgbWVzc2FnZXM7' +
    'IG1vZGUgPSAxMjggaXMgdXNlZCBmb3IgbWVzc2FnZXMgdGhhdCBhcmUgdG8gY2FycnkgYWxsIHRoZSByZW1haW5pbmcgYmFsYW5jZSBvZiB0aGUgY3VycmVudCBzbWFy' +
    'dCBjb250cmFjdCAoaW5zdGVhZCBvZiB0aGUgdmFsdWUgb3JpZ2luYWxseSBpbmRpY2F0ZWQgaW4gdGhlIG1lc3NhZ2UpOyBtb2RlID0gNjQgaXMgdXNlZCBmb3IgbWVz' +
    'c2FnZXMgdGhhdCBjYXJyeSBhbGwgdGhlIHJlbWFpbmluZyB2YWx1ZSBvZiB0aGUgaW5ib3VuZCBtZXNzYWdlIGluIGFkZGl0aW9uIHRvIHRoZSB2YWx1ZSBpbml0aWFs' +
    'bHkgaW5kaWNhdGVkIGluIHRoZSBuZXcgbWVzc2FnZSAoaWYgYml0IDAgaXMgbm90IHNldCwgdGhlIGdhcyBmZWVzIGFyZSBkZWR1Y3RlZCBmcm9tIHRoaXMgYW1vdW50' +
    'KTsgbW9kZScgPSBtb2RlICsgMSBtZWFucyB0aGF0IHRoZSBzZW5kZXIgd2FudHMgdG8gcGF5IHRyYW5zZmVyIGZlZXMgc2VwYXJhdGVseTsgbW9kZScgPSBtb2RlICsg' +
    'MiBtZWFucyB0aGF0IGFueSBlcnJvcnMgYXJpc2luZyB3aGlsZSBwcm9jZXNzaW5nIHRoaXMgbWVzc2FnZSBkdXJpbmcgdGhlIGFjdGlvbiBwaGFzZSBzaG91bGQgYmUg' +
    'aWdub3JlZC4gRmluYWxseSwgbW9kZScgPSBtb2RlICsgMzIgbWVhbnMgdGhhdCB0aGUgY3VycmVudCBhY2NvdW50IG11c3QgYmUgZGVzdHJveWVkIGlmIGl0cyByZXN1' +
    'bHRpbmcgYmFsYW5jZSBpcyB6ZXJvLiBUaGlzIGZsYWcgaXMgdXN1YWxseSBlbXBsb3llZCB0b2dldGhlciB3aXRoICsxMjguCigpIHNlbmRfcmF3X21lc3NhZ2UoY2Vs' +
    'bCBtc2csIGludCBtb2RlKSBpbXB1cmUgYXNtICJTRU5EUkFXTVNHIjsKOzs7IENyZWF0ZXMgYW4gb3V0cHV0IGFjdGlvbiB0aGF0IHdvdWxkIGNoYW5nZSB0aGlzIHNt' +
    'YXJ0IGNvbnRyYWN0IGNvZGUgdG8gdGhhdCBnaXZlbiBieSBjZWxsIG5ld19jb2RlLiBOb3RpY2UgdGhhdCB0aGlzIGNoYW5nZSB3aWxsIHRha2UgZWZmZWN0IG9ubHkg' +
    'YWZ0ZXIgdGhlIHN1Y2Nlc3NmdWwgdGVybWluYXRpb24gb2YgdGhlIGN1cnJlbnQgcnVuIG9mIHRoZSBzbWFydCBjb250cmFjdAooKSBzZXRfY29kZShjZWxsIG5ld19j' +
    'b2RlKSBpbXB1cmUgYXNtICJTRVRDT0RFIjsKCjs7OyBHZW5lcmF0ZXMgYSBuZXcgcHNldWRvLXJhbmRvbSB1bnNpZ25lZCAyNTYtYml0IGludGVnZXIgeC4gVGhlIGFs' +
    'Z29yaXRobSBpcyBhcyBmb2xsb3dzOiBpZiByIGlzIHRoZSBvbGQgdmFsdWUgb2YgdGhlIHJhbmRvbSBzZWVkLCBjb25zaWRlcmVkIGFzIGEgMzItYnl0ZSBhcnJheSAo' +
    'YnkgY29uc3RydWN0aW5nIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uIG9mIGFuIHVuc2lnbmVkIDI1Ni1iaXQgaW50ZWdlciksIHRoZW4gaXRzIHNoYTUxMihy' +
    'KSBpcyBjb21wdXRlZDsgdGhlIGZpcnN0IDMyIGJ5dGVzIG9mIHRoaXMgaGFzaCBhcmUgc3RvcmVkIGFzIHRoZSBuZXcgdmFsdWUgcicgb2YgdGhlIHJhbmRvbSBzZWVk' +
    'LCBhbmQgdGhlIHJlbWFpbmluZyAzMiBieXRlcyBhcmUgcmV0dXJuZWQgYXMgdGhlIG5leHQgcmFuZG9tIHZhbHVlIHguCmludCByYW5kb20oKSBpbXB1cmUgYXNtICJS' +
    'QU5EVTI1NiI7Cjs7OyBHZW5lcmF0ZXMgYSBuZXcgcHNldWRvLXJhbmRvbSBpbnRlZ2VyIHogaW4gdGhlIHJhbmdlIDAuLnJhbmdl4oiSMSAob3IgcmFuZ2UuLuKIkjEs' +
    'IGlmIHJhbmdlIDwgMCkuIE1vcmUgcHJlY2lzZWx5LCBhbiB1bnNpZ25lZCByYW5kb20gdmFsdWUgeCBpcyBnZW5lcmF0ZWQgYXMgaW4gcmFuZG9tOyB0aGVuIHogOj0g' +
    'eCAqIHJhbmdlIC8gMl4yNTYgaXMgY29tcHV0ZWQuCmludCByYW5kKGludCByYW5nZSkgaW1wdXJlIGFzbSAiUkFORCI7Cjs7OyBSZXR1cm5zIHRoZSBjdXJyZW50IHJh' +
    'bmRvbSBzZWVkIGFzIGFuIHVuc2lnbmVkIDI1Ni1iaXQgSW50ZWdlci4KaW50IGdldF9zZWVkKCkgaW1wdXJlIGFzbSAiUkFORFNFRUQiOwo7OzsgU2V0cyB0aGUgcmFu' +
    'ZG9tIHNlZWQgdG8gdW5zaWduZWQgMjU2LWJpdCBzZWVkLgooKSBzZXRfc2VlZChpbnQgeCkgaW1wdXJlIGFzbSAiU0VUUkFORCI7Cjs7OyBNaXhlcyB1bnNpZ25lZCAy' +
    'NTYtYml0IGludGVnZXIgeCBpbnRvIHRoZSByYW5kb20gc2VlZCByIGJ5IHNldHRpbmcgdGhlIHJhbmRvbSBzZWVkIHRvIHNoYTI1NiBvZiB0aGUgY29uY2F0ZW5hdGlv' +
    'biBvZiB0d28gMzItYnl0ZSBzdHJpbmdzOiB0aGUgZmlyc3Qgd2l0aCB0aGUgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2xkIHNlZWQgciwgYW5kIHRo' +
    'ZSBzZWNvbmQgd2l0aCB0aGUgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiB4LgooKSByYW5kb21pemUoaW50IHgpIGltcHVyZSBhc20gIkFERFJBTkQiOwo7Ozsg' +
    'RXF1aXZhbGVudCB0byByYW5kb21pemUoY3VyX2x0KCkpOy4KKCkgcmFuZG9taXplX2x0KCkgaW1wdXJlIGFzbSAiTFRJTUUiICJBRERSQU5EIjsKCjs7OyBDaGVja3Mg' +
    'd2hldGhlciB0aGUgZGF0YSBwYXJ0cyBvZiB0d28gc2xpY2VzIGNvaW5zaWRlCmludCBlcXVhbF9zbGljZXNfYml0cyhzbGljZSBhLCBzbGljZSBiKSBhc20gIlNERVEi' +
    'Owo7OzsgQ2hlY2tzIHdoZXRoZXIgYiBpcyBhIG51bGwuIE5vdGUsIHRoYXQgRnVuQyBhbHNvIGhhcyBwb2x5bW9ycGhpYyBudWxsPyBidWlsdC1pbi4KaW50IGJ1aWxk' +
    'ZXJfbnVsbD8oYnVpbGRlciBiKSBhc20gIklTTlVMTCI7Cjs7OyBDb25jYXRlbmF0ZXMgdHdvIGJ1aWxkZXJzCmJ1aWxkZXIgc3RvcmVfYnVpbGRlcihidWlsZGVyIHRv' +
    'LCBidWlsZGVyIGZyb20pIGFzbSAiU1RCUiI7Cgo7OyBDVVNUT006Cgo7OyBUVk0gVVBHUkFERSAyMDIzLTA3IGh0dHBzOi8vZG9jcy50b24ub3JnL2xlYXJuL3R2bS1p' +
    'bnN0cnVjdGlvbnMvdHZtLXVwZ3JhZGUtMjAyMy0wNwo7OyBJbiBtYWlubmV0IHNpbmNlIDIwIERlYyAyMDIzIGh0dHBzOi8vdC5tZS90b25ibG9ja2NoYWluLzIyNgoK' +
    'Ozs7IFJldHJpZXZlcyBjb2RlIG9mIHNtYXJ0LWNvbnRyYWN0IGZyb20gYzcKY2VsbCBteV9jb2RlKCkgYXNtICJNWUNPREUiOwo=';
files['stdlib.tact'] =
    'aW1wb3J0ICIuL3N0ZC9wcmltaXRpdmVzIjsKaW1wb3J0ICIuL3N0ZC9jZWxscyI7CmltcG9ydCAiLi9zdGQvY3J5cHRvIjsKaW1wb3J0ICIuL3N0ZC90ZXh0IjsKaW1w' +
    'b3J0ICIuL3N0ZC9tYXRoIjsKaW1wb3J0ICIuL3N0ZC9jb250cmFjdCI7CmltcG9ydCAiLi9zdGQvZGVidWciOwppbXBvcnQgIi4vc3RkL2NvbnRleHQiOwppbXBvcnQg' +
    'Ii4vc3RkL3Jlc2VydmUiOwppbXBvcnQgIi4vc3RkL3NlbmQiOwppbXBvcnQgIi4vc3RkL2NvbmZpZyI7CmltcG9ydCAiLi9zdGQvYmFzZSI7';
export default files;

## imported.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/project/imported.tact)


## imported_from_subfolder.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/project/imported_from_subfolder.tact)


## main.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/project/main.tact)
import "./imported"; import "./subfolder/import_from_parent";

## import_from_parent.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/project/subfolder/import_from_parent.tact)
import "../imported_from_subfolder";

## stdlib.fc (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/stdlib/stdlib.fc)


## stdlib.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/stdlib/stdlib.tact)
import "./stdlib2.fc";

## stdlib2.fc (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/stdlib/stdlib2.fc)


## config.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/stdlib/lib/config.tact)
import "./config/import2.tact"

## import2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/imports/__testdata/stdlib/lib/config/import2.tact)


## algebraic.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/optimizer/algebraic.ts)
import {
    AstBinaryOperation,
    AstExpression,
    AstOpBinary,
    AstOpUnary,
    eqExpressions,
    isValue,
} from "../grammar/ast";
import { ExpressionTransformer, Rule } from "./types";
import {
    checkIsBinaryOpNode,
    checkIsBoolean,
    checkIsName,
    checkIsNumber,
    checkIsUnaryOpNode,
} from "./util";

export class AddZero extends Rule {
    private additiveOperators: AstBinaryOperation[] = ["+", "-"];

    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (this.additiveOperators.includes(topLevelNode.op)) {
                if (
                    !isValue(topLevelNode.left) &&
                    checkIsNumber(topLevelNode.right, 0n)
                ) {
                    // The tree has this form:
                    // x op 0

                    const x = topLevelNode.left;

                    return x;
                } else if (
                    checkIsNumber(topLevelNode.left, 0n) &&
                    !isValue(topLevelNode.right)
                ) {
                    // The tree has this form:
                    // 0 op x

                    const x = topLevelNode.right;
                    const op = topLevelNode.op;

                    if (op === "-") {
                        return util.makeUnaryExpression("-", x);
                    } else {
                        return x;
                    }
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class MultiplyZero extends Rule {
    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "*") {
                if (
                    checkIsName(topLevelNode.left) &&
                    checkIsNumber(topLevelNode.right, 0n)
                ) {
                    // The tree has this form:
                    // x * 0, where x is an identifier

                    return util.makeValueExpression(0n);
                } else if (
                    checkIsNumber(topLevelNode.left, 0n) &&
                    checkIsName(topLevelNode.right)
                ) {
                    // The tree has this form:
                    // 0 * x, where x is an identifier

                    return util.makeValueExpression(0n);
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class MultiplyOne extends Rule {
    public applyRule(
        ast: AstExpression,
        _optimizer: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "*") {
                if (
                    !isValue(topLevelNode.left) &&
                    checkIsNumber(topLevelNode.right, 1n)
                ) {
                    // The tree has this form:
                    // x * 1

                    const x = topLevelNode.left;

                    return x;
                } else if (
                    checkIsNumber(topLevelNode.left, 1n) &&
                    !isValue(topLevelNode.right)
                ) {
                    // The tree has this form:
                    // 1 * x

                    const x = topLevelNode.right;

                    return x;
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class SubtractSelf extends Rule {
    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "-") {
                if (
                    checkIsName(topLevelNode.left) &&
                    checkIsName(topLevelNode.right)
                ) {
                    // The tree has this form:
                    // x - y
                    // We need to check that x and y are equal

                    const x = topLevelNode.left;
                    const y = topLevelNode.right;

                    if (eqExpressions(x, y)) {
                        return util.makeValueExpression(0n);
                    }
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class AddSelf extends Rule {
    public applyRule(
        ast: AstExpression,
        { applyRules, util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "+") {
                if (
                    !isValue(topLevelNode.left) &&
                    !isValue(topLevelNode.right)
                ) {
                    // The tree has this form:
                    // x + y
                    // We need to check that x and y are equal

                    const x = topLevelNode.left;
                    const y = topLevelNode.right;

                    if (eqExpressions(x, y)) {
                        const res = util.makeBinaryExpression(
                            "*",
                            x,
                            util.makeValueExpression(2n),
                        );
                        // Since we joined the tree, there is further opportunity
                        // for simplification
                        return applyRules(res);
                    }
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class OrTrue extends Rule {
    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "||") {
                if (
                    (checkIsName(topLevelNode.left) ||
                        isValue(topLevelNode.left)) &&
                    checkIsBoolean(topLevelNode.right, true)
                ) {
                    // The tree has this form:
                    // x || true, where x is an identifier or a value

                    return util.makeValueExpression(true);
                } else if (checkIsBoolean(topLevelNode.left, true)) {
                    // The tree has this form:
                    // true || x

                    return util.makeValueExpression(true);
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class AndFalse extends Rule {
    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "&&") {
                if (
                    (checkIsName(topLevelNode.left) ||
                        isValue(topLevelNode.left)) &&
                    checkIsBoolean(topLevelNode.right, false)
                ) {
                    // The tree has this form:
                    // x && false, where x is an identifier or a value

                    return util.makeValueExpression(false);
                } else if (checkIsBoolean(topLevelNode.left, false)) {
                    // The tree has this form:
                    // false && x

                    return util.makeValueExpression(false);
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class OrFalse extends Rule {
    public applyRule(
        ast: AstExpression,
        _optimizer: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "||") {
                if (checkIsBoolean(topLevelNode.right, false)) {
                    // The tree has this form:
                    // x || false

                    const x = topLevelNode.left;

                    return x;
                } else if (checkIsBoolean(topLevelNode.left, false)) {
                    // The tree has this form:
                    // false || x

                    const x = topLevelNode.right;

                    return x;
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class AndTrue extends Rule {
    public applyRule(
        ast: AstExpression,
        _optimizer: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "&&") {
                if (checkIsBoolean(topLevelNode.right, true)) {
                    // The tree has this form:
                    // x && true

                    const x = topLevelNode.left;

                    return x;
                } else if (checkIsBoolean(topLevelNode.left, true)) {
                    // The tree has this form:
                    // true && x

                    const x = topLevelNode.right;

                    return x;
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class OrSelf extends Rule {
    public applyRule(
        ast: AstExpression,
        _optimizer: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "||") {
                // The tree has this form:
                // x || y
                // We need to check that x and y are equal

                const x = topLevelNode.left;
                const y = topLevelNode.right;

                if (eqExpressions(x, y)) {
                    return x;
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class AndSelf extends Rule {
    public applyRule(
        ast: AstExpression,
        _optimizer: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "&&") {
                // The tree has this form:
                // x && y
                // We need to check that x and y are equal

                const x = topLevelNode.left;
                const y = topLevelNode.right;

                if (eqExpressions(x, y)) {
                    return x;
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class ExcludedMiddle extends Rule {
    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "||") {
                if (checkIsUnaryOpNode(topLevelNode.right)) {
                    const rightNode = topLevelNode.right as AstOpUnary;
                    if (rightNode.op === "!") {
                        // The tree has this form:
                        // x || !y
                        // We need to check that x is an identifier or a value
                        // and that x and y are equal

                        const x = topLevelNode.left;
                        const y = rightNode.operand;

                        if (
                            (checkIsName(x) || isValue(x)) &&
                            eqExpressions(x, y)
                        ) {
                            return util.makeValueExpression(true);
                        }
                    }
                } else if (checkIsUnaryOpNode(topLevelNode.left)) {
                    const leftNode = topLevelNode.left as AstOpUnary;
                    if (leftNode.op === "!") {
                        // The tree has this form:
                        // !x || y
                        // We need to check that x is an identifier or a value
                        // and that x and y are equal

                        const x = leftNode.operand;
                        const y = topLevelNode.right;

                        if (
                            (checkIsName(x) || isValue(x)) &&
                            eqExpressions(x, y)
                        ) {
                            return util.makeValueExpression(true);
                        }
                    }
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class Contradiction extends Rule {
    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (topLevelNode.op === "&&") {
                if (checkIsUnaryOpNode(topLevelNode.right)) {
                    const rightNode = topLevelNode.right as AstOpUnary;
                    if (rightNode.op === "!") {
                        // The tree has this form:
                        // x && !y
                        // We need to check that x is an identifier or a value
                        // and that x and y are equal

                        const x = topLevelNode.left;
                        const y = rightNode.operand;

                        if (
                            (checkIsName(x) || isValue(x)) &&
                            eqExpressions(x, y)
                        ) {
                            return util.makeValueExpression(false);
                        }
                    }
                } else if (checkIsUnaryOpNode(topLevelNode.left)) {
                    const leftNode = topLevelNode.left as AstOpUnary;
                    if (leftNode.op === "!") {
                        // The tree has this form:
                        // !x && y
                        // We need to check that x is an identifier or a value
                        // and that x and y are equal

                        const x = leftNode.operand;
                        const y = topLevelNode.right;

                        if (
                            (checkIsName(x) || isValue(x)) &&
                            eqExpressions(x, y)
                        ) {
                            return util.makeValueExpression(false);
                        }
                    }
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class DoubleNegation extends Rule {
    public applyRule(
        ast: AstExpression,
        _optimizer: ExpressionTransformer,
    ): AstExpression {
        if (checkIsUnaryOpNode(ast)) {
            const topLevelNode = ast as AstOpUnary;
            if (topLevelNode.op === "!") {
                if (checkIsUnaryOpNode(topLevelNode.operand)) {
                    const innerNode = topLevelNode.operand as AstOpUnary;
                    if (innerNode.op === "!") {
                        // The tree has this form:
                        // !!x

                        const x = innerNode.operand;

                        return x;
                    }
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class NegateTrue extends Rule {
    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsUnaryOpNode(ast)) {
            const topLevelNode = ast as AstOpUnary;
            if (topLevelNode.op === "!") {
                if (checkIsBoolean(topLevelNode.operand, true)) {
                    // The tree has this form
                    // !true

                    return util.makeValueExpression(false);
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class NegateFalse extends Rule {
    public applyRule(
        ast: AstExpression,
        { util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsUnaryOpNode(ast)) {
            const topLevelNode = ast as AstOpUnary;
            if (topLevelNode.op === "!") {
                if (checkIsBoolean(topLevelNode.operand, false)) {
                    // The tree has this form
                    // !false

                    return util.makeValueExpression(true);
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}


## associative.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/optimizer/associative.ts)
// This module includes rules involving associative rewrites of expressions

import {
    AstBinaryOperation,
    AstExpression,
    AstOpBinary,
    AstValue,
    isValue,
} from "../grammar/ast";
import * as interpreterModule from "../interpreter";
import { Value } from "../types/types";
import { ExpressionTransformer, Rule } from "./types";
import {
    abs,
    checkIsBinaryOpNode,
    checkIsBinaryOp_With_RightValue,
    checkIsBinaryOp_With_LeftValue,
    extractValue,
    sign,
    AstUtil,
} from "./util";

type TransformData = {
    simplifiedExpression: AstExpression;
    safetyCondition: boolean;
};

type Transform = (
    x1: AstExpression,
    c1: Value,
    c2: Value,
    util: AstUtil,
) => TransformData;

/* A simple wrapper function to transform the right value in a binary operator to a continuation
   so that we can call the evaluation function in the interpreter module
*/
function evalBinaryOp(op: AstBinaryOperation, valL: Value, valR: Value): Value {
    return interpreterModule.evalBinaryOp(op, valL, () => valR);
}

abstract class AssociativeRewriteRule extends Rule {
    // An entry (op, S) in the map means "operator op associates with all operators in set S",
    // mathematically: all op2 \in S. (a op b) op2 c = a op (b op2 c)
    private associativeOps: Map<AstBinaryOperation, Set<AstBinaryOperation>>;

    // This set contains all operators that commute.
    // Mathematically:
    // all op \in commutativeOps. a op b = b op a
    private commutativeOps: Set<AstBinaryOperation>;

    constructor() {
        super();

        // + associates with these on the right:
        // i.e., all op \in additiveAssoc. (a + b) op c = a + (b op c)
        const additiveAssoc: Set<AstBinaryOperation> = new Set(["+", "-"]);

        // * associates with these on the right:
        const multiplicativeAssoc: Set<AstBinaryOperation> = new Set([
            "*",
            "<<",
        ]);

        // Division / does not associate with any on the right

        // Modulus % does not associate with any on the right

        // TODO: shifts, bitwise integer operators, boolean operators

        this.associativeOps = new Map([
            ["+", additiveAssoc],
            ["*", multiplicativeAssoc],
        ]);

        this.commutativeOps = new Set(
            ["+", "*", "!=", "==", "&&", "||"], // TODO: bitwise integer operators
        );
    }

    public areAssociative(
        op1: AstBinaryOperation,
        op2: AstBinaryOperation,
    ): boolean {
        if (this.associativeOps.has(op1)) {
            const rightOperators = this.associativeOps.get(op1)!;
            return rightOperators.has(op2);
        } else {
            return false;
        }
    }

    public isCommutative(op: AstBinaryOperation): boolean {
        return this.commutativeOps.has(op);
    }
}

abstract class AllowableOpRule extends AssociativeRewriteRule {
    private allowedOps: Set<AstBinaryOperation>;

    constructor() {
        super();

        this.allowedOps = new Set();
        // Recall that integer operators +,-,*,/,% are not safe with this rule, because
        // there is a risk that they will not preserve overflows in the unknown operands.
        //["&&", "||"], // TODO: check bitwise integer operators
    }

    public isAllowedOp(op: AstBinaryOperation): boolean {
        return this.allowedOps.has(op);
    }

    public areAllowedOps(op: AstBinaryOperation[]): boolean {
        return op.reduce(
            (prev, curr) => prev && this.allowedOps.has(curr),
            true,
        );
    }
}

// This rule will be removed in a future refactoring, since
// no operator can use it due to the safety conditions.
// At first I thought that boolean expressions could use them
// but I found out they cannot.
export class AssociativeRule1 extends AllowableOpRule {
    public applyRule(
        ast: AstExpression,
        { applyRules, util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (
                checkIsBinaryOp_With_RightValue(topLevelNode.left) &&
                checkIsBinaryOp_With_RightValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // (x1 op1 c1) op (x2 op2 c2)
                const leftTree = topLevelNode.left as AstOpBinary;
                const rightTree = topLevelNode.right as AstOpBinary;

                const x1 = leftTree.left;
                const c1 = leftTree.right as AstValue;
                const op1 = leftTree.op;

                const x2 = rightTree.left;
                const c2 = rightTree.right as AstValue;
                const op2 = rightTree.op;

                const op = topLevelNode.op;

                // Check that:
                // the operators are allowed
                // op1 and op associate
                // op and op2 associate
                // op commutes
                if (
                    this.areAllowedOps([op1, op, op2]) &&
                    this.areAssociative(op1, op) &&
                    this.areAssociative(op, op2) &&
                    this.isCommutative(op)
                ) {
                    // Agglutinate the constants and compute their final value
                    try {
                        // If an error occurs, we abandon the simplification
                        const val = evalBinaryOp(
                            op2,
                            extractValue(c1),
                            extractValue(c2),
                        );

                        // The final expression is
                        // (x1 op1 x2) op val

                        // Because we are joining x1 and x2,
                        // there is further opportunity of simplification,
                        // So, we ask the evaluator to apply all the rules in the subtree.
                        const newLeft = applyRules(
                            util.makeBinaryExpression(op1, x1, x2),
                        );
                        const newRight = util.makeValueExpression(val);
                        return util.makeBinaryExpression(op, newLeft, newRight);
                    } catch (e) {
                        // Do nothing: will exit rule without modifying tree
                    }
                }
            } else if (
                checkIsBinaryOp_With_RightValue(topLevelNode.left) &&
                checkIsBinaryOp_With_LeftValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // (x1 op1 c1) op (c2 op2 x2)
                const leftTree = topLevelNode.left as AstOpBinary;
                const rightTree = topLevelNode.right as AstOpBinary;

                const x1 = leftTree.left;
                const c1 = leftTree.right as AstValue;
                const op1 = leftTree.op;

                const x2 = rightTree.right;
                const c2 = rightTree.left as AstValue;
                const op2 = rightTree.op;

                const op = topLevelNode.op;

                // Check that:
                // the operators are allowed
                // op1 and op associate
                // op and op2 associate
                if (
                    this.areAllowedOps([op1, op, op2]) &&
                    this.areAssociative(op1, op) &&
                    this.areAssociative(op, op2)
                ) {
                    // Agglutinate the constants and compute their final value
                    try {
                        // If an error occurs, we abandon the simplification
                        const val = evalBinaryOp(
                            op,
                            extractValue(c1),
                            extractValue(c2),
                        );

                        // The current expression could be either
                        // x1 op1 (val op2 x2) or
                        // (x1 op1 val) op2 x2  <--- we choose this form.
                        // Other rules will attempt to extract the constant outside the expression.

                        // Because we are joining x1 and val,
                        // there is further opportunity of simplification,
                        // So, we ask the evaluator to apply all the rules in the subtree.
                        const newValNode = util.makeValueExpression(val);
                        const newLeft = applyRules(
                            util.makeBinaryExpression(op1, x1, newValNode),
                        );
                        return util.makeBinaryExpression(op2, newLeft, x2);
                    } catch (e) {
                        // Do nothing: will exit rule without modifying tree
                    }
                }
            } else if (
                checkIsBinaryOp_With_LeftValue(topLevelNode.left) &&
                checkIsBinaryOp_With_RightValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // (c1 op1 x1) op (x2 op2 c2)
                const leftTree = topLevelNode.left as AstOpBinary;
                const rightTree = topLevelNode.right as AstOpBinary;

                const x1 = leftTree.right;
                const c1 = leftTree.left as AstValue;
                const op1 = leftTree.op;

                const x2 = rightTree.left;
                const c2 = rightTree.right as AstValue;
                const op2 = rightTree.op;

                const op = topLevelNode.op;

                // Check that:
                // the operators are allowed
                // op and op1 associate
                // op2 and op associate
                // op commutes
                if (
                    this.areAllowedOps([op1, op, op2]) &&
                    this.areAssociative(op, op1) &&
                    this.areAssociative(op2, op) &&
                    this.isCommutative(op)
                ) {
                    // Agglutinate the constants and compute their final value
                    try {
                        // If an error occurs, we abandon the simplification
                        const val = evalBinaryOp(
                            op,
                            extractValue(c2),
                            extractValue(c1),
                        );

                        // The current expression could be either
                        // x2 op2 (val op1 x1) or
                        // (x2 op2 val) op1 x1  <--- we choose this form.
                        // Other rules will attempt to extract the constant outside the expression.

                        // Because we are joining x2 and val,
                        // there is further opportunity of simplification,
                        // So, we ask the evaluator to apply all the rules in the subtree.
                        const newValNode = util.makeValueExpression(val);
                        const newLeft = applyRules(
                            util.makeBinaryExpression(op2, x2, newValNode),
                        );
                        return util.makeBinaryExpression(op1, newLeft, x1);
                    } catch (e) {
                        // Do nothing: will exit rule without modifying tree
                    }
                }
            } else if (
                checkIsBinaryOp_With_LeftValue(topLevelNode.left) &&
                checkIsBinaryOp_With_LeftValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // (c1 op1 x1) op (c2 op2 x2)
                const leftTree = topLevelNode.left as AstOpBinary;
                const rightTree = topLevelNode.right as AstOpBinary;

                const x1 = leftTree.right;
                const c1 = leftTree.left as AstValue;
                const op1 = leftTree.op;

                const x2 = rightTree.right;
                const c2 = rightTree.left as AstValue;
                const op2 = rightTree.op;

                const op = topLevelNode.op;

                // Check that:
                // the operators are allowed
                // op1 and op associate
                // op and op2 associate
                // op commutes
                if (
                    this.areAllowedOps([op1, op, op2]) &&
                    this.areAssociative(op1, op) &&
                    this.areAssociative(op, op2) &&
                    this.isCommutative(op)
                ) {
                    // Agglutinate the constants and compute their final value
                    try {
                        // If an error occurs, we abandon the simplification
                        const val = evalBinaryOp(
                            op1,
                            extractValue(c1),
                            extractValue(c2),
                        );

                        // The final expression is
                        // val op (x1 op2 x2)

                        // Because we are joining x1 and x2,
                        // there is further opportunity of simplification,
                        // So, we ask the evaluator to apply all the rules in the subtree.
                        const newRight = applyRules(
                            util.makeBinaryExpression(op2, x1, x2),
                        );
                        const newLeft = util.makeValueExpression(val);
                        return util.makeBinaryExpression(op, newLeft, newRight);
                    } catch (e) {
                        // Do nothing: will exit rule without modifying tree
                    }
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

// This rule will be removed in a future refactoring, since
// no operator can use it due to the safety conditions.
// At first I thought that boolean expressions could use them
// but I found out they cannot.
export class AssociativeRule2 extends AllowableOpRule {
    public applyRule(
        ast: AstExpression,
        { applyRules, util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (
                checkIsBinaryOp_With_RightValue(topLevelNode.left) &&
                !isValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // (x1 op1 c1) op x2
                const leftTree = topLevelNode.left as AstOpBinary;
                const rightTree = topLevelNode.right;

                const x1 = leftTree.left;
                const c1 = leftTree.right as AstValue;
                const op1 = leftTree.op;

                const x2 = rightTree;

                const op = topLevelNode.op;

                // Check that:
                // the operators are allowed
                // op1 and op associate
                // op commutes
                if (
                    this.areAllowedOps([op1, op]) &&
                    this.areAssociative(op1, op) &&
                    this.isCommutative(op)
                ) {
                    // The final expression is
                    // (x1 op1 x2) op c1

                    // Because we are joining x1 and x2,
                    // there is further opportunity of simplification,
                    // So, we ask the evaluator to apply all the rules in the subtree.
                    const newLeft = applyRules(
                        util.makeBinaryExpression(op1, x1, x2),
                    );
                    return util.makeBinaryExpression(op, newLeft, c1);
                }
            } else if (
                checkIsBinaryOp_With_LeftValue(topLevelNode.left) &&
                !isValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // (c1 op1 x1) op x2
                const leftTree = topLevelNode.left as AstOpBinary;
                const rightTree = topLevelNode.right;

                const x1 = leftTree.right;
                const c1 = leftTree.left as AstValue;
                const op1 = leftTree.op;

                const x2 = rightTree;

                const op = topLevelNode.op;

                // Check that:
                // the operators are allowed
                // op1 and op associate
                if (
                    this.areAllowedOps([op1, op]) &&
                    this.areAssociative(op1, op)
                ) {
                    // The final expression is
                    // c1 op1 (x1 op x2)

                    // Because we are joining x1 and x2,
                    // there is further opportunity of simplification,
                    // So, we ask the evaluator to apply all the rules in the subtree.
                    const newRight = applyRules(
                        util.makeBinaryExpression(op, x1, x2),
                    );
                    return util.makeBinaryExpression(op1, c1, newRight);
                }
            } else if (
                !isValue(topLevelNode.left) &&
                checkIsBinaryOp_With_RightValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // x2 op (x1 op1 c1)
                const leftTree = topLevelNode.left;
                const rightTree = topLevelNode.right as AstOpBinary;

                const x1 = rightTree.left;
                const c1 = rightTree.right as AstValue;
                const op1 = rightTree.op;

                const x2 = leftTree;

                const op = topLevelNode.op;

                // Check that:
                // the operators are allowed
                // op and op1 associate
                if (
                    this.areAllowedOps([op, op1]) &&
                    this.areAssociative(op, op1)
                ) {
                    // The final expression is
                    // (x2 op x1) op1 c1

                    // Because we are joining x1 and x2,
                    // there is further opportunity of simplification,
                    // So, we ask the evaluator to apply all the rules in the subtree.
                    const newLeft = applyRules(
                        util.makeBinaryExpression(op, x2, x1),
                    );
                    return util.makeBinaryExpression(op1, newLeft, c1);
                }
            } else if (
                !isValue(topLevelNode.left) &&
                checkIsBinaryOp_With_LeftValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // x2 op (c1 op1 x1)
                const leftTree = topLevelNode.left;
                const rightTree = topLevelNode.right as AstOpBinary;

                const x1 = rightTree.right;
                const c1 = rightTree.left as AstValue;
                const op1 = rightTree.op;

                const x2 = leftTree;

                const op = topLevelNode.op;

                // Check that:
                // the operators are allowed
                // op and op1 associate
                // op is commutative
                if (
                    this.areAllowedOps([op, op1]) &&
                    this.areAssociative(op, op1) &&
                    this.isCommutative(op)
                ) {
                    // The final expression is
                    // c1 op (x2 op1 x1)

                    // Because we are joining x1 and x2,
                    // there is further opportunity of simplification,
                    // So, we ask the evaluator to apply all the rules in the subtree.
                    const newRight = applyRules(
                        util.makeBinaryExpression(op1, x2, x1),
                    );
                    return util.makeBinaryExpression(op, c1, newRight);
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}

export class AssociativeRule3 extends Rule {
    private leftAssocTransforms: Map<
        AstBinaryOperation,
        Map<AstBinaryOperation, Transform>
    >;
    private rightAssocTransforms: Map<
        AstBinaryOperation,
        Map<AstBinaryOperation, Transform>
    >;
    private rightCommuteTransforms: Map<
        AstBinaryOperation,
        Map<AstBinaryOperation, Transform>
    >;
    private leftCommuteTransforms: Map<
        AstBinaryOperation,
        Map<AstBinaryOperation, Transform>
    >;

    // Safety conditions that repeat a lot.

    // Safety condition:
    // c1 < center ==> val_ - c1 <= 0
    // c1 > center ==> val_ - c1 >= 0
    private standardAdditiveCondition(
        c1: bigint,
        val_: bigint,
        center: bigint,
    ): boolean {
        if (c1 === center) {
            return true;
        } else if (c1 < center) {
            return val_ - c1 <= 0n;
        } else {
            return val_ - c1 >= 0n;
        }
    }

    // Safety condition:
    // c1 < 0 ==> val_ - c1 <= -1
    // c1 > 0 ==> val_ - c1 >= -1
    private shiftedAdditiveCondition(c1: bigint, val_: bigint): boolean {
        if (c1 === 0n) {
            return true;
        } else if (c1 < 0n) {
            return val_ - c1 <= -1n;
        } else {
            return val_ - c1 >= -1n;
        }
    }

    // Safety condition:
    // c1 < center ==> val_ + c1 >= -1
    // c1 > center ==> val_ + c1 <= -1
    private oppositeAdditiveCondition(
        c1: bigint,
        val_: bigint,
        center: bigint,
    ): boolean {
        if (c1 === center) {
            return true;
        } else if (c1 < center) {
            return val_ + c1 >= -1n;
        } else {
            return val_ + c1 <= -1n;
        }
    }

    // Safety condition:
    // c1 != 0 && sign(c1) == sign(val_) ==> abs(c1) <= abs(val_)
    // c1 != 0 && sign(c1) != sign(val_) ==> abs(c1) < abs(val_)
    // c1 != 0 ==> val_ != 0
    private standardMultiplicativeCondition(c1: bigint, val_: bigint): boolean {
        if (c1 === 0n) {
            return true;
        }
        // At this point, c1 != 0
        // hence, val_ must be non-zero as
        // required by the safety condition
        if (val_ === 0n) {
            return false;
        }
        // At this point, both c1 and val_ are non-zero
        if (sign(c1) === sign(val_)) {
            return abs(c1) <= abs(val_);
        } else {
            return abs(c1) < abs(val_);
        }
    }

    public constructor() {
        super();

        // First, we consider expressions of the form: (x1 op1 c1) op c2.

        // The following maps correspond to the transformation: x1 op1_ (c1_ op_ c2_)
        // for each pair of operators op1, op.
        // Here, we will denote c1_ op_ c2_ as val_.

        // op1 = +

        const plusLeftAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "+",
                    // original expression: (x1 + c1) + c2
                    (x1, c1, c2, util) => {
                        // final expression: x1 + (c1 + c2)
                        const val_ = evalBinaryOp("+", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "+",
                                x1,
                                val_node,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],

                [
                    "-",
                    // original expression: (x1 + c1) - c2
                    (x1, c1, c2, util) => {
                        // final expression: x1 + (c1 - c2)
                        const val_ = evalBinaryOp("-", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "+",
                                x1,
                                val_node,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],
            ]);

        // op1 = -

        const minusLeftAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "+",
                    // original expression: (x1 - c1) + c2
                    (x1, c1, c2, util) => {
                        // final expression x1 - (c1 - c2)
                        const val_ = evalBinaryOp("-", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                x1,
                                val_node,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],

                [
                    "-",
                    // original expression: (x1 - c1) - c2
                    (x1, c1, c2, util) => {
                        // final expression x1 - (c1 + c2)
                        const val_ = evalBinaryOp("+", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                x1,
                                val_node,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],
            ]);

        // op1 = *

        const multiplyLeftAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "*",
                    // original expression: (x1 * c1) * c2
                    (x1, c1, c2, util) => {
                        // final expression x1 * (c1 * c2)
                        const val_ = evalBinaryOp("*", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "*",
                                x1,
                                val_node,
                            ),
                            safetyCondition:
                                this.standardMultiplicativeCondition(
                                    c1 as bigint,
                                    val_ as bigint,
                                ),
                        };
                    },
                ],
            ]);

        // op1 = &&

        const andLeftAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "&&",
                    // original expression: (x1 && c1) && c2
                    (x1, c1, c2, util) => {
                        // final expression x1 && (c1 && c2)
                        const val_ = evalBinaryOp("&&", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "&&",
                                x1,
                                val_node,
                            ),
                            safetyCondition: true,
                        };
                    },
                ],
            ]);

        // op1 = ||

        const orLeftAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "||",
                    // original expression: (x1 || c1) || c2
                    (x1, c1, c2, util) => {
                        // final expression x1 || (c1 || c2)
                        const val_ = evalBinaryOp("||", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "||",
                                x1,
                                val_node,
                            ),
                            safetyCondition: true,
                        };
                    },
                ],
            ]);

        this.leftAssocTransforms = new Map([
            ["+", plusLeftAssocOperators],
            ["-", minusLeftAssocOperators],
            ["*", multiplyLeftAssocOperators],
            ["&&", andLeftAssocOperators],
            ["||", orLeftAssocOperators],
        ]);

        // Now consider expressions of the form: c2 op (c1 op1 x1).

        // The following maps correspond to the transformation: (c2_ op_ c1_) op1_ x1
        // for each pair of operators op1, op.
        // Here, we will denote c2_ op_ c1_ as val_.

        // op = +

        const plusRightAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "+",
                    // original expression: c2 + (c1 + x1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 + c1) + x1
                        const val_ = evalBinaryOp("+", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "+",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],

                [
                    "-",
                    // original expression: c2 + (c1 - x1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 + c1) - x1
                        const val_ = evalBinaryOp("+", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                -1n,
                            ),
                        };
                    },
                ],
            ]);

        // op = -

        const minusRightAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "+",
                    // original expression: c2 - (c1 + x1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 - c1) - x1
                        const val_ = evalBinaryOp("-", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.oppositeAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],

                [
                    "-",
                    // original expression: c2 - (c1 - x1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 - c1) + x1
                        const val_ = evalBinaryOp("-", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "+",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.oppositeAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                -1n,
                            ),
                        };
                    },
                ],
            ]);

        // op = *

        const multiplyRightAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "*",

                    // original expression: c2 * (c1 * x1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 * c1) * x1
                        const val_ = evalBinaryOp("*", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "*",
                                val_node,
                                x1,
                            ),
                            safetyCondition:
                                this.standardMultiplicativeCondition(
                                    c1 as bigint,
                                    val_ as bigint,
                                ),
                        };
                    },
                ],
            ]);

        // op = &&

        const andRightAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "&&",

                    // original expression: c2 && (c1 && x1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 && c1) && x1
                        const val_ = evalBinaryOp("&&", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "&&",
                                val_node,
                                x1,
                            ),
                            safetyCondition: true,
                        };
                    },
                ],
            ]);

        // op = ||

        const orRightAssocOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "||",

                    // original expression: c2 || (c1 || x1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 || c1) || x1
                        const val_ = evalBinaryOp("||", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "||",
                                val_node,
                                x1,
                            ),
                            safetyCondition: true,
                        };
                    },
                ],
            ]);

        this.rightAssocTransforms = new Map([
            ["+", plusRightAssocOperators],
            ["-", minusRightAssocOperators],
            ["*", multiplyRightAssocOperators],
            ["&&", andRightAssocOperators],
            ["||", orRightAssocOperators],
        ]);

        // Now consider expressions of the form: c2 op (x1 op1 c1).

        // The following maps correspond to the transformation: x1 op1_ (c2_ op_ c1_)_
        // for each pair of operators op1, op.
        // Here, we will denote c2_ op_ c1_ as val_.

        // op = +

        const plusRightCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "+",
                    // original expression: c2 + (x1 + c1)
                    (x1, c1, c2, util) => {
                        // final expression x1 + (c2 + c1)
                        const val_ = evalBinaryOp("+", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "+",
                                x1,
                                val_node,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],

                [
                    "-",
                    // original expression: c2 + (x1 - c1)
                    (x1, c1, c2, util) => {
                        // final expression x1 - (c1 - c2)
                        const val_ = evalBinaryOp("-", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                x1,
                                val_node,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],
            ]);

        // op = -

        const minusRightCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "+",
                    // original expression: c2 - (x1 + c1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 - c1) - x1
                        const val_ = evalBinaryOp("-", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.oppositeAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],

                [
                    "-",
                    // original expression: c2 - (x1 - c1)
                    (x1, c1, c2, util) => {
                        // final expression (c2 + c1) - x1
                        const val_ = evalBinaryOp("+", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.shiftedAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                            ),
                        };
                    },
                ],
            ]);

        // op = *

        const multiplyRightCommuteOperators: Map<
            AstBinaryOperation,
            Transform
        > = new Map([
            [
                "*",
                // original expression: c2 * (x1 * c1)
                (x1, c1, c2, util) => {
                    // Final expression x1 * (c2 * c1)
                    const val_ = evalBinaryOp("*", c2, c1);
                    const val_node = util.makeValueExpression(val_);
                    return {
                        simplifiedExpression: util.makeBinaryExpression(
                            "*",
                            x1,
                            val_node,
                        ),
                        safetyCondition: this.standardMultiplicativeCondition(
                            c1 as bigint,
                            val_ as bigint,
                        ),
                    };
                },
            ],
        ]);

        // op = &&

        const andRightCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "&&",
                    // original expression: c2 && (x1 && c1)
                    (x1, c1, c2, util) => {
                        const val_ = evalBinaryOp("&&", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        let final_expr;
                        if (c2 === true) {
                            // Final expression x1 && (c2 && c1)
                            final_expr = util.makeBinaryExpression(
                                "&&",
                                x1,
                                val_node,
                            );
                        } else {
                            // Final expression (c2 && c1) && x1

                            // Note that by the safety condition,
                            // at this point c1 = true.
                            final_expr = util.makeBinaryExpression(
                                "&&",
                                val_node,
                                x1,
                            );
                        }
                        return {
                            simplifiedExpression: final_expr,
                            safetyCondition: c1 === true || c2 === true,
                        };
                    },
                ],
            ]);

        // op = ||

        const orRightCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "||",
                    // original expression: c2 || (x1 || c1)
                    (x1, c1, c2, util) => {
                        const val_ = evalBinaryOp("||", c2, c1);
                        const val_node = util.makeValueExpression(val_);
                        let final_expr;
                        if (c2 === false) {
                            // Final expression x1 || (c2 || c1)
                            final_expr = util.makeBinaryExpression(
                                "||",
                                x1,
                                val_node,
                            );
                        } else {
                            // Final expression (c2 || c1) || x1

                            // Note that by the safety condition,
                            // at this point c1 = false.
                            final_expr = util.makeBinaryExpression(
                                "||",
                                val_node,
                                x1,
                            );
                        }
                        return {
                            simplifiedExpression: final_expr,
                            safetyCondition: c1 === false || c2 === false,
                        };
                    },
                ],
            ]);

        this.rightCommuteTransforms = new Map([
            ["+", plusRightCommuteOperators],
            ["-", minusRightCommuteOperators],
            ["*", multiplyRightCommuteOperators],
            ["&&", andRightCommuteOperators],
            ["||", orRightCommuteOperators],
        ]);

        // Now consider expressions of the form: (c1 op1 x1) op c2.

        // The following maps correspond to the transformation: x1 op1_ (c1_ op_ c2_)
        // for each pair of operators op1, op.

        // op1 = +

        const plusLeftCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "+",
                    // original expression: (c1 + x1) + c2
                    (x1, c1, c2, util) => {
                        // Final expression (c1 + c2) + x1
                        const val_ = evalBinaryOp("+", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "+",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],

                [
                    "-",
                    // original expression: (c1 + x1) - c2
                    (x1, c1, c2, util) => {
                        // Final expression (c1 - c2) + x1
                        const val_ = evalBinaryOp("-", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "+",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                0n,
                            ),
                        };
                    },
                ],
            ]);

        // op1 = -

        const minusLeftCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "+",
                    // original expression: (c1 - x1) + c2
                    (x1, c1, c2, util) => {
                        // Final expression (c1 + c2) - x1
                        const val_ = evalBinaryOp("+", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                -1n,
                            ),
                        };
                    },
                ],

                [
                    "-",
                    // original expression: (c1 - x1) - c2
                    (x1, c1, c2, util) => {
                        // Final expression (c1 - c2) - x1
                        const val_ = evalBinaryOp("-", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "-",
                                val_node,
                                x1,
                            ),
                            safetyCondition: this.standardAdditiveCondition(
                                c1 as bigint,
                                val_ as bigint,
                                -1n,
                            ),
                        };
                    },
                ],
            ]);

        // op1 = *

        const multiplyLeftCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "*",
                    // original expression: (c1 * x1) * c2
                    (x1, c1, c2, util) => {
                        // Final expression (c1 * c2) * x1
                        const val_ = evalBinaryOp("*", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        return {
                            simplifiedExpression: util.makeBinaryExpression(
                                "*",
                                val_node,
                                x1,
                            ),
                            safetyCondition:
                                this.standardMultiplicativeCondition(
                                    c1 as bigint,
                                    val_ as bigint,
                                ),
                        };
                    },
                ],
            ]);

        // op1 = &&

        const andLeftCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "&&",
                    // original expression: (c1 && x1) && c2
                    (x1, c1, c2, util) => {
                        const val_ = evalBinaryOp("&&", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        let final_expr;
                        if (c2 === true) {
                            // Final expression (c1 && c2) && x1
                            final_expr = util.makeBinaryExpression(
                                "&&",
                                val_node,
                                x1,
                            );
                        } else {
                            // Final expression x1 && (c1 && c2)

                            // Note that by the safety condition,
                            // at this point c1 = true.
                            final_expr = util.makeBinaryExpression(
                                "&&",
                                x1,
                                val_node,
                            );
                        }
                        return {
                            simplifiedExpression: final_expr,
                            safetyCondition: c1 === true || c2 === true,
                        };
                    },
                ],
            ]);

        // op1 = ||

        const orLeftCommuteOperators: Map<AstBinaryOperation, Transform> =
            new Map([
                [
                    "||",
                    // original expression: (c1 || x1) || c2
                    (x1, c1, c2, util) => {
                        const val_ = evalBinaryOp("||", c1, c2);
                        const val_node = util.makeValueExpression(val_);
                        let final_expr;
                        if (c2 === false) {
                            // Final expression (c1 || c2) || x1
                            final_expr = util.makeBinaryExpression(
                                "||",
                                val_node,
                                x1,
                            );
                        } else {
                            // Final expression x1 || (c1 || c2)

                            // Note that by the safety condition,
                            // at this point c1 = false.
                            final_expr = util.makeBinaryExpression(
                                "||",
                                x1,
                                val_node,
                            );
                        }
                        return {
                            simplifiedExpression: final_expr,
                            safetyCondition: c1 === false || c2 === false,
                        };
                    },
                ],
            ]);

        this.leftCommuteTransforms = new Map([
            ["+", plusLeftCommuteOperators],
            ["-", minusLeftCommuteOperators],
            ["*", multiplyLeftCommuteOperators],
            ["&&", andLeftCommuteOperators],
            ["||", orLeftCommuteOperators],
        ]);
    }

    private lookupTransform(
        keyOp1: AstBinaryOperation,
        keyOp2: AstBinaryOperation,
        transforms: Map<AstBinaryOperation, Map<AstBinaryOperation, Transform>>,
    ): Transform | undefined {
        if (transforms.has(keyOp1)) {
            const intermediateMap = transforms.get(keyOp1)!;
            if (intermediateMap.has(keyOp2)) {
                return intermediateMap.get(keyOp2)!;
            }
        }
        return undefined;
    }

    protected getLeftAssociativityTransform(
        keyOp1: AstBinaryOperation,
        keyOp2: AstBinaryOperation,
    ): Transform | undefined {
        return this.lookupTransform(keyOp1, keyOp2, this.leftAssocTransforms);
    }

    protected getRightAssociativityTransform(
        keyOp1: AstBinaryOperation,
        keyOp2: AstBinaryOperation,
    ): Transform | undefined {
        return this.lookupTransform(keyOp1, keyOp2, this.rightAssocTransforms);
    }

    protected getLeftCommutativityTransform(
        keyOp1: AstBinaryOperation,
        keyOp2: AstBinaryOperation,
    ): Transform | undefined {
        return this.lookupTransform(keyOp1, keyOp2, this.leftCommuteTransforms);
    }

    protected getRightCommutativityTransform(
        keyOp1: AstBinaryOperation,
        keyOp2: AstBinaryOperation,
    ): Transform | undefined {
        return this.lookupTransform(
            keyOp1,
            keyOp2,
            this.rightCommuteTransforms,
        );
    }

    public applyRule(
        ast: AstExpression,
        { applyRules, util }: ExpressionTransformer,
    ): AstExpression {
        if (checkIsBinaryOpNode(ast)) {
            const topLevelNode = ast as AstOpBinary;
            if (
                checkIsBinaryOp_With_RightValue(topLevelNode.left) &&
                isValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // (x1 op1 c1) op c2

                const leftTree = topLevelNode.left as AstOpBinary;
                const rightTree = topLevelNode.right as AstValue;

                const x1 = leftTree.left;
                const c1 = extractValue(leftTree.right as AstValue);
                const op1 = leftTree.op;

                const c2 = extractValue(rightTree);

                const op = topLevelNode.op;

                try {
                    const data = this.getLeftAssociativityTransform(op1, op)!(
                        x1,
                        c1,
                        c2,
                        util,
                    );
                    if (data.safetyCondition) {
                        // Since the tree is simpler now, there is further
                        // opportunity for simplification that was missed
                        // previously
                        return applyRules(data.simplifiedExpression);
                    }
                } catch (e) {
                    // Do nothing: will exit rule without modifying tree
                }
            } else if (
                checkIsBinaryOp_With_LeftValue(topLevelNode.left) &&
                isValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // (c1 op1 x1) op c2

                const leftTree = topLevelNode.left as AstOpBinary;
                const rightTree = topLevelNode.right as AstValue;

                const x1 = leftTree.right;
                const c1 = extractValue(leftTree.left as AstValue);
                const op1 = leftTree.op;

                const c2 = extractValue(rightTree);

                const op = topLevelNode.op;

                try {
                    const data = this.getLeftCommutativityTransform(op1, op)!(
                        x1,
                        c1,
                        c2,
                        util,
                    );
                    if (data.safetyCondition) {
                        // Since the tree is simpler now, there is further
                        // opportunity for simplification that was missed
                        // previously
                        return applyRules(data.simplifiedExpression);
                    }
                } catch (e) {
                    // Do nothing: will exit rule without modifying tree
                }
            } else if (
                isValue(topLevelNode.left) &&
                checkIsBinaryOp_With_RightValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // c2 op (x1 op1 c1)

                const leftTree = topLevelNode.left as AstValue;
                const rightTree = topLevelNode.right as AstOpBinary;

                const x1 = rightTree.left;
                const c1 = extractValue(rightTree.right as AstValue);
                const op1 = rightTree.op;

                const c2 = extractValue(leftTree);

                const op = topLevelNode.op;

                try {
                    const data = this.getRightCommutativityTransform(op, op1)!(
                        x1,
                        c1,
                        c2,
                        util,
                    );
                    if (data.safetyCondition) {
                        // Since the tree is simpler now, there is further
                        // opportunity for simplification that was missed
                        // previously
                        return applyRules(data.simplifiedExpression);
                    }
                } catch (e) {
                    // Do nothing: will exit rule without modifying tree
                }
            } else if (
                isValue(topLevelNode.left) &&
                checkIsBinaryOp_With_LeftValue(topLevelNode.right)
            ) {
                // The tree has this form:
                // c2 op (c1 op1 x1)

                const leftTree = topLevelNode.left as AstValue;
                const rightTree = topLevelNode.right as AstOpBinary;

                const x1 = rightTree.right;
                const c1 = extractValue(rightTree.left as AstValue);
                const op1 = rightTree.op;

                const c2 = extractValue(leftTree);

                const op = topLevelNode.op;

                try {
                    const data = this.getRightAssociativityTransform(op, op1)!(
                        x1,
                        c1,
                        c2,
                        util,
                    );
                    if (data.safetyCondition) {
                        // Since the tree is simpler now, there is further
                        // opportunity for simplification that was missed
                        // previously
                        return applyRules(data.simplifiedExpression);
                    }
                } catch (e) {
                    // Do nothing: will exit rule without modifying tree
                }
            }
        }

        // If execution reaches here, it means that the rule could not be applied fully
        // so, we return the original tree
        return ast;
    }
}


## standardOptimizer.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/optimizer/standardOptimizer.ts)
import { AstExpression } from "../grammar/ast";
import {
    AddSelf,
    AddZero,
    AndFalse,
    AndSelf,
    AndTrue,
    Contradiction,
    DoubleNegation,
    ExcludedMiddle,
    MultiplyOne,
    MultiplyZero,
    NegateFalse,
    NegateTrue,
    OrFalse,
    OrSelf,
    OrTrue,
    SubtractSelf,
} from "./algebraic";
import {
    AssociativeRule1,
    AssociativeRule2,
    AssociativeRule3,
} from "./associative";
import { Rule, ExpressionTransformer } from "./types";
import { AstUtil } from "./util";

type PrioritizedRule = { priority: number; rule: Rule };

// This optimizer uses rules that preserve overflows in integer expressions.
export class StandardOptimizer implements ExpressionTransformer {
    private rules: PrioritizedRule[];

    constructor(public util: AstUtil) {
        this.rules = [
            { priority: 0, rule: new AssociativeRule1() },
            { priority: 1, rule: new AssociativeRule2() },
            { priority: 2, rule: new AssociativeRule3() },
            { priority: 3, rule: new AddZero() },
            { priority: 4, rule: new MultiplyZero() },
            { priority: 5, rule: new MultiplyOne() },
            { priority: 6, rule: new SubtractSelf() },
            { priority: 7, rule: new AddSelf() },
            { priority: 8, rule: new OrTrue() },
            { priority: 9, rule: new AndFalse() },
            { priority: 10, rule: new OrFalse() },
            { priority: 11, rule: new AndTrue() },
            { priority: 12, rule: new OrSelf() },
            { priority: 13, rule: new AndSelf() },
            { priority: 14, rule: new ExcludedMiddle() },
            { priority: 15, rule: new Contradiction() },
            { priority: 16, rule: new DoubleNegation() },
            { priority: 17, rule: new NegateTrue() },
            { priority: 18, rule: new NegateFalse() },
        ];

        // Sort according to the priorities: smaller number means greater priority.
        // So, the rules will be sorted increasingly according to their priority number.
        this.rules.sort((r1, r2) => r1.priority - r2.priority);
    }

    public applyRules = (ast: AstExpression): AstExpression => {
        return this.rules.reduce(
            (prev, prioritizedRule) =>
                prioritizedRule.rule.applyRule(prev, this),
            ast,
        );
    };
}


## types.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/optimizer/types.ts)
import { AstExpression } from "../grammar/ast";
import { AstUtil } from "./util";

export interface ExpressionTransformer {
    util: AstUtil;
    applyRules(ast: AstExpression): AstExpression;
}

export abstract class Rule {
    public abstract applyRule(
        ast: AstExpression,
        optimizer: ExpressionTransformer,
    ): AstExpression;
}


## util.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/optimizer/util.ts)
import {
    AstExpression,
    AstUnaryOperation,
    AstBinaryOperation,
    AstValue,
    isValue,
    FactoryAst,
} from "../grammar/ast";
import { dummySrcInfo } from "../grammar";
import { throwInternalCompilerError } from "../errors";
import { Value } from "../types/types";

export function extractValue(ast: AstValue): Value {
    switch (
        ast.kind // Missing structs
    ) {
        case "null":
            return null;
        case "boolean":
            return ast.value;
        case "number":
            return ast.value;
        case "string":
            return ast.value;
    }
}

export const getAstUtil = ({ createNode }: FactoryAst) => {
    function makeValueExpression(value: Value): AstValue {
        if (value === null) {
            const result = createNode({
                kind: "null",
                loc: dummySrcInfo,
            });
            return result as AstValue;
        }
        if (typeof value === "string") {
            const result = createNode({
                kind: "string",
                value: value,
                loc: dummySrcInfo,
            });
            return result as AstValue;
        }
        if (typeof value === "bigint") {
            const result = createNode({
                kind: "number",
                base: 10,
                value: value,
                loc: dummySrcInfo,
            });
            return result as AstValue;
        }
        if (typeof value === "boolean") {
            const result = createNode({
                kind: "boolean",
                value: value,
                loc: dummySrcInfo,
            });
            return result as AstValue;
        }
        throwInternalCompilerError(
            `structs, addresses, cells, and comment values are not supported at the moment.`,
        );
    }

    function makeUnaryExpression(
        op: AstUnaryOperation,
        operand: AstExpression,
    ): AstExpression {
        const result = createNode({
            kind: "op_unary",
            op: op,
            operand: operand,
            loc: dummySrcInfo,
        });
        return result as AstExpression;
    }

    function makeBinaryExpression(
        op: AstBinaryOperation,
        left: AstExpression,
        right: AstExpression,
    ): AstExpression {
        const result = createNode({
            kind: "op_binary",
            op: op,
            left: left,
            right: right,
            loc: dummySrcInfo,
        });
        return result as AstExpression;
    }

    return {
        makeValueExpression,
        makeUnaryExpression,
        makeBinaryExpression,
    };
};

export type AstUtil = ReturnType<typeof getAstUtil>;

// Checks if the top level node is an unary op node
export function checkIsUnaryOpNode(ast: AstExpression): boolean {
    return ast.kind === "op_unary";
}

// Checks if the top level node is a binary op node
export function checkIsBinaryOpNode(ast: AstExpression): boolean {
    return ast.kind === "op_binary";
}

// Checks if top level node is a binary op node
// with a value node on the right
export function checkIsBinaryOp_With_RightValue(ast: AstExpression): boolean {
    return ast.kind === "op_binary" ? isValue(ast.right) : false;
}

// Checks if top level node is a binary op node
// with a value node on the left
export function checkIsBinaryOp_With_LeftValue(ast: AstExpression): boolean {
    return ast.kind === "op_binary" ? isValue(ast.left) : false;
}

// Checks if the top level node is the specified number
export function checkIsNumber(ast: AstExpression, n: bigint): boolean {
    return ast.kind === "number" ? ast.value == n : false;
}

export function checkIsName(ast: AstExpression): boolean {
    return ast.kind === "id";
}

// Checks if the top level node is the specified boolean
export function checkIsBoolean(ast: AstExpression, b: boolean): boolean {
    return ast.kind === "boolean" ? ast.value == b : false;
}

// bigint arithmetic

// precondition: the divisor is not zero
// rounds the division result towards negative infinity
export function divFloor(a: bigint, b: bigint): bigint {
    const almostSameSign = a > 0n === b > 0n;
    if (almostSameSign) {
        return a / b;
    }
    return a / b + (a % b === 0n ? 0n : -1n);
}

export function abs(a: bigint): bigint {
    return a < 0n ? -a : a;
}

export function sign(a: bigint): bigint {
    if (a === 0n) return 0n;
    else return a < 0n ? -1n : 1n;
}

// precondition: the divisor is not zero
// rounds the result towards negative infinity
// Uses the fact that a / b * b + a % b == a, for all b != 0.
export function modFloor(a: bigint, b: bigint): bigint {
    return a - divFloor(a, b) * b;
}


## partial-eval.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/optimizer/test/partial-eval.spec.ts)
import {
    AstExpression,
    FactoryAst,
    AstValue,
    eqExpressions,
    getAstFactory,
    isValue,
} from "../../grammar/ast";
import { AstUtil, extractValue, getAstUtil } from "../util";
import { getOptimizer } from "../../constEval";
import { CompilerContext } from "../../context";
import { ExpressionTransformer, Rule } from "../types";
import { AssociativeRule3 } from "../associative";
import { evalBinaryOp, evalUnaryOp } from "../../interpreter";
import { getParser } from "../../grammar";

const MAX: string =
    "115792089237316195423570985008687907853269984665640564039457584007913129639935";
const MIN: string = `(-${MAX} - 1)`;

const additiveExpressions = [
    { original: "X + 3 + 1", simplified: "X + 4" },
    { original: "3 + X + 1", simplified: "4 + X" },
    { original: "1 + (X + 3)", simplified: "X + 4" },
    { original: "1 + (3 + X)", simplified: "4 + X" },

    // Should NOT simplify to X + 2, because X could be MAX - 2,
    // so that X + 3 causes an overflow, but X + 2 does not overflow
    { original: "X + 3 - 1", simplified: "X + 3 - 1" },
    { original: "3 + X - 1", simplified: "3 + X - 1" },

    // Should NOT simplify to X - 2, because X could be MIN + 2
    { original: "1 + (X - 3)", simplified: "1 + (X - 3)" },

    { original: "1 + (3 - X)", simplified: "4 - X" },

    { original: "X + 3 - (-1)", simplified: "X + 4" },
    { original: "3 + X - (-1)", simplified: "4 + X" },
    { original: "-1 + (X - 3)", simplified: "X - 4" },

    // Should NOT simplify to 2 - X, because X could be MIN + 3,
    // so that 3 - X = -MIN = MAX + 1 causes an overflow,
    // but 2 - X = -MIN - 1 = MAX does not
    { original: "-1 + (3 - X)", simplified: "-1 + (3 - X)" },

    // Should NOT simplify to (-2) - X because X could be MAX - 2
    // so that X + 3 causes an overflow, but
    // (-2) - X = MIN + 1 does not.
    { original: "1 - (X + 3)", simplified: "1 - (X + 3)" },

    // Should NOT simplify to (-2) - X because X could be MAX - 2
    // so that 3 + X causes an overflow, but
    // (-2) - X = MIN + 1 does not.
    { original: "1 - (3 + X)", simplified: "1 - (3 + X)" },

    { original: "1 - (X - 3)", simplified: "4 - X" },

    // Should NOT simplify to -2 + X because X could be MIN + 3
    // so that 3 - X causes an overflow, but
    // (-2) + X = MIN + 1 does not.
    { original: "1 - (3 - X)", simplified: "1 - (3 - X)" },

    // This should NOT simplify to X - 2 because X could be
    // MIN + 3, so that 3 - X = MAX + 1 overflows but
    // X - 2 = MIN + 1 does not.
    { original: "1 - (3 - X)", simplified: "1 - (3 - X)" },

    { original: "1 - X + 3", simplified: "4 - X" },
    { original: "X - 1 - 3", simplified: "X - 4" },
    { original: "X - 1 + (-3)", simplified: "X - 4" },
    { original: "1 - X - (-3)", simplified: "4 - X" },

    // Should NOT simplify to X + 2 or X - (-2), because
    // X could be MIN so that X - 1 causes an overflow,
    // but X + 2 or X - (-2) does not.
    { original: "X - 1 + 3", simplified: "X - 1 + 3" },

    // Should NOT simplify to (-2) - X, because
    // X could be MIN so that 1 - X causes an overflow,
    // but (-2) - X = MAX - 1 does not.
    { original: "1 - X - 3", simplified: "1 - X - 3" },

    // The following four should NOT simplify to X + (MAX + 1)
    // because it would introduce an overflow.
    // For example, X could be
    // -MAX, so that (X + MAX) + 1 = 0 + 1 = 1 does not overflow
    // but X + (${MAX} + 1) = -MAX + (overflow).
    { original: `X + ${MAX} + 1`, simplified: `X + ${MAX} + 1` },
    { original: `${MAX} + X + 1`, simplified: `${MAX} + X + 1` },
    { original: `1 + (X + ${MAX})`, simplified: `1 + (X + ${MAX})` },
    { original: `1 + (${MAX} + X)`, simplified: `1 + (${MAX} + X)` },

    // The following two should NOT simplify to X + (MIN - 1)
    // because it would introduce an overflow.
    // For example, X could be MAX, so that
    // X + MIN - 1 = MAX - MIN - 1 = -2 (does not overflow),
    // but MIN - 1 always overflows.
    { original: `X + ${MIN} - 1`, simplified: `X + ${MIN} - 1` },
    { original: `${MIN} + X - 1`, simplified: `${MIN} + X - 1` },

    // The following two should NOT simplify to (1 - MIN) - X
    // because it would introduce an overflow.
    // For example, X could be MAX, so that
    // 1 - (X + MIN) = 1 - (-1) = 2 (does not overflow),
    // but 1 - MIN always overflows.
    { original: `1 - (X + ${MIN})`, simplified: `1 - (X + ${MIN})` },
    { original: `1 - (${MIN} + X)`, simplified: `1 - (${MIN} + X)` },

    { original: "X + 0", simplified: "X" },
    { original: "0 + X", simplified: "X" },
    { original: "X - 0", simplified: "X" },
    { original: "0 - X", simplified: "-X" },

    { original: "X - X", simplified: "0" },
    { original: "(X - X) - 10", simplified: "-10" },

    { original: "X + X", simplified: "X * 2" },
    { original: "1 * (X + X)", simplified: "X * 2" },
    { original: "2 * (X + X)", simplified: "X * 4" },
    { original: "(X + X) * 2", simplified: "X * 4" },
];

const multiplicativeExpressions = [
    { original: "X * 3 * 2", simplified: "X * 6" },
    { original: "3 * X * 2", simplified: "6 * X" },
    { original: "2 * (X * 3)", simplified: "X * 6" },
    { original: "2 * (3 * X)", simplified: "6 * X" },

    { original: "X * -3 * -2", simplified: "X * 6" },
    { original: "-3 * X * -2", simplified: "6 * X" },
    { original: "-2 * (X * -3)", simplified: "X * 6" },
    { original: "-2 * (-3 * X)", simplified: "6 * X" },

    // The following 4 cases should NOT simplify to X * 0.
    // the reason is that X could be MAX, so that X*3 causes
    // an overflow, but X*0 does not.
    { original: "X * 3 * 0", simplified: "X * 3 * 0" },
    { original: "3 * X * 0", simplified: "3 * X * 0" },
    { original: "0 * (X * 3)", simplified: "0 * (X * 3)" },
    { original: "0 * (3 * X)", simplified: "0 * (3 * X)" },

    { original: "X * 0 * 3", simplified: "0" },
    { original: "0 * X * 3", simplified: "0" },
    { original: "3 * (X * 0)", simplified: "0" },
    { original: "3 * (0 * X)", simplified: "0" },

    { original: "X * 1 * 1", simplified: "X" },
    { original: "1 * X * 1", simplified: "X" },
    { original: "1 * (X * 1)", simplified: "X" },
    { original: "1 * (1 * X)", simplified: "X" },

    // This expression cannot be further simplified to X,
    // because X could be MIN, so that X * -1 causes an overflow
    { original: "X * -1 * 1 * -1", simplified: "X * -1 * -1" },

    // This expression could be further simplified to X * -1
    // but, currently, there are no rules that reduce three multiplied -1
    // to a single -1. This should be fixed in the future.
    { original: "X * -1 * 1 * -1 * -1", simplified: "X * -1 * -1 * -1" },

    // Even though, X * -1 * 1 * -1 cannot be simplified to X,
    // when we multiply with a number with absolute value bigger than 1,
    // we ensure that the overflows are preserved, so that we can simplify
    // the expression.
    { original: "X * -1 * 1 * -1 * 2", simplified: "X * 2" },

    // Should NOT simplify to X * 2, because X could be MIN/2 = -2^255,
    // so that X * -2 = 2^256 = MAX + 1 causes an overflow,
    // but X * 2 = -2^256 does not.
    { original: "X * -2 * -1", simplified: "X * -2 * -1" },

    // Note however that multiplying first by -1 allow us
    // to simplify the expression, because if X * -1 overflows,
    // X * 2 will also.
    { original: "X * -1 * -2", simplified: "X * 2" },
];

const mixedExpressions = [
    // Should NOT simplify to 0, because X * 2 could overflow
    {
        original: "(X * -1 * -2) - (X * -1 * -2)",
        simplified: "(X * 2) - (X * 2)",
    },

    { original: "(X * -1 * -2) + (X * -1 * -2)", simplified: "X * 4" },
];

// These expressions are edge cases to test the associative rule only.
const associativeRuleExpressions = [
    // The following three cases should NOT simplify to
    // -1 - X because X could be MIN, so that 0 - X overflows
    // but -1 - X = MAX does not.
    { original: "(0 - X) + -1", simplified: "(0 - X) + -1" },
    { original: "-1 + (0 - X)", simplified: "-1 + (0 - X)" },
    { original: "(0 - X) - 1", simplified: "(0 - X) - 1" },

    // The following 4 cases Should NOT simplify to X * -2
    // because X could be -(MIN/2) = 2^255, so that
    // X * 2 = -(MIN/2) * 2 = MAX + 1 = 2^256 overflows,
    // but X * -2 = 2^255 * -2 = -2^256 = MIN does not.
    { original: "(X * 2) * -1", simplified: "(X * 2) * -1" },
    { original: "(2 * X) * -1", simplified: "(2 * X) * -1" },
    { original: "-1 * (X * 2)", simplified: "-1 * (X * 2)" },
    { original: "-1 * (2 * X)", simplified: "-1 * (2 * X)" },

    { original: "1 - (X - 1)", simplified: "2 - X" },
    { original: "0 - (X - 1)", simplified: "1 - X" },
    { original: "-1 - (X - 1)", simplified: "0 - X" },

    // Should NOT simplify to -1 - X because X could be MIN,
    // so that X - 1 causes an overflow, but -1 - X = MAX does not.
    { original: "-2 - (X - 1)", simplified: "-2 - (X - 1)" },

    { original: "-2 - (X - (-1))", simplified: "-3 - X" },
    { original: "-1 - (X - (-1))", simplified: "-2 - X" },

    // Should NOT simplify to -1 - X because X could be MAX,
    // so that X - (-1) causes an overflow, but -1 - X = MIN does not.
    { original: "0 - (X - (-1))", simplified: "0 - (X - (-1))" },

    { original: "-1 - (X + 1)", simplified: "-2 - X" },

    // Should NOT simplify to -1 - X because X could be MAX
    // so that X + 1 overflows but -1 - X = MIN does not.
    { original: "0 - (X + 1)", simplified: "0 - (X + 1)" },

    { original: "0 - (X + (-1))", simplified: "1 - X" },
    { original: "-1 - (X + (-1))", simplified: "0 - X" },

    // Should NOT simplify to -1 - X because X could be MIN,
    // so that X + (-1) causes an overflow, but -1 - X = MAX does not.
    { original: "-2 - (X + (-1))", simplified: "-2 - (X + (-1))" },

    { original: "-1 - (0 - X)", simplified: "-1 + X" },

    // Should NOT simplify to 0 + X because X could be MIN so that
    // 0 - X = MAX + 1 overflows, but 0 + X = MIN does not.
    { original: "0 - (0 - X)", simplified: "0 - (0 - X)" },

    { original: "-1 - (1 + X)", simplified: "-2 - X" },

    // Should NOT simplify to -1 - X because X could be MAX
    // so that 1 + X overflows but -1 - X = MIN does not.
    { original: "0 - (1 + X)", simplified: "0 - (1 + X)" },

    { original: "0 - ((-1) + X)", simplified: "1 - X" },
    { original: "-1 - ((-1) + X)", simplified: "0 - X" },

    // Should NOT simplify to -1 - X because X could be MIN,
    // so that (-1) + X causes an overflow, but -1 - X = MAX does not.
    { original: "-2 - ((-1) + X)", simplified: "-2 - ((-1) + X)" },
];

const booleanExpressions = [
    { original: "X && false && false", simplified: "false" },
    { original: "false && X && false", simplified: "false" },
    { original: "false && (X && false)", simplified: "false" },
    { original: "false && (false && X)", simplified: "false" },
    { original: "X && true && false", simplified: "false" },
    { original: "true && X && false", simplified: "false" },
    { original: "false && (X && true)", simplified: "false" },
    { original: "false && (true && X)", simplified: "false" },
    { original: "X && false && true", simplified: "false" },
    { original: "false && X && true", simplified: "false" },
    { original: "true && (X && false)", simplified: "false" },
    { original: "true && (false && X)", simplified: "false" },
    { original: "X && true && true", simplified: "X" },
    { original: "true && X && true", simplified: "X" },
    { original: "true && (X && true)", simplified: "X" },
    { original: "true && (true && X)", simplified: "X" },
    { original: "X || false || false", simplified: "X" },
    { original: "false || X || false", simplified: "X" },
    { original: "false || (X || false)", simplified: "X" },
    { original: "false || (false || X)", simplified: "X" },
    { original: "X || true || false", simplified: "true" },
    { original: "true || X || false", simplified: "true" },
    { original: "false || (X || true)", simplified: "true" },
    { original: "false || (true || X)", simplified: "true" },
    { original: "X || false || true", simplified: "true" },
    { original: "false || X || true", simplified: "true" },
    { original: "true || (X || false)", simplified: "true" },
    { original: "true || (false || X)", simplified: "true" },
    { original: "X || true || true", simplified: "true" },
    { original: "true || X || true", simplified: "true" },
    { original: "true || (X || true)", simplified: "true" },
    { original: "true || (true || X)", simplified: "true" },

    { original: "!!X || !X", simplified: "true" },
    { original: "!!X && !X", simplified: "false" },
    { original: "!!X && X", simplified: "X" },
    { original: "!!X || X", simplified: "X" },
    { original: "!(X && !X)", simplified: "true" },
    { original: "!(X || !X)", simplified: "false" },
    { original: "(!!X || X) && !X", simplified: "false" },
    { original: "!!X || X || !X", simplified: "true" },
    { original: "!!X && X || !X", simplified: "true" },
    { original: "!!X && X && !X", simplified: "false" },
    { original: "!!X || (X && !X)", simplified: "X" },
    { original: "!!X || (X || !X)", simplified: "true" },
    { original: "!!X && (X || !X)", simplified: "X" },
    { original: "!!X && (X && !X)", simplified: "false" },
    { original: "!!X || !(X && !X)", simplified: "true" },
    { original: "!!X || !(X || !X)", simplified: "X" },
    { original: "!!X && !(X || !X)", simplified: "false" },
    { original: "!!X && !(X && !X)", simplified: "X" },

    { original: "X && false && Y && false", simplified: "false" },
    { original: "X && true && Y && true", simplified: "X && Y" },
    { original: "X && false && (Y && true)", simplified: "false" },
    {
        original: "(!!X && !(X && !X)) && (!!Y && !(Y && !Y)) && true",
        simplified: "X && Y",
    },
];

function testExpression(original: string, simplified: string) {
    it(`should simplify ${original} to ${simplified}`, () => {
        const ast = getAstFactory();
        const { parseExpression } = getParser(ast);
        const util = getAstUtil(ast);
        const { partiallyEvalExpression } = getOptimizer(util);
        const originalValue = partiallyEvalExpression(
            parseExpression(original),
            new CompilerContext(),
        );
        const simplifiedValue = dummyEval(
            parseExpression(simplified),
            ast,
            util,
        );
        const areMatching = eqExpressions(originalValue, simplifiedValue);
        expect(areMatching).toBe(true);
    });
}

function testExpressionWithOptimizer(
    original: string,
    simplified: string,
    optimizer: ExpressionTransformer,
) {
    it(`should simplify ${original} to ${simplified}`, () => {
        const ast = getAstFactory();
        const { parseExpression } = getParser(ast);
        const util = getAstUtil(ast);
        const originalValue = optimizer.applyRules(
            dummyEval(parseExpression(original), ast, util),
        );
        const simplifiedValue = dummyEval(
            parseExpression(simplified),
            ast,
            util,
        );
        const areMatching = eqExpressions(originalValue, simplifiedValue);
        expect(areMatching).toBe(true);
    });
}

// This is a dummy partial evaluator that only simplifies constant expressions
// without manipulating the tree structure.
// The reason for doing this is that the partial evaluator will actually simplify constant
// expressions. So, when comparing for equality of expressions, we also need to simplify
// constant expressions.
function dummyEval(
    ast: AstExpression,
    { cloneNode }: FactoryAst,
    { makeValueExpression }: AstUtil,
): AstExpression {
    const recurse = (ast: AstExpression): AstExpression => {
        switch (ast.kind) {
            case "null":
                return ast;
            case "boolean":
                return ast;
            case "number":
                return ast;
            case "string":
                return ast;
            case "id":
                return ast;
            case "method_call": {
                const newNode = cloneNode(ast);
                newNode.args = ast.args.map(recurse);
                newNode.self = recurse(ast.self);
                return newNode;
            }
            case "init_of": {
                const newNode = cloneNode(ast);
                newNode.args = ast.args.map(recurse);
                return newNode;
            }
            case "op_unary": {
                const newNode = cloneNode(ast);
                newNode.operand = recurse(ast.operand);
                if (isValue(newNode.operand)) {
                    return makeValueExpression(
                        evalUnaryOp(
                            ast.op,
                            extractValue(newNode.operand as AstValue),
                        ),
                    );
                }
                return newNode;
            }
            case "op_binary": {
                const newNode = cloneNode(ast);
                newNode.left = recurse(ast.left);
                newNode.right = recurse(ast.right);
                if (isValue(newNode.left) && isValue(newNode.right)) {
                    const valR = extractValue(newNode.right as AstValue);
                    return makeValueExpression(
                        evalBinaryOp(
                            ast.op,
                            extractValue(newNode.left as AstValue),
                            () => valR,
                        ),
                    );
                }
                return newNode;
            }
            case "conditional": {
                const newNode = cloneNode(ast);
                newNode.thenBranch = recurse(ast.thenBranch);
                newNode.elseBranch = recurse(ast.elseBranch);
                return newNode;
            }
            case "struct_instance": {
                const newNode = cloneNode(ast);
                newNode.args = ast.args.map((param) => {
                    const newParam = cloneNode(param);
                    newParam.initializer = recurse(param.initializer);
                    return newParam;
                });
                return newNode;
            }
            case "field_access": {
                const newNode = cloneNode(ast);
                newNode.aggregate = recurse(ast.aggregate);
                return newNode;
            }
            case "static_call": {
                const newNode = cloneNode(ast);
                newNode.args = ast.args.map(recurse);
                return newNode;
            }
        }
    };

    return recurse(ast);
}

// A dummy optimizer to test specific rules
class ParameterizableDummyOptimizer implements ExpressionTransformer {
    private rules: Rule[];

    public util: AstUtil;

    constructor(rules: Rule[], Ast: FactoryAst) {
        this.util = getAstUtil(Ast);

        this.rules = rules;
    }

    public applyRules = (ast: AstExpression): AstExpression => {
        return this.rules.reduce(
            (prev, rule) => rule.applyRule(prev, this),
            ast,
        );
    };
}

describe("partial-evaluator", () => {
    additiveExpressions.forEach((test) => {
        testExpression(test.original, test.simplified);
    });
    multiplicativeExpressions.forEach((test) => {
        testExpression(test.original, test.simplified);
    });
    mixedExpressions.forEach((test) => {
        testExpression(test.original, test.simplified);
    });

    associativeRuleExpressions.forEach((test) => {
        // For the following cases, we need an optimizer that only
        // uses the associative rule 3.
        const optimizer = new ParameterizableDummyOptimizer(
            [new AssociativeRule3()],
            getAstFactory(),
        );

        testExpressionWithOptimizer(test.original, test.simplified, optimizer);
    });

    booleanExpressions.forEach((test) => {
        testExpression(test.original, test.simplified);
    });
});


## fileFormat.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/packaging/fileFormat.ts)
import { z } from "zod";

const typeFormat = z.union([
    z.object({
        kind: z.literal("simple"),
        type: z.string(),
        optional: z.boolean().optional().nullable(),
        format: z
            .union([z.boolean(), z.number(), z.string()])
            .optional()
            .nullable(),
    }),
    z.object({
        kind: z.literal("dict"),
        format: z
            .union([z.boolean(), z.number(), z.string()])
            .optional()
            .nullable(),
        key: z.string(),
        keyFormat: z
            .union([z.boolean(), z.number(), z.string()])
            .optional()
            .nullable(),
        value: z.string(),
        valueFormat: z
            .union([z.boolean(), z.number(), z.string()])
            .optional()
            .nullable(),
    }),
]);

const initFormat = z.object({
    kind: z.literal("direct"),
    args: z.array(
        z.object({
            name: z.string(),
            type: typeFormat,
        }),
    ),
    prefix: z
        .object({
            bits: z.number(),
            value: z.number(),
        })
        .optional(),
    deployment: z.union([
        z.object({
            kind: z.literal("direct"),
        }),
        z.object({
            kind: z.literal("system-cell"),
            system: z.string(),
        }),
    ]),
});

export const fileFormat = z.object({
    // Contract name, code and abi
    name: z.string(),
    code: z.string(),
    abi: z.string(),

    // Deployment
    init: initFormat,

    // Sources
    sources: z.record(z.string(), z.string()).optional(),

    // Compiler information
    compiler: z.object({
        name: z.string(),
        version: z.string(),
        parameters: z.string().optional().nullable(),
    }),
});

export type PackageFileFormat = z.infer<typeof fileFormat>;


## packageCode.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/packaging/packageCode.ts)
import { fileFormat, PackageFileFormat } from "./fileFormat";

export function packageCode(pkg: PackageFileFormat) {
    const parsed = fileFormat.parse(pkg);
    return JSON.stringify(parsed);
}


## build.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/pipeline/build.ts)
import { beginCell, Cell, Dictionary } from "@ton/core";
import { decompileAll } from "@tact-lang/opcode";
import { writeTypescript } from "../bindings/writeTypescript";
import { featureEnable } from "../config/features";
import { ConfigProject } from "../config/parseConfig";
import { CompilerContext } from "../context";
import { funcCompile } from "../func/funcCompile";
import { writeReport } from "../generator/writeReport";
import { getRawAST } from "../grammar/store";
import files from "../imports/stdlib";
import { ILogger, Logger } from "../logger";
import { PackageFileFormat } from "../packaging/fileFormat";
import { packageCode } from "../packaging/packageCode";
import { createABITypeRefFromTypeRef } from "../types/resolveABITypeRef";
import { getContracts, getType } from "../types/resolveDescriptors";
import { posixNormalize } from "../utils/filePath";
import { createVirtualFileSystem } from "../vfs/createVirtualFileSystem";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
import { compile } from "./compile";
import { precompile } from "./precompile";
import { getCompilerVersion } from "./version";
import { FactoryAst, getAstFactory, idText } from "../grammar/ast";
import { TactErrorCollection } from "../errors";
import { getParser, Parser } from "../grammar";

export function enableFeatures(
    ctx: CompilerContext,
    logger: ILogger,
    config: ConfigProject,
): CompilerContext {
    if (config.options === undefined) {
        return ctx;
    }
    const features = [
        { option: config.options.debug, name: "debug" },
        { option: config.options.external, name: "external" },
        { option: config.options.experimental?.inline, name: "inline" },
        { option: config.options.ipfsAbiGetter, name: "ipfsAbiGetter" },
        { option: config.options.interfacesGetter, name: "interfacesGetter" },
    ];
    return features.reduce((currentCtx, { option, name }) => {
        if (option) {
            logger.debug(`   > 👀 Enabling ${name}`);
            return featureEnable(currentCtx, name);
        }
        return currentCtx;
    }, ctx);
}

export async function build(args: {
    config: ConfigProject;
    project: VirtualFileSystem;
    stdlib: string | VirtualFileSystem;
    logger?: ILogger;
    parser?: Parser;
    ast?: FactoryAst;
}): Promise<{ ok: boolean; error: TactErrorCollection[] }> {
    const { config, project } = args;
    const stdlib =
        typeof args.stdlib === "string"
            ? createVirtualFileSystem(args.stdlib, files)
            : args.stdlib;
    const ast: FactoryAst = args.ast ?? getAstFactory();
    const parser: Parser = args.parser ?? getParser(ast);
    const logger: ILogger = args.logger ?? new Logger();

    // Configure context
    let ctx: CompilerContext = new CompilerContext();
    const cfg: string = JSON.stringify({
        entrypoint: posixNormalize(config.path),
        options: config.options ?? {},
    });
    ctx = enableFeatures(ctx, logger, config);

    // Precompile
    try {
        ctx = precompile(ctx, project, stdlib, config.path, parser, ast);
    } catch (e) {
        logger.error(
            config.mode === "checkOnly" || config.mode === "funcOnly"
                ? "Syntax and type checking failed"
                : "Tact compilation failed",
        );
        logger.error(e as Error);
        return { ok: false, error: [e as Error] };
    }

    if (config.mode === "checkOnly") {
        logger.info("✔️ Syntax and type checking succeeded.");
        return { ok: true, error: [] };
    }

    // Compile contracts
    let ok = true;
    const errorMessages: TactErrorCollection[] = [];
    const built: Record<
        string,
        | {
              codeBoc: Buffer;
              abi: string;
          }
        | undefined
    > = {};
    for (const contract of getContracts(ctx)) {
        const pathAbi = project.resolve(
            config.output,
            config.name + "_" + contract + ".abi",
        );

        const pathCodeBoc = project.resolve(
            config.output,
            config.name + "_" + contract + ".code.boc",
        );
        const pathCodeFif = project.resolve(
            config.output,
            config.name + "_" + contract + ".code.fif",
        );
        const pathCodeFifDec = project.resolve(
            config.output,
            config.name + "_" + contract + ".code.rev.fif",
        );
        let codeFc: { path: string; content: string }[];
        let codeEntrypoint: string;

        // Compiling contract to func
        logger.info(`   > ${contract}: tact compiler`);
        let abi: string;
        try {
            const res = await compile(
                ctx,
                contract,
                config.name + "_" + contract,
            );
            for (const files of res.output.files) {
                const ffc = project.resolve(config.output, files.name);
                project.writeFile(ffc, files.code);
            }
            project.writeFile(pathAbi, res.output.abi);
            abi = res.output.abi;
            codeFc = res.output.files.map((v) => ({
                path: posixNormalize(project.resolve(config.output, v.name)),
                content: v.code,
            }));
            codeEntrypoint = res.output.entrypoint;
        } catch (e) {
            logger.error("Tact compilation failed");
            logger.error(e as Error);
            ok = false;
            errorMessages.push(e as Error);
            continue;
        }

        if (config.mode === "funcOnly") {
            continue;
        }

        // Compiling contract to TVM
        logger.info(`   > ${contract}: func compiler`);
        let codeBoc: Buffer;
        try {
            const stdlibPath = stdlib.resolve("stdlib.fc");
            const stdlibCode = stdlib.readFile(stdlibPath).toString();
            const stdlibExPath = stdlib.resolve("stdlib_ex.fc");
            const stdlibExCode = stdlib.readFile(stdlibExPath).toString();
            const c = await funcCompile({
                entries: [
                    stdlibPath,
                    stdlibExPath,
                    posixNormalize(
                        project.resolve(config.output, codeEntrypoint),
                    ),
                ],
                sources: [
                    {
                        path: stdlibPath,
                        content: stdlibCode,
                    },
                    {
                        path: stdlibExPath,
                        content: stdlibExCode,
                    },
                    ...codeFc,
                ],
                logger,
            });
            if (!c.ok) {
                const match = c.log.match(
                    /undefined function `([^`]+)`, defining a global function of unknown type/,
                );
                if (match) {
                    const message = `Function '${match[1]}' does not exist in imported FunC sources`;
                    logger.error(message);
                    errorMessages.push(new Error(message));
                    return { ok: false, error: errorMessages };
                }

                logger.error(c.log);
                ok = false;
                errorMessages.push(new Error(c.log));
                continue;
            }
            project.writeFile(pathCodeFif, c.fift);
            project.writeFile(pathCodeBoc, c.output);
            codeBoc = c.output;
        } catch (e) {
            logger.error("FunC compiler crashed");
            logger.error(e as Error);
            ok = false;
            errorMessages.push(e as Error);
            continue;
        }

        // Add to built map
        built[contract] = {
            codeBoc,
            abi,
        };

        if (config.mode === "fullWithDecompilation") {
            // Fift decompiler for generated code debug
            logger.info(`   > ${contract}: fift decompiler`);
            let codeFiftDecompiled: string;
            try {
                codeFiftDecompiled = decompileAll({ src: codeBoc });
                project.writeFile(pathCodeFifDec, codeFiftDecompiled);
            } catch (e) {
                logger.error("Fift decompiler crashed");
                logger.error(e as Error);
                ok = false;
                errorMessages.push(e as Error);
                continue;
            }
        }
    }
    if (!ok) {
        logger.info("💥 Compilation failed. Skipping packaging");
        return { ok: false, error: errorMessages };
    }

    if (config.mode === "funcOnly") {
        logger.info("✔️ FunC code generation succeeded.");
        return { ok: true, error: errorMessages };
    }

    // Package
    logger.info("   > Packaging");
    const contracts = getContracts(ctx);
    const packages: PackageFileFormat[] = [];
    for (const contract of contracts) {
        logger.info("   > " + contract);
        const artifacts = built[contract];
        if (!artifacts) {
            const message = `   > ${contract}: no artifacts found`;
            logger.error(message);
            errorMessages.push(new Error(message));
            return { ok: false, error: errorMessages };
        }

        // System cell
        const depends = Dictionary.empty(
            Dictionary.Keys.Uint(16),
            Dictionary.Values.Cell(),
        );
        const ct = getType(ctx, contract);
        depends.set(ct.uid, Cell.fromBoc(built[ct.name]!.codeBoc)[0]!); // Mine
        for (const c of ct.dependsOn) {
            const cd = built[c.name];
            if (!cd) {
                const message = `   > ${c.name}: no artifacts found`;
                logger.error(message);
                errorMessages.push(new Error(message));
                return { ok: false, error: errorMessages };
            }
            depends.set(c.uid, Cell.fromBoc(cd.codeBoc)[0]!);
        }
        const systemCell = beginCell().storeDict(depends).endCell();

        // Collect sources
        const sources: Record<string, string> = {};
        const rawAst = getRawAST(ctx);
        for (const source of [...rawAst.funcSources, ...rawAst.sources]) {
            if (
                source.path.startsWith(project.root) &&
                !source.path.startsWith(stdlib.root)
            ) {
                const source_path = posixNormalize(
                    source.path.slice(project.root.length),
                );
                sources[source_path] = Buffer.from(source.code).toString(
                    "base64",
                );
            }
        }

        // Package
        const pkg: PackageFileFormat = {
            name: contract,
            abi: artifacts.abi,
            code: artifacts.codeBoc.toString("base64"),
            init: {
                kind: "direct",
                args: getType(ctx, contract).init!.params.map((v) => ({
                    name: idText(v.name),
                    type: createABITypeRefFromTypeRef(ctx, v.type, v.loc),
                })),
                prefix: {
                    bits: 1,
                    value: 0,
                },
                deployment: {
                    kind: "system-cell",
                    system: systemCell.toBoc().toString("base64"),
                },
            },
            sources,
            compiler: {
                name: "tact",
                version: getCompilerVersion(),
                parameters: cfg,
            },
        };
        const pkgData = packageCode(pkg);
        const pathPkg = project.resolve(
            config.output,
            config.name + "_" + contract + ".pkg",
        );
        project.writeFile(pathPkg, pkgData);
        packages.push(pkg);
    }

    // Bindings
    logger.info("   > Bindings");
    for (const pkg of packages) {
        logger.info(`   > ${pkg.name}`);
        if (pkg.init.deployment.kind !== "system-cell") {
            const message = `   > ${pkg.name}: unsupported deployment kind ${pkg.init.deployment.kind}`;
            logger.error(message);
            errorMessages.push(new Error(message));
            return { ok: false, error: errorMessages };
        }
        try {
            const bindingsServer = writeTypescript(JSON.parse(pkg.abi), {
                code: pkg.code,
                prefix: pkg.init.prefix,
                system: pkg.init.deployment.system,
                args: pkg.init.args,
            });
            project.writeFile(
                project.resolve(
                    config.output,
                    config.name + "_" + pkg.name + ".ts",
                ),
                bindingsServer,
            );
        } catch (e) {
            const error = e as Error;
            error.message = `Bindings compiler crashed: ${error.message}`;
            logger.error(error);
            errorMessages.push(error);
            return { ok: false, error: errorMessages };
        }
    }

    // Reports
    logger.info("   > Reports");
    for (const pkg of packages) {
        logger.info("   > " + pkg.name);
        try {
            const report = writeReport(ctx, pkg);
            const pathBindings = project.resolve(
                config.output,
                config.name + "_" + pkg.name + ".md",
            );
            project.writeFile(pathBindings, report);
        } catch (e) {
            const error = e as Error;
            error.message = `Report generation crashed: ${error.message}`;
            logger.error(error);
            errorMessages.push(error);
            return { ok: false, error: errorMessages };
        }
    }

    return { ok: true, error: [] };
}


## compile.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/pipeline/compile.ts)
import { CompilerContext } from "../context";
import { createABI } from "../generator/createABI";
import { writeProgram } from "../generator/writeProgram";

export async function compile(
    ctx: CompilerContext,
    name: string,
    basename: string,
) {
    const abi = createABI(ctx, name);
    const output = await writeProgram(ctx, abi, basename);
    const cOutput = output;
    return { output: cOutput, ctx };
}


## precompile.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/pipeline/precompile.ts)
import { CompilerContext } from "../context";
import { resolveDescriptors } from "../types/resolveDescriptors";
import { resolveAllocations } from "../storage/resolveAllocation";
import { openContext } from "../grammar/store";
import { resolveStatements } from "../types/resolveStatements";
import { resolveErrors } from "../types/resolveErrors";
import { resolveSignatures } from "../types/resolveSignatures";
import { resolveImports } from "../imports/resolveImports";
import { VirtualFileSystem } from "../vfs/VirtualFileSystem";
import { AstModule, FactoryAst } from "../grammar/ast";
import { Parser } from "../grammar";

export function precompile(
    ctx: CompilerContext,
    project: VirtualFileSystem,
    stdlib: VirtualFileSystem,
    entrypoint: string,
    parser: Parser,
    ast: FactoryAst,
    parsedModules?: AstModule[],
) {
    // Load all sources
    const imported = resolveImports({ entrypoint, project, stdlib, parser });

    // Add information about all the source code entries to the context
    ctx = openContext(ctx, imported.tact, imported.func, parser, parsedModules);

    // First load type descriptors and check that
    //       they all have valid signatures
    ctx = resolveDescriptors(ctx, ast);

    // This creates TLB-style type definitions
    ctx = resolveSignatures(ctx);

    // This creates allocations for all defined types
    ctx = resolveAllocations(ctx);

    // This checks and resolves all statements
    ctx = resolveStatements(ctx);

    // This extracts error messages
    ctx = resolveErrors(ctx);

    // Prepared context
    return ctx;
}


## version.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/pipeline/version.ts)
const version = require("../../package.json").version;

let __DANGER__VersionNumberDisabled = false;

export function __DANGER__disableVersionNumber() {
    __DANGER__VersionNumberDisabled = true;
}

export function getCompilerVersion() {
    if (__DANGER__VersionNumberDisabled) {
        return "invalid";
    }
    return version as string;
}


## StorageAllocation.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/storage/StorageAllocation.ts)
import { AllocationCell, AllocationOperation } from "./operation";

export type StorageAllocation = {
    ops: AllocationOperation[];
    header: { value: number; bits: number } | null;
    size: { bits: number; refs: number };
    root: AllocationCell;
};


## allocator.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/storage/allocator.ts)
import { ABITypeRef } from "@ton/core";
import {
    AllocationCell,
    AllocationOperation,
    AllocationOperationType,
} from "./operation";
import { throwInternalCompilerError } from "../errors";

const ALLOCATOR_RESERVE_BIT = 1;
const ALLOCATOR_RESERVE_REF = 1;

function getOperationSize(src: AllocationOperationType): {
    bits: number;
    refs: number;
} {
    switch (src.kind) {
        case "int":
        case "uint": {
            return { bits: src.bits + (src.optional ? 1 : 0), refs: 0 };
        }
        case "coins": {
            return { bits: 124 + (src.optional ? 1 : 0), refs: 0 };
        }
        case "boolean": {
            return { bits: 1 + (src.optional ? 1 : 0), refs: 0 };
        }
        case "address": {
            return { bits: 267, refs: 0 };
        }
        case "cell":
        case "slice":
        case "builder":
            {
                switch (src.format) {
                    case "default": {
                        return { bits: src.optional ? 1 : 0, refs: 1 };
                    }
                    case "remainder": {
                        if (src.optional) {
                            throwInternalCompilerError(
                                "Remainder cell cannot be optional",
                            );
                        }
                        return { bits: 0, refs: 0 };
                    }
                }
            }
            break;
        case "string": {
            return { bits: src.optional ? 1 : 0, refs: 1 };
        }
        case "map": {
            return { bits: 1, refs: 1 };
        }
        case "struct": {
            if (src.ref) {
                return { bits: src.optional ? 1 : 0, refs: 1 };
            } else {
                return {
                    bits: src.size.bits + (src.optional ? 1 : 0),
                    refs: src.size.refs,
                };
            }
        }
        case "fixed-bytes": {
            return { bits: src.bytes * 8 + (src.optional ? 1 : 0), refs: 0 };
        }
    }
}

export function getAllocationOperationFromField(
    src: ABITypeRef,
    structLoader: (name: string) => { bits: number; refs: number },
): AllocationOperationType {
    // Reference types
    switch (src.kind) {
        case "simple": {
            if (src.type === "int") {
                if (typeof src.format === "number") {
                    if (src.format < 1 || src.format > 257) {
                        throw Error("Unsupported int format " + src.format);
                    }
                    return {
                        kind: "int",
                        bits: src.format,
                        optional: src.optional ? src.optional : false,
                    };
                }
                if (src.format !== null && src.format !== undefined) {
                    throwInternalCompilerError(
                        `Unsupported int format: ${src.format}`,
                    );
                }
                return {
                    kind: "int",
                    bits: 257,
                    optional: src.optional ? src.optional : false,
                };
            }
            if (src.type === "uint") {
                if (typeof src.format === "number") {
                    if (src.format < 1 || src.format > 256) {
                        throwInternalCompilerError(
                            `Unsupported uint format: ${src.format}`,
                        );
                    }
                    return {
                        kind: "uint",
                        bits: src.format,
                        optional: src.optional ? src.optional : false,
                    };
                }
                if (src.format === "coins") {
                    return {
                        kind: "coins",
                        optional: src.optional ? src.optional : false,
                    };
                }
                if (src.format !== null && src.format !== undefined) {
                    throwInternalCompilerError(
                        `Unsupported uint format: ${src.format}`,
                    );
                }
                return {
                    kind: "uint",
                    bits: 256,
                    optional: src.optional ? src.optional : false,
                };
            }
            if (src.type === "bool") {
                if (src.format !== null && src.format !== undefined) {
                    throwInternalCompilerError(
                        `Unsupported bool format: ${src.format}`,
                    );
                }
                return {
                    kind: "boolean",
                    optional: src.optional ? src.optional : false,
                };
            }
            if (src.type === "cell") {
                if (src.format === "remainder") {
                    return {
                        kind: "cell",
                        optional: src.optional ? src.optional : false,
                        format: "remainder",
                    };
                } else if (src.format !== null && src.format !== undefined) {
                    throwInternalCompilerError(
                        `Unsupported cell format: ${src.format}`,
                    );
                }
                return {
                    kind: "cell",
                    optional: src.optional ? src.optional : false,
                    format: "default",
                };
            }
            if (src.type === "slice") {
                if (src.format === "remainder") {
                    return {
                        kind: "slice",
                        optional: src.optional ? src.optional : false,
                        format: "remainder",
                    };
                } else if (src.format !== null && src.format !== undefined) {
                    throwInternalCompilerError(
                        `Unsupported slice format: ${src.format}`,
                    );
                }
                return {
                    kind: "slice",
                    optional: src.optional ? src.optional : false,
                    format: "default",
                };
            }
            if (src.type === "builder") {
                if (src.format === "remainder") {
                    return {
                        kind: "builder",
                        optional: src.optional ? src.optional : false,
                        format: "remainder",
                    };
                } else if (src.format !== null && src.format !== undefined) {
                    throwInternalCompilerError(
                        `Unsupported slice format: ${src.format}`,
                    );
                }
                return {
                    kind: "builder",
                    optional: src.optional ? src.optional : false,
                    format: "default",
                };
            }
            if (src.type === "address") {
                return {
                    kind: "address",
                    optional: src.optional ? src.optional : false,
                };
            }
            if (src.type === "fixed-bytes") {
                if (src.format === 32 || src.format === 64) {
                    return {
                        kind: "fixed-bytes",
                        bytes: src.format,
                        optional: src.optional ? src.optional : false,
                    };
                } else {
                    throwInternalCompilerError(
                        `Unsupported fixed-bytes format: ${src.format}`,
                    );
                }
            }
            if (src.type === "string") {
                if (src.format !== null && src.format !== undefined) {
                    throwInternalCompilerError(
                        `Unsupported string format: ${src.format}`,
                    );
                }
                return {
                    kind: "string",
                    optional: src.optional ? src.optional : false,
                };
            }

            // Struct types
            const size = structLoader(src.type);
            if (src.format === "ref") {
                return {
                    kind: "struct",
                    type: src.type,
                    ref: true,
                    optional: src.optional ? src.optional : false,
                    size,
                };
            } else if (src.format !== undefined && src.format !== null) {
                throwInternalCompilerError(
                    `Unsupported struct format: ${src.format}`,
                );
            } else {
                return {
                    kind: "struct",
                    type: src.type,
                    ref: false,
                    optional: src.optional ? src.optional : false,
                    size,
                };
            }
        }
        // NOTE: That's false positive in ESLint on how it handles nested if-else
        // constructions: https://github.com/tact-lang/tact/pull/669/files#r1709420045
        // eslint-disable-next-line no-fallthrough
        case "dict": {
            if (src.format !== null && src.format !== undefined) {
                throwInternalCompilerError(
                    `Unsupported map format: ${src.format}`,
                );
            }
            return { kind: "map" };
        }
    }
}

function allocateSegment(
    ops: AllocationOperation[],
    bits: number,
    refs: number,
): AllocationCell {
    const fields: AllocationOperation[] = [];
    let next: AllocationCell | null = null;
    const used: { bits: number; refs: number } = { bits: 0, refs: 0 };

    const [totalBits, totalRefs] = ops.reduce(
        ([sumBits, sumRefs], op) => {
            const opSize = getOperationSize(op.op);
            return [sumBits + opSize.bits, sumRefs + opSize.refs];
        },
        [0, 0],
    );
    // check if there will be a new allocation segment,
    // meaning we need to have a spare ref to link it
    // from the current segment
    if (totalBits > bits || totalRefs > refs) {
        refs -= 1;
    }

    for (const [i, op] of ops.entries()) {
        const size = getOperationSize(op.op);

        // Check if we can fit this operation
        if (size.bits > bits || size.refs > refs) {
            used.refs += 1;
            next = allocateSegment(ops.slice(i), 1023, 4);
            break;
        }

        // Append operation
        bits -= size.bits;
        refs -= size.refs;
        used.bits += size.bits;
        used.refs += size.refs;
        fields.push(op);
    }

    return {
        ops: fields,
        size: used,
        next,
    };
}

export function allocate(type: {
    reserved: { bits: number; refs: number };
    ops: AllocationOperation[];
}): AllocationCell {
    return allocateSegment(
        type.ops,
        1023 - type.reserved.bits - ALLOCATOR_RESERVE_BIT,
        4 - type.reserved.refs - ALLOCATOR_RESERVE_REF,
    );
}


## operation.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/storage/operation.ts)
import { ABITypeRef } from "@ton/core";

export type AllocationCell = {
    ops: AllocationOperation[];
    size: { bits: number; refs: number };
    next: AllocationCell | null;
};

export type AllocationOperation = {
    name: string;
    type: ABITypeRef;
    op: AllocationOperationType;
};

export type AllocationOperationType =
    | {
          kind: "int" | "uint";
          bits: number;
          optional: boolean;
      }
    | {
          kind: "boolean";
          optional: boolean;
      }
    | {
          kind: "coins";
          optional: boolean;
      }
    | {
          kind: "address";
          optional: boolean;
      }
    | {
          kind: "struct";
          type: string;
          ref: boolean;
          optional: boolean;
          size: { bits: number; refs: number };
      }
    | {
          kind: "cell";
          optional: boolean;
          format: "default" | "remainder";
      }
    | {
          kind: "slice";
          optional: boolean;
          format: "default" | "remainder";
      }
    | {
          kind: "builder";
          optional: boolean;
          format: "default" | "remainder";
      }
    | {
          kind: "map";
      }
    | {
          kind: "string";
          optional: boolean;
      }
    | {
          kind: "fixed-bytes";
          bytes: number;
          optional: boolean;
      };


## resolveAllocation.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/storage/resolveAllocation.spec.ts)
import fs from "fs";
import { resolveDescriptors } from "../types/resolveDescriptors";
import { getAllocations, resolveAllocations } from "./resolveAllocation";
import { openContext } from "../grammar/store";
import { resolveStatements } from "../types/resolveStatements";
import { CompilerContext } from "../context";
import { resolveSignatures } from "../types/resolveSignatures";
import path from "path";
import { getParser } from "../grammar";
import { getAstFactory } from "../grammar/ast";

const stdlibPath = path.resolve(__dirname, "../../stdlib/std/primitives.tact");
const stdlib = fs.readFileSync(stdlibPath, "utf-8");
const src = `

trait BaseTrait {
    
}

struct Point3 {
    a: Point;
    b: Point2;
}

struct Point {
    x: Int;
    y: Int;
}

struct Point2 {
    z: Point;
}

struct Deep {
    a: Int;
    b: Int;
    c: Int;
    d: Int;
    e: Int;
    f: Int;
    g: Int;
    h: Int;
    i: Int;
    j: Int;
    k: Int;
}

struct Deep2 {
    a: Deep;
    b: Deep;
    c: Deep;
}

contract Sample {
    v: Int = 0;
    init() {

    }
    fun main(a: Int, b: Int) {
    }
}
`;

describe("resolveAllocation", () => {
    it("should write program", () => {
        const ast = getAstFactory();
        let ctx = openContext(
            new CompilerContext(),
            [
                { code: stdlib, path: stdlibPath, origin: "stdlib" },
                { code: src, path: "<unknown>", origin: "user" },
            ],
            [],
            getParser(ast),
        );
        ctx = resolveDescriptors(ctx, ast);
        ctx = resolveSignatures(ctx);
        ctx = resolveStatements(ctx);
        ctx = resolveAllocations(ctx);
        expect(getAllocations(ctx)).toMatchSnapshot();
    });
});


## resolveAllocation.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/storage/resolveAllocation.ts)
import { CompilerContext, createContextStore } from "../context";
import { getType, toBounced, getAllTypes } from "../types/resolveDescriptors";
import { TypeDescription } from "../types/types";
import { topologicalSort } from "../utils/utils";
import { StorageAllocation } from "./StorageAllocation";
import { AllocationOperation } from "./operation";
import { allocate, getAllocationOperationFromField } from "./allocator";
import { createABITypeRefFromTypeRef } from "../types/resolveABITypeRef";
import { funcInitIdOf } from "../generator/writers/id";
import { throwInternalCompilerError } from "../errors";
import { idText } from "../grammar/ast";

const store = createContextStore<StorageAllocation>();

export function getAllocation(
    ctx: CompilerContext,
    name: string,
): StorageAllocation {
    const t = store.get(ctx, name);
    if (!t) {
        throwInternalCompilerError(`Allocation for ${name} not found`);
    }
    return t;
}

export function getAllocations(ctx: CompilerContext): {
    allocation: StorageAllocation;
    type: TypeDescription;
}[] {
    return getSortedTypes(ctx).map((v) => ({
        allocation: getAllocation(ctx, v.name),
        type: v,
    }));
}

export function getSortedTypes(ctx: CompilerContext): TypeDescription[] {
    const types = getAllTypes(ctx).filter(
        (v) => v.kind === "struct" || v.kind === "contract",
    );
    let structs = types.filter((t) => t.kind === "struct");
    const refs = (src: TypeDescription) => {
        const res: TypeDescription[] = [];
        const t: Set<string> = new Set();
        for (const f of src.fields) {
            const r = f.type;
            if (r.kind === "ref") {
                const tp = getType(ctx, r.name);
                if (tp.kind === "struct") {
                    if (!t.has(tp.name)) {
                        t.add(r.name);
                        res.push(tp);
                    }
                }
            }
        }
        return res;
    };
    structs = topologicalSort(structs, refs);
    structs = [...structs, ...types.filter((v) => v.kind === "contract")];
    return structs;
}

export function resolveAllocations(ctx: CompilerContext): CompilerContext {
    // Load topological order of structs and contracts
    const types = getSortedTypes(ctx);

    // Generate allocations
    for (const s of types) {
        // Reserve bits
        let reserveBits = 0;
        let header: { value: number; bits: number } | null = null;
        if (s.header !== null) {
            reserveBits += 32; // Header size
            header = { value: Number(s.header.value), bits: 32 };
        }

        // Reserver refs
        let reserveRefs = 0;
        if (s.kind === "contract") {
            reserveRefs += 1; // Internal state
        }

        // Convert fields
        const ops: AllocationOperation[] = [];
        const partialOps: AllocationOperation[] = [];
        for (const [i, f] of s.fields.entries()) {
            const op = {
                name: f.name,
                type: f.abi.type,
                op: getAllocationOperationFromField(
                    f.abi.type,
                    (name) => getAllocation(ctx, name)!.size,
                ),
            };
            ops.push(op);
            if (i < s.partialFieldCount) {
                partialOps.push(op);
            }
        }

        // Perform allocation
        const root = allocate({
            ops,
            reserved: { bits: reserveBits, refs: reserveRefs },
        });
        const partialRoot = allocate({
            ops: partialOps,
            reserved: { bits: reserveBits, refs: reserveRefs },
        });

        // Store allocation
        const allocation: StorageAllocation = {
            ops,
            root,
            header,
            size: {
                bits: root.size.bits + reserveBits,
                refs: root.size.refs + reserveRefs,
            },
        };

        const partialAllocation: StorageAllocation = {
            ops: partialOps,
            root: partialRoot,
            header,
            size: {
                bits: root.size.bits + reserveBits,
                refs: root.size.refs + reserveRefs,
            },
        };

        ctx = store.set(ctx, s.name, allocation);
        ctx = store.set(ctx, toBounced(s.name), partialAllocation);
    }

    // Generate init allocations
    for (const s of types) {
        if (s.kind === "contract" && s.init) {
            // Reserve bits and refs
            let reserveBits = 0;
            let reserveRefs = 0;

            // Reserve first bit for init state
            reserveBits++;

            // Reserve ref for system cell
            reserveRefs++;

            // Resolve opts
            const ops: AllocationOperation[] = [];
            for (const f of s.init.params) {
                const abiType = createABITypeRefFromTypeRef(ctx, f.type, f.loc);
                ops.push({
                    name: idText(f.name),
                    type: abiType,
                    op: getAllocationOperationFromField(
                        abiType,
                        (name) => getAllocation(ctx, name)!.size,
                    ),
                });
            }

            // Perform allocation
            const root = allocate({
                ops,
                reserved: { bits: reserveBits, refs: reserveRefs },
            }); // Better allocation?

            // Store allocation
            const allocation: StorageAllocation = {
                ops,
                root,
                header: null,
                size: {
                    bits: root.size.bits + reserveBits,
                    refs: root.size.refs + reserveRefs,
                },
            };
            ctx = store.set(ctx, funcInitIdOf(s.name), allocation);
        }
    }

    return ctx;
}


## compare.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compare.spec.ts)
import fs from "fs";
import { getParser } from "../grammar";
import { join } from "path";
import { AstComparator } from "../grammar/compare";
import { CONTRACTS_DIR } from "./util";
import * as assert from "assert";
import { getAstFactory } from "../grammar/ast";

describe("comparator", () => {
    it.each(fs.readdirSync(CONTRACTS_DIR, { withFileTypes: true }))(
        "AST modules of the same file must be equal",
        (dentry) => {
            if (!dentry.isFile()) {
                return;
            }
            const filePath = join(CONTRACTS_DIR, dentry.name);
            const src = fs.readFileSync(filePath, "utf-8");
            const Ast = getAstFactory();
            const { parse } = getParser(Ast);
            const ast1 = parse(src, filePath, "user");
            const ast2 = parse(src, filePath, "user");
            assert.strictEqual(
                AstComparator.make().compare(ast1, ast2),
                true,
                `The AST comparison failed for ${dentry.name}`,
            );
        },
    );
});


## prettyPrinter.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/prettyPrinter.spec.ts)
import fs from "fs";
import { prettyPrint } from "../prettyPrinter";
import { getParser } from "../grammar";
import { join } from "path";
import { trimTrailingCR, CONTRACTS_DIR } from "./util";
import * as assert from "assert";
import JSONBig from "json-bigint";
import { getAstFactory } from "../grammar/ast";

describe("formatter", () => {
    it.each(fs.readdirSync(CONTRACTS_DIR, { withFileTypes: true }))(
        "shouldn't change proper formatting",
        (dentry) => {
            if (!dentry.isFile()) {
                return;
            }
            const Ast = getAstFactory();
            const { parse } = getParser(Ast);
            const filePath = join(CONTRACTS_DIR, dentry.name);
            const src = trimTrailingCR(fs.readFileSync(filePath, "utf-8"));
            const ast = parse(src, filePath, "user");
            const formatted = trimTrailingCR(prettyPrint(ast));
            assert.strictEqual(
                formatted,
                src,
                `The formatted AST comparison failed for ${dentry.name}`,
            );
        },
    );

    const outputDir = join(CONTRACTS_DIR, "pretty-printer-output");
    fs.mkdirSync(outputDir, { recursive: true });
    it.each(fs.readdirSync(CONTRACTS_DIR, { withFileTypes: true }))(
        "shouldn't change AST",
        (dentry) => {
            if (!dentry.isFile()) {
                return;
            }
            const Ast = getAstFactory();
            const { parse } = getParser(Ast);
            const filePath = join(CONTRACTS_DIR, dentry.name);
            const src = fs.readFileSync(filePath, "utf-8");
            const ast = parse(src, filePath, "user");
            //TODO: change for proper recursive removal
            const astStr = JSONBig.stringify(ast).replace(/"id":[0-9]+,/g, "");

            const formatted = prettyPrint(ast);
            const fileName = join(outputDir, dentry.name);
            fs.openSync(fileName, "w");
            fs.writeFileSync(fileName, formatted, { flag: "w" });
            const astFormatted = parse(formatted, fileName, "user");
            //TODO: change for proper recursive removal
            const astFormattedStr = JSONBig.stringify(astFormatted).replace(
                /"id":[0-9]+,/g,
                "",
            );
            expect(astFormattedStr).toEqual(astStr);
        },
    );
});


## rename.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/rename.spec.ts)
import fs from "fs";
import { join } from "path";
import { AstRenamer } from "../grammar/rename";
import { prettyPrint } from "../prettyPrinter";
import { trimTrailingCR, CONTRACTS_DIR } from "./util";
import * as assert from "assert";
import { getParser } from "../grammar";
import { getAstFactory } from "../grammar/ast";

const EXPECTED_DIR = join(CONTRACTS_DIR, "renamer-expected");

describe("renamer", () => {
    it.each(fs.readdirSync(CONTRACTS_DIR, { withFileTypes: true }))(
        "should have an expected content after being renamed",
        (dentry) => {
            if (!dentry.isFile()) {
                return;
            }
            const ast = getAstFactory();
            const { parse } = getParser(ast);
            const expectedFilePath = join(EXPECTED_DIR, dentry.name);
            const expected = fs.readFileSync(expectedFilePath, "utf-8");
            const filePath = join(CONTRACTS_DIR, dentry.name);
            const src = fs.readFileSync(filePath, "utf-8");
            const inAst = parse(src, filePath, "user");
            const outAst = AstRenamer.make().renameModule(inAst);
            const got = prettyPrint(outAst);
            assert.strictEqual(
                trimTrailingCR(got),
                trimTrailingCR(expected),
                `AST comparison after renamed failed for ${dentry.name}`,
            );
        },
    );
});


## util.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/util.ts)
import path from "path";

export const CONTRACTS_DIR = path.join(__dirname, "contracts");

export function trimTrailingCR(input: string): string {
    return input.replace(/\n+$/, "");
}


## all-contracts.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/all-contracts.tact)
import "./empty-message.tact";
import "./large-contract.tact";
import "./struct-field-storage-annotation.tact";
import "./struct-field-func-keywords-name-clash";
import "./message-opcode-parsing.tact";
import "./struct-with-default-and-optional-fields";
import "./mutating-method-on-non-lvalues";
import "./var-scope-global-fun-shadowing-allowed";
import "./map-uint-bool-get";
import "./emptyMap-in-equality";


## empty-message.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/empty-message.tact)
message MyMessage {
}

contract Issue74 {
    receive("send") {
        send(SendParameters {
            to: context().sender, 
            value: 0, 
            bounce: false,
            mode: SendIgnoreErrors,
            body: MyMessage {}.toCell()
        });
    }
}

## emptyMap-in-equality.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/emptyMap-in-equality.tact)
contract TestContract {
    get fun testEq(s: map<Int,Int>): Bool {
        return s == emptyMap();
    }
    get fun testNeq(s: map<Int,Int>): Bool {
        return s != emptyMap();
    }
}


## large-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/large-contract.tact)
contract LargeContract {

    init() {

    }

    testMap0: map<Int, Int>;
    testMap1: map<Int, Int>;
    testMap2: map<Int, Int>;
    testMap3: map<Int, Int>;
    testMap4: map<Int, Int>;
    testMap5: map<Int, Int>;
    testMap6: map<Int, Int>;
    testMap7: map<Int, Int>;
    testMap8: map<Int, Int>;
    testMap9: map<Int, Int>;
    testMap10: map<Int, Int>;
    testMap11: map<Int, Int>;
    testMap12: map<Int, Int>;
    testMap13: map<Int, Int>;
    testMap14: map<Int, Int>;
    testMap15: map<Int, Int>;
    testMap16: map<Int, Int>;
    testMap17: map<Int, Int>;
    testMap18: map<Int, Int>;
    testMap19: map<Int, Int>;
    testMap20: map<Int, Int>;
    testMap21: map<Int, Int>;
    testMap22: map<Int, Int>;
    testMap23: map<Int, Int>;
    testMap24: map<Int, Int>;
    testMap25: map<Int, Int>;
    testMap26: map<Int, Int>;
    testMap27: map<Int, Int>;
    testMap28: map<Int, Int>;
    testMap29: map<Int, Int>;
    testMap30: map<Int, Int>;
    testMap31: map<Int, Int>;
    testMap32: map<Int, Int>;
    testMap33: map<Int, Int>;
    testMap34: map<Int, Int>;
    testMap35: map<Int, Int>;
    testMap36: map<Int, Int>;
    testMap37: map<Int, Int>;
    testMap38: map<Int, Int>;
    testMap39: map<Int, Int>;
    testMap40: map<Int, Int>;
    testMap41: map<Int, Int>;
    testMap42: map<Int, Int>;
    testMap43: map<Int, Int>;
    testMap44: map<Int, Int>;
    testMap45: map<Int, Int>;
    testMap46: map<Int, Int>;
    testMap47: map<Int, Int>;
    testMap48: map<Int, Int>;
    testMap49: map<Int, Int>; 
    testMap50: map<Int, Int>;
    testMap51: map<Int, Int>;
    testMap52: map<Int, Int>;
    testMap53: map<Int, Int>;
    testMap54: map<Int, Int>;
    testMap55: map<Int, Int>;
    testMap56: map<Int, Int>;
    testMap57: map<Int, Int>;
    testMap58: map<Int, Int>;
    testMap59: map<Int, Int>; 
    testMap60: map<Int, Int>;
    testMap61: map<Int, Int>;
    testMap62: map<Int, Int>;

    get fun getTest0(index: Int): Int? {
        let val: Int = self.testMap0.get(index)!!;
        val = val + self.testMap1.get(index)!!;
        val = val + self.testMap2.get(index)!!;
        val = val + self.testMap3.get(index)!!;
        val = val + self.testMap4.get(index)!!;
        val = val + self.testMap5.get(index)!!;
        val = val + self.testMap6.get(index)!!;
        val = val + self.testMap7.get(index)!!; // error
        val = val + self.testMap8.get(index)!!;
        val = val + self.testMap9.get(index)!!;
        val = val + self.testMap10.get(index)!!;
        return val;
    }

    get fun getTest1(index: Int): Int? {
        let val: Int = self.testMap1.get(index)!!;
        return val;
    }

    get fun getTest2(index: Int): Int? {
        let val: Int = self.testMap2.get(index)!!;
        return val;
    }

    get fun getTest3(index: Int): Int? {
        let val: Int = self.testMap3.get(index)!!;
        return val;
    }

    get fun getTest4(index: Int): Int? {
        let val: Int = self.testMap4.get(index)!!;
        return val;
    }

    get fun getTest5(index: Int): Int? {
        let val: Int = self.testMap5.get(index)!!;
        return val;
    }

    get fun getTest6(index: Int): Int? {
        let val: Int = self.testMap6.get(index)!!;
        return val;
    }

    get fun getTest7(index: Int): Int? {
        let val: Int = self.testMap7.get(index)!!;
        return val;
    }

    get fun getTest8(index: Int): Int? {
        let val: Int = self.testMap8.get(index)!!;
        return val;
    }

    get fun getTest9(index: Int): Int? {
        let val: Int = self.testMap9.get(index)!!;
        return val;
    }

    get fun getTest10(index: Int): Int? {
        let val: Int = self.testMap10.get(index)!!;
        return val;
    }

    get fun getTest11(index: Int): Int? {
        let val: Int = self.testMap11.get(index)!!;
        return val;
    }

    get fun getTest12(index: Int): Int? {
        let val: Int = self.testMap12.get(index)!!;
        return val;
    }

    get fun getTest13(index: Int): Int? {
        let val: Int = self.testMap13.get(index)!!;
        return val;
    }

    get fun getTest14(index: Int): Int? {
        let val: Int = self.testMap14.get(index)!!;
        return val;
    }

    get fun getTest15(index: Int): Int? {
        let val: Int = self.testMap15.get(index)!!;
        return val;
    }

    get fun getTest16(index: Int): Int? {
        let val: Int = self.testMap16.get(index)!!;
        return val;
    }

    get fun getTest17(index: Int): Int? {
        let val: Int = self.testMap17.get(index)!!;
        return val;
    }

    get fun getTest18(index: Int): Int? {
        let val: Int = self.testMap18.get(index)!!;
        return val;
    }

    get fun getTest19(index: Int): Int? {
        let val: Int = self.testMap19.get(index)!!;
        return val;
    }

    get fun getTest20(index: Int): Int? {
        let val: Int = self.testMap20.get(index)!!;
        return val;
    }

    get fun getTest21(index: Int): Int? {
        let val: Int = self.testMap21.get(index)!!;
        return val;
    }

    get fun getTest22(index: Int): Int? {
        let val: Int = self.testMap22.get(index)!!;
        return val;
    }

    get fun getTest23(index: Int): Int? {
        let val: Int = self.testMap23.get(index)!!;
        return val;
    }

    get fun getTest24(index: Int): Int? {
        let val: Int = self.testMap24.get(index)!!;
        return val;
    }

    get fun getTest25(index: Int): Int? {
        let val: Int = self.testMap25.get(index)!!;
        return val;
    }

    get fun getTest26(index: Int): Int? {
        let val: Int = self.testMap26.get(index)!!;
        return val;
    }

    get fun getTest27(index: Int): Int? {
        let val: Int = self.testMap27.get(index)!!;
        return val;
    }

    get fun getTest28(index: Int): Int? {
        let val: Int = self.testMap28.get(index)!!;
        return val;
    }

    get fun getTest29(index: Int): Int? {
        let val: Int = self.testMap29.get(index)!!;
        return val;
    }

    get fun getTest30(index: Int): Int? {
        let val: Int = self.testMap30.get(index)!!;
        return val;
    }

    get fun getTest31(index: Int): Int? {
        let val: Int = self.testMap31.get(index)!!;
        return val;
    }

    get fun getTest32(index: Int): Int? {
        let val: Int = self.testMap32.get(index)!!;
        return val;
    }

    get fun getTest33(index: Int): Int? {
        let val: Int = self.testMap33.get(index)!!;
        return val;
    }

    get fun getTest34(index: Int): Int? {
        let val: Int = self.testMap34.get(index)!!;
        return val;
    }

    get fun getTest35(index: Int): Int? {
        let val: Int = self.testMap35.get(index)!!;
        return val;
    }

    get fun getTest36(index: Int): Int? {
        let val: Int = self.testMap36.get(index)!!;
        return val;
    }

    get fun getTest37(index: Int): Int? {
        let val: Int = self.testMap37.get(index)!!;
        return val;
    }

    get fun getTest38(index: Int): Int? {
        let val: Int = self.testMap38.get(index)!!;
        return val;
    }

    get fun getTest39(index: Int): Int? {
        let val: Int = self.testMap39.get(index)!!;
        return val;
    }

    get fun getTest40(index: Int): Int? {
        let val: Int = self.testMap40.get(index)!!;
        return val;
    }

    get fun getTest41(index: Int): Int? {
        let val: Int = self.testMap41.get(index)!!;
        return val;
    }

    get fun getTest42(index: Int): Int? {
        let val: Int = self.testMap42.get(index)!!;
        return val;
    }

    get fun getTest43(index: Int): Int? {
        let val: Int = self.testMap43.get(index)!!;
        return val;
    }

    get fun getTest44(index: Int): Int? {
        let val: Int = self.testMap44.get(index)!!;
        return val;
    }

    get fun getTest45(index: Int): Int? {
        let val: Int = self.testMap45.get(index)!!;
        return val;
    }

    get fun getTest46(index: Int): Int? {
        let val: Int = self.testMap46.get(index)!!;
        return val;
    }

    get fun getTest47(index: Int): Int? {
        let val: Int = self.testMap47.get(index)!!;
        return val;
    }

    get fun getTest48(index: Int): Int? {
        let val: Int = self.testMap48.get(index)!!;
        return val;
    }

    get fun getTest49(index: Int): Int? {
        let val: Int = self.testMap49.get(index)!!;
        return val;
    }

    get fun getTest50(index: Int): Int? {
        let val: Int = self.testMap50.get(index)!!;
        return val;
    }

    get fun getTest51(index: Int): Int? {
        let val: Int = self.testMap51.get(index)!!;
        return val;
    }

    get fun getTest52(index: Int): Int? {
        let val: Int = self.testMap52.get(index)!!;
        return val;
    }

    get fun getTest53(index: Int): Int? {
        let val: Int = self.testMap53.get(index)!!;
        return val;
    }

    get fun getTest54(index: Int): Int? {
        let val: Int = self.testMap54.get(index)!!;
        return val;
    }

    get fun getTest55(index: Int): Int? {
        let val: Int = self.testMap55.get(index)!!;
        return val;
    }

    get fun getTest56(index: Int): Int? {
        let val: Int = self.testMap56.get(index)!!;
        return val;
    }

    get fun getTest57(index: Int): Int? {
        let val: Int = self.testMap57.get(index)!!;
        return val;
    }

    get fun getTest58(index: Int): Int? {
        let val: Int = self.testMap58.get(index)!!;
        return val;
    }

    get fun getTest59(index: Int): Int? {
        let val: Int = self.testMap59.get(index)!!;
        return val;
    }

    get fun getTest60(index: Int): Int? {
        let val: Int = self.testMap0.get(index)!!;
        return val;
    }

    get fun getTest61(index: Int): Int? {
        let val: Int = self.testMap1.get(index)!!;
        return val;
    }

    get fun getTest62(index: Int): Int? {
        let val: Int = self.testMap2.get(index)!!;
        return val;
    }

    get fun getTest63(index: Int): Int? {
        let val: Int = self.testMap3.get(index)!!;
        return val;
    }

    get fun getTest64(index: Int): Int? {
        let val: Int = self.testMap4.get(index)!!;
        return val;
    }

    get fun getTest65(index: Int): Int? {
        let val: Int = self.testMap5.get(index)!!;
        return val;
    }

    get fun getTest66(index: Int): Int? {
        let val: Int = self.testMap6.get(index)!!;
        return val;
    }

    get fun getTest67(index: Int): Int? {
        let val: Int = self.testMap7.get(index)!!;
        return val;
    }

    get fun getTest68(index: Int): Int? {
        let val: Int = self.testMap8.get(index)!!;
        return val;
    }

    get fun getTest69(index: Int): Int? {
        let val: Int = self.testMap9.get(index)!!;
        return val;
    }

    get fun getTest70(index: Int): Int? {
        let val: Int = self.testMap0.get(index)!!;
        return val;
    }

    get fun getTest71(index: Int): Int? {
        let val: Int = self.testMap1.get(index)!!;
        return val;
    }

    get fun getTest72(index: Int): Int? {
        let val: Int = self.testMap2.get(index)!!;
        return val;
    }

    get fun getTest73(index: Int): Int? {
        let val: Int = self.testMap3.get(index)!!;
        return val;
    }

    get fun getTest74(index: Int): Int? {
        let val: Int = self.testMap4.get(index)!!;
        return val;
    }

    get fun getTest75(index: Int): Int? {
        let val: Int = self.testMap5.get(index)!!;
        return val;
    }
}


## map-uint-bool-get.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/map-uint-bool-get.tact)
contract MapUintBool {
    m: map<Int as uint64, Bool>;

    receive() {
        nativeThrowUnless(1024, self.m.get(0) == null);
        self.m.set(0, true);
        self.m.del(0);
    }
}


## message-opcode-parsing.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/message-opcode-parsing.tact)
message(0b101010) Binary {}
message(0o53) Octal {}
message(44) Decimal {}
message(0x2D) Hexadecimal {}

contract Example {
    receive(msg: Binary) { }
    receive(msg: Octal) { }
    receive(msg: Decimal) { }
    receive(msg: Hexadecimal) { }
}


## mutating-method-on-non-lvalues.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/mutating-method-on-non-lvalues.tact)
struct Foo { x : Int }

extends mutates fun inc(self: Int) { self += 1 }

const GlobalConst: Int = 42;

contract MutatingMethodOnNonLvalues {
    const ContractConst: Int = 43;

    receive("foo") {
        41.inc();
        GlobalConst.inc();
        self.ContractConst.inc();
        Foo {x: 44}.x.inc();
    }
}



## struct-field-func-keywords-name-clash.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/struct-field-func-keywords-name-clash.tact)
struct FunCKeywords {
    var: Int;
    ifnot: Int;
    then: Int;
    elseifnot: Int;
    int: Int;
    cell: Int;
    slice: Int;
    builder: Int;
    cont: Int;
    tuple: Int;
    type: Int;
    forall: Int;
    extern: Int;
    global: Int;
    asm: Int;
    impure: Int;
    inline_ref: Int;
    auto_apply: Int;
    method_id: Int;
    operator: Int;
    infix: Int;
    infixl: Int;
    infixr: Int;
}

contract Bar {
    f: FunCKeywords = FunCKeywords {
        var: 1,
        ifnot: 1,
        then: 1,
        elseifnot: 1,
        int: 1,
        cell: 1,
        slice: 1,
        builder: 1,
        cont: 1,
        tuple: 1,
        type: 1,
        forall: 1,
        extern: 1,
        global: 1,
        asm: 1,
        impure: 1,
        inline_ref: 1,
        auto_apply: 1,
        method_id: 1,
        operator: 1,
        infix: 1,
        infixl: 1,
        infixr: 1,
    };
}


## struct-field-storage-annotation.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/struct-field-storage-annotation.tact)
import "@stdlib/deploy";

struct TokenInfo {
    ticker: String;
    decimals: Int as uint8; // <------ ISSUE HERE, IF WE REMOVE "as uint8", THE CODE COMPILES WITHOUT PROBLEM
}

// messages can contain maps
message Replace {
    items: map<Int, Address>;
}

contract Maps with Deployable {

    // maps with Int as key
    mi1: map<Int, TokenInfo>;
    mi2: map<Int, Bool>;
    mi3: map<Int, Int>;
    mi4: map<Int, Address>;
    
    // maps with Address as key
    ma1: map<Address, TokenInfo>;
    ma2: map<Address, Bool>;
    ma3: map<Address, Int>;
    ma4: map<Address, Address>;

    init(arg: map<Int, Bool>) {
        // no need to initialize maps if they're empty
        self.mi2 = arg;
    }

    receive("set keys") {
        // keys are Int
        self.mi1.set(17, TokenInfo{ticker: "SHIB", decimals: 9});
        self.mi2.set(0x9377433ff21832, true);
        self.mi3.set(pow(2,240), pow(2,230));
        self.mi4.set(-900, address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N"));
        // keys are Address
        self.ma1.set(address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N"), TokenInfo{ticker: "DOGE", decimals: 18});
        self.ma2.set(address("UQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqEBI"), true);
        self.ma3.set(address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N"), ton("1.23"));
        self.ma4.set(address("UQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqEBI"), myAddress());
    }

    receive("delete keys") {
        // keys are Int
        self.mi1.set(17, null);
        self.mi2.set(0x9377433ff21832, null);
        self.mi3.set(pow(2,240), null);
        self.mi4.set(-900, null);
        // keys are Address
        self.ma1.set(address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N"), null);
        self.ma2.set(address("UQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqEBI"), null);
        self.ma3.set(address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N"), null);
        self.ma4.set(address("UQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqEBI"), null);
    }

    receive("clear") {
        self.mi1 = emptyMap();
        self.mi2 = emptyMap();
        self.mi3 = emptyMap();
        self.mi4 = emptyMap();
        self.ma1 = emptyMap();
        self.ma2 = emptyMap();
        self.ma3 = emptyMap();
        self.ma4 = emptyMap();
    }

    receive(msg: Replace) {
        // replace all items in the map with those coming in the message
        self.mi4 = msg.items;
    }

    // if the key is not found, the get() method returns null
    get fun oneItem(key: Int): Address? {
        return self.mi4.get(key);
    }

    get fun itemCheck(): String {
        if (self.mi1.get(17) == null) {
            return "not found";
        }
        let item: TokenInfo = self.mi1.get(17)!!; // the !! will tell the compiler it's not null
        return item.ticker;
    }

    // you can return maps from getters
    get fun allItems(): map<Address, TokenInfo> {
        return self.ma1;
    }
}


## struct-with-default-and-optional-fields.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/struct-with-default-and-optional-fields.tact)
struct Position {
    tokenId: Int as uint16 = 1;
    foo: Int?;
}

contract Test {
    receive ("test") {
         let p: Position = Position{ };
         dump(p.tokenId);
    }
}


## var-scope-global-fun-shadowing-allowed.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/codegen/var-scope-global-fun-shadowing-allowed.tact)
contract TestGlobalFunctionShadowing {
    receive("foo") {
        let sender = sender();
    }
}


## abi-global-errors.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/abi-global-errors.spec.ts)
import { itShouldNotCompile } from "./util";

describe("abi/global.ts errors", () => {
    itShouldNotCompile({
        testName: "sha256-expects-string-or-slice",
        errorMessage: "sha256 expects string or slice argument",
    });
});


## const-eval-failed.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/const-eval-failed.spec.ts)
import { itShouldNotCompile } from "./util";

describe("fail-const-eval", () => {
    itShouldNotCompile({
        testName: "const-eval-div-by-zero",
        errorMessage:
            "Cannot evaluate expression to a constant: divisor expression must be non-zero",
    });
    itShouldNotCompile({
        testName: "const-eval-mod-by-zero",
        errorMessage:
            "Cannot evaluate expression to a constant: divisor expression must be non-zero",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-positive-literal",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-negative-literal",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '-115792089237316195423570985008687907853269984665640564039457584007913129639937' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-add",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-sub",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '-115792089237316195423570985008687907853269984665640564039457584007913129639937' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-mul1",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '231584178474632390847141970017375815706539969331281128078915168015826259279870' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-mul2",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '-231584178474632390847141970017375815706539969331281128078915168015826259279872' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-div",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-ton1",
        errorMessage: `Cannot evaluate expression to a constant: invalid "ton" argument`,
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-ton2",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-pow-1",
        errorMessage: `"pow" builtin called with negative exponent -42`,
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-pow-2",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-pow2-1",
        errorMessage: `"pow2" builtin called with negative exponent -42`,
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-pow2-2",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-shl1",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-shl2",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '-13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-struct-instance",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-shl-invalid-bits1",
        errorMessage:
            "Cannot evaluate expression to a constant: the number of bits shifted ('257') must be within [0..256] range",
    });
    itShouldNotCompile({
        testName: "const-eval-shl-invalid-bits2",
        errorMessage:
            "Cannot evaluate expression to a constant: the number of bits shifted ('-1') must be within [0..256] range",
    });
    itShouldNotCompile({
        testName: "const-eval-unboxing-null",
        errorMessage: "non-null value expected but got null",
    });
    itShouldNotCompile({
        testName: "const-eval-invalid-address",
        errorMessage:
            "Cannot evaluate expression to a constant: invalid address encoding: FQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N",
    });

    itShouldNotCompile({
        testName: "const-eval-div-by-zero-in-fun",
        errorMessage:
            "Cannot evaluate expression to a constant: divisor expression must be non-zero",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-add-in-fun",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-div-in-fun",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-mul1-in-fun",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '231584178474632390847141970017375815706539969331281128078915168015826259279870' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-mul2-in-fun",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '-231584178474632390847141970017375815706539969331281128078915168015826259279872' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-positive-literal-in-fun",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-negative-literal-in-fun",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '-115792089237316195423570985008687907853269984665640564039457584007913129639937' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-int-overflow-struct-instance-in-fun",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '115792089237316195423570985008687907853269984665640564039457584007913129639936' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-repeat-lower-bound",
        errorMessage:
            "Cannot evaluate expression to a constant: integer '-115792089237316195423570985008687907853269984665640564039457584007913129639937' does not fit into TVM Int type",
    });
    itShouldNotCompile({
        testName: "const-eval-repeat-upper-bound",
        errorMessage:
            "Cannot evaluate expression to a constant: repeat argument must be a number between -2^256 (inclusive) and 2^31 - 1 (inclusive)",
    });
    itShouldNotCompile({
        testName: "const-eval-ascii-overflow",
        errorMessage:
            "Cannot evaluate expression to a constant: ascii string is too long, expected up to 32 bytes, got 33",
    });
    itShouldNotCompile({
        testName: "const-eval-ascii-overflow-2",
        errorMessage:
            "Cannot evaluate expression to a constant: ascii string is too long, expected up to 32 bytes, got 33",
    });
    itShouldNotCompile({
        testName: "const-eval-rawslice-not-hex",
        errorMessage:
            "Cannot evaluate expression to a constant: invalid hex string: hello world",
    });
    itShouldNotCompile({
        testName: "const-eval-rawslice-overflow",
        errorMessage:
            "Cannot evaluate expression to a constant: slice constant is too long, expected up to 1023 bits, got 1024",
    });
    itShouldNotCompile({
        testName: "const-eval-rawslice-overflow-padded",
        errorMessage:
            "Cannot evaluate expression to a constant: slice constant is too long, expected up to 1023 bits, got 1024",
    });
    itShouldNotCompile({
        testName: "const-eval-rawslice-invalid",
        errorMessage:
            "Cannot evaluate expression to a constant: invalid hex string: 4a__",
    });
    itShouldNotCompile({
        testName: "const-eval-ascii-empty",
        errorMessage:
            "Cannot evaluate expression to a constant: ascii string cannot be empty",
    });
});


## contract-duplicate-opcodes.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contract-duplicate-opcodes.spec.ts)
import { itShouldNotCompile } from "./util";

describe("contract-duplicate-opcodes", () => {
    itShouldNotCompile({
        testName: "contract-duplicate-bounced-opcode",
        errorMessage:
            'Receive functions of a contract or trait cannot process messages with the same opcode: opcodes of message types "Msg2" and "Msg1" are equal',
    });
    itShouldNotCompile({
        testName: "contract-duplicate-external-opcode",
        errorMessage:
            'Receive functions of a contract or trait cannot process messages with the same opcode: opcodes of message types "Msg2" and "Msg1" are equal',
    });
    itShouldNotCompile({
        testName: "contract-duplicate-receiver-opcode",
        errorMessage:
            'Receive functions of a contract or trait cannot process messages with the same opcode: opcodes of message types "Msg2" and "Msg1" are equal',
    });
});


## func-errors.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/func-errors.spec.ts)
import { itShouldNotCompile } from "./util";

describe("func-errors", () => {
    itShouldNotCompile({
        testName: "func-function-does-not-exist",
        errorMessage:
            "Function 'iDoNotExist' does not exist in imported FunC sources",
    });
});


## scope-errors.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/scope-errors.spec.ts)
import { itShouldNotCompile } from "./util";

describe("scope-errors", () => {
    itShouldNotCompile({
        testName: "scope-const-shadows-stdlib-ident",
        errorMessage:
            'Constant "b" is shadowing an identifier defined in the Tact standard library: pick a different constant name',
    });
});


## stdlib-bugs.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/stdlib-bugs.spec.ts)
import { itShouldNotCompile } from "./util";

describe("stdlib-bugs", () => {
    itShouldNotCompile({
        testName: "stdlib-skipBits",
        errorMessage: 'Type mismatch: "<void>" is not assignable to "Slice"',
    });
});


## tact.config.json (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/tact.config.json)
{
  "$schema": "http://raw.githubusercontent.com/tact-lang/tact/main/schemas/configSchema.json",
  "projects": [
    {
      "name": "const-eval-invalid-address",
      "path": "./contracts/const-eval-invalid-address.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-div-by-zero",
      "path": "./contracts/const-eval-div-by-zero.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-mod-by-zero",
      "path": "./contracts/const-eval-mod-by-zero.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-positive-literal",
      "path": "./contracts/const-eval-int-overflow-positive-literal.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-negative-literal",
      "path": "./contracts/const-eval-int-overflow-negative-literal.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-add",
      "path": "./contracts/const-eval-int-overflow-add.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-sub",
      "path": "./contracts/const-eval-int-overflow-sub.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-mul1",
      "path": "./contracts/const-eval-int-overflow-mul1.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-mul2",
      "path": "./contracts/const-eval-int-overflow-mul2.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-div",
      "path": "./contracts/const-eval-int-overflow-div.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-ton1",
      "path": "./contracts/const-eval-int-overflow-ton1.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-ton2",
      "path": "./contracts/const-eval-int-overflow-ton2.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-pow-1",
      "path": "./contracts/const-eval-int-overflow-pow-1.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-pow-2",
      "path": "./contracts/const-eval-int-overflow-pow-2.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-pow2-1",
      "path": "./contracts/const-eval-int-overflow-pow2-1.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-pow2-2",
      "path": "./contracts/const-eval-int-overflow-pow2-2.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-shl1",
      "path": "./contracts/const-eval-int-overflow-shl1.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-shl2",
      "path": "./contracts/const-eval-int-overflow-shl2.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-struct-instance",
      "path": "./contracts/const-eval-int-overflow-struct-instance.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-shl-invalid-bits1",
      "path": "./contracts/const-eval-shl-invalid-bits1.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-shl-invalid-bits2",
      "path": "./contracts/const-eval-shl-invalid-bits2.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-unboxing-null",
      "path": "./contracts/const-eval-unboxing-null.tact",
      "output": "./contracts/output"
    },
    {
      "name": "stdlib-skipBits",
      "path": "./contracts/stdlib-skipBits.tact",
      "output": "./contracts/output"
    },
    {
      "name": "contract-duplicate-bounced-opcode",
      "path": "./contracts/contract-duplicate-bounced-opcode.tact",
      "output": "./contracts/output"
    },
    {
      "name": "contract-duplicate-external-opcode",
      "path": "./contracts/contract-duplicate-external-opcode.tact",
      "output": "./contracts/output",
      "options": { "external": true }
    },
    {
      "name": "contract-duplicate-receiver-opcode",
      "path": "./contracts/contract-duplicate-receiver-opcode.tact",
      "output": "./contracts/output"
    },
    {
      "name": "func-function-does-not-exist",
      "path": "./contracts/func-function-does-not-exist.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-div-by-zero-in-fun",
      "path": "./contracts/const-eval-div-by-zero-in-fun.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-add-in-fun",
      "path": "./contracts/const-eval-int-overflow-add-in-fun.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-div-in-fun",
      "path": "./contracts/const-eval-int-overflow-div-in-fun.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-mul1-in-fun",
      "path": "./contracts/const-eval-int-overflow-mul1-in-fun.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-mul2-in-fun",
      "path": "./contracts/const-eval-int-overflow-mul2-in-fun.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-positive-literal-in-fun",
      "path": "./contracts/const-eval-int-overflow-positive-literal-in-fun.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-negative-literal-in-fun",
      "path": "./contracts/const-eval-int-overflow-negative-literal-in-fun.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-int-overflow-struct-instance-in-fun",
      "path": "./contracts/const-eval-int-overflow-struct-instance-in-fun.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-repeat-lower-bound",
      "path": "./contracts/const-eval-repeat-lower-bound.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-repeat-upper-bound",
      "path": "./contracts/const-eval-repeat-upper-bound.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-ascii-overflow",
      "path": "./contracts/const-eval-ascii-overflow.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-ascii-overflow-2",
      "path": "./contracts/const-eval-ascii-overflow-2.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-rawslice-not-hex",
      "path": "./contracts/const-eval-rawslice-not-hex.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-rawslice-overflow",
      "path": "./contracts/const-eval-rawslice-overflow.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-rawslice-overflow-padded",
      "path": "./contracts/const-eval-rawslice-overflow-padded.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-rawslice-invalid",
      "path": "./contracts/const-eval-rawslice-invalid.tact",
      "output": "./contracts/output"
    },
    {
      "name": "const-eval-ascii-empty",
      "path": "./contracts/const-eval-ascii-empty.tact",
      "output": "./contracts/output"
    },
    {
      "name": "scope-const-shadows-stdlib-ident",
      "path": "./contracts/scope-const-shadows-stdlib-ident.tact",
      "output": "./contracts/output"
    },
    {
      "name": "sha256-expects-string-or-slice",
      "path": "./contracts/sha256-expects-string-or-slice.tact",
      "output": "./contracts/output"
    }
  ]
}


## util.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/util.ts)
import { run } from "../../node";

// helper to reduce boilerplate
export function itShouldNotCompile(params: {
    testName: string;
    errorMessage: string;
}) {
    it(`should not compile ${params.testName}`, async () => {
        const result = await run({
            configPath: __dirname + "/tact.config.json",
            projectNames: [params.testName],
            suppressLog: true,
        });
        expect(result.ok).toBe(false);
        const message = result.error.map((err) => err.message).join("; ");
        expect(message).toContain(params.errorMessage);
    });
}


## const-eval-ascii-empty.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-ascii-empty.tact)
contract AsciiOverflow {
    get fun getAscii_fail(): Int {
        return ascii("");
    }
}

## const-eval-ascii-overflow-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-ascii-overflow-2.tact)
contract AsciiOverflow {
    get fun getAscii_fail(): Int {
        return ascii("⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡");
    }
}

## const-eval-ascii-overflow.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-ascii-overflow.tact)
contract AsciiOverflow {
    get fun getAscii_fail(): Int {
        return ascii("000000000000000000000000000000000");
    }
}

## const-eval-div-by-zero-in-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-div-by-zero-in-fun.tact)
fun functionTest(): Int {
    let result = 100;
    let i = 2;
    repeat(5) {
        i -= 1;
        result /= i;
    }
    return result;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest();
    }
}


## const-eval-div-by-zero.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-div-by-zero.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        return 2 / 0;
    }
}


## const-eval-int-overflow-add-in-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-add-in-fun.tact)
fun functionTest(v: Int): Int {
    // (2 ** 256 - 2)
    let result = 115792089237316195423570985008687907853269984665640564039457584007913129639934;
    if (v >= 10) {
        result += 1;
        if (v >= 15) {
            result += 1;
        }
    }
    return result;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest(15);
    }
}

## const-eval-int-overflow-add.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-add.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // (2 ** 256 - 1) + 1
        return 115792089237316195423570985008687907853269984665640564039457584007913129639935 + 1;
    }
}


## const-eval-int-overflow-div-in-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-div-in-fun.tact)
fun functionTest(v: Int): Int {
    // -(2 ** 256)
    let result = -115792089237316195423570985008687907853269984665640564039457584007913129639936;
    if (v >= 10) {
        result /= -1;
    }
    return result;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest(10);
    }
}


## const-eval-int-overflow-div.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-div.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // -(2 ** 256) / -1
        return -115792089237316195423570985008687907853269984665640564039457584007913129639936 / -1;
    }
}


## const-eval-int-overflow-mul1-in-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-mul1-in-fun.tact)
fun functionTest(): Int {
    // (2 ** 256 - 1)
    let result = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
    repeat(5) {
        result *= 2;
    }
    return result;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest();
    }
}


## const-eval-int-overflow-mul1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-mul1.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // 2 * (2 ** 256 - 1)
        return 2 * 115792089237316195423570985008687907853269984665640564039457584007913129639935;
    }
}


## const-eval-int-overflow-mul2-in-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-mul2-in-fun.tact)
fun functionTest(): Int {
    // -(2 ** 256)
    let result = -115792089237316195423570985008687907853269984665640564039457584007913129639936;
    do {
        result *= 2;
    } until (false);
    return result;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest();
    }
}


## const-eval-int-overflow-mul2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-mul2.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // 2 * -(2 ** 256)
        return 2 * -115792089237316195423570985008687907853269984665640564039457584007913129639936;
    }
}


## const-eval-int-overflow-negative-literal-in-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-negative-literal-in-fun.tact)
fun functionTest(): Int {
    repeat(5) {
        // - (2 ** 256 + 1)
        let i = -115792089237316195423570985008687907853269984665640564039457584007913129639937;
    }
    return 0;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest();
    }
}


## const-eval-int-overflow-negative-literal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-negative-literal.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // - (2 ** 256 + 1)
        // actually Tact does not have proper negative integer literals
        // there is a special case for a unary negation of positive literals hardcoded
        // into the const evaluator
        return -115792089237316195423570985008687907853269984665640564039457584007913129639937;
    }
}


## const-eval-int-overflow-positive-literal-in-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-positive-literal-in-fun.tact)
fun functionTest(): Int {
    while (true) {
        // 2 ** 256
        let i = 115792089237316195423570985008687907853269984665640564039457584007913129639936;
    }
    return 0;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest();
    }
}


## const-eval-int-overflow-positive-literal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-positive-literal.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // 2 ** 256
        return 115792089237316195423570985008687907853269984665640564039457584007913129639936;
    }
}


## const-eval-int-overflow-pow-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-pow-1.tact)
contract ConstEvalNegativeTest {
    get fun test_pow(): Int {
        // negative exponent
        return pow(1, -42);
    }
}


## const-eval-int-overflow-pow-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-pow-2.tact)
contract ConstEvalNegativeTest {
    get fun test_pow(): Int {
        // integer overflow
        return pow(-2, 256);
    }
}


## const-eval-int-overflow-pow2-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-pow2-1.tact)
contract ConstEvalNegativeTest {
    get fun test_pow(): Int {
        // negative exponent
        return pow2(-42);
    }
}


## const-eval-int-overflow-pow2-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-pow2-2.tact)
contract ConstEvalNegativeTest {
    get fun test_pow(): Int {
        // integer overflow
        return pow2(256);
    }
}


## const-eval-int-overflow-shl1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-shl1.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        return 1 << 256;
    }
}


## const-eval-int-overflow-shl2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-shl2.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        return -115792089237316195423570985008687907853269984665640564039457584007913129639936 << 256;
    }
}


## const-eval-int-overflow-struct-instance-in-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-struct-instance-in-fun.tact)
struct Foo {
    x: Int;
    y: Bool;
}

// Overflow in recursive call
fun functionTest(i: Int): Int {
    functionTest(2 * i);
    return 0;
}

contract ConstEvalNegativeTest {
    get fun test_struct(): Foo {
        return Foo {y: false, x: functionTest(pow2(253))};
    }
}


## const-eval-int-overflow-struct-instance.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-struct-instance.tact)
struct Foo {
    x: Int;
    y: Bool;
}

contract ConstEvalNegativeTest {
    get fun test_struct(): Foo {
        return Foo {y: false, x: pow2(255) * 2};
    }
}


## const-eval-int-overflow-sub.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-sub.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // -2 - (2**256 - 1)
        return -2 - 115792089237316195423570985008687907853269984665640564039457584007913129639935;
    }
}


## const-eval-int-overflow-ton1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-ton1.tact)
contract ConstEvalNegativeTest {
    get fun test_ton(): Int {
        // too many digits after the decimal point
        return ton("1.0123456789");
    }
}


## const-eval-int-overflow-ton2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-int-overflow-ton2.tact)
contract ConstEvalNegativeTest {
    get fun test_ton(): Int {
        // the number of tons does not fit TVM int
        return ton("115792089237316195423570985008687907853269984665640564039457584007913.129639936");
    }
}


## const-eval-invalid-address.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-invalid-address.tact)
contract ConstEvalNegativeTest {
    get fun test_address(): Address {
        return address("FQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N");
    }
}


## const-eval-mod-by-zero.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-mod-by-zero.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        return 2 % 0;
    }
}


## const-eval-rawslice-invalid.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-rawslice-invalid.tact)
contract AsciiOverflow {
    get fun getRawSlice_fail(): Slice {
        return rawSlice("4a__");
    }
}

## const-eval-rawslice-not-hex.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-rawslice-not-hex.tact)
contract AsciiOverflow {
    get fun getRawSlice_fail(): Slice {
        return rawSlice("hello world");
    }
}

## const-eval-rawslice-overflow-padded.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-rawslice-overflow-padded.tact)
contract AsciiOverflow {
    get fun getRawSlice_fail(): Slice {
        return rawSlice("abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd8_");
    }
}

## const-eval-rawslice-overflow.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-rawslice-overflow.tact)
contract AsciiOverflow {
    get fun getRawSlice_fail(): Slice {
        return rawSlice("abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd");
    }
}

## const-eval-repeat-lower-bound.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-repeat-lower-bound.tact)
fun functionTest(): Int {
    // -(2 ** 256)
    let i = -115792089237316195423570985008687907853269984665640564039457584007913129639936;
    repeat (i - 1) {  // Causes an overflow error
        // do nothing
    }
    return i;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest();
    }
}


## const-eval-repeat-upper-bound.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-repeat-upper-bound.tact)
fun functionTest(): Int {
    // (2 ** 31 - 1)
    let i = 2147483647;
    repeat (i + 1) {  // Causes a repeat bound error
        // do nothing
    }
    return i;
}

contract ConstEvalNegativeTest {
    get fun something(): Int {
        return functionTest();
    }
}


## const-eval-shl-invalid-bits1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-shl-invalid-bits1.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // the number of shifted bits is too large
        return 0 << 257;
    }
}


## const-eval-shl-invalid-bits2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-shl-invalid-bits2.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        // the number of shifted bits cannot be negative
        return 1 << -1;
    }
}


## const-eval-unboxing-null.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/const-eval-unboxing-null.tact)
contract ConstEvalNegativeTest {
    get fun something(): Int {
        return (false ? 42 : null)!!;
    }
}


## contract-duplicate-bounced-opcode.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/contract-duplicate-bounced-opcode.tact)
message(1) Msg1 {}
message(1) Msg2 {}

contract Test {
    bounced(msg: Msg1) { }
    bounced(msg: Msg2) { }
}



## contract-duplicate-external-opcode.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/contract-duplicate-external-opcode.tact)
message(1) Msg1 {}
message(1) Msg2 {}

contract Test {
    external(msg: Msg1) { }
    external(msg: Msg2) { }
}



## contract-duplicate-receiver-opcode.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/contract-duplicate-receiver-opcode.tact)
message(1) Msg1 {}
message(1 + 0) Msg2 {}

contract Test {
    receive(msg: Msg1) { }
    receive(msg: Msg2) { }
}



## func-function-does-not-exist.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/func-function-does-not-exist.tact)
@name(iDoNotExist)
native youDo();

contract Test {
   get fun test() {
       youDo();
   }
}

## scope-const-shadows-stdlib-ident.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/scope-const-shadows-stdlib-ident.tact)
const b: Int = 42;


## sha256-expects-string-or-slice.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/sha256-expects-string-or-slice.tact)
contract Sha256 {
    val: Int = 0;
    receive() {
        sha256(self.val);
    }
}


## stdlib-skipBits.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/compilation-failed/contracts/stdlib-skipBits.tact)
contract StdlibSkipBits {
    receive() {
        let s: Slice = beginCell().storeUint(123, 64).endCell().asSlice();
        let r: Int = s.loadUint(1);
        s.skipBits(1);
        let x: Slice = s.skipBits(1);
    }
}


## attributes.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/attributes.tact)
extends mutates fun fun1(self: Int, c: Int) {
    let res: Int = 1;
    repeat (c) {
        res *= self;
    }
    self = res;
}

mutates extends fun fun2(self: Int, c: Int) {
    let res: Int = 1;
    repeat (c) {
        res *= self;
    }
    self = res;
}


## case-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-1.tact)
struct Source {
    a: Int;
    b: Int;
    c: Int;
    d: Int;
}

fun isZero(x: Int, y: Int, z: Bool, m: Source): Bool {
    let b: Int = x + y;
    b = b + 1 + m.a + m.b;
    let c: Int = y >> 123;
    let d: Int = x << 10;
    return b > 0 && z && c == 0 && d == 0;
}

contract Empty {
    init() {}

    get fun a(x: Int, y: Int, z: Bool, m: Source): Bool {
        return isZero(x, y, z, m);
    }
}


## case-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-2.tact)
struct Source {
    a: Int;
    b: Int;
}

fun isZero(x: Int, y: Int, z: Bool, m: Source): Bool {
    m.b = 10;
    return x + m.b > 0 && z;
}

contract Empty {
    init() {}
}

## case-3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-3.tact)
struct Source {
    a: Int;
    b: Int;
}

fun isZero(x: Int, y: Int, z: Bool, m: Source): Bool {
    m.b = 10;
    return 2 * x + m.b > 0 && z;
}

contract SampleContract {
    a: Int;
    b: Int;
    c: Source;

    init() {
        self.a = 0;
        self.b = 0;
        self.c = Source{a: 0, b: 0};
    }

    fun addStake() {
        self.a = 10;
        self.b = -20;
        self.c = Source{a: 10, b: 20};
    }

    get fun stake(): Int {
        return self.a;
    }
}

## case-4.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-4.tact)
import "@stdlib/deploy";

primitive NInt;

struct Source {
    a: Int;
    b: Int;
}

@name(store_uint)
native storeUint(s: Builder, value: Int, bits: Int): Builder;

fun isZero(x: Int, y: Int, z: Bool, m: Source): Bool {
    m.b = 10;
    return x + m.b > 0 && z;
}

const a: Int = 0;
const s: String = "string";
const t: Bool = true;
const f: Bool = false;

contract SampleContract {
    a: Int;
    b: Int;
    c: Source;
    d: map<Int, Int>;

    const e: Int = 42;

    init() {
        self.a = 0;
        self.b = 0;
        self.c = Source{a: 0, b: 0};
    }

    fun addStake() {
        let d: Int? = null;
        self.a = 10;
        d = a > 0 ? self.a : 0;
        let res: Bool = isZero(1, 2, false, self.c);
        let e = 42;
        self.b = a;
        self.c = Source{a: 10, b: 20};
    }

    get fun stake(): Int {
        self.addStake();
        return self.a;
    }

    receive("increment") {
        self.a -= 1;
    }
}


## case-asm-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-asm-fun.tact)
asm fun keccak256(s: Slice): Int {
    1
    INT
    HASHEXT_KECCAK256
}

asm( -> 1 0) extends fun loadCoins(self: Slice): Int {
    LDVARUINT16
}

asm(c b) extends fun storeDict(b: Builder, c: Cell) {
    STDICT
}

asm(s len -> 1 0) extends fun loadInt(self: Slice, len: Int): Int {
    LDIX
}


## case-augmented-assign.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-augmented-assign.tact)
contract SampleContract {
    a: Int;

    init() {
        self.a = 0;
        self.a += 2;
        self.a -= 1;
        self.a *= 2;
        self.a /= 2;
        self.a %= 5;
    }
}

## case-bin-ops.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-bin-ops.tact)
contract SampleContract {
    a: Int;

    init() {
        self.a = (1 + 2 - 3) / 4 % 5 | 255 & 53 ^ 2;
        if (1 > 2 || 3 == 0 && (5 - 3) * 10 > 0) {

        }
    }
}

## case-destructuring.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-destructuring.tact)
struct S {
    a: Int;
    b: Int;
    c: Int;
}

message M {
    a: Int;
    b: Int;
}

fun testFunc(): Int {
    let s = S{a: 1, b: 2, c: 3};
    let S {a, b, c} = s;
    let S {a: a1, ..} = s;
    let S {b: b1, ..} = s;
    let S {c: c1, ..} = s;
    let S {a: a2, b: b2, ..} = s;
    let S {a: a3, c: c3, ..} = s;
    let S {b: b4, c: c4, ..} = s;
    let m = M{a: 1, b: 2};
    let M {a: a_m, b: b_m} = m;
    return a + b + c + a1 + b1 + c1 + a2 + b2 + a3 + c3 + b4 + c4 + a_m + b_m;
}

## case-if.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-if.tact)
fun checkIf(x: Int, y: Int): Int {
    if (x < y) {
        return x;
    } else {
        return y;
    }
}

contract SampleContract {
    x: Int as int32;

    init() {
        if (1 > 0) {
            if (2 > 3) {
                self.x = 1;
            } else {
                self.x = 2;
            }
        } else {
            self.x = 0;
        }
    }
}

## case-initOf.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-initOf.tact)
contract A {
    a: Int;
    b: Bool;

    init(a: Int, b: Bool) {
        self.a = a;
        self.b = b;
    }
}

contract B {
    init() {
        initOf A(1, false);
    }
}

## case-loops.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-loops.tact)
contract SampleContract {
    x: Int;
    y: map<Int, Int>;

    init() {
        self.x = 5;
        self.y = emptyMap();
        self.y.set(1, 42);
        elf.y.set(2, 3);
        let y: map<Int, Int> = emptyMap();
        y.set(1, 42);
        y.set(2, 3);
        while (self.x > 0) {
            self.x = self.x - 1;
        }
        repeat (self.x) {
            self.x += self.x;
        }
        do {
            self.x = self.x + 1;
        } until (self.x < 10);
        foreach (k, v in y) {
            self.x += v;
        }
        foreach (k, v in self.y) {
            self.x += v;
        }
    }
}

## case-message-opcode.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-message-opcode.tact)
message(0xdeadbeef) MyMessageHex {
    x: Int;
}

message(3735928559) MyMessageDec {
    x: Int;
    y: Int;
}

message(0o33653337357) MyMessageOct {
    x: Int;
    y: Int;
    z: Int;
}

message(0b11011110101011011011111011101111) MyMessageBin {
    x: Int;
    y: Int;
    z: Int;
    w: Int;
}

message MyMessageAuto {
    value: Int;
}

const DEADBEEF: Int = 0xdeadbeef;

message(DEADBEEF + 1) MyMessageWithExprOpcode {
    a: Int;
}

contract TestContract {
}


## case-priority.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-priority.tact)
contract Priority {
    x: Bool;
    y: Int;

    init() {
        self.x = true || true && true == 5 < 6 << 9 + 7 * 8;
        self.x = true || true && true != 5 > 6 >> 9 - 7 / 8;
        self.x = true || true && true != 5 <= 6 >> 9 - 7 % 8;
        self.x = true || true && true != 5 >= 6 >> 9 - 7 % 8;
        self.y = 1 | 2 ^ 3 & 6 >> 9 - 7 % 8;
        self.x = (true ? true : false) ? 1 : 2;
        self.x = true ? (true ? 1 : 2) : 3;
        self.x = false ? 1 : false ? 2 : 3;
        self.x = +self.x!!;
        self.x = (+self.x)!!;
    }
}


## case-receive.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-receive.tact)
message MyMessage {
    value: Int;
}

contract ReceiveTestContract {
    a: Int;

    init() {
        self.a = 0;
    }

    receive() {
        self.a = 1;
    }

    receive("message") {
        self.a = 2;
    }

    receive(m: MyMessage) {
        self.a = m.value;
    }

    bounced(m: bounced<MyMessage>) {
        self.a = 3;
    }

    external() {
        self.a = 4;
        acceptMessage();
    }

    external("message") {
        self.a = 5;
        acceptMessage();
    }

    external(m: MyMessage) {
        self.a = m.value;
        acceptMessage();
    }
}

## case-traits.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-traits.tact)
@interface("") trait B {
}

trait C {
    abstract get fun d(e: String): String;
}

trait Ownable with B {
    owner: Address;
    value: Int;

    const someNum: Int = 2;
    abstract const something: Int;

    receive("message") {

    }

    fun requireOwner() {
        nativeThrowUnless(132, context().sender == self.owner);
    }

    get fun owner(): Address {
        return self.owner;
    }
}

@interface("a") contract Treasure with Ownable {
    owner: Address;
    value: Int;

    const something: Int = 2;

    init(owner: Address) {
        self.owner = owner;
        self.value = 1;
    }
}

## case-trycatch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/case-trycatch.tact)
fun braveAndTrue() {
    try {
        nativeThrow(42);
    }
    dump(42);
}

fun niceCatch() {
    try {
        nativeThrow(42);
    } catch (err) {
        dump(err);
    }
}

## getter-with-method-id-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/getter-with-method-id-const.tact)
const FOO: Int = crc32("crc32") + 42;

contract Test {
    get(FOO) fun test(): Int {
        return FOO;
    }
}


## getter-with-method-id.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/getter-with-method-id.tact)
contract Test {
    get(crc32("crc32") + 42 & 0x3ffff | 0x4000) fun test(): Int {
        return 0;
    }
}



## native-functions.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/native-functions.tact)
@name(hello_world)
native helloWorld(): Int;

@name(__tact_compute_contract_address)
native contractAddressExt(chain: Int, code: Cell, data: Cell): Address;


## attributes.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/attributes.tact)
extends mutates fun function_def_0(self: Int, c: Int) {
    let res: Int = 1;
    repeat (c) {
        res *= self;
    }
    self = res;
}

extends mutates fun function_def_0(self: Int, c: Int) {
    let res: Int = 1;
    repeat (c) {
        res *= self;
    }
    self = res;
}



## case-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-1.tact)
struct struct_decl_0 {
    a: Int;
    b: Int;
    c: Int;
    d: Int;
}

fun function_def_1(x: Int, y: Int, z: Bool, m: Source): Bool {
    let b: Int = x + y;
    b = b + 1 + m.a + m.b;
    let c: Int = y >> 123;
    let d: Int = x << 10;
    return b > 0 && z && c == 0 && d == 0;
}

contract contract_2 {
    init() {}

    get fun function_def_3(x: Int, y: Int, z: Bool, m: Source): Bool {
        return isZero(x, y, z, m);
    }
}


## case-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-2.tact)
struct struct_decl_0 {
    a: Int;
    b: Int;
}

fun function_def_1(x: Int, y: Int, z: Bool, m: Source): Bool {
    m.b = 10;
    return x + m.b > 0 && z;
}

contract contract_2 {
    init() {}
}


## case-3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-3.tact)
struct struct_decl_0 {
    a: Int;
    b: Int;
}

fun function_def_1(x: Int, y: Int, z: Bool, m: Source): Bool {
    m.b = 10;
    return 2 * x + m.b > 0 && z;
}

contract contract_2 {
    a: Int;
    b: Int;
    c: Source;

    init() {
        self.a = 0;
        self.b = 0;
        self.c = Source{a: 0, b: 0};
    }

    fun function_def_3() {
        self.a = 10;
        self.b = -20;
        self.c = Source{a: 10, b: 20};
    }

    get fun function_def_4(): Int {
        return self.a;
    }
}


## case-4.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-4.tact)
import "@stdlib/deploy";

primitive NInt;

@name(store_uint)
native native_store_uint(s: Builder, value: Int, bits: Int): Builder;

struct struct_decl_0 {
    a: Int;
    b: Int;
}

const constant_def_2: Int = 0;
const constant_def_3: String = "string";
const constant_def_4: Bool = true;
const constant_def_5: Bool = false;

fun function_def_1(x: Int, y: Int, z: Bool, m: Source): Bool {
    m.b = 10;
    return x + m.b > 0 && z;
}

contract contract_6 {
    a: Int;
    b: Int;
    c: Source;
    d: map<Int, Int>;

    const constant_def_7: Int = 42;

    init() {
        self.a = 0;
        self.b = 0;
        self.c = Source{a: 0, b: 0};
    }

    fun function_def_8() {
        let d: Int? = null;
        self.a = 10;
        d = constant_def_2 > 0 ? self.a : 0;
        let res: Bool = isZero(1, 2, false, self.c);
        let e = 42;
        self.b = constant_def_2;
        self.c = Source{a: 10, b: 20};
    }

    get fun function_def_9(): Int {
        self.addStake();
        return self.a;
    }

    receive("increment") {
        self.a -= 1;
    }
}


## case-asm-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-asm-fun.tact)
asm fun asm_function_def_0(s: Slice): Int {
    1
    INT
    HASHEXT_KECCAK256
}

asm( -> 1 0) extends fun asm_function_def_1(self: Slice): Int {
    LDVARUINT16
}

asm(c b) extends fun asm_function_def_2(b: Builder, c: Cell) {
    STDICT
}

asm(s len -> 1 0) extends fun asm_function_def_3(self: Slice, len: Int): Int {
    LDIX
}


## case-augmented-assign.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-augmented-assign.tact)
contract contract_0 {
    a: Int;

    init() {
        self.a = 0;
        self.a += 2;
        self.a -= 1;
        self.a *= 2;
        self.a /= 2;
        self.a %= 5;
    }
}


## case-bin-ops.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-bin-ops.tact)
contract contract_0 {
    a: Int;

    init() {
        self.a = (1 + 2 - 3) / 4 % 5 | 255 & 53 ^ 2;
        if (1 > 2 || 3 == 0 && (5 - 3) * 10 > 0) {

        }
    }
}


## case-destructuring.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-destructuring.tact)
struct struct_decl_0 {
    a: Int;
    b: Int;
    c: Int;
}

message message_decl_1 {
    a: Int;
    b: Int;
}

fun function_def_2(): Int {
    let s = S{a: 1, b: 2, c: 3};
    let S {a, b, c} = s;
    let S {a: a1, ..} = s;
    let S {b: b1, ..} = s;
    let S {c: c1, ..} = s;
    let S {a: a2, b: b2, ..} = s;
    let S {a: a3, c: c3, ..} = s;
    let S {b: b4, c: c4, ..} = s;
    let m = M{a: 1, b: 2};
    let M {a: a_m, b: b_m} = m;
    return a + b + c + a1 + b1 + c1 + a2 + b2 + a3 + c3 + b4 + c4 + a_m + b_m;
}

## case-if.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-if.tact)
fun function_def_0(x: Int, y: Int): Int {
    if (x < y) {
        return x;
    } else {
        return y;
    }
}

contract contract_1 {
    x: Int as int32;

    init() {
        if (1 > 0) {
            if (2 > 3) {
                self.x = 1;
            } else {
                self.x = 2;
            }
        } else {
            self.x = 0;
        }
    }
}


## case-initOf.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-initOf.tact)
contract contract_0 {
    a: Int;
    b: Bool;

    init(a: Int, b: Bool) {
        self.a = a;
        self.b = b;
    }
}

contract contract_1 {
    init() {
        initOf A(1, false);
    }
}


## case-loops.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-loops.tact)
contract contract_0 {
    x: Int;
    y: map<Int, Int>;

    init() {
        self.x = 5;
        self.y = emptyMap();
        self.y.set(1, 42);
        elf.y.set(2, 3);
        let y: map<Int, Int> = emptyMap();
        y.set(1, 42);
        y.set(2, 3);
        while (self.x > 0) {
            self.x = self.x - 1;
        }
        repeat (self.x) {
            self.x += self.x;
        }
        do {
            self.x = self.x + 1;
        } until (self.x < 10);
        foreach (k, v in y) {
            self.x += v;
        }
        foreach (k, v in self.y) {
            self.x += v;
        }
    }
}


## case-message-opcode.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-message-opcode.tact)
message(0xdeadbeef) message_decl_0 {
    x: Int;
}

message(3735928559) message_decl_1 {
    x: Int;
    y: Int;
}

message(0o33653337357) message_decl_2 {
    x: Int;
    y: Int;
    z: Int;
}

message(0b11011110101011011011111011101111) message_decl_3 {
    x: Int;
    y: Int;
    z: Int;
    w: Int;
}

message message_decl_4 {
    value: Int;
}

message(constant_def_5 + 1) message_decl_6 {
    a: Int;
}

const constant_def_5: Int = 0xdeadbeef;

contract contract_7 {
}


## case-priority.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-priority.tact)
contract contract_0 {
    x: Bool;
    y: Int;

    init() {
        self.x = true || true && true == 5 < 6 << 9 + 7 * 8;
        self.x = true || true && true != 5 > 6 >> 9 - 7 / 8;
        self.x = true || true && true != 5 <= 6 >> 9 - 7 % 8;
        self.x = true || true && true != 5 >= 6 >> 9 - 7 % 8;
        self.y = 1 | 2 ^ 3 & 6 >> 9 - 7 % 8;
        self.x = (true ? true : false) ? 1 : 2;
        self.x = true ? (true ? 1 : 2) : 3;
        self.x = false ? 1 : false ? 2 : 3;
        self.x = +self.x!!;
        self.x = (+self.x)!!;
    }
}


## case-receive.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-receive.tact)
message message_decl_0 {
    value: Int;
}

contract contract_1 {
    a: Int;

    init() {
        self.a = 0;
    }

    receive() {
        self.a = 1;
    }

    receive("message") {
        self.a = 2;
    }

    receive(m: MyMessage) {
        self.a = m.value;
    }

    bounced(m: bounced<MyMessage>) {
        self.a = 3;
    }

    external() {
        self.a = 4;
        acceptMessage();
    }

    external("message") {
        self.a = 5;
        acceptMessage();
    }

    external(m: MyMessage) {
        self.a = m.value;
        acceptMessage();
    }
}


## case-traits.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-traits.tact)
@interface("") trait trait_0 {
}

trait trait_1 {
    abstract get fun function_decl_2(e: String): String;
}

trait trait_3 with B {
    owner: Address;
    value: Int;

    const constant_def_4: Int = 2;
    abstract const constant_decl_5: Int;

    receive("message") {

    }

    fun function_def_6() {
        nativeThrowUnless(132, context().sender == self.owner);
    }

    get fun function_def_7(): Address {
        return self.owner;
    }
}

@interface("a") contract contract_8 with Ownable {
    owner: Address;
    value: Int;

    const constant_def_4: Int = 2;

    init(owner: Address) {
        self.owner = owner;
        self.value = 1;
    }
}


## case-trycatch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/case-trycatch.tact)
fun function_def_0() {
    try {
        nativeThrow(42);
    }
    dump(42);
}

fun function_def_1() {
    try {
        nativeThrow(42);
    } catch (err) {
        dump(err);
    }
}


## getter-with-method-id-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/getter-with-method-id-const.tact)
const constant_def_0: Int = crc32("crc32") + 42;

contract contract_1 {
    get(constant_def_0) fun function_def_2(): Int {
        return constant_def_0;
    }
}


## getter-with-method-id.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/getter-with-method-id.tact)
contract contract_0 {
    get(crc32("crc32") + 42 & 0x3ffff | 0x4000) fun function_def_1(): Int {
        return 0;
    }
}


## native-functions.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/contracts/renamer-expected/native-functions.tact)
@name(__tact_compute_contract_address)
native native___tact_compute_contract_address(chain: Int, code: Cell, data: Cell): Address;

@name(hello_world)
native native_hello_world(): Int;


## address.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/address.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { AddressTester } from "./contracts/output/address_AddressTester";
import "@ton/test-utils";

describe("address", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<AddressTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");
        contract = blockchain.openContract(await AddressTester.fromInit());

        const result = await contract.send(
            treasure.getSender(),
            {
                value: toNano("10"),
            },
            null, // No specific message, sending a basic transfer
        );

        expect(result.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement addresses correctly", async () => {
        // Check methods
        expect((await contract.getTest1()).toRawString()).toEqual(
            "0:4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873",
        );
        expect((await contract.getTest2()).toRawString()).toEqual(
            "0:4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873",
        );
        expect((await contract.getTest3()).toRawString()).toEqual(
            "0:4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873",
        );
    });
});


## allocation.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/allocation.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Test } from "./contracts/output/allocation_Test";
import "@ton/test-utils";

describe("allocation", () => {
    let blockchain: Blockchain;
    let owner: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Test>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        owner = await blockchain.treasury("owner");

        contract = blockchain.openContract(
            await Test.fromInit(owner.address, {
                $$type: "Struct2",
                c: "",
                d: "",
                e: "",
                f: "",
            }),
        );

        const deployResult = await contract.send(
            owner.getSender(),
            {
                value: toNano(1),
            },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: owner.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should deploy correctly and process SetCost message without cell overflow", async () => {
        const setCostResult = await contract.send(
            owner.getSender(),
            { value: toNano(1) },
            { $$type: "SetCost", cost: toNano("0.1") },
        );

        expect(setCostResult.transactions).toHaveTransaction({
            from: owner.address,
            to: contract.address,
            success: true,
        });
    });
});


## asm-functions.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/asm-functions.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { AsmFunctionsTester as TestContract } from "./contracts/output/asm-functions_AsmFunctionsTester";
import "@ton/test-utils";

describe("asm functions", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<TestContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await TestContract.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement asm functions correctly", async () => {
        expect(await contract.getTestAsmStoreDict()).toEqual(true);
        expect(await contract.getTestAsmLoadCoins()).toEqual(true);
        expect(await contract.getTestAsmLoadInt()).toEqual(true);
        expect(await contract.getTestAsmDebugStr()).toEqual(true);
        expect(await contract.getTestAsmCreateUseWord()).toEqual(true);
    });
});


## bounced-routing.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/bounced-routing.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { SampleContract2 } from "./contracts/output/bounced-routing_SampleContract2";
import { SampleContract } from "./contracts/output/bounced-routing_SampleContract";
import "@ton/test-utils";

describe("strings", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<SampleContract>;
    let contract2: SandboxContract<SampleContract2>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await SampleContract.fromInit());
        contract2 = blockchain.openContract(await SampleContract2.fromInit());

        // Deploy contracts
        let deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );
        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        deployResult = await contract2.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );
        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract2.address,
            success: true,
            deploy: true,
        });
    });

    it("should bounce based on type router", async () => {
        // Initial amount check
        expect(await contract.getAmount()).toBe(100n);

        // Send EntryFirst message
        let result = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            {
                $$type: "EntryFirst",
                amountToAdd: 10n,
                toAddress: contract2.address,
            },
        );
        expect(result.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        // Verify amount after EntryFirst
        expect(await contract.getAmount()).toBe(98n);

        // Send EntrySecond message
        result = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            {
                $$type: "EntrySecond",
                amountToAdd: 10n,
                toAddress: contract2.address,
            },
        );
        expect(result.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        // Verify amount after EntrySecond
        expect(await contract.getAmount()).toBe(94n);
    });
});


## constants.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/constants.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { ConstantTester } from "./contracts/output/constants_ConstantTester";
import "@ton/test-utils";

describe("constants", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<ConstantTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await ConstantTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );
        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement constants correctly", async () => {
        // Check methods
        expect(await contract.getSomething1()).toEqual(11n);
        expect(await contract.getSomething2()).toBeNull();
        expect(await contract.getSomething3()).toEqual(toNano("123"));
        expect(await contract.getSomething4()).toEqual(toNano("456"));
        expect(await contract.getSomething5()).toEqual("Hello world!");
        expect(await contract.getSomething6()).toEqual(10n);
        expect(await contract.getSomething7()).toEqual(5n);
        expect(await contract.getSomething8()).toEqual(4n);
        expect((await contract.getSomething9()).toRawString()).toEqual(
            "0:4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873",
        );
        expect((await contract.getSomething10()).toRawString()).toEqual(
            "0:4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873",
        );
        expect(await contract.getSomething11()).toEqual(88n);
        expect(await contract.getSomething12()).toEqual(-90n);
        expect(await contract.getSomething13()).toEqual(88n);
        expect(await contract.getSomething14()).toEqual(243n);
        expect(await contract.getSomething15()).toEqual(32n);
        expect(await contract.getSomething16()).toEqual(
            -115792089237316195423570985008687907853269984665640564039457584007913129639936n,
        );
        expect(await contract.getSomething17()).toEqual(
            115792089237316195423570985008687907853269984665640564039457584007913129639935n,
        );
        expect(await contract.getSomething18()).toEqual(
            -115792089237316195423570985008687907853269984665640564039457584007913129639935n,
        );
        expect(await contract.getSomething19()).toEqual(
            -115792089237316195423570985008687907853269984665640564039457584007913129639936n,
        );
        expect(await contract.getMinInt1()).toEqual(
            -115792089237316195423570985008687907853269984665640564039457584007913129639936n,
        );
        expect(await contract.getSomething20()).toEqual(-6n);
        expect(await contract.getGlobalConst()).toEqual(100n);

        expect(await contract.getSomething21()).toEqual(0n);
        expect(await contract.getSomething22()).toEqual(-1n);
        expect(await contract.getSomething23()).toEqual(-1n);
        expect(await contract.getSomething24()).toEqual(0n);
        expect(await contract.getSomething25()).toEqual(1n);
        expect(await contract.getSomething26()).toEqual(4n);
        expect(await contract.getSomething27()).toEqual(-4n);
        expect(await contract.getSomething28()).toEqual(-1n);

        expect(await contract.getSomething29()).toEqual(42n);
        expect(await contract.getSomething30()).toEqual(null);
        expect(await contract.getSomething31()).toEqual(42n);
        expect(await contract.getSomething32()).toEqual(42n);

        expect((await contract.getSomething33()).size).toEqual(0);
        expect((await contract.getSomething34()).size).toEqual(0);

        expect(await contract.getSomething35()).toEqual({
            $$type: "S",
            a: false,
            b: 42n,
        });
        expect(await contract.getSomething36()).toEqual({
            $$type: "S",
            a: false,
            b: 42n,
        });
        expect(await contract.getSomething37()).toEqual({
            $$type: "T",
            a: 42n,
            s: { $$type: "S", a: true, b: 42n },
        });
        expect(await contract.getSomething38()).toEqual(4n);
        expect(await contract.getSomething39()).toEqual(true);
        expect(await contract.getSomething40()).toEqual(true);
        expect((await contract.getSomething41()).toRawString()).toEqual(
            "0:0000000000000000000000000000000000000000000000000000000000000000",
        );
        expect((await contract.getSomething42()).toRawString()).toEqual(
            "0:0000000000000000000000000000000000000000000000000000000000012345",
        );
        expect((await contract.getSomething43()).toRawString()).toEqual(
            "0:0000000000000000000000000000000000000000000000000123456789abcdef",
        );
        expect((await contract.getSomething44()).toRawString()).toEqual(
            "0:4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873",
        );

        expect(await contract.getGlobalConst1()).toEqual(1n);
        expect(await contract.getGlobalConst2()).toEqual(2n);
        expect(await contract.getGlobalConst3()).toEqual(4n);
        expect(await contract.getGlobalConst4()).toEqual(15n);
        expect(await contract.getGlobalConst5()).toEqual(15n);
        expect(await contract.getGlobalConst6()).toEqual(26n);
        expect(await contract.getGlobalConst7()).toEqual(27n);
        expect(await contract.getGlobalConst8()).toEqual(2n);
        expect(await contract.getGlobalConst9()).toEqual(2n);
        expect(await contract.getGlobalConst10()).toEqual(24n);
        expect(await contract.getGlobalConst11()).toEqual(24n);
        expect(await contract.getGlobalConst12()).toEqual(8n);
        expect(await contract.getGlobalConst13()).toEqual(8n);
    });
});


## contract-methods.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contract-methods.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Test } from "./contracts/output/contract-methods_Test";
import "@ton/test-utils";

describe("contract-methods", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Test>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await Test.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );
        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement contract methods correctly", async () => {});
});


## debug.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/debug.spec.ts)
import { Address, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Debug } from "./contracts/output/debug_Debug";
import { posixNormalize } from "../../utils/filePath";
import "@ton/test-utils";

describe("debug", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Debug>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await Debug.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should dump values correctly", async () => {
        // Send Debug message
        const result = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "Debug",
        );

        const debugLogs =
            result.transactions[1]?.debugLogs.replace(/#DEBUG#: /g, "") ?? "";

        const filePath = posixNormalize(
            "src/test/e2e-emulated/contracts/debug.tact",
        );

        expect(debugLogs).toStrictEqual(`File ${filePath}:10:9:
dumpStack()
stack(2 values) : 10000000000 () 
File ${filePath}:11:9:
dump("Hello world!")
Hello world!
File ${filePath}:12:9:
dump(123)
123
File ${filePath}:13:9:
dump(true)
true
File ${filePath}:14:9:
dump(false)
false
File ${filePath}:15:9:
dump(null)
null
File ${filePath}:16:9:
dump(myAddress())
${contract.address.toString({ bounceable: true })}
File ${filePath}:17:9:
dump(newAddress(0, 0x83dfd552e63729b472fcbcc8c45ebcc6691702558b68ec7527e1ba403a0f31a8))
${Address.parseRaw(
    "0:83dfd552e63729b472fcbcc8c45ebcc6691702558b68ec7527e1ba403a0f31a8",
).toString()}
File ${filePath}:18:9:
dump(myBalance())
10000000000`);
    });
});


## deep.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/deep.spec.ts)
import { beginCell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { A } from "./contracts/output/deep_A";
import { B } from "./contracts/output/deep_B";
import { C } from "./contracts/output/deep_C";
import "@ton/test-utils";

describe("random", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contractA: SandboxContract<A>;
    let contractB: SandboxContract<B>;
    let contractC: SandboxContract<C>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contractA = blockchain.openContract(await A.fromInit());
        contractB = blockchain.openContract(
            await B.fromInit(contractA.address),
        );
        contractC = blockchain.openContract(
            await C.fromInit(contractB.address),
        );
    });

    it("should chain deep sequences correctly", async () => {
        // Send a message to contract A
        const result = await contractA.send(
            treasure.getSender(),
            { value: toNano("10") },
            "Message",
        );

        // Verify the transaction for contract A
        expect(result.transactions).toHaveTransaction({
            from: treasure.address,
            to: contractA.address,
            success: true,
            // Add any other specific transaction properties you want to check here
        });

        // Verify the chaining by checking the "next" contracts in sequence
        const nextA = await contractA.getGetNext();
        expect(nextA.code.equals(contractB.init!.code!)).toBe(true);
        expect(nextA.data.equals(contractB.init!.data!)).toBe(true);

        const nextB = await contractB.getGetNext();
        expect(nextB.code.equals(contractC.init!.code!)).toBe(true);
        expect(nextB.data.equals(contractC.init!.data!)).toBe(true);

        expect(result.transactions).toHaveTransaction({
            from: treasure.address,
            to: contractA.address,
            success: true,
            body: beginCell()
                .storeUint(0, 32)
                .storeStringTail("Message")
                .endCell(),
        });

        expect(result.transactions).toHaveTransaction({
            from: contractA.address,
            to: contractB.address,
            success: true,
            body: beginCell()
                .storeUint(0, 32)
                .storeStringTail("Message")
                .endCell(),
        });

        expect(result.transactions).toHaveTransaction({
            from: contractB.address,
            to: contractC.address,
            success: true,
            body: beginCell()
                .storeUint(0, 32)
                .storeStringTail("Message")
                .endCell(),
        });

        expect(result.transactions).toHaveTransaction({
            from: contractC.address,
            to: contractC.address,
            success: true,
            body: beginCell()
                .storeUint(0, 32)
                .storeStringTail("Message2")
                .endCell(),
        });
    });
});


## dns.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/dns.spec.ts)
import { beginCell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { DNSTester } from "./contracts/output/dns_DNSTester";
import "@ton/test-utils";

function convertToInternal(src: string) {
    if (src === ".") {
        return Buffer.alloc(1, 0);
    }
    const parts = src.split(".").map((x) => Buffer.from(x));
    let res = Buffer.alloc(0);
    for (let i = 0; i < parts.length; i++) {
        if (i > 0) {
            res = Buffer.concat([res, Buffer.from([0])]);
        }
        res = Buffer.concat([res, parts[parts.length - i - 1]!]);
    }
    res = Buffer.concat([res, Buffer.from([0])]);
    return res;
}

describe("dns", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<DNSTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await DNSTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    const invalidNames = [
        "..",
        "a..b",
        "a.b..c",
        "a.b.c..",
        "a.!b",
        "a.-b",
        "a.b-",
        "_a.b",
        "a..b",
        "a b",
        "A.b",
    ];
    const validNames = [
        ".",
        "ton.dns",
        "a.b",
        "a.b.c",
        "a.b.c.d",
        "a.b.c.",
        "ton-dns.com",
        "ton-dns.com.hello",
    ];

    const equalNormalized = [
        ["ton.dns", "t0n.dns"],
        ["t1n.dns", "tln.dns"],
    ];
    const notEqualNormalized = [
        ["ton.dns", "tan.dns"],
        ["t1n.dns", "tin.dns"],
    ];

    for (const invalidName of invalidNames) {
        it(`should fail on invalid name: ${invalidName}`, async () => {
            expect(await contract.getStringToInternal(invalidName)).toBe(null);
            const internalAddress = convertToInternal(invalidName);
            expect(
                await contract.getDnsInternalVerify(
                    beginCell()
                        .storeBuffer(internalAddress)
                        .endCell()
                        .asSlice(),
                ),
            ).toBe(false);
        });
    }

    for (const validName of validNames) {
        it(`should convert valid name: ${validName}`, async () => {
            const data = (await contract.getStringToInternal(validName))!;
            const received = data
                .loadBuffer(data.remainingBits / 8)
                .toString("hex");
            expect(received).toBe(
                convertToInternal(
                    validName.endsWith(".") && validName !== "."
                        ? validName.slice(0, validName.length - 1)
                        : validName,
                ).toString("hex"),
            );
        });
    }

    for (const validName of validNames) {
        if (validName !== ".") {
            it(`should verify DNS internal structure for valid name: ${validName}`, async () => {
                const data = (await contract.getStringToInternal(validName))!;
                expect(await contract.getDnsInternalVerify(data)).toBe(true);
            });
        }
    }

    for (const equalNormalizedElem of equalNormalized) {
        it(`should convert equal normalized names: ${equalNormalizedElem[0]!} ${equalNormalizedElem[1]!}`, async () => {
            let data1 = (await contract.getStringToInternal(
                equalNormalizedElem[0]!,
            ))!;
            data1 = await contract.getInternalNormalize(data1);
            const received1 = data1
                .loadBuffer(data1.remainingBits / 8)
                .toString("hex");
            let data2 = (await contract.getStringToInternal(
                equalNormalizedElem[1]!,
            ))!;
            data2 = await contract.getInternalNormalize(data2);
            const received2 = data2
                .loadBuffer(data2.remainingBits / 8)
                .toString("hex");
            expect(received1).toBe(received2);
            expect(received1.length).toBe(received2.length);
        });
    }

    for (const notEqualNormalizedElem of notEqualNormalized) {
        it(`should convert not equal normalized names: ${notEqualNormalizedElem[0]!} ${notEqualNormalizedElem[1]!}`, async () => {
            let data1 = (await contract.getStringToInternal(
                notEqualNormalizedElem[0]!,
            ))!;
            data1 = await contract.getInternalNormalize(data1);
            const received1 = data1
                .loadBuffer(data1.remainingBits / 8)
                .toString("hex");
            let data2 = (await contract.getStringToInternal(
                notEqualNormalizedElem[1]!,
            ))!;
            data2 = await contract.getInternalNormalize(data2);
            const received2 = data2
                .loadBuffer(data2.remainingBits / 8)
                .toString("hex");
            expect(received1).not.toBe(received2);
            expect(received1.length).toBe(received2.length);
        });
    }

    for (const validName of validNames) {
        it("should resolve name " + validName, async () => {
            const internalAddress = convertToInternal(validName);
            const resolved = (await contract.getDnsresolve(
                beginCell().storeBuffer(internalAddress).endCell().asSlice(),
                1n,
            ))!;
            expect(resolved.prefix).toBe(BigInt(internalAddress.length * 8));
            if (validName === ".") {
                expect(resolved.record!.bits.length).toBe(0);
                expect(resolved.record!.refs.length).toBe(0);
            } else if (validName.endsWith(".")) {
                expect(
                    resolved
                        .record!.beginParse()
                        .loadBuffer(internalAddress.length - 1)
                        .toString("hex"),
                ).toBe(internalAddress.subarray(1).toString("hex"));
            } else {
                expect(
                    resolved
                        .record!.beginParse()
                        .loadBuffer(internalAddress.length)
                        .toString("hex"),
                ).toBe(internalAddress.toString("hex"));
            }
        });
    }

    for (const invalidName of invalidNames) {
        it("should not resolve name " + invalidName, async () => {
            const internalAddress = convertToInternal(invalidName);
            await expect(
                contract.getDnsresolve(
                    beginCell()
                        .storeBuffer(internalAddress)
                        .endCell()
                        .asSlice(),
                    1n,
                ),
            ).rejects.toThrowError();
        });
    }

    for (const validName of validNames) {
        if (validName.endsWith(".")) {
            continue;
        }
        it("should resolve name with leading zero " + validName, async () => {
            const internalAddress = convertToInternal(validName);
            const resolved = (await contract.getDnsresolve(
                beginCell()
                    .storeBuffer(
                        Buffer.concat([Buffer.alloc(1, 0), internalAddress]),
                    )
                    .endCell()
                    .asSlice(),
                1n,
            ))!;
            expect(resolved.prefix).toBe(
                BigInt(internalAddress.length * 8 + 8),
            );
            if (validName === ".") {
                expect(resolved.record!.bits.length).toBe(0);
                expect(resolved.record!.refs.length).toBe(0);
            } else {
                expect(
                    resolved
                        .record!.beginParse()
                        .loadBuffer(internalAddress.length)
                        .toString("hex"),
                ).toBe(internalAddress.toString("hex"));
            }
        });
    }

    it("should test dnsInternalNormalize throws", async () => {
        const sendResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "test dnsInternalNormalize throws",
        );

        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: false,
            exitCode: 134, // Invalid argument
        });
    });
});


## external-fallbacks.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/external-fallbacks.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { ExternalFallbacksTester } from "./contracts/output/external-fallbacks_ExternalFallbacksTester";
import "@ton/test-utils";

describe("external fallbacks", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<ExternalFallbacksTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(
            await ExternalFallbacksTester.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        expect(await contract.getGetA()).toBe(100n);
    });

    it("should implement external fallbacks correctly", async () => {
        // Test the `Add` function via internal message
        const addResultInternal = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            {
                $$type: "Add",
                x: 10n,
            },
        );
        expect(addResultInternal.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });
        expect(await contract.getGetA()).toBe(110n);

        // Test the `Add` function via external message
        const addResultExternal = await contract.sendExternal({
            $$type: "Add",
            x: 10n,
        });
        expect(addResultExternal.transactions).toHaveTransaction({
            to: contract.address,
            success: true,
        });
        expect(await contract.getGetA()).toBe(120n);

        // Test the external fallback handling (null external message)
        const fallbackResult = await contract.sendExternal(null);
        expect(fallbackResult.transactions).toHaveTransaction({
            to: contract.address,
            success: true,
        });
        expect(await contract.getGetA()).toBe(220n);
    });
});


## getters.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/getters.spec.ts)
import { beginCell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Test, Test_getterMapping } from "./contracts/output/getters_Test";
import "@ton/test-utils";

describe("getters", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Test>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await Test.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            {
                $$type: "Deploy",
                queryId: 0n,
            },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement getters correctly", async () => {
        // Getter name conflicts
        expect(await contract.getTestGetter()).toBe(1n);
        expect(await contract.gettest_getter()).toBe(2n);
        expect(await contract.getTest_getter()).toBe(3n);

        expect(Test_getterMapping["testGetter"]).toBe("getTestGetter");
        expect(Test_getterMapping["test_getter"]).toBe("gettest_getter");
        expect(Test_getterMapping["Test_getter"]).toBe("getTest_getter");

        // Passing `S` struct to getter
        expect(
            await contract.getStructAsInput({
                $$type: "S",
                a: 1n,
                b: 2n,
            }),
        ).toMatchSnapshot();

        // Returning `self` from getter
        expect(await contract.getContractData()).toMatchSnapshot();

        // Passing `SetIdAndData` message to getter
        expect(
            await contract.getMessageAsInput1({
                $$type: "SetIdAndData",
                id: 42n,
                data: beginCell().endCell(),
            }),
        ).toBe(42n);
        expect(
            await contract.getMessageAsInput2({
                $$type: "SetIdAndData",
                id: 42n,
                data: beginCell().endCell(),
            }),
        ).toMatchSnapshot();

        // Passing `Test` contract data to getter
        expect(
            await contract.getContractAsInput({
                $$type: "Test$Data",
                id: 123n,
                anotherData: beginCell().storeUint(123, 64).endCell(),
            }),
        ).toMatchSnapshot();

        expect(await contract.getMethodIdExpr()).toBe(true);
        expect(await contract.getMethodIdConst()).toBe(2n ** 14n);
        expect(await contract.getMethodIdMin()).toBe(true);
        expect(await contract.getMethodIdMax()).toBe(true);
    });
});


## implicit-init.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/implicit-init.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { MyContract } from "./contracts/output/implicit-init_MyContract";
import "@ton/test-utils";

describe("implicit-init", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<MyContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await MyContract.fromInit());
    });

    it("should deploy", async () => {
        // Deploy the contract
        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("1") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Verify initial state
        expect(await contract.getGetCounter()).toBe(0n);
    });

    it("should increment counter", async () => {
        // Deploy the contract
        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("1") },
            { $$type: "Deploy", queryId: 0n },
        );
        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Verify initial state
        expect(await contract.getGetCounter()).toBe(0n);

        // Increment counter
        const incrementResult1 = await contract.send(
            treasure.getSender(),
            { value: toNano("1") },
            "increment",
        );
        expect(incrementResult1.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });
        expect(await contract.getGetCounter()).toBe(1n);

        const incrementResult2 = await contract.send(
            treasure.getSender(),
            { value: toNano("1") },
            "increment",
        );
        expect(incrementResult2.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });
        expect(await contract.getGetCounter()).toBe(2n);
    });
});


## init-of-message.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/init-of-message.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { InitData, Test } from "./contracts/output/init-of-message_Test";
import "@ton/test-utils";

describe("init-of-message", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Test>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        const msg: InitData = {
            $$type: "InitData",
            seller: treasure.address,
            nonce: 0n,
        };
        contract = blockchain.openContract(await Test.fromInit(msg));

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should deploy when given a message as init", async () => {});
});


## init-return.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/init-return.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Test } from "./contracts/output/init-return_Test";
import "@ton/test-utils";

describe("init-return", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Test>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await Test.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should deploy with return statement in init", async () => {
        expect(await contract.getA()).toEqual(123n);
    });
});


## initof.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/initof.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Self } from "./contracts/output/initof_Self";
import { Parent } from "./contracts/output/initof_Parent";
import { TestInit } from "./contracts/output/initof-2_TestInit";
import { A } from "./contracts/output/initof-3_A";
import "@ton/test-utils";

describe("initOf", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");
    });

    it("should implement initOf correctly - 1", async () => {
        const contract = blockchain.openContract(await Self.fromInit());

        await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(await contract.getTestInitOfAddress()).toEqualAddress(
            await contract.getTestMyAddress(),
        );
    });

    it("should implement initOf correctly - 2", async () => {
        const contract = blockchain.openContract(await Parent.fromInit());

        await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(await contract.getTestInitOfAddressChild()).toEqualAddress(
            await contract.getTestMyAddressChild(),
        );
    });

    it("should implement initOf correctly - 3", async () => {
        const contract = blockchain.openContract(await TestInit.fromInit());

        const result = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            {
                $$type: "Deploy",
                queryId: 0n,
            },
        );

        const logs = result.transactions[1]!.debugLogs;

        expect(logs).toContain("init@TestInit-SUCCESS");
        expect(logs).not.toContain("ERROR@TestInit");
    });

    it("should implement initOf correctly - 4", async () => {
        const contract = blockchain.openContract(await A.fromInit());

        const result = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "aa",
        );

        expect(result.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });
    });
});


## integer-literals.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/integer-literals.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { IntegerLiteralsTester } from "./contracts/output/integer-literals_IntegerLiteralsTester";
import "@ton/test-utils";

describe("integer-literals", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<IntegerLiteralsTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(
            await IntegerLiteralsTester.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement integer literals correctly", async () => {
        // Check decimal literals
        expect(await contract.getDecLiteral1()).toEqual(123n);
        expect(await contract.getDecLiteral2()).toEqual(-123n);
        expect(await contract.getDecLiteral3()).toEqual(1012300000n);

        // Check hexadecimal literals
        expect(await contract.getHexLiteral1()).toEqual(0x123n);
        expect(await contract.getHexLiteral2()).toEqual(-0x123n);
        expect(await contract.getHexLiteral3()).toEqual(0x1012300000n);

        // Check binary literals
        expect(await contract.getBinLiteral1()).toEqual(0b101010n);
        expect(await contract.getBinLiteral2()).toEqual(-0b101010n);
        expect(await contract.getBinLiteral3()).toEqual(0b1010100000n);

        // Check octal literals
        expect(await contract.getOctLiteral1()).toEqual(0o123n);
        expect(await contract.getOctLiteral2()).toEqual(-0o123n);
        expect(await contract.getOctLiteral3()).toEqual(0o1012300000n);
    });
});


## intrinsics.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/intrinsics.spec.ts)
import { Address, beginCell, Cell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { IntrinsicsTester } from "./contracts/output/intrinsics_IntrinsicsTester";
import { sha256_sync } from "@ton/crypto";
import "@ton/test-utils";
import { paddedBufferToBits } from "@ton/core/dist/boc/utils/paddedBits";

describe("intrinsics", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<IntrinsicsTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await IntrinsicsTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "Deploy",
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should return correct intrinsic results", async () => {
        // Compile-time constants
        expect(await contract.getGetTons()).toBe(toNano("10.1234"));
        expect(await contract.getGetTons2()).toBe(toNano("10.1234"));
        expect(await contract.getGetString()).toBe("Hello world");
        expect(await contract.getGetString2()).toBe("Hello world");
        expect(
            (await contract.getGetAddress()).equals(
                Address.parse(
                    "EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N",
                ),
            ),
        ).toBe(true);
        expect(
            (await contract.getGetAddress2()).equals(
                Address.parse(
                    "EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N",
                ),
            ),
        ).toBe(true);
        expect(
            (await contract.getGetCell()).equals(
                Cell.fromBase64("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw="),
            ),
        ).toBe(true);
        expect(
            (await contract.getGetCell2()).equals(
                Cell.fromBase64("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw="),
            ),
        ).toBe(true);
        expect(await contract.getGetPow()).toBe(512n);
        expect(await contract.getGetPow2()).toBe(512n);

        // Compile-time optimizations
        expect(
            (await contract.getGetComment()).equals(
                beginCell()
                    .storeUint(0, 32)
                    .storeStringTail("Hello world")
                    .endCell(),
            ),
        ).toBe(true);

        // Compile-time send/emit optimizations
        const emitResult = await contract.send(
            treasure.getSender(),
            { value: toNano(1) },
            "emit_1",
        );

        // Verify emitted message
        expect(emitResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            outMessagesCount: 1,
        });
        const outMessage = emitResult.externals[0]!.body.beginParse();
        expect(outMessage.loadUint(32)).toEqual(0);
        expect(outMessage.loadStringTail()).toEqual("Hello world");
        expect(outMessage.remainingBits).toEqual(0);
        expect(outMessage.remainingRefs).toEqual(0);

        // Check sha256
        function sha256(src: string | Buffer) {
            return BigInt("0x" + sha256_sync(src).toString("hex"));
        }
        expect(await contract.getGetHash()).toBe(sha256("hello world"));
        expect(await contract.getGetHash2()).toBe(sha256("hello world"));
        expect(
            await contract.getGetHash3(
                beginCell().storeStringTail("sometest").endCell().asSlice(),
            ),
        ).toBe(sha256("sometest"));
        expect(await contract.getGetHash4("wallet")).toBe(sha256("wallet"));
        const longString =
            "------------------------------------------------------------------------------------------------------------------------------129";
        expect(await contract.getGetHashLongComptime()).toBe(
            sha256(longString),
        );
        // NOTE: The discrepancy here is expected, since SHA256U operates only on the first 127 bytes
        expect(
            (await contract.getGetHashLongRuntime(longString)) !==
                sha256(longString),
        ).toBe(true);

        // Check `slice`
        expect(
            (await contract.getGetSlice())
                .asCell()
                .equals(
                    Cell.fromBase64("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw="),
                ),
        ).toBe(true);
        expect(
            (await contract.getGetSlice2())
                .asCell()
                .equals(
                    Cell.fromBase64("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw="),
                ),
        ).toBe(true);

        // Check `rawSlice`
        expect(
            (await contract.getGetRawSlice())
                .asCell()
                .equals(
                    beginCell()
                        .storeBuffer(Buffer.from("abcdef", "hex"))
                        .endCell(),
                ),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice2())
                .asCell()
                .equals(
                    beginCell()
                        .storeBuffer(Buffer.from("abcdef", "hex"))
                        .endCell(),
                ),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice3()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice4()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice5())
                .asCell()
                .equals(beginCell().storeUint(18, 6).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice6())
                .asCell()
                .equals(beginCell().storeUint(18, 6).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice7()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice8()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice9())
                .asCell()
                .equals(beginCell().storeUint(0, 3).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice10())
                .asCell()
                .equals(beginCell().storeUint(0, 3).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice11()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice12()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice13())
                .asCell()
                .equals(beginCell().storeUint(7, 4).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice14())
                .asCell()
                .equals(beginCell().storeUint(7, 4).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice15()).asCell().equals(
                beginCell()
                    .storeBits(
                        paddedBufferToBits(
                            Buffer.from(
                                "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcf",
                                "hex",
                            ),
                        ),
                    )
                    .endCell(),
            ),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice16()).asCell().equals(
                beginCell()
                    .storeBits(
                        paddedBufferToBits(
                            Buffer.from(
                                "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcf",
                                "hex",
                            ),
                        ),
                    )
                    .endCell(),
            ),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice17())
                .asCell()
                .equals(beginCell().storeUint(0b100010, 6).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice18())
                .asCell()
                .equals(beginCell().storeUint(0b100010, 6).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice19())
                .asCell()
                .equals(beginCell().storeUint(0b100010, 6).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice20())
                .asCell()
                .equals(beginCell().storeUint(0b100010, 6).endCell()),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice21()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice22()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice23()).asCell().equals(Cell.EMPTY),
        ).toBe(true);
        expect(
            (await contract.getGetRawSlice24()).asCell().equals(Cell.EMPTY),
        ).toBe(true);

        // Check `ascii`
        expect(await contract.getGetAscii()).toBe(
            BigInt("0x68656c6c6f20776f726c64"),
        );
        expect(await contract.getGetAscii2()).toBe(
            BigInt("0x68656c6c6f20776f726c64"),
        );
        expect(await contract.getGetAscii3()).toBe(
            BigInt(
                "1563963554659859369353828835329962428465513941646011501275668087180532385",
            ),
        );
        expect(await contract.getGetAscii4()).toBe(
            BigInt(
                "1563963554659859369353828835329962428465513941646011501275668087180532385",
            ),
        );

        // Check `crc32`
        expect(await contract.getGetCrc32()).toBe(BigInt(2235694568));
        expect(await contract.getGetCrc32_2()).toBe(BigInt(2235694568));
        expect(await contract.getGetCrc32_3()).toBe(0n);
        expect(await contract.getGetCrc32_4()).toBe(0n);
    });
});


## local-type-inference.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/local-type-inference.spec.ts)
import { beginCell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { LocalTypeInferenceTester } from "./contracts/output/local-type-inference_LocalTypeInferenceTester";
import "@ton/test-utils";

describe("local-type-inference", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<LocalTypeInferenceTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(
            await LocalTypeInferenceTester.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should automatically set types for let statements", async () => {
        expect(await contract.getTest1()).toStrictEqual(1n);
        expect(await contract.getTest2()).toStrictEqual(2n);
        expect((await contract.getTest3()).toRawString()).toBe(
            contract.address.toRawString(),
        );
        expect((await contract.getTest4()).toRawString()).toBe(
            contract.address.toRawString(),
        );
        expect(await contract.getTest5()).toStrictEqual(true);
        expect((await contract.getTest6()).toString()).toStrictEqual(
            beginCell().storeUint(123, 64).endCell().asSlice().toString(),
        );
        expect((await contract.getTest7()).toString()).toStrictEqual(
            beginCell().storeUint(123, 64).endCell().toString(),
        );
        expect((await contract.getTest8()).asCell().toString()).toStrictEqual(
            beginCell().storeUint(123, 64).endCell().toString(),
        );
        expect(await contract.getTest9()).toStrictEqual("hello");
        expect(await contract.getTest10()).toStrictEqual("hello");

        const test11 = await contract.getTest11();
        expect(test11.code.toString()).toStrictEqual(
            contract.init?.code.toString(),
        );
        expect(test11.data.toString()).toStrictEqual(
            contract.init?.data.toString(),
        );

        expect(await contract.getTest14()).toStrictEqual({
            $$type: "MyStruct",
            x: 1n,
            y: 2n,
        });
        expect(await contract.getTest15()).toStrictEqual({
            $$type: "MyStruct",
            x: 1n,
            y: 2n,
        });
        expect(await contract.getTest16()).toBeNull();
        expect(await contract.getTest17()).toBeNull();
        expect(await contract.getTest18()).toBe(2n);
        expect(await contract.getTest19()).toBeNull();

        // Test contract's ABI
        expect(contract.abi).toMatchSnapshot();
    });
});


## map-comparison.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/map-comparison.spec.ts)
import { Address, beginCell, Cell, Dictionary, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { MapComparisonTestContract } from "./contracts/output/map-comparison_MapComparisonTestContract";
import "@ton/test-utils";

describe("map-comparison", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<MapComparisonTestContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(
            await MapComparisonTestContract.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement map comparison correctly", async () => {
        // Test Int Int - Equal
        {
            const m1: Dictionary<bigint, bigint> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.BigInt(256),
            );
            m1.set(1n, 2n);
            m1.set(3n, 4n);
            const m2: Dictionary<bigint, bigint> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.BigInt(256),
            );
            m2.set(1n, 2n);
            m2.set(3n, 4n);
            expect(await contract.getCompareIntInt(m1, m2)).toBe(true);
        }

        // Test Int Int - Not Equal
        {
            const m1: Dictionary<bigint, bigint> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.BigInt(256),
            );
            m1.set(1n, 2n);
            m1.set(3n, 4n);
            const m2: Dictionary<bigint, bigint> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.BigInt(256),
            );
            m2.set(1n, 2n);
            m2.set(3n, 5n);
            expect(await contract.getCompareIntInt(m1, m2)).toBe(false);
        }

        // Test Int Cell - Equal
        {
            const m1: Dictionary<bigint, Cell> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.Cell(),
            );
            m1.set(1n, beginCell().storeUint(123, 64).endCell());
            m1.set(3n, beginCell().storeUint(456, 64).endCell());
            const m2: Dictionary<bigint, Cell> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.Cell(),
            );
            m2.set(1n, beginCell().storeUint(123, 64).endCell());
            m2.set(3n, beginCell().storeUint(456, 64).endCell());
            expect(await contract.getCompareIntCell(m1, m2)).toBe(true);
        }

        // Test Int Cell - Not Equal
        {
            const m1: Dictionary<bigint, Cell> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.Cell(),
            );
            m1.set(1n, beginCell().storeUint(123, 64).endCell());
            m1.set(3n, beginCell().storeUint(456, 64).endCell());
            const m2: Dictionary<bigint, Cell> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.Cell(),
            );
            m2.set(1n, beginCell().storeUint(123, 64).endCell());
            m2.set(3n, beginCell().storeUint(457, 64).endCell());
            expect(await contract.getCompareIntCell(m1, m2)).toBe(false);
        }

        // Test Int Address - Equal
        {
            const m1: Dictionary<bigint, Address> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.Address(),
            );
            m1.set(
                1n,
                Address.parseRaw(
                    "0:0000000000000000000000000000000000000000000000000000000000000002",
                ),
            );
            m1.set(
                3n,
                Address.parseRaw(
                    "0:0000000000000000000000000000000000000000000000000000000000000004",
                ),
            );
            const m2: Dictionary<bigint, Address> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.Address(),
            );
            m2.set(
                1n,
                Address.parseRaw(
                    "0:0000000000000000000000000000000000000000000000000000000000000002",
                ),
            );
            m2.set(
                3n,
                Address.parseRaw(
                    "0:0000000000000000000000000000000000000000000000000000000000000004",
                ),
            );
            expect(await contract.getCompareIntAddress(m1, m2)).toBe(true);
        }

        // Test Int Address - Not Equal
        {
            const m1: Dictionary<bigint, Address> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.Address(),
            );
            m1.set(
                1n,
                Address.parseRaw(
                    "0:0000000000000000000000000000000000000000000000000000000000000002",
                ),
            );
            m1.set(
                3n,
                Address.parseRaw(
                    "0:0000000000000000000000000000000000000000000000000000000000000004",
                ),
            );
            const m2: Dictionary<bigint, Address> = Dictionary.empty(
                Dictionary.Keys.BigInt(256),
                Dictionary.Values.Address(),
            );
            m2.set(
                1n,
                Address.parseRaw(
                    "0:0000000000000000000000000000000000000000000000000000000000000002",
                ),
            );
            m2.set(
                3n,
                Address.parseRaw(
                    "0:0000000000000000000000000000000000000000000000000000000000000005",
                ),
            );
            expect(await contract.getCompareIntAddress(m1, m2)).toBe(false);
        }

        // Test edge case (https://github.com/tact-lang/tact/issues/196#issuecomment-2075088934)
        {
            const d1 = beginCell()
                .storeUint(2, 2) // long label
                .storeUint(8, 4) // key length
                .storeUint(1, 8) // key
                .storeBit(true) // value
                .endCell();

            const d2 = beginCell()
                .storeUint(0, 1) // short label
                .storeUint(0b111111110, 9) // key length
                .storeUint(1, 8) // key
                .storeBit(true) // value
                .endCell();

            let result = await treasure.send({
                to: contract.address,
                value: toNano("0.1"),
                body: beginCell()
                    .storeUint(
                        contract.abi.types!.find((t) => t.name === "Compare")!
                            .header!,
                        32,
                    )
                    .storeMaybeRef(d1)
                    .storeMaybeRef(d2)
                    .endCell(),
                init: contract.init,
            });

            expect(result.transactions).toHaveTransaction({
                from: treasure.address,
                to: contract.address,
                success: false,
                exitCode: 53111,
            });

            result = await treasure.send({
                to: contract.address,
                value: toNano("0.1"),
                body: beginCell()
                    .storeUint(
                        contract.abi.types!.find(
                            (t) => t.name === "CompareDeep",
                        )!.header!,
                        32,
                    )
                    .storeMaybeRef(d1)
                    .storeMaybeRef(d2)
                    .endCell(),
                init: contract.init,
            });

            expect(result.transactions).toHaveTransaction({
                from: treasure.address,
                to: contract.address,
                success: true,
            });

            // Just to make sure:
            const m1 = Dictionary.loadDirect(
                Dictionary.Keys.Uint(8),
                Dictionary.Values.Bool(),
                d1,
            );
            const m2 = Dictionary.loadDirect(
                Dictionary.Keys.Uint(8),
                Dictionary.Values.Bool(),
                d2,
            );
            expect(m1.size).toBe(1);
            expect(m2.size).toBe(1);
            expect(m1.get(1)).toBe(true);
            expect(m2.get(1)).toBe(true);
        }
    });
});


## map-traverse.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/map-traverse.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { MapTraverseTestContract } from "./contracts/output/map-traverse_MapTraverseTestContract";
import "@ton/test-utils";

describe("map-traversal", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<MapTraverseTestContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(
            await MapTraverseTestContract.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement map traversal correctly", async () => {
        // Check methods
        expect(await contract.getTestIntInt()).toEqual(1010n);
        expect(await contract.getTestIntBool()).toEqual(12n);
        expect(await contract.getTestIntCell()).toEqual(1010n);
        expect(await contract.getTestIntAddress()).toEqual(28n);
        expect(await contract.getTestIntStruct()).toEqual(1010n);

        expect(await contract.getTestAddressInt()).toEqual(1018n);
        expect(await contract.getTestAddressBool()).toEqual(20n);
        expect(await contract.getTestAddressCell()).toEqual(1018n);
        expect(await contract.getTestAddressAddress()).toEqual(26n);
        expect(await contract.getTestAddressStruct()).toEqual(1018n);

        expect(await contract.getTestEmptyMap()).toEqual(0n);
        expect(await contract.getTestNull()).toEqual(0n);

        expect(await contract.getTestMapModificationDuringTraversal1()).toEqual(
            808n,
        );

        // XXX works on my macOS instance, but fails in CI for some reason
        // await expect(contract.getTestMapModificationDuringTraversal2()).rejects.toMatchObject(Error("Exit code: -14"));

        expect(await contract.getTestMapSize()).toEqual(4n);
        expect(await contract.getTestMapAsField()).toEqual(606n);
        expect(await contract.getTestMapAsStructField()).toEqual(606n);
    });
});


## map.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/map.spec.ts)
/* eslint-disable @typescript-eslint/no-explicit-any */

import { randomAddress } from "../utils/randomAddress";
import {
    MapTestContract,
    MapTestContract$Data,
    SetAllMaps,
    DelAllMaps,
    SomeStruct,
    ReplaceAllMaps,
    ReplaceGetAllMaps,
} from "./contracts/output/maps_MapTestContract";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Address, beginCell, Cell, Dictionary, toNano } from "@ton/core";
import "@ton/test-utils";

// Type Guard for SomeStruct
function isSomeStruct(value: unknown): value is SomeStruct {
    return (
        typeof value === "object" &&
        value !== null &&
        "$$type" in value &&
        (value as { $$type: string }).$$type === "SomeStruct" &&
        "int" in value &&
        "bool" in value &&
        "address" in value &&
        "a" in value &&
        "b" in value &&
        typeof (value as any).int === "bigint" &&
        typeof (value as any).bool === "boolean" &&
        (value as any).address instanceof Address &&
        typeof (value as any).a === "bigint" &&
        typeof (value as any).b === "bigint"
    );
}

// Comparator for SomeStruct
function compareStructs(a: SomeStruct, b: SomeStruct): boolean {
    return (
        a.int === b.int &&
        a.bool === b.bool &&
        a.address.equals(b.address) &&
        a.a === b.a &&
        a.b === b.b
    );
}

// Type definitions for keys and values to make them type-safe
type TestKeys = {
    keyInt: bigint;
    keyInt8: bigint;
    keyInt42: bigint;
    keyInt256: bigint;
    keyUint8: bigint;
    keyUint42: bigint;
    keyUint256: bigint;
    keyAddress: Address;
};

type TestValues = {
    valueInt: bigint;
    valueInt8: bigint;
    valueInt42: bigint;
    valueInt256: bigint;
    valueUint8: bigint;
    valueUint42: bigint;
    valueUint256: bigint;
    valueCoins: bigint;
    valueBool: boolean;
    valueCell: Cell;
    valueAddress: Address;
    valueStruct: SomeStruct;
};

// Configuration for all maps
type MapConfig = {
    mapName: keyof MapTestContract$Data;
    key: keyof TestKeys;
    value: keyof TestValues;
    keyTransform?: (key: any) => any;
    valueTransform?: (value: any) => any;
};

type TestCase = {
    keys: TestKeys;
    values: TestValues;
};

const testCases: TestCase[] = [
    {
        keys: {
            keyInt: 123n,
            keyInt8: -10n,
            keyInt42: 42n,
            keyInt256: 456n,
            keyUint8: 200n,
            keyUint42: 500_000n,
            keyUint256: 1_000_000_000_000n,
            keyAddress: randomAddress(0, "address0"),
        },
        values: {
            valueInt: 999n,
            valueInt8: -128n,
            valueInt42: 123_456n,
            valueInt256: 789n,
            valueUint8: 255n,
            valueUint42: 123_456_789n,
            valueUint256: 999_999_999_999n,
            valueCoins: 100_000_000n,
            valueBool: true,
            valueCell: beginCell().storeUint(42, 32).endCell(),
            valueAddress: randomAddress(0, "address"),
            valueStruct: {
                $$type: "SomeStruct",
                int: 321n,
                bool: false,
                address: randomAddress(0, "address"),
                a: 10n,
                b: -20n,
            } as SomeStruct,
        },
    },
    {
        keys: {
            keyInt: -(2n ** 31n), // Min 32-bit signed int
            keyInt8: -128n, // Min 8-bit signed int
            keyInt42: -(2n ** 41n), // Min 42-bit signed int
            keyInt256: -(2n ** 255n), // Min 256-bit signed int
            keyUint8: 255n, // Max 8-bit unsigned int
            keyUint42: 2n ** 42n - 1n, // Max 42-bit unsigned int
            keyUint256: 2n ** 256n - 1n, // Max 256-bit unsigned int
            keyAddress: randomAddress(0, "address1"),
        },
        values: {
            valueInt: 2n ** 31n - 1n, // Max 32-bit signed int
            valueInt8: 127n, // Max 8-bit signed int
            valueInt42: 2n ** 41n - 1n, // Max 42-bit signed int
            valueInt256: 2n ** 255n - 1n, // Max 256-bit signed int
            valueUint8: 0n, // Min unsigned int
            valueUint42: 0n, // Min unsigned int
            valueUint256: 0n, // Min unsigned int
            valueCoins: 0n,
            valueBool: false,
            valueCell: beginCell()
                .storeUint(2n ** 32n - 1n, 32)
                .endCell(),
            valueAddress: randomAddress(0, "address"),
            valueStruct: {
                $$type: "SomeStruct",
                int: -(2n ** 31n), // Min 32-bit signed int
                bool: true,
                address: randomAddress(0, "address"),
                a: 2n ** 41n - 1n, // Max 42-bit signed int
                b: -(2n ** 41n), // Min 42-bit signed int
            } as SomeStruct,
        },
    },
    {
        keys: {
            keyInt: 0n,
            keyInt8: 0n,
            keyInt42: 0n,
            keyInt256: 0n,
            keyUint8: 0n,
            keyUint42: 0n,
            keyUint256: 0n,
            keyAddress: randomAddress(0, "address2"),
        },
        values: {
            valueInt: 1n,
            valueInt8: -1n,
            valueInt42: -1n,
            valueInt256: 1n,
            valueUint8: 1n,
            valueUint42: 1n,
            valueUint256: 1n,
            valueCoins: 1n,
            valueBool: false,
            valueCell: beginCell().storeUint(0, 32).endCell(),
            valueAddress: randomAddress(0, "address"),
            valueStruct: {
                $$type: "SomeStruct",
                int: 0n,
                bool: false,
                address: randomAddress(0, "address"),
                a: 0n,
                b: 0n,
            } as SomeStruct,
        },
    },
    {
        keys: {
            keyInt: 1n,
            keyInt8: -1n,
            keyInt42: 424n,
            keyInt256: 2n ** 128n, // Large but not maximum value
            keyUint8: 128n, // Middle value
            keyUint42: 2n ** 41n, // Large power of 2
            keyUint256: 2n ** 128n, // Large power of 2
            keyAddress: randomAddress(0, "address3"),
        },
        values: {
            valueInt: -1n,
            valueInt8: -127n, // Near min but not quite
            valueInt42: 2n ** 40n, // Large power of 2
            valueInt256: -(2n ** 254n), // Large negative power of 2
            valueUint8: 128n, // Middle value
            valueUint42: 2n ** 41n, // Large power of 2
            valueUint256: 2n ** 255n, // Large power of 2
            valueCoins: 2n ** 120n - 1n,
            valueBool: true,
            valueCell: beginCell()
                .storeUint(2n ** 31n, 32)
                .endCell(),
            valueAddress: randomAddress(0, "address"),
            valueStruct: {
                $$type: "SomeStruct",
                int: -42n, // Special number
                bool: true,
                address: randomAddress(0, "address"),
                a: 2n ** 40n, // Large power of 2
                b: -(2n ** 40n), // Large negative power of 2
            } as SomeStruct,
        },
    },
];

// Define all 88 map configurations
const mapConfigs: MapConfig[] = [
    // int_* Maps
    { mapName: "int_int", key: "keyInt", value: "valueInt" },
    {
        mapName: "int_int8",
        key: "keyInt",
        value: "valueInt8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "int_int42", key: "keyInt", value: "valueInt42" },
    { mapName: "int_int256", key: "keyInt", value: "valueInt256" },
    {
        mapName: "int_uint8",
        key: "keyInt",
        value: "valueUint8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "int_uint42", key: "keyInt", value: "valueUint42" },
    { mapName: "int_uint256", key: "keyInt", value: "valueUint256" },
    { mapName: "int_bool", key: "keyInt", value: "valueBool" },
    { mapName: "int_cell", key: "keyInt", value: "valueCell" },
    { mapName: "int_address", key: "keyInt", value: "valueAddress" },
    { mapName: "int_struct", key: "keyInt", value: "valueStruct" },

    // int8_* Maps
    {
        mapName: "int8_int",
        key: "keyInt8",
        value: "valueInt",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "int8_int8",
        key: "keyInt8",
        value: "valueInt8",
        keyTransform: (k: bigint) => Number(k),
        valueTransform: (v: bigint) => Number(v),
    },
    {
        mapName: "int8_int42",
        key: "keyInt8",
        value: "valueInt42",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "int8_int256",
        key: "keyInt8",
        value: "valueInt256",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "int8_uint8",
        key: "keyInt8",
        value: "valueUint8",
        keyTransform: (k: bigint) => Number(k),
        valueTransform: (v: bigint) => Number(v),
    },
    {
        mapName: "int8_uint42",
        key: "keyInt8",
        value: "valueUint42",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "int8_uint256",
        key: "keyInt8",
        value: "valueUint256",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "int8_bool",
        key: "keyInt8",
        value: "valueBool",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "int8_cell",
        key: "keyInt8",
        value: "valueCell",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "int8_address",
        key: "keyInt8",
        value: "valueAddress",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "int8_struct",
        key: "keyInt8",
        value: "valueStruct",
        keyTransform: (k: bigint) => Number(k),
    },

    // int42_* Maps
    { mapName: "int42_int", key: "keyInt42", value: "valueInt" },
    {
        mapName: "int42_int8",
        key: "keyInt42",
        value: "valueInt8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "int42_int42", key: "keyInt42", value: "valueInt42" },
    { mapName: "int42_int256", key: "keyInt42", value: "valueInt256" },
    {
        mapName: "int42_uint8",
        key: "keyInt42",
        value: "valueUint8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "int42_uint42", key: "keyInt42", value: "valueUint42" },
    { mapName: "int42_uint256", key: "keyInt42", value: "valueUint256" },
    { mapName: "int42_bool", key: "keyInt42", value: "valueBool" },
    { mapName: "int42_cell", key: "keyInt42", value: "valueCell" },
    { mapName: "int42_address", key: "keyInt42", value: "valueAddress" },
    { mapName: "int42_struct", key: "keyInt42", value: "valueStruct" },

    // int256_* Maps
    { mapName: "int256_int", key: "keyInt256", value: "valueInt" },
    {
        mapName: "int256_int8",
        key: "keyInt256",
        value: "valueInt8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "int256_int42", key: "keyInt256", value: "valueInt42" },
    { mapName: "int256_int256", key: "keyInt256", value: "valueInt256" },
    {
        mapName: "int256_uint8",
        key: "keyInt256",
        value: "valueUint8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "int256_uint42", key: "keyInt256", value: "valueUint42" },
    { mapName: "int256_uint256", key: "keyInt256", value: "valueUint256" },
    { mapName: "int256_bool", key: "keyInt256", value: "valueBool" },
    { mapName: "int256_cell", key: "keyInt256", value: "valueCell" },
    { mapName: "int256_address", key: "keyInt256", value: "valueAddress" },
    { mapName: "int256_struct", key: "keyInt256", value: "valueStruct" },

    // uint8_* Maps
    {
        mapName: "uint8_int",
        key: "keyUint8",
        value: "valueInt",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "uint8_int8",
        key: "keyUint8",
        value: "valueInt8",
        keyTransform: (k: bigint) => Number(k),
        valueTransform: (v: bigint) => Number(v),
    },
    {
        mapName: "uint8_int42",
        key: "keyUint8",
        value: "valueInt42",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "uint8_int256",
        key: "keyUint8",
        value: "valueInt256",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "uint8_uint8",
        key: "keyUint8",
        value: "valueUint8",
        keyTransform: (k: bigint) => Number(k),
        valueTransform: (v: bigint) => Number(v),
    },
    {
        mapName: "uint8_uint42",
        key: "keyUint8",
        value: "valueUint42",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "uint8_uint256",
        key: "keyUint8",
        value: "valueUint256",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "uint8_bool",
        key: "keyUint8",
        value: "valueBool",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "uint8_cell",
        key: "keyUint8",
        value: "valueCell",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "uint8_address",
        key: "keyUint8",
        value: "valueAddress",
        keyTransform: (k: bigint) => Number(k),
    },
    {
        mapName: "uint8_struct",
        key: "keyUint8",
        value: "valueStruct",
        keyTransform: (k: bigint) => Number(k),
    },

    // uint42_* Maps
    { mapName: "uint42_int", key: "keyUint42", value: "valueInt" },
    {
        mapName: "uint42_int8",
        key: "keyUint42",
        value: "valueInt8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "uint42_int42", key: "keyUint42", value: "valueInt42" },
    { mapName: "uint42_int256", key: "keyUint42", value: "valueInt256" },
    {
        mapName: "uint42_uint8",
        key: "keyUint42",
        value: "valueUint8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "uint42_uint42", key: "keyUint42", value: "valueUint42" },
    { mapName: "uint42_uint256", key: "keyUint42", value: "valueUint256" },
    { mapName: "uint42_bool", key: "keyUint42", value: "valueBool" },
    { mapName: "uint42_cell", key: "keyUint42", value: "valueCell" },
    { mapName: "uint42_address", key: "keyUint42", value: "valueAddress" },
    { mapName: "uint42_struct", key: "keyUint42", value: "valueStruct" },

    // uint256_* Maps
    { mapName: "uint256_int", key: "keyUint256", value: "valueInt" },
    {
        mapName: "uint256_int8",
        key: "keyUint256",
        value: "valueInt8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "uint256_int42", key: "keyUint256", value: "valueInt42" },
    { mapName: "uint256_int256", key: "keyUint256", value: "valueInt256" },
    {
        mapName: "uint256_uint8",
        key: "keyUint256",
        value: "valueUint8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "uint256_uint42", key: "keyUint256", value: "valueUint42" },
    { mapName: "uint256_uint256", key: "keyUint256", value: "valueUint256" },
    { mapName: "uint256_bool", key: "keyUint256", value: "valueBool" },
    { mapName: "uint256_cell", key: "keyUint256", value: "valueCell" },
    { mapName: "uint256_address", key: "keyUint256", value: "valueAddress" },
    { mapName: "uint256_struct", key: "keyUint256", value: "valueStruct" },

    // address_* Maps
    { mapName: "address_int", key: "keyAddress", value: "valueInt" },
    {
        mapName: "address_int8",
        key: "keyAddress",
        value: "valueInt8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "address_int42", key: "keyAddress", value: "valueInt42" },
    { mapName: "address_int256", key: "keyAddress", value: "valueInt256" },
    {
        mapName: "address_uint8",
        key: "keyAddress",
        value: "valueUint8",
        valueTransform: (v: bigint) => Number(v),
    },
    { mapName: "address_uint42", key: "keyAddress", value: "valueUint42" },
    { mapName: "address_uint256", key: "keyAddress", value: "valueUint256" },
    { mapName: "address_bool", key: "keyAddress", value: "valueBool" },
    { mapName: "address_cell", key: "keyAddress", value: "valueCell" },
    { mapName: "address_address", key: "keyAddress", value: "valueAddress" },
    { mapName: "address_struct", key: "keyAddress", value: "valueStruct" },
];

describe("MapTestContract", () => {
    let blockchain: Blockchain;
    let treasury: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<MapTestContract>;

    beforeEach(async () => {
        // Initialize the blockchain and contracts
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasury = await blockchain.treasury("treasury");
        contract = blockchain.openContract(await MapTestContract.fromInit());

        // Fund the contract with some TONs
        await contract.send(
            treasury.getSender(),
            { value: toNano("10") },
            null,
        );

        // Check that all maps are empty initially
        const maps = await contract.getAllMaps();
        for (const [_mapName, map] of Object.entries(maps)) {
            if (map instanceof Dictionary) {
                expect(map.size).toBe(0);
            }
        }
    });

    it("set: should set and clear values", async () => {
        for (const { keys, values } of testCases) {
            // Send the set operation
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            // Retrieve all maps using `allMaps` getter
            const allMaps = await contract.getAllMaps();

            // Iterate over mapConfigs and perform assertions
            mapConfigs.forEach(
                ({ mapName, key, value, keyTransform, valueTransform }) => {
                    const map = allMaps[mapName] as Dictionary<any, any>;

                    expect(map.size).toBe(1);

                    let mapKey = keys[key];
                    if (keyTransform) {
                        mapKey = keyTransform(mapKey);
                    }

                    let expectedValue = values[value];
                    if (valueTransform) {
                        expectedValue = valueTransform(expectedValue);
                    }

                    const actualValue = map.get(mapKey);

                    if (expectedValue instanceof Cell) {
                        expect(actualValue).toEqualCell(expectedValue);
                    } else if (expectedValue instanceof Address) {
                        expect(actualValue).toEqualAddress(expectedValue);
                    } else if (isSomeStruct(expectedValue)) {
                        expect(compareStructs(actualValue, expectedValue)).toBe(
                            true,
                        );
                    } else {
                        expect(actualValue).toEqual(expectedValue);
                    }
                },
            );

            // Clear all maps by setting values to null
            const clearMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                valueInt: null,
                valueInt8: null,
                valueInt42: null,
                valueInt256: null,
                valueUint8: null,
                valueUint42: null,
                valueUint256: null,
                valueCoins: null,
                valueBool: null,
                valueCell: null,
                valueAddress: null,
                valueStruct: null,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                clearMessage,
            );

            // Retrieve all maps again to ensure they are empty
            const clearedMaps = await contract.getAllMaps();

            // Iterate over mapConfigs and assert maps are empty
            mapConfigs.forEach(({ mapName }) => {
                const map = clearedMaps[mapName] as Dictionary<any, any>;
                expect(map.size).toBe(0);
            });
        }
    });

    it("set: should set multiple values", async () => {
        for (const { keys, values } of testCases) {
            // Send the set operation
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );
        }

        // Retrieve all maps using `allMaps` getter
        const allMaps = await contract.getAllMaps();

        for (const { keys, values } of testCases) {
            // Iterate over mapConfigs and perform assertions
            mapConfigs.forEach(
                ({ mapName, key, value, keyTransform, valueTransform }) => {
                    const map = allMaps[mapName] as Dictionary<any, any>;

                    expect(map.size).toBe(testCases.length);

                    let mapKey = keys[key];
                    if (keyTransform) {
                        mapKey = keyTransform(mapKey);
                    }

                    let expectedValue = values[value];
                    if (valueTransform) {
                        expectedValue = valueTransform(expectedValue);
                    }

                    const actualValue = map.get(mapKey);

                    if (expectedValue instanceof Cell) {
                        expect(actualValue).toEqualCell(expectedValue);
                    } else if (expectedValue instanceof Address) {
                        expect(actualValue).toEqualAddress(expectedValue);
                    } else if (isSomeStruct(expectedValue)) {
                        expect(compareStructs(actualValue, expectedValue)).toBe(
                            true,
                        );
                    } else {
                        expect(actualValue).toEqual(expectedValue);
                    }
                },
            );
        }

        for (const { keys } of testCases) {
            // Clear all maps by setting values to null
            const clearMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                valueInt: null,
                valueInt8: null,
                valueInt42: null,
                valueInt256: null,
                valueUint8: null,
                valueUint42: null,
                valueUint256: null,
                valueCoins: null,
                valueBool: null,
                valueCell: null,
                valueAddress: null,
                valueStruct: null,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                clearMessage,
            );
        }

        // Retrieve all maps again to ensure they are empty
        const clearedMaps = await contract.getAllMaps();

        // Iterate over mapConfigs and assert maps are empty
        mapConfigs.forEach(({ mapName }) => {
            const map = clearedMaps[mapName] as Dictionary<any, any>;
            expect(map.size).toBe(0);
        });
    });

    it("set: should overwrite values", async () => {
        for (const { keys } of testCases) {
            for (const { values } of testCases) {
                // Send the set operation
                const setMessage: SetAllMaps = {
                    $$type: "SetAllMaps",
                    ...keys,
                    ...values,
                };

                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    setMessage,
                );

                // Retrieve all maps using `allMaps` getter
                const allMaps = await contract.getAllMaps();

                // Iterate over mapConfigs and perform assertions
                mapConfigs.forEach(
                    ({ mapName, key, value, keyTransform, valueTransform }) => {
                        const map = allMaps[mapName] as Dictionary<any, any>;

                        expect(map.size).toBe(1);

                        let mapKey = keys[key];
                        if (keyTransform) {
                            mapKey = keyTransform(mapKey);
                        }

                        let expectedValue = values[value];
                        if (valueTransform) {
                            expectedValue = valueTransform(expectedValue);
                        }

                        const actualValue = map.get(mapKey);

                        if (expectedValue instanceof Cell) {
                            expect(actualValue).toEqualCell(expectedValue);
                        } else if (expectedValue instanceof Address) {
                            expect(actualValue).toEqualAddress(expectedValue);
                        } else if (isSomeStruct(expectedValue)) {
                            expect(
                                compareStructs(actualValue, expectedValue),
                            ).toBe(true);
                        } else {
                            expect(actualValue).toEqual(expectedValue);
                        }
                    },
                );
            }

            // Clear all maps by setting values to null
            const clearMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                valueInt: null,
                valueInt8: null,
                valueInt42: null,
                valueInt256: null,
                valueUint8: null,
                valueUint42: null,
                valueUint256: null,
                valueCoins: null,
                valueBool: null,
                valueCell: null,
                valueAddress: null,
                valueStruct: null,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                clearMessage,
            );

            // Retrieve all maps again to ensure they are empty
            const clearedMaps = await contract.getAllMaps();

            // Iterate over mapConfigs and assert maps are empty
            mapConfigs.forEach(({ mapName }) => {
                const map = clearedMaps[mapName] as Dictionary<any, any>;
                expect(map.size).toBe(0);
            });
        }
    });

    it("get: should get values after setting them and nulls after clearing", async () => {
        for (const { keys, values } of testCases) {
            // Send the set operation
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            // Call the .get operation on all maps
            const getResponse = await contract.getGetAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
            );

            // Iterate over mapConfigs and perform assertions
            mapConfigs.forEach(
                ({
                    mapName,
                    key: _key,
                    value,
                    keyTransform: _keyTransform,
                    valueTransform,
                }) => {
                    let expectedValue = values[value];
                    let actualValue = getResponse[mapName];

                    if (valueTransform) {
                        expectedValue = valueTransform(expectedValue);
                        actualValue = valueTransform(actualValue);
                    }

                    if (expectedValue instanceof Cell) {
                        expect(actualValue).toEqualCell(expectedValue);
                    } else if (expectedValue instanceof Address) {
                        expect(actualValue).toEqualAddress(expectedValue);
                    } else if (isSomeStruct(expectedValue)) {
                        expect(
                            compareStructs(
                                actualValue as SomeStruct,
                                expectedValue,
                            ),
                        ).toBe(true);
                    } else {
                        expect(actualValue).toEqual(expectedValue);
                    }
                },
            );

            // Clear all maps by setting values to null
            const clearMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                valueInt: null,
                valueInt8: null,
                valueInt42: null,
                valueInt256: null,
                valueUint8: null,
                valueUint42: null,
                valueUint256: null,
                valueCoins: null,
                valueBool: null,
                valueCell: null,
                valueAddress: null,
                valueStruct: null,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                clearMessage,
            );

            // Call the .get operation on all maps again
            const clearedGetResponse = await contract.getGetAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
            );

            // Iterate over mapConfigs and assert maps are empty
            mapConfigs.forEach(({ mapName }) => {
                const actualValue = clearedGetResponse[mapName];
                expect(actualValue).toBeNull();
            });
        }
    });

    it("get: should return null for all maps when no values are set", async () => {
        for (const { keys } of testCases) {
            // Call the .get operation on all maps
            const getResponse = await contract.getGetAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
            );

            // Iterate over mapConfigs and assert that all values are null
            mapConfigs.forEach(({ mapName }) => {
                const actualValue = getResponse[mapName];
                expect(actualValue).toBeNull();
            });
        }
    });

    it("get: should retrieve multiple values after setting them", async () => {
        // Set multiple values
        for (const { keys, values } of testCases) {
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );
        }

        // Now retrieve values for each test case
        for (const { keys, values } of testCases) {
            // Call the .get operation on all maps
            const getResponse = await contract.getGetAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
            );

            // Iterate over mapConfigs and perform assertions
            mapConfigs.forEach(
                ({
                    mapName,
                    key: _key,
                    value,
                    keyTransform: _keyTransform,
                    valueTransform,
                }) => {
                    let expectedValue = values[value];
                    let actualValue = getResponse[mapName];

                    if (valueTransform) {
                        expectedValue = valueTransform(expectedValue);
                        actualValue = valueTransform(actualValue);
                    }

                    if (expectedValue instanceof Cell) {
                        expect(actualValue).toEqualCell(expectedValue);
                    } else if (expectedValue instanceof Address) {
                        expect(actualValue).toEqualAddress(expectedValue);
                    } else if (isSomeStruct(expectedValue)) {
                        expect(
                            compareStructs(
                                actualValue as SomeStruct,
                                expectedValue,
                            ),
                        ).toBe(true);
                    } else {
                        expect(actualValue).toEqual(expectedValue);
                    }
                },
            );
        }
    });

    it("get: should retrieve updated values after overwriting", async () => {
        for (const { keys } of testCases) {
            for (const { values } of testCases) {
                // Send the set operation
                const setMessage: SetAllMaps = {
                    $$type: "SetAllMaps",
                    ...keys,
                    ...values,
                };

                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    setMessage,
                );

                // Call the .get operation on all maps
                const getResponse = await contract.getGetAllMaps(
                    keys.keyInt,
                    keys.keyInt8,
                    keys.keyInt42,
                    keys.keyInt256,
                    keys.keyUint8,
                    keys.keyUint42,
                    keys.keyUint256,
                    keys.keyAddress,
                );

                // Iterate over mapConfigs and perform assertions
                mapConfigs.forEach(
                    ({
                        mapName,
                        key: _key,
                        value,
                        keyTransform: _keyTransform,
                        valueTransform,
                    }) => {
                        let expectedValue = values[value];
                        let actualValue = getResponse[mapName];

                        if (valueTransform) {
                            expectedValue = valueTransform(expectedValue);
                            actualValue = valueTransform(actualValue);
                        }

                        if (expectedValue instanceof Cell) {
                            expect(actualValue).toEqualCell(expectedValue);
                        } else if (expectedValue instanceof Address) {
                            expect(actualValue).toEqualAddress(expectedValue);
                        } else if (isSomeStruct(expectedValue)) {
                            expect(
                                compareStructs(
                                    actualValue as SomeStruct,
                                    expectedValue,
                                ),
                            ).toBe(true);
                        } else {
                            expect(actualValue).toEqual(expectedValue);
                        }
                    },
                );
            }
        }
    });

    it("get: should return null for non-existent keys", async () => {
        // First, set some keys
        for (const { keys, values } of testCases.slice(0, -1)) {
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );
        }

        // Now, attempt to get values for keys that have not been set
        const nonExistentKeys = testCases[testCases.length - 1]!.keys;

        const getResponse = await contract.getGetAllMaps(
            nonExistentKeys.keyInt,
            nonExistentKeys.keyInt8,
            nonExistentKeys.keyInt42,
            nonExistentKeys.keyInt256,
            nonExistentKeys.keyUint8,
            nonExistentKeys.keyUint42,
            nonExistentKeys.keyUint256,
            nonExistentKeys.keyAddress,
        );

        // Iterate over mapConfigs and assert that values are null
        mapConfigs.forEach(({ mapName }) => {
            const actualValue = getResponse[mapName];
            expect(actualValue).toBeNull();
        });
    });

    it("del: should delete values", async () => {
        for (const { keys, values } of testCases) {
            // Send the set operation
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            // Retrieve all maps using `allMaps` getter to ensure they are set
            const allMapsBeforeDel = await contract.getAllMaps();

            // Iterate over mapConfigs and verify all maps have one entry
            mapConfigs.forEach(
                ({ mapName, key, value, keyTransform, valueTransform }) => {
                    const map = allMapsBeforeDel[mapName] as Dictionary<
                        any,
                        any
                    >;

                    expect(map.size).toBe(1);

                    let mapKey = keys[key];
                    if (keyTransform) {
                        mapKey = keyTransform(mapKey);
                    }

                    let expectedValue = values[value];
                    if (valueTransform) {
                        expectedValue = valueTransform(expectedValue);
                    }

                    const actualValue = map.get(mapKey);

                    if (expectedValue instanceof Cell) {
                        expect(actualValue).toEqualCell(expectedValue);
                    } else if (expectedValue instanceof Address) {
                        expect(actualValue).toEqualAddress(expectedValue);
                    } else if (isSomeStruct(expectedValue)) {
                        expect(compareStructs(actualValue, expectedValue)).toBe(
                            true,
                        );
                    } else {
                        expect(actualValue).toEqual(expectedValue);
                    }
                },
            );

            // Send the del operation
            const delMessage: DelAllMaps = {
                $$type: "DelAllMaps",
                ...keys,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                delMessage,
            );

            // Retrieve all maps using `allMaps` getter to ensure they are deleted
            const allMapsAfterDel = await contract.getAllMaps();

            // Iterate over mapConfigs and assert maps are empty
            mapConfigs.forEach(({ mapName }) => {
                const map = allMapsAfterDel[mapName] as Dictionary<any, any>;
                expect(map.size).toBe(0);
            });
        }
    });

    it("del: should delete multiple values", async () => {
        // Set multiple values
        for (const { keys, values } of testCases) {
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );
        }

        // Check that all maps are set
        const allMapsBeforeDel = await contract.getAllMaps();
        mapConfigs.forEach(({ mapName }) => {
            const map = allMapsBeforeDel[mapName] as Dictionary<any, any>;
            expect(map.size).toBe(testCases.length);
        });

        // Delete them
        for (const { keys } of testCases) {
            const delMessage: DelAllMaps = { $$type: "DelAllMaps", ...keys };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                delMessage,
            );
        }

        // Ensure maps are empty
        const allMapsAfterDel = await contract.getAllMaps();
        mapConfigs.forEach(({ mapName }) => {
            const map = allMapsAfterDel[mapName] as Dictionary<any, any>;
            expect(map.size).toBe(0);
        });
    });

    it("del: should not affect other keys when deleting", async () => {
        // Set multiple values
        for (const { keys, values } of testCases) {
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );
        }

        // Delete only the first test case's keys
        const keysToDelete = testCases[0]!.keys;
        const delMessage: DelAllMaps = {
            $$type: "DelAllMaps",
            ...keysToDelete,
        };
        await contract.send(
            treasury.getSender(),
            { value: toNano("1") },
            delMessage,
        );

        // Check that only the deleted keys are removed
        const allMapsAfterDel = await contract.getAllMaps();
        mapConfigs.forEach(({ mapName }) => {
            const map = allMapsAfterDel[mapName] as Dictionary<any, any>;
            expect(map.size).toBe(testCases.length - 1);
        });

        // Verify other keys are unaffected
        for (const { keys, values } of testCases.slice(1)) {
            const getResponse = await contract.getAllMaps();

            mapConfigs.forEach(
                ({ mapName, key, value, keyTransform, valueTransform }) => {
                    const map = getResponse[mapName] as Dictionary<any, any>;

                    let mapKey = keys[key];
                    if (keyTransform) {
                        mapKey = keyTransform(mapKey);
                    }

                    let expectedValue = values[value];
                    if (valueTransform) {
                        expectedValue = valueTransform(expectedValue);
                    }

                    const actualValue = map.get(mapKey);

                    if (expectedValue instanceof Cell) {
                        expect(actualValue).toEqualCell(expectedValue);
                    } else if (expectedValue instanceof Address) {
                        expect(actualValue).toEqualAddress(expectedValue);
                    } else if (isSomeStruct(expectedValue)) {
                        expect(compareStructs(actualValue, expectedValue)).toBe(
                            true,
                        );
                    } else {
                        expect(actualValue).toEqual(expectedValue);
                    }
                },
            );
        }
    });

    it("del: should do nothing when deleting non-existent keys", async () => {
        // Set values except for the last test case
        for (const { keys, values } of testCases.slice(0, -1)) {
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );
        }

        // Ensure existing data is unaffected
        const allMapsBeforeDel = await contract.getAllMaps();
        mapConfigs.forEach(({ mapName }) => {
            const map = allMapsBeforeDel[mapName] as Dictionary<any, any>;
            expect(map.size).toBe(testCases.length - 1);
        });

        // Attempt to delete non-existent keys
        const nonExistentKeys = testCases[testCases.length - 1]!.keys;
        const delMessage: DelAllMaps = {
            $$type: "DelAllMaps",
            ...nonExistentKeys,
        };
        await contract.send(
            treasury.getSender(),
            { value: toNano("1") },
            delMessage,
        );

        // Ensure existing data is unaffected
        const allMapsAfterDel = await contract.getAllMaps();
        mapConfigs.forEach(({ mapName }) => {
            const map = allMapsAfterDel[mapName] as Dictionary<any, any>;
            expect(map.size).toBe(testCases.length - 1);
        });

        // Verify that the existing values are still there
        for (const { keys, values } of testCases.slice(0, -1)) {
            const allMaps = await contract.getAllMaps();

            mapConfigs.forEach(
                ({ mapName, key, value, keyTransform, valueTransform }) => {
                    const map = allMaps[mapName] as Dictionary<any, any>;

                    let mapKey = keys[key];
                    if (keyTransform) {
                        mapKey = keyTransform(mapKey);
                    }

                    let expectedValue = values[value];
                    if (valueTransform) {
                        expectedValue = valueTransform(expectedValue);
                    }

                    const actualValue = map.get(mapKey);

                    if (expectedValue instanceof Cell) {
                        expect(actualValue).toEqualCell(expectedValue);
                    } else if (expectedValue instanceof Address) {
                        expect(actualValue).toEqualAddress(expectedValue);
                    } else if (isSomeStruct(expectedValue)) {
                        expect(compareStructs(actualValue, expectedValue)).toBe(
                            true,
                        );
                    } else {
                        expect(actualValue).toEqual(expectedValue);
                    }
                },
            );
        }
    });

    it("del: should handle delete after overwriting", async () => {
        for (const { keys } of testCases) {
            for (const { values } of testCases) {
                // Set values
                const setMessage: SetAllMaps = {
                    $$type: "SetAllMaps",
                    ...keys,
                    ...values,
                };
                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    setMessage,
                );

                // Delete values
                const delMessage: DelAllMaps = {
                    $$type: "DelAllMaps",
                    ...keys,
                };
                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    delMessage,
                );

                // Ensure maps are empty
                const allMapsAfterDel = await contract.getAllMaps();
                mapConfigs.forEach(({ mapName }) => {
                    const map = allMapsAfterDel[mapName] as Dictionary<
                        any,
                        any
                    >;
                    expect(map.size).toBe(0);
                });
            }
        }
    });

    it("exists: should return 'true' for existing keys and 'false' for non-existent keys", async () => {
        // Set values for all test cases
        for (const { keys, values } of testCases.slice(0, -1)) {
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );
        }

        // Check that all keys exist
        for (const { keys } of testCases.slice(0, -1)) {
            const existsResponse = await contract.getExistsAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
            );

            Object.values(existsResponse).forEach((exists) => {
                if (typeof exists === "boolean") {
                    expect(exists).toBe(true);
                }
            });
        }

        // Check that non-existent keys do not exist
        const nonExistentKeys = testCases[testCases.length - 1]!.keys;
        const nonExistentResponse = await contract.getExistsAllMaps(
            nonExistentKeys.keyInt,
            nonExistentKeys.keyInt8,
            nonExistentKeys.keyInt42,
            nonExistentKeys.keyInt256,
            nonExistentKeys.keyUint8,
            nonExistentKeys.keyUint42,
            nonExistentKeys.keyUint256,
            nonExistentKeys.keyAddress,
        );

        Object.values(nonExistentResponse).forEach((exists) => {
            if (typeof exists === "boolean") {
                expect(exists).toBe(false);
            }
        });
    });

    it("exists: should still return 'true' after overwriting", async () => {
        for (const { keys } of testCases) {
            for (const { values } of testCases) {
                // Send the set operation
                const setMessage: SetAllMaps = {
                    $$type: "SetAllMaps",
                    ...keys,
                    ...values,
                };

                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    setMessage,
                );

                // Call the .exists operation on all maps
                const existsResponse = await contract.getExistsAllMaps(
                    keys.keyInt,
                    keys.keyInt8,
                    keys.keyInt42,
                    keys.keyInt256,
                    keys.keyUint8,
                    keys.keyUint42,
                    keys.keyUint256,
                    keys.keyAddress,
                );

                Object.values(existsResponse).forEach((exists) => {
                    if (typeof exists === "boolean") {
                        expect(exists).toBe(true);
                    }
                });
            }
        }
    });

    it("exists: should return 'false' for all keys after clearing all maps", async () => {
        for (const { keys, values } of testCases) {
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );
        }

        for (const { keys } of testCases) {
            const clearMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                valueInt: null,
                valueInt8: null,
                valueInt42: null,
                valueInt256: null,
                valueUint8: null,
                valueUint42: null,
                valueUint256: null,
                valueCoins: null,
                valueBool: null,
                valueCell: null,
                valueAddress: null,
                valueStruct: null,
            };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                clearMessage,
            );
        }

        for (const { keys } of testCases) {
            const existsResponse = await contract.getExistsAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
            );

            Object.values(existsResponse).forEach((exists) => {
                if (typeof exists === "boolean") {
                    expect(exists).toBe(false);
                }
            });
        }
    });

    it("isEmpty: should return 'true' for empty maps and 'false' for non-empty maps", async () => {
        for (const { keys, values } of testCases) {
            // Check that all maps are empty initially
            const initialIsEmptyResponse = await contract.getIsEmptyAllMaps();
            Object.values(initialIsEmptyResponse).forEach((isEmpty) => {
                if (typeof isEmpty === "boolean") {
                    expect(isEmpty).toBe(true);
                }
            });

            // Set values for the current test case
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            // Check that all maps are non-empty
            const nonEmptyIsEmptyResponse = await contract.getIsEmptyAllMaps();
            Object.values(nonEmptyIsEmptyResponse).forEach((isEmpty) => {
                if (typeof isEmpty === "boolean") {
                    expect(isEmpty).toBe(false);
                }
            });

            // Clear all maps
            for (const { keys } of testCases) {
                const clearMessage: SetAllMaps = {
                    $$type: "SetAllMaps",
                    ...keys,
                    valueInt: null,
                    valueInt8: null,
                    valueInt42: null,
                    valueInt256: null,
                    valueUint8: null,
                    valueUint42: null,
                    valueUint256: null,
                    valueCoins: null,
                    valueBool: null,
                    valueCell: null,
                    valueAddress: null,
                    valueStruct: null,
                };
                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    clearMessage,
                );
            }

            // Check that all maps are empty again
            const emptyIsEmptyResponse = await contract.getIsEmptyAllMaps();
            Object.values(emptyIsEmptyResponse).forEach((isEmpty) => {
                if (typeof isEmpty === "boolean") {
                    expect(isEmpty).toBe(true);
                }
            });
        }
    });

    it("asCell: should correctly serialize and deserialize maps", async () => {
        for (const { keys, values } of testCases) {
            // Set values for the current test case
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };
            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            // Serialize all maps to a Cell
            const cellResponse = await contract.getAsCellAllMaps();

            // Retrieve all maps using `allMaps` getter
            const allMaps = await contract.getAllMaps();

            // Iterate over mapConfigs and perform assertions
            mapConfigs.forEach(
                ({ mapName, key, value, keyTransform, valueTransform }) => {
                    const map = allMaps[mapName] as Dictionary<any, any>;

                    expect(map.size).toBe(1);

                    let mapKey = keys[key];
                    if (keyTransform) {
                        mapKey = keyTransform(mapKey);
                    }

                    let expectedValue = values[value];
                    if (valueTransform) {
                        expectedValue = valueTransform(expectedValue);
                    }

                    const actualValue = map.get(mapKey);

                    if (expectedValue instanceof Cell) {
                        expect(actualValue).toEqualCell(expectedValue);
                    } else if (expectedValue instanceof Address) {
                        expect(actualValue).toEqualAddress(expectedValue);
                    } else if (isSomeStruct(expectedValue)) {
                        expect(compareStructs(actualValue, expectedValue)).toBe(
                            true,
                        );
                    } else {
                        expect(actualValue).toEqual(expectedValue);
                    }

                    // Serialize the map from allMaps to a Cell to compare with the response
                    const serializedMap = beginCell()
                        .storeDictDirect(map)
                        .endCell();

                    expect(cellResponse[mapName]).toEqualCell(serializedMap);
                },
            );

            // Clear all maps
            for (const { keys } of testCases) {
                const clearMessage: SetAllMaps = {
                    $$type: "SetAllMaps",
                    ...keys,
                    valueInt: null,
                    valueInt8: null,
                    valueInt42: null,
                    valueInt256: null,
                    valueUint8: null,
                    valueUint42: null,
                    valueUint256: null,
                    valueCoins: null,
                    valueBool: null,
                    valueCell: null,
                    valueAddress: null,
                    valueStruct: null,
                };
                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    clearMessage,
                );
            }
        }
    });

    it("replace: should replace values and clear them", async () => {
        for (const { keys } of testCases) {
            // Send the set operation
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...testCases[0]!.values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            for (const { values } of testCases) {
                // Send the replace operation
                const replaceMessage: ReplaceAllMaps = {
                    $$type: "ReplaceAllMaps",
                    ...keys,
                    ...values,
                };

                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    replaceMessage,
                );

                // Retrieve all maps using `allMaps` getter
                const allMaps = await contract.getAllMaps();

                // Iterate over mapConfigs and perform assertions
                mapConfigs.forEach(
                    ({ mapName, key, value, keyTransform, valueTransform }) => {
                        const map = allMaps[mapName] as Dictionary<any, any>;

                        expect(map.size).toBe(1);

                        let mapKey = keys[key];
                        if (keyTransform) {
                            mapKey = keyTransform(mapKey);
                        }

                        let expectedValue = values[value];
                        if (valueTransform) {
                            expectedValue = valueTransform(expectedValue);
                        }

                        const actualValue = map.get(mapKey);

                        if (expectedValue instanceof Cell) {
                            expect(actualValue).toEqualCell(expectedValue);
                        } else if (expectedValue instanceof Address) {
                            expect(actualValue).toEqualAddress(expectedValue);
                        } else if (isSomeStruct(expectedValue)) {
                            expect(
                                compareStructs(actualValue, expectedValue),
                            ).toBe(true);
                        } else {
                            expect(actualValue).toEqual(expectedValue);
                        }
                    },
                );
            }

            // Clear all maps
            for (const { keys } of testCases) {
                const clearMessage: ReplaceAllMaps = {
                    $$type: "ReplaceAllMaps",
                    ...keys,
                    valueInt: null,
                    valueInt8: null,
                    valueInt42: null,
                    valueInt256: null,
                    valueUint8: null,
                    valueUint42: null,
                    valueUint256: null,
                    valueCoins: null,
                    valueBool: null,
                    valueCell: null,
                    valueAddress: null,
                    valueStruct: null,
                };
                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    clearMessage,
                );
            }
        }

        // Check that all maps are empty again
        const allMaps = await contract.getAllMaps();
        mapConfigs.forEach(({ mapName }) => {
            const map = allMaps[mapName] as Dictionary<any, any>;
            expect(map.size).toBe(0);
        });
    });

    it("replace: should not replace values when keys do not exist", async () => {
        for (const { keys, values } of testCases) {
            // Send the replace operation
            const replaceMessage: ReplaceAllMaps = {
                $$type: "ReplaceAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                replaceMessage,
            );

            // Retrieve all maps using `allMaps` getter
            const allMaps = await contract.getAllMaps();

            // Check that all maps are still empty
            mapConfigs.forEach(({ mapName }) => {
                const map = allMaps[mapName] as Dictionary<any, any>;
                expect(map.size).toBe(0);
            });
        }
    });

    it("replace: should return 'true' when replacing values and 'false' when keys do not exist", async () => {
        for (const { keys, values } of testCases) {
            // Call the .replace operation on all maps
            const replaceResult = await contract.getReplaceAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
                values.valueInt,
                values.valueInt8,
                values.valueInt42,
                values.valueInt256,
                values.valueUint8,
                values.valueUint42,
                values.valueUint256,
                values.valueCoins,
                values.valueBool,
                values.valueCell,
                values.valueAddress,
                values.valueStruct,
            );

            // Check that all return values are 'false'
            Object.values(replaceResult).forEach((result) => {
                if (typeof result === "boolean") {
                    expect(result).toBe(false);
                }
            });

            // Send the set operation
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            // Call the .replace operation on all maps
            const replaceResultAfterSet = await contract.getReplaceAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
                values.valueInt,
                values.valueInt8,
                values.valueInt42,
                values.valueInt256,
                values.valueUint8,
                values.valueUint42,
                values.valueUint256,
                values.valueCoins,
                values.valueBool,
                values.valueCell,
                values.valueAddress,
                values.valueStruct,
            );

            // Check that all return values are 'true'
            Object.values(replaceResultAfterSet).forEach((result) => {
                if (typeof result === "boolean") {
                    expect(result).toBe(true);
                }
            });
        }
    });

    it("replaceGet: should replace values and clear them", async () => {
        for (const { keys } of testCases) {
            // Send the set operation
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...testCases[0]!.values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            for (const { values } of testCases) {
                // Send the replace operation
                const replaceGetMessage: ReplaceGetAllMaps = {
                    $$type: "ReplaceGetAllMaps",
                    ...keys,
                    ...values,
                };

                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    replaceGetMessage,
                );

                // Retrieve all maps using `allMaps` getter
                const allMaps = await contract.getAllMaps();

                // Iterate over mapConfigs and perform assertions
                mapConfigs.forEach(
                    ({ mapName, key, value, keyTransform, valueTransform }) => {
                        const map = allMaps[mapName] as Dictionary<any, any>;

                        expect(map.size).toBe(1);

                        let mapKey = keys[key];
                        if (keyTransform) {
                            mapKey = keyTransform(mapKey);
                        }

                        let expectedValue = values[value];
                        if (valueTransform) {
                            expectedValue = valueTransform(expectedValue);
                        }

                        const actualValue = map.get(mapKey);

                        if (expectedValue instanceof Cell) {
                            expect(actualValue).toEqualCell(expectedValue);
                        } else if (expectedValue instanceof Address) {
                            expect(actualValue).toEqualAddress(expectedValue);
                        } else if (isSomeStruct(expectedValue)) {
                            expect(
                                compareStructs(actualValue, expectedValue),
                            ).toBe(true);
                        } else {
                            expect(actualValue).toEqual(expectedValue);
                        }
                    },
                );
            }

            // Clear all maps
            for (const { keys } of testCases) {
                const clearMessage: ReplaceGetAllMaps = {
                    $$type: "ReplaceGetAllMaps",
                    ...keys,
                    valueInt: null,
                    valueInt8: null,
                    valueInt42: null,
                    valueInt256: null,
                    valueUint8: null,
                    valueUint42: null,
                    valueUint256: null,
                    valueCoins: null,
                    valueBool: null,
                    valueCell: null,
                    valueAddress: null,
                    valueStruct: null,
                };
                await contract.send(
                    treasury.getSender(),
                    { value: toNano("1") },
                    clearMessage,
                );
            }
        }

        // Check that all maps are empty again
        const allMaps = await contract.getAllMaps();
        mapConfigs.forEach(({ mapName }) => {
            const map = allMaps[mapName] as Dictionary<any, any>;
            expect(map.size).toBe(0);
        });
    });

    it("replaceGet: should not replace values when keys do not exist", async () => {
        for (const { keys, values } of testCases) {
            // Send the replace operation
            const replaceGetMessage: ReplaceGetAllMaps = {
                $$type: "ReplaceGetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                replaceGetMessage,
            );

            // Retrieve all maps using `allMaps` getter
            const allMaps = await contract.getAllMaps();

            // Check that all maps are still empty
            mapConfigs.forEach(({ mapName }) => {
                const map = allMaps[mapName] as Dictionary<any, any>;
                expect(map.size).toBe(0);
            });
        }
    });

    it("replaceGet: should return old values when replaced and null when keys do not exist", async () => {
        for (const { keys, values } of testCases) {
            // Call the .replace operation on all maps
            const replaceGetResult = await contract.getReplaceGetAllMaps(
                keys.keyInt,
                keys.keyInt8,
                keys.keyInt42,
                keys.keyInt256,
                keys.keyUint8,
                keys.keyUint42,
                keys.keyUint256,
                keys.keyAddress,
                values.valueInt,
                values.valueInt8,
                values.valueInt42,
                values.valueInt256,
                values.valueUint8,
                values.valueUint42,
                values.valueUint256,
                values.valueCoins,
                values.valueBool,
                values.valueCell,
                values.valueAddress,
                values.valueStruct,
            );

            // Check that all return values are 'null'
            Object.values(replaceGetResult).forEach((result) => {
                if (result !== "ReplaceGetAllMapsResult") {
                    expect(result).toBeNull();
                }
            });

            // Send the set operation
            const setMessage: SetAllMaps = {
                $$type: "SetAllMaps",
                ...keys,
                ...values,
            };

            await contract.send(
                treasury.getSender(),
                { value: toNano("1") },
                setMessage,
            );

            // Call the .replace operation on all maps
            const replaceGetResultAfterSet =
                await contract.getReplaceGetAllMaps(
                    keys.keyInt,
                    keys.keyInt8,
                    keys.keyInt42,
                    keys.keyInt256,
                    keys.keyUint8,
                    keys.keyUint42,
                    keys.keyUint256,
                    keys.keyAddress,
                    values.valueInt,
                    values.valueInt8,
                    values.valueInt42,
                    values.valueInt256,
                    values.valueUint8,
                    values.valueUint42,
                    values.valueUint256,
                    values.valueCoins,
                    values.valueBool,
                    values.valueCell,
                    values.valueAddress,
                    values.valueStruct,
                );

            // Check that all return values are equal to the old values
            mapConfigs.forEach(({ mapName, value, valueTransform }) => {
                let expectedValue = values[value];
                let actualValue = replaceGetResultAfterSet[mapName];
                if (valueTransform) {
                    expectedValue = valueTransform(expectedValue);
                    actualValue = valueTransform(actualValue);
                }

                if (expectedValue instanceof Cell) {
                    expect(actualValue).toEqualCell(expectedValue);
                } else if (expectedValue instanceof Address) {
                    expect(actualValue).toEqualAddress(expectedValue);
                } else if (isSomeStruct(expectedValue)) {
                    expect(
                        compareStructs(
                            actualValue as SomeStruct,
                            expectedValue,
                        ),
                    ).toBe(true);
                } else {
                    expect(actualValue).toEqual(expectedValue);
                }
            });
        }
    });

    it("checkNullReference: should throw an error in getter when accessing a null reference", async () => {
        await expect(contract.getCheckNullReference()).rejects.toThrow();
    });

    it("checkNullReference: should throw an error in receiver when accessing a null reference", async () => {
        const result = await contract.send(
            treasury.getSender(),
            { value: toNano("1") },
            {
                $$type: "CheckNullReference",
            },
        );

        expect(result.transactions).toHaveLength(3);
        expect(result.transactions).toHaveTransaction({
            on: contract.address,
            success: false,
            exitCode: 128,
        });
    });
});


## masterchain.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/masterchain.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { MasterchainTester } from "./contracts/output/masterchain_MasterchainTester";
import "@ton/test-utils";

describe("masterchain", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");
    });

    //
    // Deployment and simple message receiving
    //

    it("should deploy to workchain", async () => {
        const contract = blockchain.openContract(
            await MasterchainTester.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "DeployToWorkchain",
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should not deploy to workchain from masterchain", async () => {
        const treasure = await blockchain.treasury("treasure", {
            workchain: -1,
        });
        const contract = blockchain.openContract(
            await MasterchainTester.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "DeployToWorkchain",
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: false,
            deploy: true,
            exitCode: 1137,
        });
    });

    it("should deploy to masterchain from masterchain", async () => {
        const treasure = await blockchain.treasury("treasure", {
            workchain: -1,
        });
        const contract = blockchain.openContract(
            await MasterchainTester.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "DeployToMasterchain",
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });
});


## math.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/math.spec.ts)
import { beginCell, Dictionary, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { MathTester } from "./contracts/output/math_MathTester";
import "@ton/test-utils";
import { randomAddress } from "../utils/randomAddress";

describe("math", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<MathTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await MathTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should perform math operations correctly", async () => {
        const addressA = randomAddress(0, "a");
        const addressB = randomAddress(0, "b");
        const cellA = beginCell().storeUint(0, 32).endCell();
        const cellB = beginCell().storeUint(1, 32).endCell();
        const sliceA = beginCell()
            .storeBit(0)
            .storeRef(beginCell().storeBit(1).endCell())
            .endCell()
            .asSlice();
        const sliceB = beginCell()
            .storeBit(1)
            .storeRef(beginCell().storeBit(1).endCell())
            .endCell()
            .asSlice();
        const stringA = "foo";
        const stringB = "bar";
        const dictA = Dictionary.empty<bigint, bigint>().set(0n, 0n);
        const dictB = Dictionary.empty<bigint, bigint>().set(0n, 2n);

        // Tests
        expect(await contract.getAdd(1n, 2n)).toBe(3n);
        expect(await contract.getAdd(1n, -2n)).toBe(-1n);
        expect(await contract.getSub(1n, 2n)).toBe(-1n);
        expect(await contract.getSub(1n, -2n)).toBe(3n);
        expect(await contract.getMul(2n, 2n)).toBe(4n);
        expect(await contract.getDiv(2n, 2n)).toBe(1n);
        expect(await contract.getMod(2n, 2n)).toBe(0n);
        expect(await contract.getShr(4n, 1n)).toBe(2n);
        expect(await contract.getShl(2n, 1n)).toBe(4n);
        expect(await contract.getAnd(2n, 3n)).toBe(2n);
        expect(await contract.getOr(2n, 3n)).toBe(3n);
        expect(await contract.getXor(2n, 3n)).toBe(1n);
        expect(await contract.getXor(2n, -3n)).toBe(-1n);
        expect(await contract.getXor(-2n, 3n)).toBe(-3n);
        expect(await contract.getXor(-2n, -3n)).toBe(3n);
        expect(await contract.getBitwiseNot(2n)).toBe(-3n);
        expect(await contract.getBitwiseNot(-2n)).toBe(1n);
        expect(await contract.getBitwiseNot(6n)).toBe(-7n);

        // Augmented Assign
        expect(await contract.getAddAug(1n, 2n)).toBe(3n);
        expect(await contract.getAddAug(1n, -2n)).toBe(-1n);
        expect(await contract.getSubAug(1n, 2n)).toBe(-1n);
        expect(await contract.getSubAug(1n, -2n)).toBe(3n);
        expect(await contract.getMulAug(2n, 2n)).toBe(4n);
        expect(await contract.getDivAug(2n, 2n)).toBe(1n);
        expect(await contract.getModAug(2n, 2n)).toBe(0n);
        expect(await contract.getModAug(3n, 2n)).toBe(1n);
        expect(await contract.getBitwiseOrAug(2n, 1n)).toBe(3n);
        expect(await contract.getBitwiseOrAug(2n, 2n)).toBe(2n);
        expect(await contract.getBitwiseOrAug(5n, 3n)).toBe(7n);
        expect(await contract.getBitwiseAndAug(3n, 2n)).toBe(2n);
        expect(await contract.getBitwiseAndAug(5n, 6n)).toBe(4n);
        expect(await contract.getBitwiseAndAug(1n, 3n)).toBe(1n);
        expect(await contract.getBitwiseXorAug(1n, 2n)).toBe(3n);
        expect(await contract.getBitwiseXorAug(3n, 1n)).toBe(2n);
        expect(await contract.getBitwiseXorAug(2n, 0n)).toBe(2n);

        // Basic Compare
        expect(await contract.getCompare1(1n, 2n)).toBe(false);
        expect(await contract.getCompare1(1n, 1n)).toBe(true);
        expect(await contract.getCompare2(1n, 2n)).toBe(true);
        expect(await contract.getCompare2(1n, 1n)).toBe(false);

        // Compare with second nullable
        expect(await contract.getCompare1(1n, 2n)).toBe(false);
        expect(await contract.getCompare1(1n, 1n)).toBe(true);
        expect(await contract.getCompare1(1n, null)).toBe(false);
        expect(await contract.getCompare2(1n, 2n)).toBe(true);
        expect(await contract.getCompare2(1n, 1n)).toBe(false);
        expect(await contract.getCompare2(1n, null)).toBe(true);

        // Compare with first nullable
        expect(await contract.getCompare3(2n, 1n)).toBe(false);
        expect(await contract.getCompare3(1n, 1n)).toBe(true);
        expect(await contract.getCompare3(null, 1n)).toBe(false);
        expect(await contract.getCompare4(2n, 1n)).toBe(true);
        expect(await contract.getCompare4(1n, 1n)).toBe(false);
        expect(await contract.getCompare4(null, 1n)).toBe(true);

        // Compare with both nullable
        expect(await contract.getCompare5(2n, 1n)).toBe(false);
        expect(await contract.getCompare5(1n, 1n)).toBe(true);
        expect(await contract.getCompare5(null, 1n)).toBe(false);
        expect(await contract.getCompare5(1n, null)).toBe(false);
        expect(await contract.getCompare5(null, null)).toBe(true);
        expect(await contract.getCompare6(2n, 1n)).toBe(true);
        expect(await contract.getCompare6(1n, 1n)).toBe(false);
        expect(await contract.getCompare6(null, 1n)).toBe(true);
        expect(await contract.getCompare6(1n, null)).toBe(true);
        expect(await contract.getCompare6(null, null)).toBe(false);

        // >
        expect(await contract.getCompare7(2n, 1n)).toBe(true);
        expect(await contract.getCompare7(1n, 2n)).toBe(false);
        expect(await contract.getCompare7(1n, 1n)).toBe(false);

        // >=
        expect(await contract.getCompare8(2n, 1n)).toBe(true);
        expect(await contract.getCompare8(1n, 2n)).toBe(false);
        expect(await contract.getCompare8(1n, 1n)).toBe(true);

        // <
        expect(await contract.getCompare9(2n, 1n)).toBe(false);
        expect(await contract.getCompare9(1n, 2n)).toBe(true);
        expect(await contract.getCompare9(1n, 1n)).toBe(false);

        // <=
        expect(await contract.getCompare10(2n, 1n)).toBe(false);
        expect(await contract.getCompare10(1n, 2n)).toBe(true);
        expect(await contract.getCompare10(1n, 1n)).toBe(true);

        // IsNul
        expect(await contract.getIsNull1(0n)).toBe(false);
        expect(await contract.getIsNull1(-1n)).toBe(false);
        expect(await contract.getIsNull1(1n)).toBe(false);
        expect(await contract.getIsNull1(null)).toBe(true);

        // IsNotNull
        expect(await contract.getIsNotNull1(0n)).toBe(true);
        expect(await contract.getIsNotNull1(-1n)).toBe(true);
        expect(await contract.getIsNotNull1(1n)).toBe(true);
        expect(await contract.getIsNotNull1(null)).toBe(false);

        // IsNull Address
        expect(await contract.getIsNull2(addressA)).toBe(false);
        expect(await contract.getIsNull2(addressB)).toBe(false);
        expect(await contract.getIsNull2(null)).toBe(true);

        // IsNotNull Address
        expect(await contract.getIsNotNull2(addressA)).toBe(true);
        expect(await contract.getIsNotNull2(addressB)).toBe(true);
        expect(await contract.getIsNotNull2(null)).toBe(false);

        // Address equals
        expect(await contract.getCompare11(addressA, addressB)).toBe(false);
        expect(await contract.getCompare11(addressB, addressA)).toBe(false);
        expect(await contract.getCompare11(addressA, addressA)).toBe(true);
        expect(await contract.getCompare12(addressA, addressB)).toBe(false);
        expect(await contract.getCompare12(addressB, addressA)).toBe(false);
        expect(await contract.getCompare12(addressA, addressA)).toBe(true);
        expect(await contract.getCompare12(addressB, null)).toBe(false);
        expect(await contract.getCompare12(addressA, null)).toBe(false);
        expect(await contract.getCompare13(addressA, addressB)).toBe(false);
        expect(await contract.getCompare13(addressB, addressA)).toBe(false);
        expect(await contract.getCompare13(addressA, addressA)).toBe(true);
        expect(await contract.getCompare13(null, addressB)).toBe(false);
        expect(await contract.getCompare13(null, addressA)).toBe(false);
        expect(await contract.getCompare14(addressA, addressB)).toBe(false);
        expect(await contract.getCompare14(addressB, addressA)).toBe(false);
        expect(await contract.getCompare14(addressA, addressA)).toBe(true);
        expect(await contract.getCompare14(null, addressB)).toBe(false);
        expect(await contract.getCompare14(null, addressA)).toBe(false);
        expect(await contract.getCompare14(addressB, null)).toBe(false);
        expect(await contract.getCompare14(addressA, null)).toBe(false);
        expect(await contract.getCompare14(null, null)).toBe(true);
        expect(await contract.getCompare14(null, null)).toBe(true);

        // Address not equals
        expect(await contract.getCompare15(addressA, addressB)).toBe(true);
        expect(await contract.getCompare15(addressB, addressA)).toBe(true);
        expect(await contract.getCompare15(addressA, addressA)).toBe(false);
        expect(await contract.getCompare16(addressA, addressB)).toBe(true);
        expect(await contract.getCompare16(addressB, addressA)).toBe(true);
        expect(await contract.getCompare16(addressA, addressA)).toBe(false);
        expect(await contract.getCompare16(addressB, null)).toBe(true);
        expect(await contract.getCompare16(addressA, null)).toBe(true);
        expect(await contract.getCompare17(addressA, addressB)).toBe(true);
        expect(await contract.getCompare17(addressB, addressA)).toBe(true);
        expect(await contract.getCompare17(addressA, addressA)).toBe(false);
        expect(await contract.getCompare17(null, addressB)).toBe(true);
        expect(await contract.getCompare17(null, addressA)).toBe(true);
        expect(await contract.getCompare18(addressA, addressB)).toBe(true);
        expect(await contract.getCompare18(addressB, addressA)).toBe(true);
        expect(await contract.getCompare18(addressA, addressA)).toBe(false);
        expect(await contract.getCompare18(null, addressB)).toBe(true);
        expect(await contract.getCompare18(null, addressA)).toBe(true);
        expect(await contract.getCompare18(addressB, null)).toBe(true);
        expect(await contract.getCompare18(addressA, null)).toBe(true);
        expect(await contract.getCompare18(null, null)).toBe(false);
        expect(await contract.getCompare18(null, null)).toBe(false);

        // IsNull Cell
        expect(await contract.getIsNull3(cellA)).toBe(false);
        expect(await contract.getIsNull3(cellB)).toBe(false);
        expect(await contract.getIsNull3(null)).toBe(true);

        // IsNotNull Address
        expect(await contract.getIsNotNull3(cellA)).toBe(true);
        expect(await contract.getIsNotNull3(cellB)).toBe(true);
        expect(await contract.getIsNotNull3(null)).toBe(false);

        // Cell equals
        expect(await contract.getCompare19(cellA, cellB)).toBe(false);
        expect(await contract.getCompare19(cellB, cellA)).toBe(false);
        expect(await contract.getCompare19(cellA, cellA)).toBe(true);
        expect(await contract.getCompare20(cellA, cellB)).toBe(false);
        expect(await contract.getCompare20(cellB, cellA)).toBe(false);
        expect(await contract.getCompare20(cellA, cellA)).toBe(true);
        expect(await contract.getCompare20(cellB, null)).toBe(false);
        expect(await contract.getCompare20(cellA, null)).toBe(false);
        expect(await contract.getCompare21(cellA, cellB)).toBe(false);
        expect(await contract.getCompare21(cellB, cellA)).toBe(false);
        expect(await contract.getCompare21(cellA, cellA)).toBe(true);
        expect(await contract.getCompare21(null, cellB)).toBe(false);
        expect(await contract.getCompare21(null, cellA)).toBe(false);
        expect(await contract.getCompare22(cellA, cellB)).toBe(false);
        expect(await contract.getCompare22(cellB, cellA)).toBe(false);
        expect(await contract.getCompare22(cellA, cellA)).toBe(true);
        expect(await contract.getCompare22(null, cellB)).toBe(false);
        expect(await contract.getCompare22(null, cellA)).toBe(false);
        expect(await contract.getCompare22(cellB, null)).toBe(false);
        expect(await contract.getCompare22(cellA, null)).toBe(false);
        expect(await contract.getCompare22(null, null)).toBe(true);
        expect(await contract.getCompare22(null, null)).toBe(true);

        // Cell not equals
        expect(await contract.getCompare23(cellA, cellB)).toBe(true);
        expect(await contract.getCompare23(cellB, cellA)).toBe(true);
        expect(await contract.getCompare23(cellA, cellA)).toBe(false);
        expect(await contract.getCompare24(cellA, cellB)).toBe(true);
        expect(await contract.getCompare24(cellB, cellA)).toBe(true);
        expect(await contract.getCompare24(cellA, cellA)).toBe(false);
        expect(await contract.getCompare24(cellB, null)).toBe(true);
        expect(await contract.getCompare24(cellA, null)).toBe(true);
        expect(await contract.getCompare25(cellA, cellB)).toBe(true);
        expect(await contract.getCompare25(cellB, cellA)).toBe(true);
        expect(await contract.getCompare25(cellA, cellA)).toBe(false);
        expect(await contract.getCompare25(null, cellB)).toBe(true);
        expect(await contract.getCompare25(null, cellA)).toBe(true);
        expect(await contract.getCompare26(cellA, cellB)).toBe(true);
        expect(await contract.getCompare26(cellB, cellA)).toBe(true);
        expect(await contract.getCompare26(cellA, cellA)).toBe(false);
        expect(await contract.getCompare26(null, cellB)).toBe(true);
        expect(await contract.getCompare26(null, cellA)).toBe(true);
        expect(await contract.getCompare26(cellB, null)).toBe(true);
        expect(await contract.getCompare26(cellA, null)).toBe(true);
        expect(await contract.getCompare26(null, null)).toBe(false);
        expect(await contract.getCompare26(null, null)).toBe(false);

        // Slice equals
        expect(await contract.getCompare29(sliceA, sliceB)).toBe(false);
        expect(await contract.getCompare29(sliceB, sliceA)).toBe(false);
        expect(await contract.getCompare29(sliceA, sliceA)).toBe(true);
        expect(await contract.getCompare30(sliceA, sliceB)).toBe(false);
        expect(await contract.getCompare30(sliceB, sliceA)).toBe(false);
        expect(await contract.getCompare30(sliceA, sliceA)).toBe(true);
        expect(await contract.getCompare30(sliceB, null)).toBe(false);
        expect(await contract.getCompare30(sliceA, null)).toBe(false);
        expect(await contract.getCompare31(sliceA, sliceB)).toBe(false);
        expect(await contract.getCompare31(sliceB, sliceA)).toBe(false);
        expect(await contract.getCompare31(sliceA, sliceA)).toBe(true);
        expect(await contract.getCompare31(null, sliceB)).toBe(false);
        expect(await contract.getCompare31(null, sliceA)).toBe(false);
        expect(await contract.getCompare32(sliceA, sliceB)).toBe(false);
        expect(await contract.getCompare32(sliceB, sliceA)).toBe(false);
        expect(await contract.getCompare32(sliceA, sliceA)).toBe(true);
        expect(await contract.getCompare32(null, sliceB)).toBe(false);
        expect(await contract.getCompare32(null, sliceA)).toBe(false);
        expect(await contract.getCompare32(sliceB, null)).toBe(false);
        expect(await contract.getCompare32(sliceA, null)).toBe(false);
        expect(await contract.getCompare32(null, null)).toBe(true);
        expect(await contract.getCompare32(null, null)).toBe(true);

        // Slice not equals
        expect(await contract.getCompare33(sliceA, sliceB)).toBe(true);
        expect(await contract.getCompare33(sliceB, sliceA)).toBe(true);
        expect(await contract.getCompare33(sliceA, sliceA)).toBe(false);
        expect(await contract.getCompare34(sliceA, sliceB)).toBe(true);
        expect(await contract.getCompare34(sliceB, sliceA)).toBe(true);
        expect(await contract.getCompare34(sliceA, sliceA)).toBe(false);
        expect(await contract.getCompare34(sliceB, null)).toBe(true);
        expect(await contract.getCompare34(sliceA, null)).toBe(true);
        expect(await contract.getCompare35(sliceA, sliceB)).toBe(true);
        expect(await contract.getCompare35(sliceB, sliceA)).toBe(true);
        expect(await contract.getCompare35(sliceA, sliceA)).toBe(false);
        expect(await contract.getCompare35(null, sliceB)).toBe(true);
        expect(await contract.getCompare35(null, sliceA)).toBe(true);
        expect(await contract.getCompare36(sliceA, sliceB)).toBe(true);
        expect(await contract.getCompare36(sliceB, sliceA)).toBe(true);
        expect(await contract.getCompare36(sliceA, sliceA)).toBe(false);
        expect(await contract.getCompare36(null, sliceB)).toBe(true);
        expect(await contract.getCompare36(null, sliceA)).toBe(true);
        expect(await contract.getCompare36(sliceB, null)).toBe(true);
        expect(await contract.getCompare36(sliceA, null)).toBe(true);
        expect(await contract.getCompare36(null, null)).toBe(false);
        expect(await contract.getCompare36(null, null)).toBe(false);

        // string equals
        expect(await contract.getCompare37(stringA, stringB)).toBe(false);
        expect(await contract.getCompare37(stringB, stringA)).toBe(false);
        expect(await contract.getCompare37(stringA, stringA)).toBe(true);
        expect(await contract.getCompare38(stringA, stringB)).toBe(false);
        expect(await contract.getCompare38(stringB, stringA)).toBe(false);
        expect(await contract.getCompare38(stringA, stringA)).toBe(true);
        expect(await contract.getCompare38(stringB, null)).toBe(false);
        expect(await contract.getCompare38(stringA, null)).toBe(false);
        expect(await contract.getCompare39(stringA, stringB)).toBe(false);
        expect(await contract.getCompare39(stringB, stringA)).toBe(false);
        expect(await contract.getCompare39(stringA, stringA)).toBe(true);
        expect(await contract.getCompare39(null, stringB)).toBe(false);
        expect(await contract.getCompare39(null, stringA)).toBe(false);
        expect(await contract.getCompare40(stringA, stringB)).toBe(false);
        expect(await contract.getCompare40(stringB, stringA)).toBe(false);
        expect(await contract.getCompare40(stringA, stringA)).toBe(true);
        expect(await contract.getCompare40(null, stringB)).toBe(false);
        expect(await contract.getCompare40(null, stringA)).toBe(false);
        expect(await contract.getCompare40(stringB, null)).toBe(false);
        expect(await contract.getCompare40(stringA, null)).toBe(false);
        expect(await contract.getCompare40(null, null)).toBe(true);
        expect(await contract.getCompare40(null, null)).toBe(true);

        // string not equals
        expect(await contract.getCompare41(stringA, stringB)).toBe(true);
        expect(await contract.getCompare41(stringB, stringA)).toBe(true);
        expect(await contract.getCompare41(stringA, stringA)).toBe(false);
        expect(await contract.getCompare42(stringA, stringB)).toBe(true);
        expect(await contract.getCompare42(stringB, stringA)).toBe(true);
        expect(await contract.getCompare42(stringA, stringA)).toBe(false);
        expect(await contract.getCompare42(stringB, null)).toBe(true);
        expect(await contract.getCompare42(stringA, null)).toBe(true);
        expect(await contract.getCompare43(stringA, stringB)).toBe(true);
        expect(await contract.getCompare43(stringB, stringA)).toBe(true);
        expect(await contract.getCompare43(stringA, stringA)).toBe(false);
        expect(await contract.getCompare43(null, stringB)).toBe(true);
        expect(await contract.getCompare43(null, stringA)).toBe(true);
        expect(await contract.getCompare44(stringA, stringB)).toBe(true);
        expect(await contract.getCompare44(stringB, stringA)).toBe(true);
        expect(await contract.getCompare44(stringA, stringA)).toBe(false);
        expect(await contract.getCompare44(null, stringB)).toBe(true);
        expect(await contract.getCompare44(null, stringA)).toBe(true);
        expect(await contract.getCompare44(stringB, null)).toBe(true);
        expect(await contract.getCompare44(stringA, null)).toBe(true);
        expect(await contract.getCompare44(null, null)).toBe(false);
        expect(await contract.getCompare44(null, null)).toBe(false);

        // Test maps
        expect(await contract.getCompare27(dictA, dictB)).toBe(false);
        expect(await contract.getCompare27(dictB, dictA)).toBe(false);
        expect(await contract.getCompare27(dictA, dictA)).toBe(true);
        expect(await contract.getCompare28(dictA, dictB)).toBe(true);
        expect(await contract.getCompare28(dictB, dictA)).toBe(true);
        expect(await contract.getCompare28(dictA, dictA)).toBe(false);

        // Test advanced math operations
        for (let num = 1n; num <= 100n; num++) {
            expect(await contract.getLog2(num)).toBe(
                BigInt(Math.floor(Math.log2(Number(num)))),
            );
        }

        for (let num = 1n; num <= 10n; num++) {
            for (let base = 2n; base <= 10; base++) {
                const logarithm = BigInt(
                    Math.floor(
                        Math.log2(Number(num)) / Math.log2(Number(base)),
                    ),
                );
                expect(await contract.getLog(num, base)).toBe(logarithm);
            }
        }

        for (let num = -3n; num <= 3n; num++) {
            if (num <= 0n) {
                await expect(contract.getLog2(num)).rejects.toThrow(
                    "Unable to execute get method. Got exit_code: 5",
                );
            }
        }

        for (let num = -3n; num <= 3n; num++) {
            for (let base = -3n; base <= 3n; base++) {
                if (num <= 0n || base <= 1n) {
                    await expect(contract.getLog(num, base)).rejects.toThrow(
                        "Unable to execute get method. Got exit_code: 5",
                    );
                } else {
                    const logarithm = BigInt(
                        Math.floor(
                            Math.log2(Number(num)) / Math.log2(Number(base)),
                        ),
                    );
                    expect(await contract.getLog(num, base)).toBe(logarithm);
                }
            }
        }

        const maxint = 2n ** 256n - 1n;

        for (let num = maxint - 100n; num <= maxint; num++) {
            expect(await contract.getLog2(num)).toBe(255n);
        }

        for (let num = maxint - 10n; num <= maxint; num++) {
            for (let base = 2; base <= 10; base++) {
                expect(await contract.getLog(num, BigInt(base))).toBe(
                    BigInt(num.toString(base).length - 1),
                );
            }
        }

        for (let num = maxint / 2n - 50n; num <= maxint / 2n; num++) {
            expect(await contract.getLog2(num)).toBe(254n);
        }
        for (let num = maxint / 2n + 1n; num <= maxint / 2n + 50n; num++) {
            expect(await contract.getLog2(num)).toBe(255n);
        }

        for (let num = maxint / 2n - 5n; num <= maxint / 2n + 5n; num++) {
            for (let base = 2; base <= 10; base++) {
                expect(await contract.getLog(num, BigInt(base))).toBe(
                    BigInt(num.toString(base).length - 1),
                );
            }
        }

        expect(await contract.getPow(2n, 0n)).toBe(1n);
        expect(await contract.getPow(2n, 1n)).toBe(2n);
        expect(await contract.getPow(2n, 2n)).toBe(4n);
        expect(await contract.getPow(2n, 3n)).toBe(8n);
        expect(await contract.getPow(0n, 0n)).toBe(1n);
        expect(await contract.getPow(0n, 1n)).toBe(0n);
        expect(await contract.getPow(1n, 10n)).toBe(1n);
        expect(await contract.getPow(10n, 2n)).toBe(100n);

        expect(await contract.getPow2(0n)).toBe(1n);
        expect(await contract.getPow2(1n)).toBe(2n);
        expect(await contract.getPow2(2n)).toBe(4n);
        expect(await contract.getPow2(3n)).toBe(8n);

        await expect(contract.getPow(2n, -1n)).rejects.toThrow(
            "Unable to execute get method. Got exit_code: 5",
        );
        await expect(contract.getPow2(-1n)).rejects.toThrow(
            "Unable to execute get method. Got exit_code: 5",
        );

        // Test operation precedence

        expect(await contract.getPrecedence1()).toBe(12n);
        expect(await contract.getPrecedence2()).toBe(4n);
        expect(await contract.getPrecedence3()).toBe(12n);
        expect(await contract.getPrecedence4()).toBe(12n);
        expect(await contract.getPrecedence5()).toBe(5n);
        expect(await contract.getPrecedence6()).toBe(0n);
        expect(await contract.getPrecedence7()).toBe(7n);
        expect(await contract.getPrecedence8()).toBe(3n);
        expect(await contract.getPrecedence9()).toBe(7n);
        expect(await contract.getPrecedence10()).toBe(3n);
        expect(await contract.getPrecedence11()).toBe(3n);
        expect(await contract.getPrecedence12()).toBe(5n);

        // Test multiple unary operations in a row
        expect(await contract.getBitwiseNot1(5n)).toBe(5n);
        expect(await contract.getBitwiseNot2(5n)).toBe(-6n);
        expect(await contract.getBitwiseNot3(5n)).toBe(4n);
        expect(await contract.getBitwiseNot4(5n)).toBe(6n);

        // Augmented Logical Operations
        expect(await contract.getAugmentedAnd(true, true)).toBe(true);
        expect(await contract.getAugmentedAnd(true, false)).toBe(false);
        expect(await contract.getAugmentedAnd(false, true)).toBe(false);
        expect(await contract.getAugmentedAnd(false, false)).toBe(false);

        expect(await contract.getAugmentedOr(true, true)).toBe(true);
        expect(await contract.getAugmentedOr(true, false)).toBe(true);
        expect(await contract.getAugmentedOr(false, true)).toBe(true);
        expect(await contract.getAugmentedOr(false, false)).toBe(false);

        // Augmented Binary Shift Operations
        expect(await contract.getAugmentedShiftLeft(1n, 1n)).toBe(2n);
        expect(await contract.getAugmentedShiftLeft(1n, 2n)).toBe(4n);
        expect(await contract.getAugmentedShiftLeft(2n, 3n)).toBe(16n);
        expect(await contract.getAugmentedShiftRight(2n, 1n)).toBe(1n);
        expect(await contract.getAugmentedShiftRight(4n, 2n)).toBe(1n);
        expect(await contract.getAugmentedShiftRight(16n, 3n)).toBe(2n);
    });
});


## mutating-methods.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/mutating-methods.spec.ts)
import { beginCell, BitString, Dictionary, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Tester } from "./contracts/output/mutating-methods_Tester";
import "@ton/test-utils";

describe("bugs", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Tester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await Tester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement mutating method chaining correctly", async () => {
        // Ensure initial transaction works as expected
        const initialResult = await contract.send(
            treasure.getSender(),
            { value: toNano("1") },
            null,
        );

        expect(initialResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        // Check contract methods
        expect(await contract.getTest1()).toBe(0n);
        expect(await contract.getTest2()).toBe(0n);
        expect(await contract.getTest3()).toBe(6n);
        expect(await contract.getTest4()).toBe(24n);
        expect(await contract.getTest5()).toBe(97n);
        expect(await contract.getTest7()).toBe(42n);
        expect(await contract.getTest8()).toBe(5n);
        expect(await contract.getTest9()).toBe(5n);

        // Test `extends mutates` function with optional self param
        {
            // Non-empty dictionary
            const d = Dictionary.empty(
                Dictionary.Keys.Uint(8),
                Dictionary.Values.BitString(12),
            );
            d.set(1, new BitString(Buffer.from("1234", "hex"), 0, 12));
            const c = beginCell().storeDictDirect(d).endCell();
            const c2 = await contract.getTest10(c);
            const d2 = c2
                ?.beginParse()
                .loadDictDirect(
                    Dictionary.Keys.Uint(8),
                    Dictionary.Values.BitString(12),
                );
            expect(d2?.size).toBe(2);
            expect(d2?.get(1)?.toString()).toBe("123");
            expect(d2?.get(123)?.toString()).toBe("456");
        }
        {
            // Empty dictionary
            const c = await contract.getTest10(null);
            const d = c
                ?.beginParse()
                .loadDictDirect(
                    Dictionary.Keys.Uint(8),
                    Dictionary.Values.BitString(12),
                );
            expect(d?.size).toBe(1);
            expect(d?.get(123)?.toString()).toBe("456");
        }

        expect(await contract.getTest11(1n)).toBe(6n);
        expect(await contract.getTest11(2n)).toBe(12n);
    });
});


## optionals.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/optionals.spec.ts)
import { randomAddress } from "../utils/randomAddress";
import {
    ContractWithOptionals,
    SomeGenericStruct,
    StructWithOptionals,
} from "./contracts/output/optionals_ContractWithOptionals";
import { Opt4 } from "./contracts/output/optionals_Opt4";
import { Address, beginCell, Cell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import "@ton/test-utils";

function strEq2(a: StructWithOptionals | null, b: StructWithOptionals | null) {
    // Null checks
    if (a === null && b === null) {
        return true;
    }
    if (a !== null && b === null) {
        return false;
    }
    if (a === null && b !== null) {
        return false;
    }

    // a: BN | null;
    if (a!.a === null && b!.a !== null) {
        return false;
    }
    if (a!.a !== null && b!.a === null) {
        return false;
    }
    if (a!.a !== null && b!.a !== null && a!.a !== b!.a) {
        return false;
    }

    // b: boolean | null;
    if (a!.b === null && b!.b !== null) {
        return false;
    }
    if (a!.b !== null && b!.b === null) {
        return false;
    }
    if (a!.b !== null && b!.b !== null && a!.b !== b!.b) {
        return false;
    }

    // c: Cell | null;
    if (a!.c === null && b!.c !== null) {
        return false;
    }
    if (a!.c !== null && b!.c === null) {
        return false;
    }
    if (a!.c !== null && b!.c !== null && !a!.c.equals(b!.c)) {
        return false;
    }

    // d: Address | null;
    if (a!.d === null && b!.d !== null) {
        return false;
    }
    if (a!.d !== null && b!.d === null) {
        return false;
    }
    if (a!.d !== null && b!.d !== null && !a!.d.equals(b!.d)) {
        return false;
    }

    // e: SomeGenericStruct | null;
    if (a!.e === null && b!.e !== null) {
        return false;
    }
    if (a!.e !== null && b!.e === null) {
        return false;
    }
    if (a!.e !== null && b!.e !== null && !strEq(a!.e, b!.e)) {
        return false;
    }

    return true;
}

function strEq(a: SomeGenericStruct | null, b: SomeGenericStruct | null) {
    if (a === null && b === null) {
        return true;
    }
    if (a !== null && b === null) {
        return false;
    }
    if (a === null && b !== null) {
        return false;
    }
    if (a!.value1 !== b!.value1) {
        return false;
    }
    if (a!.value2 !== b!.value2) {
        return false;
    }
    if (a!.value3 !== b!.value3) {
        return false;
    }
    if (a!.value4 !== b!.value4) {
        return false;
    }
    if (a!.value5 !== b!.value5) {
        return false;
    }
    return true;
}

describe("features", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");
    });

    const eV = {
        $$type: "SomeGenericStruct" as const,
        value1: 1n,
        value2: 2n,
        value3: 3n,
        value4: 4n,
        value5: 5n,
    };
    const ev2: StructWithOptionals = {
        $$type: "StructWithOptionals" as const,
        a: 1n,
        b: true,
        c: null,
        d: randomAddress(0, "address1"),
        e: eV,
    };
    const ev3: StructWithOptionals = {
        $$type: "StructWithOptionals" as const,
        a: 1n,
        b: true,
        c: null,
        d: null,
        e: null,
    };
    const cases: {
        a: bigint | null;
        b: boolean | null;
        c: Cell | null;
        d: Address | null;
        e: SomeGenericStruct | null;
        f: StructWithOptionals | null;
    }[] = [];
    cases.push({ a: null, b: null, c: null, d: null, e: null, f: null });
    cases.push({
        a: 10n,
        b: true,
        c: null,
        d: randomAddress(0, "address1"),
        e: eV,
        f: ev2,
    });
    cases.push({
        a: -10n,
        b: false,
        c: null,
        d: randomAddress(-1, "address2"),
        e: null,
        f: ev2,
    });
    cases.push({
        a: -10n,
        b: false,
        c: beginCell().storeAddress(randomAddress(0, "asdasd")).endCell(),
        d: randomAddress(-1, "address2"),
        e: null,
        f: ev3,
    });

    for (let i = 0; i < cases.length; i++) {
        it("should handle case #" + i, async () => {
            const cs = cases[i]!;

            const contract = blockchain.openContract(
                await ContractWithOptionals.fromInit(
                    cs.a,
                    cs.b,
                    cs.c,
                    cs.d,
                    cs.e,
                    cs.f,
                ),
            );

            const deployResult = await contract.send(
                treasure.getSender(),
                { value: toNano("10") },
                null,
            );
            expect(deployResult.transactions).toHaveTransaction({
                from: treasure.address,
                to: contract.address,
                success: true,
            });

            if (cs.a !== null) {
                expect(await contract.getNotNullA()).toBe(cs.a);
            } else {
                await expect(() => contract.getNotNullA()).rejects.toThrowError(
                    "Unable to execute get method. Got exit_code: 128",
                );
            }
            if (cs.b !== null) {
                expect((await contract.getNotNullB()) === cs.b).toBe(true);
            } else {
                await expect(() => contract.getNotNullB()).rejects.toThrowError(
                    "Unable to execute get method. Got exit_code: 128",
                );
            }
            if (cs.c !== null) {
                expect((await contract.getNotNullC()).equals(cs.c)).toBe(true);
            } else {
                await expect(() => contract.getNotNullC()).rejects.toThrowError(
                    "Unable to execute get method. Got exit_code: 128",
                );
            }
            if (cs.d !== null) {
                expect((await contract.getNotNullD()).equals(cs.d)).toBe(true);
            } else {
                await expect(() => contract.getNotNullD()).rejects.toThrowError(
                    "Unable to execute get method. Got exit_code: 128",
                );
            }
            if (cs.e !== null) {
                expect(strEq(await contract.getNotNullE(), cs.e)).toBe(true);
            } else {
                await expect(() => contract.getNotNullE()).rejects.toThrowError(
                    "Unable to execute get method. Got exit_code: 128",
                );
            }
            if (cs.f !== null) {
                expect(strEq2(await contract.getNotNullF(), cs.f)).toBe(true);
            } else {
                await expect(() => contract.getNotNullF()).rejects.toThrowError(
                    "Unable to execute get method. Got exit_code: 128",
                );
            }

            // Check inputs
            expect(await contract.getIsNotNullA()).toBe(cs.a !== null);
            expect(await contract.getIsNotNullB()).toBe(cs.b !== null);
            expect(await contract.getIsNotNullC()).toBe(cs.c !== null);
            expect(await contract.getIsNotNullD()).toBe(cs.d !== null);
            expect(await contract.getIsNotNullE()).toBe(cs.e !== null);
            expect(await contract.getIsNotNullF()).toBe(cs.f !== null);
        });
    }

    it("Optional address should load correctly", async () => {
        const contract = blockchain.openContract(await Opt4.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );
        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        const sendResult = await contract.send(
            treasure.getSender(),
            { value: toNano(1) },
            {
                $$type: "OptAddr",
                x: BigInt(255),
                y: null,
                z: BigInt(12345),
            },
        );
        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        expect(await contract.getZ()).toEqual(12345n);
    });
});


## ordering.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/ordering.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { A } from "./contracts/output/ordering_A";
import { B } from "./contracts/output/ordering_B";
import "@ton/test-utils";

describe("ordering", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");
    });

    it("should implement constructor ordering correctly in contract A", async () => {
        const contract = blockchain.openContract(
            await A.fromInit(treasure.address),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Check constructor order in contract A
        const res = await contract.getCreate(0n);
        expect(res.v1).toBe(3n);
        expect(res.v2).toBe(2n);
        expect(res.v3).toBe(1n);
    });

    it("should implement punned constructor correctly in contract B", async () => {
        const contract = blockchain.openContract(await B.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Check constructor order in contract B
        const res = await contract.getCreate(0n);
        expect(res.v1).toBe(1n);
        expect(res.v2).toBe(2n);
        expect(res.v3).toBe(3n);
    });
});


## random.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/random.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { RandomContract } from "./contracts/output/random_RandomContract";
import "@ton/test-utils";

describe("random", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<RandomContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await RandomContract.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement random correctly", async () => {
        // Check random values
        // NOTE: These values are generated by the emulator and are deterministic.
        //       They also ensure that `randomize_lt` was called, as without it,
        //       the values would differ.
        expect(await contract.getRandomInt()).toBe(
            12029244659758160506229899028078921673473662712472979861368849515350569944843n,
        );
        expect(await contract.getRandom(0n, 10000n)).toBe(1038n);
    });
});


## receiver-empty.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/receiver-empty.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { Test } from "./contracts/output/receiver-empty_Test";
import "@ton/test-utils";

describe("receiver-empty", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<Test>;
    const amount = toNano("0.5");

    const checkBalanceIsWithinLimits = async (
        amount: bigint,
        epsilon: bigint,
    ) => {
        const contractBalance = await contract.getBalance();
        expect(contractBalance).toBeGreaterThan(amount - epsilon);
        expect(contractBalance).toBeLessThan(amount);
    };

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await Test.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: amount },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
        await checkBalanceIsWithinLimits(amount, toNano("0.002"));
    });

    it("empty receivers accept sent funds", async () => {
        const sendResult = await contract.send(
            treasure.getSender(),
            { value: amount },
            null,
        );
        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: false,
        });
        await checkBalanceIsWithinLimits(2n * amount, toNano("0.003"));
    });
});


## recursion.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/recursion.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { RecursionTester } from "./contracts/output/recursion_RecursionTester";
import "@ton/test-utils";

describe("recursion", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<RecursionTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await RecursionTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should perform recursive operations correctly", async () => {
        // Check Fibonacci sequence
        expect(await contract.getFib(0n)).toBe(0n);
        expect(await contract.getFib(1n)).toBe(1n);
        expect(await contract.getFib(2n)).toBe(1n);
        expect(await contract.getFib(3n)).toBe(2n);

        // Check Factorial calculations
        expect(await contract.getFact(0n)).toBe(1n);
        expect(await contract.getFact(1n)).toBe(1n);
        expect(await contract.getFact(2n)).toBe(2n);
        expect(await contract.getFact(3n)).toBe(6n);
    });
});


## sample-jetton.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/sample-jetton.spec.ts)
import { beginCell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { SampleJetton } from "./contracts/output/sample-jetton_SampleJetton";
import { JettonDefaultWallet } from "./contracts/output/sample-jetton_JettonDefaultWallet";
import "@ton/test-utils";

describe("bugs", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<SampleJetton>;
    let target: SandboxContract<JettonDefaultWallet>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(
            await SampleJetton.fromInit(
                treasure.address,
                beginCell().endCell(),
                toNano("100"),
            ),
        );

        target = blockchain.openContract(
            await JettonDefaultWallet.fromInit(
                contract.address,
                treasure.address,
            ),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            {
                $$type: "Mint",
                receiver: treasure.address,
                amount: toNano("10"),
            },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should deploy sample jetton correctly", async () => {
        // Ensure that the Mint operation was successful and the transaction was correct
        const mintResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            {
                $$type: "Mint",
                receiver: treasure.address,
                amount: toNano("10"),
            },
        );

        expect(mintResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });
        expect(mintResult.transactions).toHaveTransaction({
            from: contract.address,
            op: 0x178d4519,
            success: true,
        });
        expect(mintResult.transactions).toHaveTransaction({
            to: treasure.address,
            op: 0xd53276db,
        });

        expect((await target.getGetWalletData()).balance).toBe(toNano("20"));
    });
});


## semantics.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/semantics.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { SemanticsTester } from "./contracts/output/semantics_SemanticsTester";
import "@ton/test-utils";

describe("semantics", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<SemanticsTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await SemanticsTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );
        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement semantics correctly", async () => {
        // Check methods
        expect(await contract.getCheckAllContractFieldsAreUnchanged()).toEqual(
            true,
        );

        // Structs

        expect(await contract.getStructAssign1()).toEqual(true);
        expect(await contract.getStructAssign2()).toEqual(true);
        expect(await contract.getParamStruct1()).toEqual(true);
        expect(await contract.getParamStruct2()).toEqual(true);
        expect(await contract.getMutateParamStruct1()).toEqual(true);
        expect(await contract.getMutateParamStruct2()).toEqual(true);
        expect(await contract.getTestReturnedStructs()).toEqual(true);
        expect(await contract.getMutatesChainStruct1()).toEqual(true);
        expect(await contract.getMutatesChainStruct2()).toEqual(true);
        expect(await contract.getMutatesChainStruct3()).toEqual(true);
        expect(await contract.getMutatesChainStruct4()).toEqual(true);
        expect(await contract.getMutatesChainStruct5()).toEqual(true);
        expect(await contract.getMutatesChainStruct6()).toEqual(true);

        // Maps

        expect(await contract.getMapAssign1()).toEqual(true);
        expect(await contract.getMapAssign2()).toEqual(true);
        expect(await contract.getParamMap1()).toEqual(true);
        expect(await contract.getParamMap2()).toEqual(true);
        expect(await contract.getMutateParamMap1()).toEqual(true);
        expect(await contract.getMutateParamMap2()).toEqual(true);
        expect(await contract.getTestReturnedMaps1()).toEqual(true);
        // expect(await contract.getTestReturnedMaps2()).toEqual(true);
        expect(await contract.getMutateNestedMap1()).toEqual(true);

        // Integers

        expect(await contract.getMutatesChainInt1()).toEqual(true);
        expect(await contract.getMutatesChainInt2()).toEqual(true);
        expect(await contract.getMutatesChainInt3()).toEqual(true);
        expect(await contract.getMutatesChainInt4()).toEqual(true);
        expect(await contract.getMutatesChainInt5()).toEqual(true);
        expect(await contract.getMutatesChainInt6()).toEqual(true);

        // Boolean expressions

        expect(await contract.getAndMutateShortCircuit()).toEqual(true);
        expect(await contract.getAndInfiniteLoopShortCircuit()).toEqual(true);
        expect(await contract.getAndExceptionShortCircuit()).toEqual(true);
        expect(await contract.getOrMutateShortCircuit()).toEqual(true);
        expect(await contract.getOrInfiniteLoopShortCircuit()).toEqual(true);
        expect(await contract.getOrExceptionShortCircuit()).toEqual(true);

        // Contracts

        expect(await contract.getContractAssign1()).toEqual(true);
        expect(await contract.getContractAssign2()).toEqual(true);
        expect(await contract.getParamContract()).toEqual(true);
        expect(await contract.getMutateParamContract()).toEqual(true);
        expect(await contract.getTestReturnedContracts()).toEqual(true);

        // Obtain the address before the contract gets modified
        const address1 = await contract.getAddress();

        // Send the message to mutate the contract
        const mutateResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "mutate",
        );
        expect(mutateResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });

        // The contract was successfully mutated
        expect(await contract.getMutateContractStateFlag()).toEqual(true);
        // And the changes persisted
        expect(await contract.getChangesPersisted()).toEqual(true);

        // Obtain the address after the contract was modified
        const address2 = await contract.getAddress();

        // The address before mutation and after mutation is the same.
        expect(address1.equals(address2)).toEqual(true);
    });
});


## send.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/send.spec.ts)
import { toNano, beginCell } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { SendTester } from "./contracts/output/send_SendTester";
import "@ton/test-utils";

describe("send", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<SendTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await SendTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should send reply correctly", async () => {
        const sendResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "Hello",
        );

        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            body: beginCell()
                .storeUint(0, 32)
                .storeStringTail("Hello")
                .endCell(),
        });
    });

    it("should bounce on unknown message", async () => {
        const sendResult = await treasure.send({
            to: contract.address,
            value: toNano("10"),
            body: beginCell().storeStringTail("Unknown").endCell(),
        });

        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: false,
            exitCode: 130,
        });
    });
});


## serialization.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/serialization.spec.ts)
import { beginCell, Builder, Cell, Slice, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { SerializationTester3 } from "./contracts/output/serialization-3_SerializationTester3";
import { SerializationTester2 } from "./contracts/output/serialization-2_SerializationTester2";
import { SerializationTester } from "./contracts/output/serialization_SerializationTester";
import "@ton/test-utils";

describe("serialization", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");
    });

    //
    // Simple case
    //
    {
        const cases: {
            a: bigint;
            b: bigint;
            c: bigint;
            d: bigint;
            e: bigint;
            f: bigint;
            g: bigint;
            h: bigint;
            i: bigint;
        }[] = [];
        cases.push({
            a: 1n,
            b: 2n,
            c: 3n,
            d: 4n,
            e: 5n,
            f: 6n,
            g: 7n,
            h: 8n,
            i: 9n,
        });

        for (let i = 0; i < cases.length; i++) {
            it("should handle case #" + i, async () => {
                const cs = cases[i]!;

                // Init contract
                const contract = blockchain.openContract(
                    await SerializationTester.fromInit(
                        cs.a,
                        cs.b,
                        cs.c,
                        cs.d,
                        cs.e,
                        cs.f,
                        cs.g,
                        cs.h,
                        cs.i,
                    ),
                );

                const deployResult = await contract.send(
                    treasure.getSender(),
                    { value: toNano("10") },
                    null,
                );

                expect(deployResult.transactions).toHaveTransaction({
                    from: treasure.address,
                    to: contract.address,
                    success: true,
                    deploy: true,
                });

                // Check inputs
                expect(await contract.getGetA()).toBe(cs.a);
                expect(await contract.getGetB()).toBe(cs.b);
                expect(await contract.getGetC()).toBe(cs.c);
                expect(await contract.getGetD()).toBe(cs.d);
                expect(await contract.getGetE()).toBe(cs.e);
                expect(await contract.getGetF()).toBe(cs.f);
                expect(await contract.getGetG()).toBe(cs.g);
                expect(await contract.getGetH()).toBe(cs.h);
                expect(await contract.getGetI()).toBe(cs.i);
            });
        }
    }

    //
    // Cases with references
    //
    {
        const cases: {
            a: {
                $$type: "Vars";
                a: bigint;
                b: bigint;
                c: bigint;
                d: bigint;
                e: bigint;
            };
            b: {
                $$type: "Vars";
                a: bigint;
                b: bigint;
                c: bigint;
                d: bigint;
                e: bigint;
            };
        }[] = [];
        cases.push({
            a: {
                $$type: "Vars",
                a: 1n,
                b: 2n,
                c: 3n,
                d: 4n,
                e: 5n,
            },
            b: {
                $$type: "Vars",
                a: 6n,
                b: 7n,
                c: 8n,
                d: 9n,
                e: 10n,
            },
        });

        for (let i = 0; i < cases.length; i++) {
            it("should handle case-2 #" + i, async () => {
                const cs = cases[i]!;

                // Init contract
                const contract = blockchain.openContract(
                    await SerializationTester2.fromInit(cs.a, cs.b),
                );

                const deployResult = await contract.send(
                    treasure.getSender(),
                    { value: toNano("10") },
                    null,
                );

                expect(deployResult.transactions).toHaveTransaction({
                    from: treasure.address,
                    to: contract.address,
                    success: true,
                    deploy: true,
                });

                // Check values
                const a = await contract.getGetA();
                const aOpt = await contract.getGetAOpt();
                const b = await contract.getGetB();
                const bOpt = await contract.getGetBOpt();
                const both = await contract.getGetBoth();
                expect(aOpt).toMatchObject(a);
                expect(bOpt).toMatchObject(b);
                expect(a.a).toBe(cs.a.a);
                expect(a.b).toBe(cs.a.b);
                expect(a.c).toBe(cs.a.c);
                expect(a.d).toBe(cs.a.d);
                expect(a.e).toBe(cs.a.e);
                expect(b.a).toBe(cs.b.a);
                expect(b.b).toBe(cs.b.b);
                expect(b.c).toBe(cs.b.c);
                expect(b.d).toBe(cs.b.d);
                expect(b.e).toBe(cs.b.e);
                expect(both.a.a).toBe(cs.a.a);
                expect(both.a.b).toBe(cs.a.b);
                expect(both.a.c).toBe(cs.a.c);
                expect(both.a.d).toBe(cs.a.d);
                expect(both.a.e).toBe(cs.a.e);
                expect(both.b.a).toBe(cs.b.a);
                expect(both.b.b).toBe(cs.b.b);
                expect(both.b.c).toBe(cs.b.c);
                expect(both.b.d).toBe(cs.b.d);
                expect(both.b.e).toBe(cs.b.e);
            });
        }
    }

    it("serialization-3", async () => {
        // Init contract
        const contract = blockchain.openContract(
            await SerializationTester3.fromInit(
                1n,
                true,
                beginCell().endCell(),
                beginCell().endCell().asSlice(),
                beginCell().endCell().asBuilder(),
                "test",
            ),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Check values
        expect(await contract.getGetA()).toBe(1n);
        expect(await contract.getGetB()).toBe(true);
        expect(await contract.getGetC()).toBeInstanceOf(Cell);
        expect(await contract.getGetD()).toBeInstanceOf(Slice);
        expect(await contract.getGetE()).toBeInstanceOf(Builder);
        expect(await contract.getGetF()).toBe("test");
    });
});


## stdlib.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/stdlib.spec.ts)
import { Address, beginCell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { StdlibTest } from "./contracts/output/stdlib_StdlibTest";
import "@ton/test-utils";

describe("stdlib", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<StdlibTest>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await StdlibTest.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should execute stdlib methods correctly", async () => {
        const slice = beginCell()
            .storeBit(1)
            .storeBit(1)
            .storeRef(beginCell().storeBit(1).endCell())
            .endCell()
            .asSlice();

        // Execute and verify slice methods
        expect(await contract.getSliceBits(slice)).toBe(2n);
        expect(await contract.getSliceRefs(slice)).toBe(1n);
        expect(await contract.getSliceEmpty(slice)).toBe(false);
        expect(await contract.getLoadBool(slice)).toBe(true);
        expect(await contract.getLoadBit(slice)).toBe(true);

        expect(
            (await contract.getStoreBool(beginCell(), true))
                .endCell()
                .toString(),
        ).toBe(beginCell().storeBit(true).endCell().toString());

        expect(
            (await contract.getStoreBit(beginCell(), true))
                .endCell()
                .toString(),
        ).toBe(beginCell().storeBit(true).endCell().toString());

        expect(await contract.getTvm_2023_07Upgrade()).toEqual(1355n);
        expect(await contract.getTvm_2024_04Upgrade()).toEqual(82009144n);

        expect(
            (
                await contract.getStoreMaybeRef(
                    beginCell(),
                    beginCell().storeUint(123, 64).endCell(),
                )
            ).endCell(),
        ).toEqualCell(
            beginCell()
                .storeMaybeRef(beginCell().storeUint(123, 64).endCell())
                .endCell(),
        );

        expect(
            (await contract.getStoreMaybeRef(beginCell(), null)).endCell(),
        ).toEqualCell(beginCell().storeMaybeRef(null).endCell());

        const addrStd = await contract.getParseStdAddress(
            beginCell()
                .storeAddress(
                    Address.parse(
                        "0:4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873",
                    ),
                )
                .endCell()
                .asSlice(),
        );
        expect(addrStd.workchain).toBe(0n);
        expect(addrStd.address).toBe(
            BigInt(
                "0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873",
            ),
        );

        const addrVar = await contract.getParseVarAddress(
            beginCell()
                .storeUint(6, 3)
                .storeUint(123, 9)
                .storeUint(234, 32)
                .storeUint(345, 123)
                .endCell()
                .asSlice(),
        );
        expect(addrVar.workchain).toBe(234n);
        expect(addrVar.address.asCell()).toEqualCell(
            beginCell().storeUint(345, 123).endCell(),
        );
    });
});


## strings.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/strings.spec.ts)
import { beginCell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { StringsTester } from "./contracts/output/strings_StringsTester";
import "@ton/test-utils";

describe("strings", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<StringsTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await StringsTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement strings correctly", async () => {
        expect(contract.abi.errors!["31733"]!.message).toStrictEqual(
            "condition can`t be...",
        );

        // Check methods
        expect(await contract.getConstantString()).toBe("test string");
        expect(await contract.getConstantStringUnicode()).toBe("привет мир 👀");
        const l =
            "привет мир 👀 привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀";
        expect(await contract.getConstantStringUnicodeLong()).toBe(l);
        expect(
            (await contract.getDynamicStringCell()).equals(
                beginCell().storeStringTail("Hello!").endCell(),
            ),
        ).toBe(true);
        expect(
            (await contract.getDynamicStringCell2()).equals(
                beginCell().storeStringTail("Hello, World!").endCell(),
            ),
        ).toBe(true);
        expect(
            (await contract.getDynamicCommentCell()).equals(
                beginCell()
                    .storeUint(0, 32)
                    .storeStringTail("Something something world!")
                    .endCell(),
            ),
        ).toBe(true);
        const l2 =
            "Hello!привет мир 👀 привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀";
        expect(
            (await contract.getDynamicCommentCellLarge()).equals(
                beginCell().storeStringTail(l2).endCell(),
            ),
        ).toBe(true);
        expect(await contract.getDynamicCommentStringLarge()).toEqual(l2);
        expect(await contract.getStringWithNumber()).toEqual(
            "Hello, your balance: 123",
        );
        expect(await contract.getStringWithLargeNumber()).toEqual(
            "Hello, your balance: 1000000000000000000000000000000000000000000000000000000000000",
        );
        expect(await contract.getStringWithNegativeNumber()).toEqual(
            "Hello, your balance: -123",
        );
        expect(await contract.getStringWithFloat()).toEqual("9.5");

        const base = await contract.getBase64();
        expect(base.loadBuffer(base.remainingBits / 8).toString()).toEqual(
            "Many hands make light work.",
        );

        const b64cases = [
            "SGVsbG8gV29ybGQ=",
            "li7dzDacuo67Jg7mtqEm2TRuOMU=",
            "FKIhdgaG5LGKiEtF1vHy4f3y700zaD6QwDS3IrNVGzNp2rY+1LFWTK6D44AyiC1n8uWz1itkYMZF0/aKDK0Yjg==",
            "AA==",
        ];
        for (const b of b64cases) {
            const s = Buffer.from(b, "base64");
            const r = await contract.getProcessBase64(b);
            const d = r.loadBuffer(r.remainingBits / 8);
            expect(d.toString("hex")).toEqual(s.toString("hex"));
        }

        expect(await contract.getStringWithEscapedChars1()).toBe(
            'test \n \n \\ \\\n "string"',
        );
        expect(await contract.getStringWithEscapedChars2()).toEqual(
            'test \n test \t test \r test \b test \f test " test \' test \\ \\\\ "_" "" test',
        );
        expect(await contract.getStringWithEscapedChars3()).toEqual(
            'test \\n test \\t test \\r test \\\\b\b test \\f test \\" test \\\' test \v \v \\\\ \\\\\\\\ \\"_\\" \\"\\" test',
        );
        expect(await contract.getStringWithEscapedChars4()).toEqual(
            "\u{2028}\u{2029} \u0044 \x41\x42\x43",
        );
        expect(await contract.getStringWithEscapedChars5()).toEqual(
            "\u{0} \u{00} \u{000} \u{0000} \u{00000} \u{000000} \u0000 \x00",
        );
        expect(await contract.getStringWithEscapedChars6()).toEqual(
            `\x7F\x1F\x0A\x00 TACT`,
        );

        expect(await contract.getStringWithAddress()).toEqual(
            "EQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doc2lN",
        );
    });
});


## structs.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/structs.spec.ts)
import { Dictionary, beginCell, toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import {
    IntFields,
    MyMessage1,
    MyStruct1,
    MyStruct2,
    MyStruct3,
    OptionalFields,
    S1,
    StructsTester,
    UintFields,
    loadMyMessage1,
    loadMyStruct1,
    loadMyStruct2,
    storeMyMessage1,
    storeMyStruct1,
    storeMyStruct2,
} from "./contracts/output/structs_StructsTester";
import "@ton/test-utils";

describe("structs", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<StructsTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await StructsTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement structs correctly", async () => {
        expect(await contract.getStructInitializerTest()).toEqual(true);

        // Prepare test values
        const s1: MyStruct1 = {
            $$type: "MyStruct1",
            a: 1n,
            b: 2n,
            c: 3n,
        };
        const s2: MyStruct1 = {
            $$type: "MyStruct1",
            a: 1n,
            b: 2n,
            c: null,
        };
        const s3: MyStruct2 = {
            $$type: "MyStruct2",
            m: Dictionary.empty(
                Dictionary.Keys.BigInt(257),
                Dictionary.Values.BigUint(64),
            ),
            s: s1,
        };
        const s4: MyStruct2 = {
            $$type: "MyStruct2",
            m: Dictionary.empty(
                Dictionary.Keys.BigInt(257),
                Dictionary.Values.BigUint(64),
            ),
            s: null,
        };
        const m1: MyMessage1 = {
            $$type: "MyMessage1",
            a: 1n,
            s: s3,
        };
        const m2: MyMessage1 = {
            $$type: "MyMessage1",
            a: 2n,
            s: s4,
        };

        const c1 = beginCell()
            .storeInt(1, 257)
            .storeUint(2, 32)
            .storeBit(true) // has c
            .storeInt(3, 257)
            .endCell();
        const c2 = beginCell()
            .storeInt(1, 257)
            .storeUint(2, 32)
            .storeBit(false) // no c
            .endCell();
        const c3 = beginCell()
            .storeBit(false) // empty dict
            .storeBit(true) // has struct
            .storeSlice(c1.asSlice())
            .endCell();
        const c4 = beginCell()
            .storeBit(false) // empty dict
            .storeBit(false) // no struct
            .endCell();

        // my_message1#a98a916c a:int257 s:MyStruct2{m:dict<int, uint64>,s:Maybe MyStruct1{a:int257,b:uint32,c:Maybe int257}} = MyMessage1
        const c5 = beginCell()
            .storeUint(0xa98a916c, 32)
            .storeInt(1, 257)
            .store(storeMyStruct2(s3))
            .endCell();
        const c6 = beginCell()
            .storeUint(0xa98a916c, 32)
            .storeInt(2, 257)
            .store(storeMyStruct2(s4))
            .endCell();

        // Test smart contract

        expect((await contract.getToCell1(s1)).toString()).toEqual(
            c1.toString(),
        );
        expect((await contract.getToCell1(s2)).toString()).toEqual(
            c2.toString(),
        );
        expect((await contract.getToCell2(s3)).toString()).toEqual(
            c3.toString(),
        );
        expect((await contract.getToCell2(s4)).toString()).toEqual(
            c4.toString(),
        );
        expect((await contract.getToCellMessage1(m1)).toString()).toEqual(
            c5.toString(),
        );
        expect((await contract.getToCellMessage1(m2)).toString()).toEqual(
            c6.toString(),
        );

        expect((await contract.getToSlice1(s1)).toString()).toEqual(
            c1.toString(),
        );

        expect(await contract.getFromCell1(c1)).toMatchObject<MyStruct1>(s1);
        expect(await contract.getFromCell1(c2)).toMatchObject<MyStruct1>(s2);
        expect(await contract.getFromCell2(c3)).toMatchSnapshot();
        expect(await contract.getFromCell2(c4)).toMatchSnapshot();
        expect(await contract.getFromCellMessage1(c5)).toMatchSnapshot();
        expect(await contract.getFromCellMessage1(c6)).toMatchSnapshot();

        expect(
            await contract.getFromSlice1(c1.asSlice()),
        ).toMatchObject<MyStruct1>(s1);
        expect(
            await contract.getFromSlice1(c2.asSlice()),
        ).toMatchObject<MyStruct1>(s2);
        expect(await contract.getFromSlice2(c3.asSlice())).toMatchSnapshot();
        expect(await contract.getFromSlice2(c4.asSlice())).toMatchSnapshot();
        expect(
            await contract.getFromSliceMessage1(c5.asSlice()),
        ).toMatchSnapshot();
        expect(
            await contract.getFromSliceMessage1(c6.asSlice()),
        ).toMatchSnapshot();

        expect((await contract.getTest1(s1, s3)).toString()).toEqual(
            beginCell().storeRef(c1).storeRef(c3).endCell().toString(),
        );
        expect((await contract.getTest1(s2, s4)).toString()).toEqual(
            beginCell().storeRef(c2).storeRef(c4).endCell().toString(),
        );
        expect((await contract.getTest1(s1, s4)).toString()).toEqual(
            beginCell().storeRef(c1).storeRef(c4).endCell().toString(),
        );
        expect((await contract.getTest1(s2, s3)).toString()).toEqual(
            beginCell().storeRef(c2).storeRef(c3).endCell().toString(),
        );

        // Test wrappers

        expect(loadMyStruct1(c1.asSlice())).toMatchObject<MyStruct1>(s1);
        expect(loadMyStruct1(c2.asSlice())).toMatchObject<MyStruct1>(s2);
        expect(loadMyStruct2(c3.asSlice())).toMatchSnapshot();
        expect(loadMyStruct2(c4.asSlice())).toMatchSnapshot();
        expect(loadMyMessage1(c5.asSlice())).toMatchSnapshot();
        expect(loadMyMessage1(c6.asSlice())).toMatchSnapshot();
        expect(
            beginCell().store(storeMyStruct1(s1)).endCell().toString(),
        ).toEqual(c1.toString());
        expect(
            beginCell().store(storeMyStruct1(s2)).endCell().toString(),
        ).toEqual(c2.toString());
        expect(
            beginCell().store(storeMyStruct2(s3)).endCell().toString(),
        ).toEqual(c3.toString());
        expect(
            beginCell().store(storeMyStruct2(s4)).endCell().toString(),
        ).toEqual(c4.toString());
        expect(
            beginCell().store(storeMyMessage1(m1)).endCell().toString(),
        ).toEqual(c5.toString());
        expect(
            beginCell().store(storeMyMessage1(m2)).endCell().toString(),
        ).toEqual(c6.toString());

        // Negative parsing tests

        await expect(
            contract.getFromCell1(beginCell().storeUint(0, 123).endCell()),
        ).rejects.toThrow("Unable to execute get method. Got exit_code: 9");

        await expect(
            contract.getFromCell1(
                beginCell()
                    .storeStringTail(
                        "a long string a long string a long string a long string a long string a long string a long string a long string a long string",
                    )
                    .endCell(),
            ),
        ).rejects.toThrow("Unable to execute get method. Got exit_code: 9");

        expect(() =>
            loadMyStruct1(beginCell().storeUint(0, 123).endCell().asSlice()),
        ).toThrow();

        const s5: MyStruct3 = {
            $$type: "MyStruct3",
            s: "contract const struct test",
        };
        const s6: MyStruct3 = {
            $$type: "MyStruct3",
            s: "global const struct test",
        };
        expect(await contract.getContractStructConstantImmediate()).toEqual(s5);
        expect(await contract.getGlobalConstStructConstantImmediate()).toEqual(
            s6,
        );
        expect(
            await contract.getContractStructConstantFieldImmediate(),
        ).toEqual(s5.s);
        expect(
            await contract.getGlobalConstStructConstantFieldImmediate(),
        ).toEqual(s6.s);

        expect(await contract.getContractStructConstantViaVar()).toEqual(s5);
        expect(await contract.getGlobalConstStructConstantViaVar()).toEqual(s6);
        expect(await contract.getContractStructConstantFieldViaVar()).toEqual(
            s5.s,
        );
        expect(
            await contract.getGlobalConstStructConstantFieldViaVar(),
        ).toEqual(s6.s);

        // https://github.com/tact-lang/tact/issues/472

        const sendResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "example",
        );
        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: false,
            exitCode: 9,
        });

        expect(await contract.getLongStruct15Test()).toMatchSnapshot();
        expect(await contract.getLongStruct16Test()).toMatchSnapshot();
        expect(await contract.getLongStruct32Test()).toMatchSnapshot();
        expect(await contract.getLongNestedStructTest()).toMatchSnapshot();
        expect(
            await contract.getLongNestedStructWithOptsTest(),
        ).toMatchSnapshot();
        expect(await contract.getLongContractTest()).toEqual(210n);

        // https://github.com/tact-lang/tact/issues/671

        expect(
            (
                await blockchain
                    .provider(contract.address)
                    .get("longStruct15Test", [])
            ).stack,
        ).toMatchSnapshot();
        expect(
            (
                await blockchain
                    .provider(contract.address)
                    .get("longStruct16Test", [])
            ).stack,
        ).toMatchSnapshot();
        expect(
            (
                await blockchain
                    .provider(contract.address)
                    .get("longStruct32Test", [])
            ).stack,
        ).toMatchSnapshot();
        expect(
            (
                await blockchain
                    .provider(contract.address)
                    .get("longNestedStructTest", [])
            ).stack,
        ).toMatchSnapshot();
        expect(
            (
                await blockchain
                    .provider(contract.address)
                    .get("longNestedStructWithOptsTest", [])
            ).stack,
        ).toMatchSnapshot();

        // https://github.com/tact-lang/tact/issues/690

        expect(await contract.getLocation1()).toMatchSnapshot();
        expect(await contract.getLocation2()).toMatchSnapshot();
        expect(await contract.getTripleNestedStructOpt1()).toMatchSnapshot();
        expect(await contract.getTripleNestedStructOpt2()).toMatchSnapshot();
        expect(await contract.getTripleNestedStructOpt3()).toMatchSnapshot();
        expect(await contract.getLongAndDeepNestedStruct1()).toMatchSnapshot();
        expect(await contract.getLongAndDeepNestedStruct2()).toMatchSnapshot();
        expect(await contract.getLongAndDeepNestedStruct3()).toMatchSnapshot();

        // https://github.com/tact-lang/tact/issues/374

        // int serialization formats
        const sIntFields: IntFields = {
            $$type: "IntFields",
            i1: -1n,
            i2: -2n,
            i3: -4n,
            i255: -(2n ** 254n),
            i256: -(2n ** 255n),
            i257: -(2n ** 256n),
        };
        const sIntFieldsCell = beginCell()
            // Storing min values for each bit length
            .storeInt(-1n, 1)
            .storeInt(-2n, 2)
            .storeInt(-4n, 3)
            .storeInt(-(2n ** 254n), 255)
            .storeInt(-(2n ** 255n), 256)
            .storeInt(-(2n ** 256n), 257)
            .endCell();
        expect(await contract.getIntFieldsStruct()).toEqual(sIntFields);
        expect(await contract.getIntFieldsFromCell(sIntFieldsCell)).toEqual(
            sIntFields,
        );

        // uint serialization formats
        const mUintFields: UintFields = {
            $$type: "UintFields",
            u1: 1n,
            u2: 3n,
            u3: 7n,
            u254: 2n ** 254n - 1n,
            u255: 2n ** 255n - 1n,
            u256: 2n ** 256n - 1n,
        };
        const _mUintFieldsCell = beginCell()
            // Header
            .storeUint(0xea01f46a, 32)
            // Storing max values for each bit length
            .storeUint(1n, 1)
            .storeUint(3n, 2)
            .storeUint(7n, 3)
            .storeUint(2n ** 254n - 1n, 254)
            .storeUint(2n ** 255n - 1n, 255)
            .storeUint(2n ** 256n - 1n, 256)
            .endCell();

        expect(await contract.getUintFieldsMessage()).toEqual(mUintFields);

        // https://github.com/tact-lang/tact/issues/767

        const m = Dictionary.empty(
            Dictionary.Keys.Uint(8),
            Dictionary.Values.BigVarUint(4),
        );
        m.set(1, 1n);
        m.set(2, 2n);
        m.set(3, 3n);
        const result = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            {
                $$type: "Foo",
                s: beginCell().storeDict(m).endCell().asSlice(),
            },
        );
        expect(result.transactions).toHaveTransaction({
            on: contract.address,
            success: true,
        });
        expect(result.transactions).toHaveTransaction({
            from: contract.address,
            to: treasure.address,
            body: beginCell().storeDict(m).endCell(),
        });

        const optionalFields: OptionalFields = {
            $$type: "OptionalFields",
            nickname: null,
            avatar: "non-null string",
        };
        expect(
            await contract.getOptionalFields(),
        ).toMatchObject<OptionalFields>(optionalFields);

        // Struct destructuring
        expect(await contract.getDestructuringTest1()).toBe(43n);
        expect(await contract.getDestructuringTest1Const()).toBe(43n);
        expect(await contract.getDestructuringTest2()).toBe(42n);
        expect(await contract.getDestructuringTest2Const()).toBe(42n);
        expect(await contract.getDestructuringTest3()).toBe(43n);
        expect(await contract.getDestructuringTest3Const()).toBe(43n);
        expect(await contract.getDestructuringTest4()).toBe(43n);
        expect(await contract.getDestructuringTest4Const()).toBe(43n);
        expect(await contract.getDestructuringTest5()).toBe(43n);
        expect(await contract.getDestructuringTest5Const()).toBe(43n);
        expect(await contract.getDestructuringTest6()).toBe(6n);
        expect(await contract.getDestructuringTest6Const()).toBe(6n);
        expect(await contract.getDestructuringTest7()).toMatchObject<S1>({
            $$type: "S1",
            a: 3n,
            b: 2n,
            c: 1n,
        });
        expect(await contract.getDestructuringTest7Const()).toMatchObject<S1>({
            $$type: "S1",
            a: 3n,
            b: 2n,
            c: 1n,
        });
        expect(await contract.getDestructuringTest8()).toBe(42n);
        expect(await contract.getDestructuringTest8Const()).toBe(42n);
    });
});


## ternary.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/ternary.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { TernaryTester } from "./contracts/output/ternary_TernaryTester";
import "@ton/test-utils";

describe("ternary", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<TernaryTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await TernaryTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement ternary operator correctly", async () => {
        // Check methods
        expect(await contract.getTest1(123n)).toEqual(1n);
        expect(await contract.getTest1(5n)).toEqual(2n);

        expect(await contract.getTest2(123n)).toEqual(246n);
        expect(await contract.getTest2(5n)).toEqual(15n);

        expect(await contract.getTest3(2n, 2n)).toEqual(1n);
        expect(await contract.getTest3(2n, 3n)).toEqual(2n);

        expect(await contract.getTest4(123n, 456n)).toEqual(1n);
        expect(await contract.getTest4(123n, 5n)).toEqual(2n);
        expect(await contract.getTest4(5n, 789n)).toEqual(3n);
        expect(await contract.getTest4(5n, 5n)).toEqual(4n);

        expect(await contract.getTest5()).toEqual(1n);

        expect(await contract.getTest6()).toEqual(1n);

        expect(await contract.getTest7()).toEqual(2n);

        expect(await contract.getTest8()).toEqual(3n);

        expect(await contract.getTest9()).toEqual(3n);

        expect(await contract.getTest10(1n)).toEqual(42n);
        expect(await contract.getTest10(2n)).toEqual(43n);
        expect(await contract.getTest10(3n)).toEqual(44n);
        expect(await contract.getTest10(4n)).toEqual(45n);
        expect(await contract.getTest10(0n)).toEqual(45n);
        expect(await contract.getTest10(42n)).toEqual(45n);
    });
});


## text-message-receivers.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/text-message-receivers.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { TextMessageReceivers } from "./contracts/output/text-message-receivers_TextMessageReceivers";
import "@ton/test-utils";

describe("text-message-receivers", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<TextMessageReceivers>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(
            await TextMessageReceivers.fromInit(),
        );
    });

    it("should deploy", async () => {
        // Deploy the contract
        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("1") },
            { $$type: "Deploy", queryId: 0n },
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Verify initial state
        expect(await contract.getGetCounter()).toBe(0n);
    });

    it("should increment counter with different text messages", async () => {
        // Deploy the contract
        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("1") },
            { $$type: "Deploy", queryId: 0n },
        );
        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });

        // Verify initial state
        expect(await contract.getGetCounter()).toBe(0n);

        const sendMessage = async (
            message:
                | "increment'"
                | 'increment-2\\"'
                | "increment-3`"
                | "\\\\increment-4\\\\",
        ) => {
            const incrementResult1 = await contract.send(
                treasure.getSender(),
                { value: toNano("1") },
                message,
            );
            expect(incrementResult1.transactions).toHaveTransaction({
                from: treasure.address,
                to: contract.address,
                success: true,
            });
        };

        // Increment counter
        await sendMessage("increment'");
        expect(await contract.getGetCounter()).toBe(1n);

        await sendMessage('increment-2\\"');
        expect(await contract.getGetCounter()).toBe(3n);

        await sendMessage("increment-3`");
        expect(await contract.getGetCounter()).toBe(6n);

        await sendMessage("\\\\increment-4\\\\");
        expect(await contract.getGetCounter()).toBe(10n);
    });
});


## traits.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/traits.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { LaikaContract } from "./contracts/output/traits_LaikaContract";
import "@ton/test-utils";

describe("traits", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<LaikaContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await LaikaContract.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("0.5") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement traits correctly", async () => {
        // Check the contract's behavior after deployment
        expect(await contract.getSay()).toBe("I am a Laika and I say Woof");
    });
});


## try-catch.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/try-catch.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { TryCatchTester } from "./contracts/output/try-catch_TryCatchTester";
import "@ton/test-utils";

describe("try-catch", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<TryCatchTester>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(await TryCatchTester.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement try-catch statements correctly", async () => {
        // Check try-catch method results
        expect(await contract.getTestTryCatch1()).toEqual(7n);
        expect(await contract.getTestTryCatch2()).toEqual(101n);
        expect(await contract.getTestTryCatch3()).toEqual(4n);

        // Check state rollbacks
        expect(await contract.getGetCounter()).toEqual(0n);
        let sendResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "increment",
        );
        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });
        expect(await contract.getGetCounter()).toEqual(1n);

        sendResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "incrementTryCatch",
        );
        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });
        expect(await contract.getGetCounter()).toEqual(1n); // Counter should not change

        sendResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "tryCatchRegisters",
        );
        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
        });
        expect(await contract.getGetCounter()).toEqual(2n); // Counter should increment
    });
});


## underscore-variable.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/underscore-variable.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { UnderscoreVariableTestContract } from "./contracts/output/underscore-variable_UnderscoreVariableTestContract";
import "@ton/test-utils";

describe("underscore-variable", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<UnderscoreVariableTestContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure");

        contract = blockchain.openContract(
            await UnderscoreVariableTestContract.fromInit(),
        );

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should implement underscore variables correctly", async () => {
        // Check methods
        expect(await contract.getTest1()).toEqual(0n);
        expect(await contract.getTest2()).toEqual(12n);
        expect(await contract.getTest3()).toEqual(6n);
        expect(await contract.getTest4()).toEqual(4n);
    });
});


## address.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/address.tact)
contract AddressTester {
    init() {
        
    }

    receive() {

    }

    get fun test1(): Address {
        return address("UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI");
    }

    get fun test2(): Address {
        return address("EQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doc2lN");
    }

    get fun test3(): Address {
        return address("0:4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873");
    }
}

## allocation.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/allocation.tact)
import "@stdlib/deploy";

message SetCost {
    cost: Int? as coins;
}

struct Struct2 {
    c: String;
    d: String;
    e: String;
    f: String;
}

contract Test with Deployable {
    owner: Address;
    seqno: Int as uint256 = 0;
    a: Int as uint256 = 0;
    b: Int as uint256 = 0;

    struct2: Struct2;

    author3: Address?;

    cost: Int? as coins;
    address: Address?;
    price: Int? as coins;

    init(owner: Address, struct2: Struct2) {
        self.owner = owner;
        self.struct2 = struct2;
    }

    receive(msg: SetCost) {
        self.cost = msg.cost;
        self.reply("Cost is updated".asComment());
    }
}

## asm-functions.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/asm-functions.tact)
contract AsmFunctionsTester {
    /// To handle deployment
    receive() {}

    get fun testAsmStoreDict(): Bool {
        let m: map<Int, Int> = emptyMap();
        m.set(35, 34);
        m.set(42, 27);

        let s = beginCell().asmStoreDict(m.asCell()).asSlice();
        let m2: map<Int, Int> = s.asmLoadMapIntInt().val;

        return m2 == m;
    }

    get fun testAsmLoadCoins(): Bool {
        let s = beginCell().storeCoins(42).asSlice();
        return s.asmLoadCoins().val == 42;
    }

    get fun testAsmLoadInt(): Bool {
        let s = beginCell().storeInt(42, 7).asSlice();
        return s.asmLoadInt(7).val == 42;
    }

    get fun testAsmDebugStr(): Bool {
        asmDebugStr();
        return true;
    }

    get fun testAsmCreateUseWord(): Bool {
        return asmCreateUseWord(6) == 7;
    }
}

// Functions to test

asm(c self) extends fun asmStoreDict(self: Builder, c: Cell?): Builder { STDICT }

asm extends fun asmLoadMapIntInt(self: Slice): MapIntIntSlice { LDDICT }

asm extends fun asmLoadCoins(self: Slice): IntSlice { LDVARUINT16 }

asm(self len -> 1 0) extends fun asmLoadInt(self: Slice, len: Int): SliceInt { LDIX }

asm fun asmDebugStr() { "Works!" DEBUGSTR }

asm fun asmCreateUseWord(x: Int): Int {
    { INC INC INC } : 🥰🥰🥰
    { DEC DEC DEC } : 💀💀💀
    🥰🥰🥰 💀💀💀 INC
}

// Helper Structs

struct MapIntIntSlice {
    val: map<Int, Int>;
    rem: Slice;
}

struct IntSlice {
    val: Int;
    rem: Slice;
}

struct SliceInt {
    rem: Slice;
    val: Int;
}


## bounced-routing.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/bounced-routing.tact)
message EntryFirst {
    amountToAdd: Int as uint32;
    toAddress: Address;
}

message EntrySecond {
    amountToAdd: Int as uint32;
    toAddress: Address;
}

message First {
    amount: Int as uint32;
    myCoins: Int as coins;
    myBool3: Bool;
    anAddress: Address;
}

message Second {
    amount_bigger: Int as uint64;
    myBool: Bool;
    thisDoesNotFit: Int as uint256;
    myAddress: Address;
    myBool2: Bool;
    myStruct: MyStruct;
    myStruct2: MyStruct;
}

message Large {
    address: Address;
    value: Int as coins;
}

message SmallBounce {
    amount: Int as uint32;
    myBool3: Bool;
}

struct MyStruct {
    amount: Int;
}

contract SampleContract {
    a: Int;

    init() {
        self.a = 100;
    }

    receive() {
        // Deploy
    }

    receive(msg: EntryFirst) {
        self.a = self.a - msg.amountToAdd;
        send(SendParameters{
            to: msg.toAddress,
            value: ton("1"), 
            mode: SendIgnoreErrors, 
            bounce: true, 
            body: First{amount: msg.amountToAdd, myCoins: 3, myBool3: false, anAddress: sender()}.toCell()
        });
    }
    
    receive(msg: EntrySecond) {
        self.a = self.a - msg.amountToAdd;
        send(SendParameters{
            to: msg.toAddress,
            value: ton("1"), 
            mode: SendIgnoreErrors, 
            bounce: true, 
            body: Second{amount_bigger: msg.amountToAdd, myBool: false, thisDoesNotFit: 1, myAddress: sender(), myBool2: false, myStruct: MyStruct{amount: 1}, myStruct2: MyStruct{amount: 2}}.toCell()
        });
    }
    
    receive(msg: First) {
        // do something with the Second struct
        let x: First = msg;
    }

    receive(msg: Second) {
        // do something with the Second struct
    }

    receive("Increment") {
        // simple handler for a text message
    }

    bounced(msg: Slice) {
        dump("In generic bounce");
        let y: Int = msg.loadUint(32);
        self.a = 77;
    }
    
    bounced(msg: bounced<First>) {
        dump("In bounce of first");
        // only the first 224 bits are populated into a partial First struct
        let y: Bool = msg.myBool3;
        self.a = self.a + msg.amount - 2;
        // let z: Address = msg.anAddress; // This would throw
        let z: bounced<First> = msg;
    }
    
    bounced(msg: bounced<Second>) {
        dump("In bounce of second");
        self.a = self.a + msg.amount_bigger - 4;
    }

    bounced(msg: SmallBounce) {
        dump("In bounce of small bounce");
        self.a = self.a + msg.amount - 4;
    }

    bounced(msg: bounced<Large>) {
        dump("In bounce of large bounce");
    }

    // This will be supported in a future commit, and will throw if the string does not fit within a bounced message
    //bounced("Increment") {
    // }

    get fun amount(): Int {
        return self.a;
    }
}

contract SampleContract2 {
    init() {}

    receive() {
    }

    receive(msg: First) {
        dump("Bouncing First!");
        throw(144);
    }
    
    receive(msg: Second) {
        dump("Bouncing Second!");
        throw(145);
    }
}

## constants.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/constants.tact)
const someGlobalConst: Int = 100;

const globalConst1: Int = 1;
const globalConst2: Int = globalConst1 + 1;  // 2
const globalConst3: Int = globalFun1(globalConst1) + 1;  // 4
const globalConst4: Int = globalFun2(globalConst1) + globalConst3;  // 15
const globalConst5: Int = globalFun3(globalConst4);  // 15
const globalConst6: Int = globalFun4(globalConst5 + 10);  // 26
const globalConst7: Int = globalFun5(globalConst6 + 1, globalConst5 + 10);  // 27
const globalConst8: Int = GCD_recursive(globalConst6, globalConst7 + 1);  // GCD(26, 28) = 2
const globalConst9: Int = GCD_iterative(globalConst6, globalConst7 + 1);  // 2
const globalConst10: Int = factorial_recursive(globalConst3);  // 4! = 24
const globalConst11: Int = factorial_iterative(globalConst3);  // 4! = 24
const globalConst12: Int = fibonacci_recursive(globalConst3 + 2);  // fibonacci(6) = 8
const globalConst13: Int = fibonacci_iterative(globalConst3 + 2);  // fibonacci(6) = 8

struct S {
    a: Bool;
    b: Int;
}

struct T {
    a: Int;
    s: S;
}

// Global functions

// Test assignments
fun globalFun1(v: Int): Int {
    let i = v;
    let j = 1;
    let k = i + j;
    k = k * 10;
    k += 2;
    k -= 1;
    k /= 2;
    k *= 5;
    k %= 2;
    k |= 9;
    k &= 22;
    k ^= 3;
    return k;
}

// Test repeat
fun globalFun2(v: Int): Int {
    let j = v;
    repeat(10) {
        let i = 1;
        j += i;
    }
    return j;
}

// Test do..until
fun globalFun3(v: Int): Int {
    let i = 20;
    do {
        i -= 1;
    } until (i <= v);
    return i;
}

// Test while
fun globalFun4(v: Int): Int {
    let i = 20;
    while (i <= v) {
        i += 1;
    }
    return i;
}

// MAX, test conditionals
fun globalFun5(a: Int, b: Int): Int {
    if (a <= b) {
        return b;
    } else {
        return a;
    }
}

// Recursive GCD for non-negative integers
fun GCD_recursive(a: Int, b: Int): Int {
    if (a < 0 || b < 0) {
        // there will be a throws error here once 
        // try-catch is implemented in
        // the interpreter
        return 0;
    }

    if (b == 0) {
        return a;
    } else {
        return GCD_recursive(b, a % b);
    }
}

// Iterative GCD for non-negative integers
fun GCD_iterative(a: Int, b: Int): Int {
    if (a < 0 || b < 0) {
        // there will be a throws error here once 
        // try-catch is implemented in
        // the interpreter
        return 0;
    }

    let na = a;
    let nb = b;
    
    while (nb != 0) {
        let temp = nb;
        nb = na % nb;
        na = temp;
    }
    return na;
}

fun factorial_recursive(a: Int): Int {
    if (a < 0) {
        // there will be a throws error here once 
        // try-catch is implemented in
        // the interpreter
        return 0;
    }

    if (a <= 1) {
        return 1;
    } else {
        return a * factorial_recursive(a - 1);
    }
}

fun factorial_iterative(a: Int): Int {
    if (a < 0) {
        // there will be a throws error here once 
        // try-catch is implemented in
        // the interpreter
        return 0;
    }

    let result = 1;
    let i = 2;

    while (i <= a) {
        result *= i;
        i += 1;
    }
    return result;
}

fun fibonacci_recursive(a: Int): Int {
    if (a < 0) {
        // there will be a throws error here once 
        // try-catch is implemented in
        // the interpreter
        return 0;
    }

    if (a <= 1) {
        return a;
    } else {
        return fibonacci_recursive(a - 2) + fibonacci_recursive(a - 1);
    }
}

fun fibonacci_iterative(a: Int): Int {
    if (a < 0) {
        // there will be a throws error here once 
        // try-catch is implemented in
        // the interpreter
        return 0;
    }

    if (a <= 1) {
        return a;
    }

    let prev = 0;
    let current = 1;

    repeat (a - 1) {
        let temp = current;
        current += prev;
        prev = temp;
    }
    return current;
}


contract ConstantTester {
    const something1: Int = 10 + 1;
    const something2: Int? = null;
    const something3: Int = ton("123");
    const something4: Int = ton("123") + ton("33.3") * 10;
    const something5: String = "Hello world!";
    const something6: Int = 10 * 1;
    const something7: Int = 10 >> 1;
    const something8: Int = (2 + 4) & 4;
    const something9: Address = address("UQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doczSI");
    const something10: Address = newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873);
    const something11: Int = 123 ^ 35;
    const something12: Int = -123 ^ 35;
    const something13: Int = -123 ^ -35;
    const something14: Int = pow(3, 5);
    const something15: Int = pow2(5);
    const something16: Int = -115792089237316195423570985008687907853269984665640564039457584007913129639936;
    const something17: Int = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
    const something18: Int = -(pow2(255) - 1 + pow2(255));
    const something19: Int = -(pow2(255) - 1 + pow2(255)) - 1;
    const something20: Int = ~5;
    // division rounds towards negative infinity, like Python's `//` operator
    const something21: Int = 1 / 5; // = 0, as one would expect
    const something22: Int = -1 / 5; // = -1, not zero as in JS/TS
    const something23: Int = 1 / -5; // = -1, not zero as in JS/TS
    const something24: Int = -1 / -5; // = 0, as one would expect
    // modulo rounds towards negative infinity too
    // the following holds: a / b * b + a % b == a, for all b != 0
    const something25: Int = 1 % 5; // = 1
    const something26: Int = -1 % 5; // = 4
    const something27: Int = 1 % -5; // = -4
    const something28: Int = -1 % -5; // = -1

    const something29: Int? = true ? 42 : null;
    const something30: Int? = false ? 42 : null;
    const something31: Int = false ? (1 / 0) : 42; // no exception, then branch is ignored

    const something32: Int = (true ? 42 : null)!!;

    const something33: map<Int, Int> = emptyMap();
    const something34: map<Int, Int> = null;

    const something35: S = S {a: false || false, b: 21 + 21};
    const something36: S = S {b: 21 + 21, a: false || false};
    const something37: T = T {
        a: pow(3, 3) + 3 * 5,
        s: S {a: true ? 1 == 1 : false, b: ton("0.000000042")}
    };

    const something38: Int = 5 & 6 | 1 << (5 + 11) * 3 % 12 >> 11; // = 4

    const something39: Bool = 42 == 43 || "foo" == "bar" || true != true ||
                              3 < 1 || 3 <= 1 || 1 < 3 || 1 <= 3 ||
                              newAddress(0, 0x606813c5f6a76175eae668630c6d8ffe229543610e3d204db245dd51f9ba0503)
                              !=
                              newAddress(0, 0x606813c5f6a76175eae668630c6d8ffe229543610e3d204db245dd51f9ba0503) ||
                              !(true && false);

    const something40: Bool = T {
        a: pow(3, 3) + 3 * 5,
        s: S {a: true ? 1 == 1 : false, b: ton("0.000000042")}
    }.s.a;

    const something41: Address = newAddress(0, 0);
    const something42: Address = newAddress(0, 0x12345);
    const something43: Address = newAddress(0, 0x123456789abcdef);
    const something44: Address = newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873);

    init() { }

    receive() { }

    get fun something1(): Int { return self.something1; }
    get fun something2(): Int? { return self.something2; }
    get fun something3(): Int { return self.something3; }
    get fun something4(): Int { return self.something4; }
    get fun something5(): String { return self.something5; }
    get fun something6(): Int { return self.something6; }
    get fun something7(): Int { return self.something7; }
    get fun something8(): Int { return self.something8; }
    get fun something9(): Address { return self.something9; }
    get fun something10(): Address { return self.something10; }
    get fun something11(): Int { return self.something11; }
    get fun something12(): Int { return self.something12; }
    get fun something13(): Int { return self.something13; }
    get fun something14(): Int { return self.something14; }
    get fun something15(): Int { return self.something15; }
    get fun something16(): Int { return self.something16; }
    get fun something17(): Int { return self.something17; }
    get fun something18(): Int { return self.something18; }
    get fun something19(): Int { return self.something19; }
    get fun something20(): Int { return self.something20; }
    get fun something21(): Int { return self.something21; }
    get fun something22(): Int { return self.something22; }
    get fun something23(): Int { return self.something23; }
    get fun something24(): Int { return self.something24; }
    get fun something25(): Int { return self.something25; }
    get fun something26(): Int { return self.something26; }
    get fun something27(): Int { return self.something27; }
    get fun something28(): Int { return self.something28; }
    get fun something29(): Int? { return self.something29; }
    get fun something30(): Int? { return self.something30; }
    get fun something31(): Int { return self.something31; }
    get fun something32(): Int { return self.something32; }
    get fun something33(): map<Int, Int> { return self.something33; }
    get fun something34(): map<Int, Int> { return self.something34; }
    get fun something35(): S { return self.something35; }
    get fun something36(): S { return self.something36; }
    get fun something37(): T { return self.something37; }
    get fun something38(): Int { return self.something38; }
    get fun something39(): Bool { return self.something39; }
    get fun something40(): Bool { return self.something40; }
    get fun something41(): Address { return self.something41; }
    get fun something42(): Address { return self.something42; }
    get fun something43(): Address { return self.something43; }
    get fun something44(): Address { return self.something44; }

    get fun globalConst1(): Int { return globalConst1; }
    get fun globalConst2(): Int { return globalConst2; }
    get fun globalConst3(): Int { return globalConst3; }
    get fun globalConst4(): Int { return globalConst4; }
    get fun globalConst5(): Int { return globalConst5; }
    get fun globalConst6(): Int { return globalConst6; }
    get fun globalConst7(): Int { return globalConst7; }
    get fun globalConst8(): Int { return globalConst8; }
    get fun globalConst9(): Int { return globalConst9; }
    get fun globalConst10(): Int { return globalConst10; }
    get fun globalConst11(): Int { return globalConst11; }
    get fun globalConst12(): Int { return globalConst12; }
    get fun globalConst13(): Int { return globalConst13; }

    get fun minInt1(): Int {
        return -115792089237316195423570985008687907853269984665640564039457584007913129639936;
    }

    get fun minInt2(): Int {
        return -(pow2(255) - 1 + pow2(255));
    }

    get fun minInt3(): Int {
        return -(pow2(255) - 1 + pow2(255)) - 1;
    }

    get fun globalConst(): Int {
        return someGlobalConst;
    }
}

## contract-methods.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/contract-methods.tact)
contract Test {
    flags: Int as uint256 = 0;
    oneMoreVar: Int = 239;
    receive() {
        self.checkImmediateReturn();
        require(self.flags == 42, "checkImmediateReturn() is mis-compiled");
        self.flags = 0;
        self.checkReturnViaLocalVar();
        require(self.flags == 42, "checkReturnViaLocalVar() is mis-compiled");
    }

    fun checkImmediateReturn(): Bool {
        return self.check();
    }
    fun checkReturnViaLocalVar(): Bool {
        let foo = self.check();
        return foo;
    }
    fun check(): Bool {
        self.flags = 42;
        return true;
    }
}



## debug.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/debug.tact)
import "@stdlib/deploy";

contract Debug with Deployable {

    init() {
        
    }

    receive("Debug") {
        dumpStack();
        dump("Hello world!");
        dump(123); // this comment is not included in the output
        dump(true); /* this comment is not included in the output */
        dump(false);
        dump(null);
        dump(myAddress());
        dump(newAddress(0, 0x83dfd552e63729b472fcbcc8c45ebcc6691702558b68ec7527e1ba403a0f31a8));
        dump(myBalance());
    }

    get fun debug() {
        dumpStack();
        dump("Hello world!");
        dump(123); // this comment is not included in the output
        dump(true); /* this comment is not included in the output */
        dump(false);
        dump(null);
        dump(myAddress());
        dump(newAddress(0, 0x83dfd552e63729b472fcbcc8c45ebcc6691702558b68ec7527e1ba403a0f31a8));
    }
}

## deep-sequence.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/deep-sequence.tact)
contract A {

    init() {

    }

    receive("Message") {
        let init: StateInit = initOf B(myAddress());
        let address: Address = contractAddress(init);
        send(SendParameters{
            value: 0, 
            to: address, 
            mode: SendRemainingValue | SendIgnoreErrors,
            bounce: true,
            code: init.code,
            data: init.data,
            body: "Message".asComment()
        });
    }

    get fun getNext(): StateInit {
        return initOf B(myAddress());
    }
}

contract B {
    parent: Address;
    init(parent: Address) {
        self.parent = parent;
    }

    receive("Message") {
        let init: StateInit = initOf C(myAddress());
        let address: Address = contractAddress(init);
        send(SendParameters{
            value: 0, 
            to: address, 
            mode: SendRemainingValue | SendIgnoreErrors,
            bounce: true,
            code: init.code,
            data: init.data,
            body: "Message".asComment()
        });
    }

    get fun getNext(): StateInit {
        return initOf C(myAddress());
    }
}

contract C {
    parent: Address;
    init(parent: Address) {
        self.parent = parent;
    }

    receive("Message") {
        let init: StateInit = initOf C(self.parent);
        let address: Address = contractAddress(init);
        send(SendParameters{
            value: 0, 
            to: address, 
            mode: SendRemainingValue | SendIgnoreErrors,
            bounce: true,
            code: init.code,
            data: init.data,
            body: "Message2".asComment()
        });
    }

    receive("Message2") {
        // Nothing to do
    }
}

## dns.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/dns.tact)
import "@stdlib/dns";
import "@stdlib/deploy";

contract DNSTester with Deployable, DNSResolver {
    /// Used for storing temporary values
    tmpC: Cell = cell("te6cckEBAQEAAgAAAEysuc0="); // empty cell

    init() {}

    get fun stringToInternal(src: String): Slice? {
        return dnsStringToInternal(src);
    }

    get fun internalNormalize(src: Slice): Slice {
        return dnsInternalNormalize(src);
    }

    get fun dnsInternalVerify(subdomain: Slice): Bool {
        return dnsInternalVerify(subdomain);
    }

    get fun dnsExtractTopDomainLength(subdomain: Slice): Int {
        return dnsExtractTopDomainLength(subdomain);
    }

    get fun dnsExtractTopDomain(subdomain: Slice): Slice {
        return dnsExtractTopDomain(subdomain);
    }

    override fun doResolveDNS(subdomain: Slice, category: Int): DNSResolveResult {
        return DNSResolveResult{ prefix: subdomain.bits(), record: beginCell().storeSlice(subdomain).endCell() };
    }

    receive("test dnsInternalNormalize throws") {
        let sliceWithRef = beginCell().storeRef(emptyCell()).asSlice();

        // Refs in the passed Slice are prohibited
        self.tmpC = dnsInternalNormalize(sliceWithRef).asCell();
    }
}


## external-fallbacks.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/external-fallbacks.tact)
message Add {
    x: Int as uint32;
}

contract ExternalFallbacksTester {
    a: Int;

    init() {
        self.a = 100;
    }

    receive() {
        // Deploy
    }

    receive(msg: Add) {
        self.a += msg.x;
    }

    external() {
        acceptMessage();
        self.a += 100;
    }

    external(msg: Add) {
        acceptMessage();
        self.a += msg.x;
    }

    get fun getA(): Int {
        return self.a;
    }
}

## getters.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/getters.tact)
import "@stdlib/deploy";

struct S {
    a: Int;
    b: Int;
}

message SetIdAndData {
    id: Int;
    data: Cell;
}

const METHOD_ID: Int = 16384;

contract Test with Deployable {
    id: Int as uint32 = 0;
    anotherData: Cell;

    init() {
        self.anotherData = beginCell().endCell();
    }

    receive(msg: SetIdAndData) {
        self.id = msg.id;
        self.anotherData = msg.data;
    }

    get fun testGetter(): Int {
        return 1;
    }

    get fun test_getter(): Int {
        return 2;
    }

    get fun Test_getter(): Int {
        return 3;
    }

    get fun contractData(): Test {
        return self;
    }

    get fun structAsInput(s: S): S {
        return s;
    }

    get fun messageAsInput1(m: SetIdAndData): Int {
        return m.id;
    }

    get fun messageAsInput2(m: SetIdAndData): SetIdAndData {
        return m;
    }

    get fun contractAsInput(test: Test): Test {
        return test;
    }

    // method ids are 19 bit signed integers
    // so we truncate the result with a (18-bit) bit mask
    get((crc32("methodId") + 42) & 0b111111111111111111) fun methodIdExpr(): Bool {
        return true;
    }
    get(METHOD_ID) fun methodIdConst(): Int {
        return METHOD_ID;
    }
    get(-pow2(18)) fun methodIdMin(): Bool {
        return true;
    }
    get(pow2(18) - 1) fun methodIdMax(): Bool {
        return true;
    }
}

## implicit-init.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/implicit-init.tact)
import "@stdlib/deploy";

contract MyContract with Deployable {
    counter: Int = 0;

    receive("increment") {
        self.counter += 1;
    }

    get fun getCounter(): Int {
        return self.counter;
    }
}

## init-of-message.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/init-of-message.tact)
message InitData {
    seller: Address;
    nonce: Int as uint64;
}

contract Test {
    seller: Address;

    init(i: InitData) {
        self.seller = i.seller;
    }

    receive() {
        // deploy
    } 
}



## init-return.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/init-return.tact)
contract Test {
    a: Int;
    
    init() {
        self.a = 123;
        return;
    }

    receive () {}

    get fun a(): Int {
        return self.a;
    }
}

## initof-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/initof-2.tact)
import "@stdlib/deploy";

message(42) Foo { }

contract TestNested with Deployable {
    init() { dump("Nested----init@SUCCESS") }
}

contract TestInit with Deployable {
    init() {
        try {
            let init: StateInit = initOf TestNested();
            dump("init@TestInit-1");
            send(SendParameters {
                to: contractAddress(init),
                value: 0,
                mode: SendIgnoreErrors | SendRemainingValue,
                code: init.code,
                data: init.data,
                body: Deploy { queryId: 0 }.toCell(),
            });
            dump("init@TestInit-SUCCESS");
        } catch (e) {
            dump("ERROR@TestInit");
            dump(e);
        }
    }

    receive(_: Foo) {}
}

## initof-3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/initof-3.tact)
contract B {
    owner: Address;
    init(addr: Address){
        self.owner = addr;
    }
}

fun get_init(addr: Address): StateInit {
    return initOf B(addr);
}

contract A {
    receive("aa") {
        let c1: StateInit = get_init(myAddress());
        dump(c1.data);
        let c2: StateInit = initOf B(myAddress());
        dump(c2.data);
    }
}


## initof.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/initof.tact)
contract Self {

    init() { }

    receive() { }

    get fun testInitOfAddress(): Address {
        return contractAddress(initOf Self());
    }

    get fun testMyAddress(): Address {
        return myAddress();
    }
}

message ChildAddress {
    address: Address;
}

contract Child {

    owner: Address;

    init(owner: Address) {
        self.owner = owner;
    }

    receive() {
        send(SendParameters {
            to: sender(),
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
            bounce: false, 
            body: ChildAddress { address: myAddress() }.toCell(),
        });
    }
}

contract Parent {

    childMyAddress: Address;

    init() {
      self.childMyAddress = myAddress();  // dummy value to be replaced by the child
    }

    receive() {
        let ci = initOf Child(myAddress());
        send(SendParameters {
            to: contractAddress(ci),
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
            bounce: false, 
            body: beginCell().endCell(),
            code: ci.code,
            data: ci.data,
        });
    }

    receive(msg: ChildAddress) {
        self.childMyAddress = msg.address;
    }

    get fun testInitOfAddressChild(): Address {
        return contractAddress(initOf Child(myAddress()));
    }

    get fun testMyAddressChild(): Address {
        return self.childMyAddress;
    }
}

## integer-literals.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/integer-literals.tact)
contract IntegerLiteralsTester {

    init() {
        
    }
    
    receive() {
        // Deploy
    }

    get fun decLiteral1(): Int {
        return 123;
    }

    get fun decLiteral2(): Int {
        return -123;
    }

    get fun decLiteral3(): Int {
        return 1_0123_00_000;
    }

    get fun hexLiteral1(): Int {
        return 0x123;
    }

    get fun hexLiteral2(): Int {
        return -0x123;
    }

    get fun hexLiteral3(): Int {
        return 0x1_0123_00_000;
    }

    get fun binLiteral1(): Int {
        return 0b101010;
    }

    get fun binLiteral2(): Int {
        return -0b101010;
    }

    get fun binLiteral3(): Int {
        return 0b1_0101_00_000;
    }

    get fun octLiteral1(): Int {
        return 0o123;
    }

    get fun octLiteral2(): Int {
        return -0o123;
    }

    get fun octLiteral3(): Int {
        return 0o1_0123_00_000;
    }
}

## intrinsics.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/intrinsics.tact)
contract IntrinsicsTester {

    a: Int = ton("10.1234");
    b: String = "Hello world";
    c: Address = address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N");
    d: Cell = cell("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw=");
    e: Int = pow(2, 9);
    f: Int = sha256("hello world");
    g: Slice = slice("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw=");
    h: Slice = rawSlice("abcdef");
    i: Int = ascii("hello world");
    j: Int = crc32("transfer(slice, int)");
    k: Int = crc32("");
    l: Int = ascii("⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡");
    m: Slice = rawSlice("");
    n: Slice = rawSlice("4a_");
    o: Slice = rawSlice("0_");
    p: Slice = rawSlice("1_");
    q: Slice = rawSlice("_");
    r: Slice = rawSlice("7");
    s: Slice = rawSlice("abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcf_");
    t: Slice = rawSlice("8a_");
    u: Slice = rawSlice("8a0_");
    w: Slice = rawSlice("8_");
    v: Slice = rawSlice("00_");

    init() {

    }

    receive("Deploy") {

    }

    get fun getTons(): Int {
        return ton("10.1234");
    }

    get fun getTons2(): Int {
        return self.a;
    }

    get fun getString(): String {
        return "Hello world";
    }

    get fun getString2(): String {
        return self.b;
    }

    get fun getAddress(): Address {
        return address("EQCD39VS5jcptHL8vMjEXrzGaRcCVYto7HUn4bpAOg8xqB2N");
    }

    get fun getAddress2(): Address {
        return self.c;
    }

    get fun getCell(): Cell {
        return cell("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw=");
    }

    get fun getCell2(): Cell {
        return self.d;
    }

    get fun getPow(): Int {
        return pow(2, 9);
    }

    get fun getPow2(): Int {
        return self.e;
    }

    get fun getComment(): Cell {
        return "Hello world".asComment();
    }

    get fun getHash(): Int {
        return sha256("hello world");
    }

    get fun getHash2(): Int {
        return self.f;
    }

    get fun getHash3(src: Slice): Int {
        return sha256(src);
    }

    get fun getHash4(src: String): Int {
        return sha256(src);
    }

    get fun getHashLongComptime(): Int {
        return sha256("------------------------------------------------------------------------------------------------------------------------------129");
    }

    get fun getHashLongRuntime(src: String): Int {
        return sha256(src);
    }

    receive("emit_1") {
        emit("Hello world".asComment());
    }

    get fun getSlice(): Slice {
        return slice("te6cckEBAQEADgAAGEhlbGxvIHdvcmxkIXgtxbw=");
    }

    get fun getSlice2(): Slice {
        return self.g;
    }

    get fun getRawSlice(): Slice {
        return rawSlice("abcdef");
    }

    get fun getRawSlice2(): Slice {
        return self.h;
    }

    get fun getRawSlice3(): Slice {
        return rawSlice("");
    }

    get fun getRawSlice4(): Slice {
        return self.m;
    }

    get fun getAscii(): Int {
        return ascii("hello world");
    }

    get fun getAscii2(): Int {
        return self.i;
    }

    get fun getAscii3(): Int {
        return ascii("⚡⚡⚡⚡⚡⚡⚡⚡⚡⚡");
    }

    get fun getAscii4(): Int {
        return self.l;
    }

    get fun getCrc32(): Int {
        return crc32("transfer(slice, int)");
    }

    get fun getCrc32_2(): Int {
        return self.j;
    }

    get fun getCrc32_3(): Int {
        return self.k;
    }

    get fun getCrc32_4(): Int {
        return crc32("");
    }

    get fun getRawSlice5(): Slice {
        return rawSlice("4a_");
    }

    get fun getRawSlice6(): Slice {
        return self.n;
    }

    get fun getRawSlice7(): Slice {
        return rawSlice("0_");
    }

    get fun getRawSlice8(): Slice {
        return self.o;
    }

    get fun getRawSlice9(): Slice {
        return rawSlice("1_");
    }

    get fun getRawSlice10(): Slice {
        return self.p;
    }

    get fun getRawSlice11(): Slice {
        return rawSlice("_");
    }

    get fun getRawSlice12(): Slice {
        return self.q;
    }

    get fun getRawSlice13(): Slice {
        return rawSlice("7");
    }

    get fun getRawSlice14(): Slice {
        return self.r;
    }

    get fun getRawSlice15(): Slice {
        return rawSlice("abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcf_");
    }

    get fun getRawSlice16(): Slice {
        return self.s;
    }

    get fun getRawSlice17(): Slice {
        return rawSlice("8a_");
    }

    get fun getRawSlice18(): Slice {
        return self.t;
    }

    get fun getRawSlice19(): Slice {
        return rawSlice("8a0_");
    }

    get fun getRawSlice20(): Slice {
        return self.u;
    }

    get fun getRawSlice21(): Slice {
        return rawSlice("8_");
    }

    get fun getRawSlice22(): Slice {
        return self.w;
    }

    get fun getRawSlice23(): Slice {
        return rawSlice("00_");
    }

    get fun getRawSlice24(): Slice {
        return self.v;
    }
}


## local-type-inference.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/local-type-inference.tact)
import "@stdlib/deploy";

struct MyStruct {
    x: Int;
    y: Int;
}

contract LocalTypeInferenceTester with Deployable {
    get fun test1(): Int {
        let x = 1;
        return x;
    }

    get fun test2(): Int {
        let x = 1;
        let y = x + 1;
        return y;
    }

    get fun test3(): Address {
        let x = myAddress();
        return x;
    }

    get fun test4(): Address {
        let x = myAddress();
        let y = x;
        return y;
    }

    get fun test5(): Bool {
        let x: Int = 123;
        let y = x == 123;
        return y;
    }

    get fun test6(): Slice {
        let x = beginCell().storeUint(123, 64).endCell().asSlice();
        return x;
    }

    get fun test7(): Cell {
        let x = beginCell().storeUint(123, 64).endCell();
        return x;
    }

    get fun test8(): Builder {
        let x = beginCell().storeUint(123, 64);
        return x;
    }

    get fun test9(): String {
        let x = beginString().concat("hello").toString();
        return x;
    }

    get fun test10(): String {
        let x = beginString();
        let y = x.concat("hello").toString();
        return y;
    }

    get fun test11(): StateInit {
        let x = initOf LocalTypeInferenceTester();
        return x;
    }

    get fun test12(): map<Int, Int> {
        let x: map<Int, Int> = emptyMap();
        let y = x;
        return y;
    }

    get fun test13(): map<Int, Int as uint32> {
        let x: map<Int, Int as uint32> = emptyMap();
        let y = x;
        return y;
    }

    get fun test14(): MyStruct {
        let x = MyStruct{ x: 1, y: 2 };
        return x;
    }

    get fun test15(): MyStruct {
        let x = MyStruct{ x: 1, y: 2 };
        let y = x;
        return y;
    }

    get fun test16(): Int? {
        let m: map<Int, Int> = emptyMap();
        let x = m.get(1);
        return x;
    }

    get fun test17(): Int? {
        let m: map<Int, Int> = emptyMap();
        let x = m.get(1);
        let y = x;
        return y;
    }

    get fun test18(): Int? {
        let m: map<Int, Int> = emptyMap();
        m.set(1, 2);
        let x = m.get(1);
        return x;
    }

    get fun test19(): Int? {
        let x: Int? = null;
        let y = x;
        return y;
    }
}

## map-comparison.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/map-comparison.tact)
message Compare {
    m1: map<Int as uint8, Bool>;
    m2: map<Int as uint8, Bool>;
}

message CompareDeep {
    m1: map<Int as uint8, Bool>;
    m2: map<Int as uint8, Bool>;
}

contract MapComparisonTestContract {
    receive() {}

    receive(msg: Compare) {
        require(msg.m1 == msg.m2, "Maps are not equal");
    }

    receive(msg: CompareDeep) {
        require(msg.m1.deepEquals(msg.m2), "Maps are not equal");
    }
    
    get fun compareIntInt(m1: map<Int, Int>, m2: map<Int, Int>): Bool {
        return m1.deepEquals(m2);
    }

    get fun compareIntCell(m1: map<Int, Cell>, m2: map<Int, Cell>): Bool {
        return m1.deepEquals(m2);
    }
    
    get fun compareIntAddress(m1: map<Int, Address>, m2: map<Int, Address>): Bool {
        return m1.deepEquals(m2);
    }

    get fun compareAddressInt(m1: map<Address, Int>, m2: map<Address, Int>): Bool {
        return m1.deepEquals(m2);
    }

    get fun compareAddressCell(m1: map<Address, Cell>, m2: map<Address, Cell>): Bool {
        return m1.deepEquals(m2);
    }

    get fun compareAddressAddress(m1: map<Address, Address>, m2: map<Address, Address>): Bool {
        return m1.deepEquals(m2);
    }
}

## map-traverse.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/map-traverse.tact)
struct MyStruct {
    a: Int;
    b: Bool;
}

struct MyStructWithMap {
    m: map<Int, Int>;
}

contract MapTraverseTestContract {
    m: map<Int, Int>;
    s: MyStructWithMap;

    init() {
        self.m = emptyMap();
        self.m.set(1, 100);
        self.m.set(2, 200);
        self.m.set(3, 300);

        self.s = MyStructWithMap{m: self.m};
    }

    receive() {
        // Nothing to do
    }

    get fun test_int_int(): Int {
        let m: map<Int, Int> = emptyMap();
        m.set(1, 100);
        m.set(2, 200);
        m.set(3, 300);
        m.set(4, 400);

        let sum1: Int = 0;
        let sum2: Int = 0;
        foreach (k, v in m) {
            sum1 += k;
            sum2 += v;
        }

        return sum1 + sum2;
    }

    get fun test_int_bool(): Int {
        let m: map<Int, Bool> = emptyMap();
        m.set(1, true);
        m.set(2, false);
        m.set(3, true);
        m.set(4, false);

        let sum11: Int = 0;
        let sum12: Int = 0;
        let sum21: Int = 0;
        foreach (k, v in m) {
            if (v) {
                sum11 += k;
                sum12 += 1;
            } else {
                sum21 += k;
            }
        }

        return sum11 + sum12 + sum21;
    }

    get fun test_int_cell(): Int {
        let m: map<Int, Cell> = emptyMap();
        m.set(1, beginCell().storeUint(100, 16).endCell());
        m.set(2, beginCell().storeUint(200, 16).endCell());
        m.set(3, beginCell().storeUint(300, 16).endCell());
        m.set(4, beginCell().storeUint(400, 16).endCell());

        let sum1: Int = 0;
        let sum2: Int = 0;
        foreach (k, v in m) {
            let s: Slice = v.beginParse();
            sum1 += k;
            sum2 += s.loadUint(16);
        }

        return sum1 + sum2;
    }

    get fun test_int_address(): Int {
        let m: map<Int, Address> = emptyMap();
        m.set(1, newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873));
        m.set(2, newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76874));
        m.set(3, newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76875));
        m.set(4, newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76876));

        let sum1: Int = 0;
        let sum2: Int = 0;
        foreach (k, v in m) {
            let s: Slice = beginCell().storeAddress(v).endCell().beginParse();
            s.skipBits(264);
            sum1 += k;
            sum2 += s.loadUint(3);
        }

        return sum1 + sum2;
    }

    get fun test_int_struct(): Int {
        let m: map<Int, MyStruct> = emptyMap();
        m.set(1, MyStruct{a: 100, b: true});
        m.set(2, MyStruct{a: 200, b: false});
        m.set(3, MyStruct{a: 300, b: true});
        m.set(4, MyStruct{a: 400, b: false});

        let sum11: Int = 0;
        let sum12: Int = 0;
        let sum21: Int = 0;
        let sum22: Int = 0;
        foreach (k, v in m) {
            if (v.b) {
                sum11 += k;
                sum12 += v.a;
            } else {
                sum21 += k;
                sum22 += v.a;
            }
        }

        return sum11 + sum12 + sum21 + sum22;
    }

    get fun test_address_int(): Int {
        let m: map<Address, Int> = emptyMap();
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873), 100);
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76874), 200);
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76875), 300);
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76876), 400);

        let sum1: Int = 0;
        let sum2: Int = 0;
        foreach (k, v in m) {
            let s: Slice = beginCell().storeAddress(k).endCell().beginParse();
            s.skipBits(264);
            sum1 += s.loadUint(3);
            sum2 += v;
        }
        
        return sum1 + sum2;
    }

    get fun test_address_bool(): Int {
        let m: map<Address, Bool> = emptyMap();
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873), true);
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76874), false);
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76875), true);
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76876), false);

        let sum11: Int = 0;
        let sum12: Int = 0;
        let sum21: Int = 0;
        foreach (k, v in m) {
            let s: Slice = beginCell().storeAddress(k).endCell().beginParse();
            s.skipBits(264);
            if (v) {
                sum11 += s.loadUint(3);
                sum12 += 1;
            } else {
                sum21 += s.loadUint(3);
            }
        }

        return sum11 + sum12 + sum21;
    }

    get fun test_address_cell(): Int {
        let m: map<Address, Cell> = emptyMap();
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873), beginCell().storeUint(100, 16).endCell());
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76874), beginCell().storeUint(200, 16).endCell());
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76875), beginCell().storeUint(300, 16).endCell());
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76876), beginCell().storeUint(400, 16).endCell());

        let sum1: Int = 0;
        let sum2: Int = 0;
        foreach (k, v in m) {
            let s: Slice = beginCell().storeAddress(k).endCell().beginParse();
            s.skipBits(264);
            sum1 += s.loadUint(3);
            let vs: Slice = v.beginParse();
            sum2 += vs.loadUint(16);
        }

        return sum1 + sum2;
    }

    get fun test_address_address(): Int {
        let m: map<Address, Address> = emptyMap();
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873), newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76874));
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76875), newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76876));
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76877), newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76878));
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76879), newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76880));

        let sum1: Int = 0;
        let sum2: Int = 0;
        foreach (k, v in m) {
            let s1: Slice = beginCell().storeAddress(k).endCell().beginParse();
            s1.skipBits(264);
            sum1 += s1.loadUint(3);
            let s2: Slice = beginCell().storeAddress(v).endCell().beginParse();
            s2.skipBits(264);
            sum2 += s2.loadUint(3);
        }

        return sum1 + sum2;
    }

    get fun test_address_struct(): Int {
        let m: map<Address, MyStruct> = emptyMap();
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76873), MyStruct{a: 100, b: true});
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76874), MyStruct{a: 200, b: false});
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76875), MyStruct{a: 300, b: true});
        m.set(newAddress(0, 0x4a81708d2cf7b15a1b362fbf64880451d698461f52f05f145b36c08517d76876), MyStruct{a: 400, b: false});

        let sum11: Int = 0;
        let sum12: Int = 0;
        let sum21: Int = 0;
        let sum22: Int = 0;
        foreach (k, v in m) {
            let s: Slice = beginCell().storeAddress(k).endCell().beginParse();
            s.skipBits(264);
            if (v.b) {
                sum11 += s.loadUint(3);
                sum12 += v.a;
            } else {
                sum21 += s.loadUint(3);
                sum22 += v.a;
            }
        }

        return sum11 + sum12 + sum21 + sum22;
    }

    get fun test_empty_map(): Int {
        let m: map<Int, Int> = emptyMap();
        let sum: Int = 0;
        foreach (k, v in m) {
            return 42;
        }
        return sum;
    }

    get fun test_null(): Int {
        let m: map<Int, Int> = null;
        let sum: Int = 0;
        foreach (k, v in m) {
            return 42;
        }
        return sum;
    }

    get fun test_map_modification_during_traversal1(): Int {
        let m: map<Int, Int> = emptyMap();
        m.set(1, 100);
        m.set(2, 200);
        m.set(3, 300);
        m.set(4, 400);
        let sum: Int = 0;
        foreach (k, v in m) {
            m.del(2);
            sum += k + v;
        }
        return sum;
    }

    // out of gas: always inserts a new key during traversal
    get fun test_map_modification_during_traversal2() {
        let m: map<Int, Int> = emptyMap();
        m.set(1, 100);
        let sum: Int = 0;
        foreach (k, v in m) {
            m.set(k + 1, v + 1);
        }
    }

    // map size: we actually cannot express this as a user-defined function
    // because we don't have bounded polymorphism in the language
    get fun test_map_size(): Int {
        let m: map<Int, Int> = emptyMap();
        m.set(1, 100);
        m.set(2, 200);
        m.set(3, 300);
        m.set(4, 400);
        let size: Int = 0;
        foreach (k, v in m) {
            size += 1;
        }
        return size;
    }

    get fun test_map_as_field(): Int {
        let sum: Int = 0;
        foreach (k, v in self.m) {
            sum += k + v;
        }
        return sum;
    }

    get fun test_map_as_struct_field(): Int {
        let sum: Int = 0;
        foreach (k, v in self.s.m) {
            sum += k + v;
        }
        return sum;
    }
}

## maps.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/maps.tact)
// struct with over 1023 bits so that it is serialized as multiple cells
struct SomeStruct {
    int: Int;
    bool: Bool;
    address: Address;
    a: Int;
    b: Int;
}

// ===============================
// Structs For Getters
// ===============================

struct GetAllMapsResult {
    // Integer Key Maps
    int_int: Int?;
    int_int8: Int?;
    int_int42: Int?;
    int_int256: Int?;
    int_uint8: Int?;
    int_uint42: Int?;
    int_uint256: Int?;
    int_coins: Int?;
    int_bool: Bool?;
    int_cell: Cell?;
    int_address: Address?;
    int_struct: SomeStruct?;

    int8_int: Int?;
    int8_int8: Int?;
    int8_int42: Int?;
    int8_int256: Int?;
    int8_uint8: Int?;
    int8_uint42: Int?;
    int8_uint256: Int?;
    int8_coins: Int?;
    int8_bool: Bool?;
    int8_cell: Cell?;
    int8_address: Address?;
    int8_struct: SomeStruct?;

    int42_int: Int?;
    int42_int8: Int?;
    int42_int42: Int?;
    int42_int256: Int?;
    int42_uint8: Int?;
    int42_uint42: Int?;
    int42_uint256: Int?;
    int42_coins: Int?;
    int42_bool: Bool?;
    int42_cell: Cell?;
    int42_address: Address?;
    int42_struct: SomeStruct?;

    int256_int: Int?;
    int256_int8: Int?;
    int256_int42: Int?;
    int256_int256: Int?;
    int256_uint8: Int?;
    int256_uint42: Int?;
    int256_uint256: Int?;
    int256_coins: Int?;
    int256_bool: Bool?;
    int256_cell: Cell?;
    int256_address: Address?;
    int256_struct: SomeStruct?;

    uint8_int: Int?;
    uint8_int8: Int?;
    uint8_int42: Int?;
    uint8_int256: Int?;
    uint8_uint8: Int?;
    uint8_uint42: Int?;
    uint8_uint256: Int?;
    uint8_coins: Int?;
    uint8_bool: Bool?;
    uint8_cell: Cell?;
    uint8_address: Address?;
    uint8_struct: SomeStruct?;

    uint42_int: Int?;
    uint42_int8: Int?;
    uint42_int42: Int?;
    uint42_int256: Int?;
    uint42_uint8: Int?;
    uint42_uint42: Int?;
    uint42_uint256: Int?;
    uint42_coins: Int?;
    uint42_bool: Bool?;
    uint42_cell: Cell?;
    uint42_address: Address?;
    uint42_struct: SomeStruct?;

    uint256_int: Int?;
    uint256_int8: Int?;
    uint256_int42: Int?;
    uint256_int256: Int?;
    uint256_uint8: Int?;
    uint256_uint42: Int?;
    uint256_uint256: Int?;
    uint256_coins: Int?;
    uint256_bool: Bool?;
    uint256_cell: Cell?;
    uint256_address: Address?;
    uint256_struct: SomeStruct?;

    // Address Key Maps
    address_int: Int?;
    address_int8: Int?;
    address_int42: Int?;
    address_int256: Int?;
    address_uint8: Int?;
    address_uint42: Int?;
    address_uint256: Int?;
    address_coins: Int?;
    address_bool: Bool?;
    address_cell: Cell?;
    address_address: Address?;
    address_struct: SomeStruct?;
}

struct ReplaceAllMapsResult {
    // Integer Key Maps
    int_int: Bool;
    int_int8: Bool;
    int_int42: Bool;
    int_int256: Bool;
    int_uint8: Bool;
    int_uint42: Bool;
    int_uint256: Bool;
    int_coins: Bool;
    int_bool: Bool;
    int_cell: Bool;
    int_address: Bool;
    int_struct: Bool;

    int8_int: Bool;
    int8_int8: Bool;
    int8_int42: Bool;
    int8_int256: Bool;
    int8_uint8: Bool;
    int8_uint42: Bool;
    int8_uint256: Bool;
    int8_coins: Bool;
    int8_bool: Bool;
    int8_cell: Bool;
    int8_address: Bool;
    int8_struct: Bool;

    int42_int: Bool;
    int42_int8: Bool;
    int42_int42: Bool;
    int42_int256: Bool;
    int42_uint8: Bool;
    int42_uint42: Bool;
    int42_uint256: Bool;
    int42_coins: Bool;
    int42_bool: Bool;
    int42_cell: Bool;
    int42_address: Bool;
    int42_struct: Bool;

    int256_int: Bool;
    int256_int8: Bool;
    int256_int42: Bool;
    int256_int256: Bool;
    int256_uint8: Bool;
    int256_uint42: Bool;
    int256_uint256: Bool;
    int256_coins: Bool;
    int256_bool: Bool;
    int256_cell: Bool;
    int256_address: Bool;
    int256_struct: Bool;

    uint8_int: Bool;
    uint8_int8: Bool;
    uint8_int42: Bool;
    uint8_int256: Bool;
    uint8_uint8: Bool;
    uint8_uint42: Bool;
    uint8_uint256: Bool;
    uint8_coins: Bool;
    uint8_bool: Bool;
    uint8_cell: Bool;
    uint8_address: Bool;
    uint8_struct: Bool;

    uint42_int: Bool;
    uint42_int8: Bool;
    uint42_int42: Bool;
    uint42_int256: Bool;
    uint42_uint8: Bool;
    uint42_uint42: Bool;
    uint42_uint256: Bool;
    uint42_coins: Bool;
    uint42_bool: Bool;
    uint42_cell: Bool;
    uint42_address: Bool;
    uint42_struct: Bool;

    uint256_int: Bool;
    uint256_int8: Bool;
    uint256_int42: Bool;
    uint256_int256: Bool;
    uint256_uint8: Bool;
    uint256_uint42: Bool;
    uint256_uint256: Bool;
    uint256_coins: Bool;
    uint256_bool: Bool;
    uint256_cell: Bool;
    uint256_address: Bool;
    uint256_struct: Bool;

    // Address Key Maps
    address_int: Bool;
    address_int8: Bool;
    address_int42: Bool;
    address_int256: Bool;
    address_uint8: Bool;
    address_uint42: Bool;
    address_uint256: Bool;
    address_coins: Bool;
    address_bool: Bool;
    address_cell: Bool;
    address_address: Bool;
    address_struct: Bool;
}

struct ReplaceGetAllMapsResult {
    // Integer Key Maps
    int_int: Int?;
    int_int8: Int?;
    int_int42: Int?;
    int_int256: Int?;
    int_uint8: Int?;
    int_uint42: Int?;
    int_uint256: Int?;
    int_coins: Int?;
    int_bool: Bool?;
    int_cell: Cell?;
    int_address: Address?;
    int_struct: SomeStruct?;

    int8_int: Int?;
    int8_int8: Int?;
    int8_int42: Int?;
    int8_int256: Int?;
    int8_uint8: Int?;
    int8_uint42: Int?;
    int8_uint256: Int?;
    int8_coins: Int?;
    int8_bool: Bool?;
    int8_cell: Cell?;
    int8_address: Address?;
    int8_struct: SomeStruct?;

    int42_int: Int?;
    int42_int8: Int?;
    int42_int42: Int?;
    int42_int256: Int?;
    int42_uint8: Int?;
    int42_uint42: Int?;
    int42_uint256: Int?;
    int42_coins: Int?;
    int42_bool: Bool?;
    int42_cell: Cell?;
    int42_address: Address?;
    int42_struct: SomeStruct?;

    int256_int: Int?;
    int256_int8: Int?;
    int256_int42: Int?;
    int256_int256: Int?;
    int256_uint8: Int?;
    int256_uint42: Int?;
    int256_uint256: Int?;
    int256_coins: Int?;
    int256_bool: Bool?;
    int256_cell: Cell?;
    int256_address: Address?;
    int256_struct: SomeStruct?;

    uint8_int: Int?;
    uint8_int8: Int?;
    uint8_int42: Int?;
    uint8_int256: Int?;
    uint8_uint8: Int?;
    uint8_uint42: Int?;
    uint8_uint256: Int?;
    uint8_coins: Int?;
    uint8_bool: Bool?;
    uint8_cell: Cell?;
    uint8_address: Address?;
    uint8_struct: SomeStruct?;

    uint42_int: Int?;
    uint42_int8: Int?;
    uint42_int42: Int?;
    uint42_int256: Int?;
    uint42_uint8: Int?;
    uint42_uint42: Int?;
    uint42_uint256: Int?;
    uint42_coins: Int?;
    uint42_bool: Bool?;
    uint42_cell: Cell?;
    uint42_address: Address?;
    uint42_struct: SomeStruct?;

    uint256_int: Int?;
    uint256_int8: Int?;
    uint256_int42: Int?;
    uint256_int256: Int?;
    uint256_uint8: Int?;
    uint256_uint42: Int?;
    uint256_uint256: Int?;
    uint256_coins: Int?;
    uint256_bool: Bool?;
    uint256_cell: Cell?;
    uint256_address: Address?;
    uint256_struct: SomeStruct?;

    // Address Key Maps
    address_int: Int?;
    address_int8: Int?;
    address_int42: Int?;
    address_int256: Int?;
    address_uint8: Int?;
    address_uint42: Int?;
    address_uint256: Int?;
    address_coins: Int?;
    address_bool: Bool?;
    address_cell: Cell?;
    address_address: Address?;
    address_struct: SomeStruct?;
}

struct ExistsAllMapsResult {
    // Integer Key Maps
    int_int: Bool;
    int_int8: Bool;
    int_int42: Bool;
    int_int256: Bool;
    int_uint8: Bool;
    int_uint42: Bool;
    int_uint256: Bool;
    int_coins: Bool;
    int_bool: Bool;
    int_cell: Bool;
    int_address: Bool;
    int_struct: Bool;

    int8_int: Bool;
    int8_int8: Bool;
    int8_int42: Bool;
    int8_int256: Bool;
    int8_uint8: Bool;
    int8_uint42: Bool;
    int8_uint256: Bool;
    int8_coins: Bool;
    int8_bool: Bool;
    int8_cell: Bool;
    int8_address: Bool;
    int8_struct: Bool;

    int42_int: Bool;
    int42_int8: Bool;
    int42_int42: Bool;
    int42_int256: Bool;
    int42_uint8: Bool;
    int42_uint42: Bool;
    int42_uint256: Bool;
    int42_coins: Bool;
    int42_bool: Bool;
    int42_cell: Bool;
    int42_address: Bool;
    int42_struct: Bool;

    int256_int: Bool;
    int256_int8: Bool;
    int256_int42: Bool;
    int256_int256: Bool;
    int256_uint8: Bool;
    int256_uint42: Bool;
    int256_uint256: Bool;
    int256_coins: Bool;
    int256_bool: Bool;
    int256_cell: Bool;
    int256_address: Bool;
    int256_struct: Bool;

    uint8_int: Bool;
    uint8_int8: Bool;
    uint8_int42: Bool;
    uint8_int256: Bool;
    uint8_uint8: Bool;
    uint8_uint42: Bool;
    uint8_uint256: Bool;
    uint8_coins: Bool;
    uint8_bool: Bool;
    uint8_cell: Bool;
    uint8_address: Bool;
    uint8_struct: Bool;

    uint42_int: Bool;
    uint42_int8: Bool;
    uint42_int42: Bool;
    uint42_int256: Bool;
    uint42_uint8: Bool;
    uint42_uint42: Bool;
    uint42_uint256: Bool;
    uint42_coins: Bool;
    uint42_bool: Bool;
    uint42_cell: Bool;
    uint42_address: Bool;
    uint42_struct: Bool;

    uint256_int: Bool;
    uint256_int8: Bool;
    uint256_int42: Bool;
    uint256_int256: Bool;
    uint256_uint8: Bool;
    uint256_uint42: Bool;
    uint256_uint256: Bool;
    uint256_coins: Bool;
    uint256_bool: Bool;
    uint256_cell: Bool;
    uint256_address: Bool;
    uint256_struct: Bool;

    // Address Key Maps
    address_int: Bool;
    address_int8: Bool;
    address_int42: Bool;
    address_int256: Bool;
    address_uint8: Bool;
    address_uint42: Bool;
    address_uint256: Bool;
    address_coins: Bool;
    address_bool: Bool;
    address_cell: Bool;
    address_address: Bool;
    address_struct: Bool;
}

struct IsEmptyAllMapsResult {
    // Integer Key Maps
    int_int: Bool;
    int_int8: Bool;
    int_int42: Bool;
    int_int256: Bool;
    int_uint8: Bool;
    int_uint42: Bool;
    int_uint256: Bool;
    int_coins: Bool;
    int_bool: Bool;
    int_cell: Bool;
    int_address: Bool;
    int_struct: Bool;

    int8_int: Bool;
    int8_int8: Bool;
    int8_int42: Bool;
    int8_int256: Bool;
    int8_uint8: Bool;
    int8_uint42: Bool;
    int8_uint256: Bool;
    int8_coins: Bool;
    int8_bool: Bool;
    int8_cell: Bool;
    int8_address: Bool;
    int8_struct: Bool;

    int42_int: Bool;
    int42_int8: Bool;
    int42_int42: Bool;
    int42_int256: Bool;
    int42_uint8: Bool;
    int42_uint42: Bool;
    int42_uint256: Bool;
    int42_coins: Bool;
    int42_bool: Bool;
    int42_cell: Bool;
    int42_address: Bool;
    int42_struct: Bool;

    int256_int: Bool;
    int256_int8: Bool;
    int256_int42: Bool;
    int256_int256: Bool;
    int256_uint8: Bool;
    int256_uint42: Bool;
    int256_uint256: Bool;
    int256_coins: Bool;
    int256_bool: Bool;
    int256_cell: Bool;
    int256_address: Bool;
    int256_struct: Bool;

    uint8_int: Bool;
    uint8_int8: Bool;
    uint8_int42: Bool;
    uint8_int256: Bool;
    uint8_uint8: Bool;
    uint8_uint42: Bool;
    uint8_uint256: Bool;
    uint8_coins: Bool;
    uint8_bool: Bool;
    uint8_cell: Bool;
    uint8_address: Bool;
    uint8_struct: Bool;

    uint42_int: Bool;
    uint42_int8: Bool;
    uint42_int42: Bool;
    uint42_int256: Bool;
    uint42_uint8: Bool;
    uint42_uint42: Bool;
    uint42_uint256: Bool;
    uint42_coins: Bool;
    uint42_bool: Bool;
    uint42_cell: Bool;
    uint42_address: Bool;
    uint42_struct: Bool;

    uint256_int: Bool;
    uint256_int8: Bool;
    uint256_int42: Bool;
    uint256_int256: Bool;
    uint256_uint8: Bool;
    uint256_uint42: Bool;
    uint256_uint256: Bool;
    uint256_coins: Bool;
    uint256_bool: Bool;
    uint256_cell: Bool;
    uint256_address: Bool;
    uint256_struct: Bool;

    // Address Key Maps
    address_int: Bool;
    address_int8: Bool;
    address_int42: Bool;
    address_int256: Bool;
    address_uint8: Bool;
    address_uint42: Bool;
    address_uint256: Bool;
    address_coins: Bool;
    address_bool: Bool;
    address_cell: Bool;
    address_address: Bool;
    address_struct: Bool;
}

struct AsCellAllMapsResult {
    // Integer Key Maps
    int_int: Cell?;
    int_int8: Cell?;
    int_int42: Cell?;
    int_int256: Cell?;
    int_uint8: Cell?;
    int_uint42: Cell?;
    int_uint256: Cell?;
    int_coins: Cell?;
    int_bool: Cell?;
    int_cell: Cell?;
    int_address: Cell?;
    int_struct: Cell?;

    int8_int: Cell?;
    int8_int8: Cell?;
    int8_int42: Cell?;
    int8_int256: Cell?;
    int8_uint8: Cell?;
    int8_uint42: Cell?;
    int8_uint256: Cell?;
    int8_coins: Cell?;
    int8_bool: Cell?;
    int8_cell: Cell?;
    int8_address: Cell?;
    int8_struct: Cell?;

    int42_int: Cell?;
    int42_int8: Cell?;
    int42_int42: Cell?;
    int42_int256: Cell?;
    int42_uint8: Cell?;
    int42_uint42: Cell?;
    int42_uint256: Cell?;
    int42_coins: Cell?;
    int42_bool: Cell?;
    int42_cell: Cell?;
    int42_address: Cell?;
    int42_struct: Cell?;

    int256_int: Cell?;
    int256_int8: Cell?;
    int256_int42: Cell?;
    int256_int256: Cell?;
    int256_uint8: Cell?;
    int256_uint42: Cell?;
    int256_uint256: Cell?;
    int256_coins: Cell?;
    int256_bool: Cell?;
    int256_cell: Cell?;
    int256_address: Cell?;
    int256_struct: Cell?;

    uint8_int: Cell?;
    uint8_int8: Cell?;
    uint8_int42: Cell?;
    uint8_int256: Cell?;
    uint8_uint8: Cell?;
    uint8_uint42: Cell?;
    uint8_uint256: Cell?;
    uint8_coins: Cell?;
    uint8_bool: Cell?;
    uint8_cell: Cell?;
    uint8_address: Cell?;
    uint8_struct: Cell?;

    uint42_int: Cell?;
    uint42_int8: Cell?;
    uint42_int42: Cell?;
    uint42_int256: Cell?;
    uint42_uint8: Cell?;
    uint42_uint42: Cell?;
    uint42_uint256: Cell?;
    uint42_coins: Cell?;
    uint42_bool: Cell?;
    uint42_cell: Cell?;
    uint42_address: Cell?;
    uint42_struct: Cell?;

    uint256_int: Cell?;
    uint256_int8: Cell?;
    uint256_int42: Cell?;
    uint256_int256: Cell?;
    uint256_uint8: Cell?;
    uint256_uint42: Cell?;
    uint256_uint256: Cell?;
    uint256_coins: Cell?;
    uint256_bool: Cell?;
    uint256_cell: Cell?;
    uint256_address: Cell?;
    uint256_struct: Cell?;

    // Address Key Maps
    address_int: Cell?;
    address_int8: Cell?;
    address_int42: Cell?;
    address_int256: Cell?;
    address_uint8: Cell?;
    address_uint42: Cell?;
    address_uint256: Cell?;
    address_coins: Cell?;
    address_bool: Cell?;
    address_cell: Cell?;
    address_address: Cell?;
    address_struct: Cell?;
}

// ===============================
// Messages For Operations
// ===============================

message SetAllMaps {
    // Key fields
    keyInt: Int;
    keyInt8: Int;
    keyInt42: Int;
    keyInt256: Int;
    keyUint8: Int;
    keyUint42: Int;
    keyUint256: Int;
    keyAddress: Address;

    // Value fields
    valueInt: Int?;
    valueInt8: Int?;
    valueInt42: Int?;
    valueInt256: Int?;
    valueUint8: Int?;
    valueUint42: Int?;
    valueUint256: Int?;
    valueCoins: Int?;
    valueBool: Bool?;
    valueCell: Cell?;
    valueAddress: Address?;
    valueStruct: SomeStruct?;
}

message DelAllMaps {
    // Key fields
    keyInt: Int;
    keyInt8: Int;
    keyInt42: Int;
    keyInt256: Int;
    keyUint8: Int;
    keyUint42: Int;
    keyUint256: Int;
    keyAddress: Address;
}

message ReplaceAllMaps {
    // Key fields
    keyInt: Int;
    keyInt8: Int;
    keyInt42: Int;
    keyInt256: Int;
    keyUint8: Int;
    keyUint42: Int;
    keyUint256: Int;
    keyAddress: Address;

    // Value fields
    valueInt: Int?;
    valueInt8: Int?;
    valueInt42: Int?;
    valueInt256: Int?;
    valueUint8: Int?;
    valueUint42: Int?;
    valueUint256: Int?;
    valueCoins: Int?;
    valueBool: Bool?;
    valueCell: Cell?;
    valueAddress: Address?;
    valueStruct: SomeStruct?;
}

message ReplaceGetAllMaps {
    // Key fields
    keyInt: Int;
    keyInt8: Int;
    keyInt42: Int;
    keyInt256: Int;
    keyUint8: Int;
    keyUint42: Int;
    keyUint256: Int;
    keyAddress: Address;

    // Value fields
    valueInt: Int?;
    valueInt8: Int?;
    valueInt42: Int?;
    valueInt256: Int?;
    valueUint8: Int?;
    valueUint42: Int?;
    valueUint256: Int?;
    valueCoins: Int?;
    valueBool: Bool?;
    valueCell: Cell?;
    valueAddress: Address?;
    valueStruct: SomeStruct?;
}

message CheckNullReference {
    
}

// ===============================
// Test Contract
// ===============================

contract MapTestContract {
    receive() {}

    // ===============================
    // Integer (`Int`) Key Maps
    // ===============================

    int_int: map<Int, Int>;
    int_int8: map<Int, Int as int8>;
    int_int42: map<Int, Int as int42>;
    int_int256: map<Int, Int as int256>;
    int_uint8: map<Int, Int as uint8>;
    int_uint42: map<Int, Int as uint42>;
    int_uint256: map<Int, Int as uint256>;
    int_coins: map<Int, Int as coins>;
    int_bool: map<Int, Bool>;
    int_cell: map<Int, Cell>;
    int_address: map<Int, Address>;
    int_struct: map<Int, SomeStruct>;

    // ===============================
    // Integer (`Int as int8`) Key Maps
    // ===============================

    int8_int: map<Int as int8, Int>;
    int8_int8: map<Int as int8, Int as int8>;
    int8_int42: map<Int as int8, Int as int42>;
    int8_int256: map<Int as int8, Int as int256>;
    int8_uint8: map<Int as int8, Int as uint8>;
    int8_uint42: map<Int as int8, Int as uint42>;
    int8_uint256: map<Int as int8, Int as uint256>;
    int8_coins: map<Int as int8, Int as coins>;
    int8_bool: map<Int as int8, Bool>;
    int8_cell: map<Int as int8, Cell>;
    int8_address: map<Int as int8, Address>;
    int8_struct: map<Int as int8, SomeStruct>;

    // ===============================
    // Integer (`Int as int42`) Key Maps
    // ===============================

    int42_int: map<Int as int42, Int>;
    int42_int8: map<Int as int42, Int as int8>;
    int42_int42: map<Int as int42, Int as int42>;
    int42_int256: map<Int as int42, Int as int256>;
    int42_uint8: map<Int as int42, Int as uint8>;
    int42_uint42: map<Int as int42, Int as uint42>;
    int42_uint256: map<Int as int42, Int as uint256>;
    int42_coins: map<Int as int42, Int as coins>;
    int42_bool: map<Int as int42, Bool>;
    int42_cell: map<Int as int42, Cell>;
    int42_address: map<Int as int42, Address>;
    int42_struct: map<Int as int42, SomeStruct>;

    // ===============================
    // Integer (`Int as int256`) Key Maps
    // ===============================

    int256_int: map<Int as int256, Int>;
    int256_int8: map<Int as int256, Int as int8>;
    int256_int42: map<Int as int256, Int as int42>;
    int256_int256: map<Int as int256, Int as int256>;
    int256_uint8: map<Int as int256, Int as uint8>;
    int256_uint42: map<Int as int256, Int as uint42>;
    int256_uint256: map<Int as int256, Int as uint256>;
    int256_coins: map<Int as int256, Int as coins>;
    int256_bool: map<Int as int256, Bool>;
    int256_cell: map<Int as int256, Cell>;
    int256_address: map<Int as int256, Address>;
    int256_struct: map<Int as int256, SomeStruct>;

    // ===============================
    // Unsigned Integer (`Int as uint8`) Key Maps
    // ===============================

    uint8_int: map<Int as uint8, Int>;
    uint8_int8: map<Int as uint8, Int as int8>;
    uint8_int42: map<Int as uint8, Int as int42>;
    uint8_int256: map<Int as uint8, Int as int256>;
    uint8_uint8: map<Int as uint8, Int as uint8>;
    uint8_uint42: map<Int as uint8, Int as uint42>;
    uint8_uint256: map<Int as uint8, Int as uint256>;
    uint8_coins: map<Int as uint8, Int as coins>;
    uint8_bool: map<Int as uint8, Bool>;
    uint8_cell: map<Int as uint8, Cell>;
    uint8_address: map<Int as uint8, Address>;
    uint8_struct: map<Int as uint8, SomeStruct>;

    // ===============================
    // Unsigned Integer (`Int as uint42`) Key Maps
    // ===============================

    uint42_int: map<Int as uint42, Int>;
    uint42_int8: map<Int as uint42, Int as int8>;
    uint42_int42: map<Int as uint42, Int as int42>;
    uint42_int256: map<Int as uint42, Int as int256>;
    uint42_uint8: map<Int as uint42, Int as uint8>;
    uint42_uint42: map<Int as uint42, Int as uint42>;
    uint42_uint256: map<Int as uint42, Int as uint256>;
    uint42_coins: map<Int as uint42, Int as coins>;
    uint42_bool: map<Int as uint42, Bool>;
    uint42_cell: map<Int as uint42, Cell>;
    uint42_address: map<Int as uint42, Address>;
    uint42_struct: map<Int as uint42, SomeStruct>;

    // ===============================
    // Unsigned Integer (`Int as uint256`) Key Maps
    // ===============================

    uint256_int: map<Int as uint256, Int>;
    uint256_int8: map<Int as uint256, Int as int8>;
    uint256_int42: map<Int as uint256, Int as int42>;
    uint256_int256: map<Int as uint256, Int as int256>;
    uint256_uint8: map<Int as uint256, Int as uint8>;
    uint256_uint42: map<Int as uint256, Int as uint42>;
    uint256_uint256: map<Int as uint256, Int as uint256>;
    uint256_coins: map<Int as uint256, Int as coins>;
    uint256_bool: map<Int as uint256, Bool>;
    uint256_cell: map<Int as uint256, Cell>;
    uint256_address: map<Int as uint256, Address>;
    uint256_struct: map<Int as uint256, SomeStruct>;

    // ===============================
    // Address Key Maps
    // ===============================

    address_int: map<Address, Int>;
    address_int8: map<Address, Int as int8>;
    address_int42: map<Address, Int as int42>;
    address_int256: map<Address, Int as int256>;
    address_uint8: map<Address, Int as uint8>;
    address_uint42: map<Address, Int as uint42>;
    address_uint256: map<Address, Int as uint256>;
    address_coins: map<Address, Int as coins>;
    address_bool: map<Address, Bool>;
    address_cell: map<Address, Cell>;
    address_address: map<Address, Address>;
    address_struct: map<Address, SomeStruct>;

    // ===============================
    // Receivers For Operations
    // ===============================

    receive(msg: SetAllMaps) {
        // Integer Key Maps
        self.int_int.set(msg.keyInt, msg.valueInt);
        self.int_int8.set(msg.keyInt, msg.valueInt8);
        self.int_int42.set(msg.keyInt, msg.valueInt42);
        self.int_int256.set(msg.keyInt, msg.valueInt256);
        self.int_uint8.set(msg.keyInt, msg.valueUint8);
        self.int_uint42.set(msg.keyInt, msg.valueUint42);
        self.int_uint256.set(msg.keyInt, msg.valueUint256);
        self.int_coins.set(msg.keyInt, msg.valueCoins);
        self.int_bool.set(msg.keyInt, msg.valueBool);
        self.int_cell.set(msg.keyInt, msg.valueCell);
        self.int_address.set(msg.keyInt, msg.valueAddress);
        self.int_struct.set(msg.keyInt, msg.valueStruct);

        self.int8_int.set(msg.keyInt8, msg.valueInt);
        self.int8_int8.set(msg.keyInt8, msg.valueInt8);
        self.int8_int42.set(msg.keyInt8, msg.valueInt42);
        self.int8_int256.set(msg.keyInt8, msg.valueInt256);
        self.int8_uint8.set(msg.keyInt8, msg.valueUint8);
        self.int8_uint42.set(msg.keyInt8, msg.valueUint42);
        self.int8_uint256.set(msg.keyInt8, msg.valueUint256);
        self.int8_coins.set(msg.keyInt8, msg.valueCoins);
        self.int8_bool.set(msg.keyInt8, msg.valueBool);
        self.int8_cell.set(msg.keyInt8, msg.valueCell);
        self.int8_address.set(msg.keyInt8, msg.valueAddress);
        self.int8_struct.set(msg.keyInt8, msg.valueStruct);

        self.int42_int.set(msg.keyInt42, msg.valueInt);
        self.int42_int8.set(msg.keyInt42, msg.valueInt8);
        self.int42_int42.set(msg.keyInt42, msg.valueInt42);
        self.int42_int256.set(msg.keyInt42, msg.valueInt256);
        self.int42_uint8.set(msg.keyInt42, msg.valueUint8);
        self.int42_uint42.set(msg.keyInt42, msg.valueUint42);
        self.int42_uint256.set(msg.keyInt42, msg.valueUint256);
        self.int42_coins.set(msg.keyInt42, msg.valueCoins);
        self.int42_bool.set(msg.keyInt42, msg.valueBool);
        self.int42_cell.set(msg.keyInt42, msg.valueCell);
        self.int42_address.set(msg.keyInt42, msg.valueAddress);
        self.int42_struct.set(msg.keyInt42, msg.valueStruct);

        self.int256_int.set(msg.keyInt256, msg.valueInt);
        self.int256_int8.set(msg.keyInt256, msg.valueInt8);
        self.int256_int42.set(msg.keyInt256, msg.valueInt42);
        self.int256_int256.set(msg.keyInt256, msg.valueInt256);
        self.int256_uint8.set(msg.keyInt256, msg.valueUint8);
        self.int256_uint42.set(msg.keyInt256, msg.valueUint42);
        self.int256_uint256.set(msg.keyInt256, msg.valueUint256);
        self.int256_coins.set(msg.keyInt256, msg.valueCoins);
        self.int256_bool.set(msg.keyInt256, msg.valueBool);
        self.int256_cell.set(msg.keyInt256, msg.valueCell);
        self.int256_address.set(msg.keyInt256, msg.valueAddress);
        self.int256_struct.set(msg.keyInt256, msg.valueStruct);

        self.uint8_int.set(msg.keyUint8, msg.valueInt);
        self.uint8_int8.set(msg.keyUint8, msg.valueInt8);
        self.uint8_int42.set(msg.keyUint8, msg.valueInt42);
        self.uint8_int256.set(msg.keyUint8, msg.valueInt256);
        self.uint8_uint8.set(msg.keyUint8, msg.valueUint8);
        self.uint8_uint42.set(msg.keyUint8, msg.valueUint42);
        self.uint8_uint256.set(msg.keyUint8, msg.valueUint256);
        self.uint8_coins.set(msg.keyUint8, msg.valueCoins);
        self.uint8_bool.set(msg.keyUint8, msg.valueBool);
        self.uint8_cell.set(msg.keyUint8, msg.valueCell);
        self.uint8_address.set(msg.keyUint8, msg.valueAddress);
        self.uint8_struct.set(msg.keyUint8, msg.valueStruct);

        self.uint42_int.set(msg.keyUint42, msg.valueInt);
        self.uint42_int8.set(msg.keyUint42, msg.valueInt8);
        self.uint42_int42.set(msg.keyUint42, msg.valueInt42);
        self.uint42_int256.set(msg.keyUint42, msg.valueInt256);
        self.uint42_uint8.set(msg.keyUint42, msg.valueUint8);
        self.uint42_uint42.set(msg.keyUint42, msg.valueUint42);
        self.uint42_uint256.set(msg.keyUint42, msg.valueUint256);
        self.uint42_coins.set(msg.keyUint42, msg.valueCoins);
        self.uint42_bool.set(msg.keyUint42, msg.valueBool);
        self.uint42_cell.set(msg.keyUint42, msg.valueCell);
        self.uint42_address.set(msg.keyUint42, msg.valueAddress);
        self.uint42_struct.set(msg.keyUint42, msg.valueStruct);

        self.uint256_int.set(msg.keyUint256, msg.valueInt);
        self.uint256_int8.set(msg.keyUint256, msg.valueInt8);
        self.uint256_int42.set(msg.keyUint256, msg.valueInt42);
        self.uint256_int256.set(msg.keyUint256, msg.valueInt256);
        self.uint256_uint8.set(msg.keyUint256, msg.valueUint8);
        self.uint256_uint42.set(msg.keyUint256, msg.valueUint42);
        self.uint256_uint256.set(msg.keyUint256, msg.valueUint256);
        self.uint256_coins.set(msg.keyUint256, msg.valueCoins);
        self.uint256_bool.set(msg.keyUint256, msg.valueBool);
        self.uint256_cell.set(msg.keyUint256, msg.valueCell);
        self.uint256_address.set(msg.keyUint256, msg.valueAddress);
        self.uint256_struct.set(msg.keyUint256, msg.valueStruct);

        // Address Key Maps
        self.address_int.set(msg.keyAddress, msg.valueInt);
        self.address_int8.set(msg.keyAddress, msg.valueInt8);
        self.address_int42.set(msg.keyAddress, msg.valueInt42);
        self.address_int256.set(msg.keyAddress, msg.valueInt256);
        self.address_uint8.set(msg.keyAddress, msg.valueUint8);
        self.address_uint42.set(msg.keyAddress, msg.valueUint42);
        self.address_uint256.set(msg.keyAddress, msg.valueUint256);
        self.address_coins.set(msg.keyAddress, msg.valueCoins);
        self.address_bool.set(msg.keyAddress, msg.valueBool);
        self.address_cell.set(msg.keyAddress, msg.valueCell);
        self.address_address.set(msg.keyAddress, msg.valueAddress);
        self.address_struct.set(msg.keyAddress, msg.valueStruct);
    }

    receive(msg: DelAllMaps) {
        // Integer Key Maps
        self.int_int.del(msg.keyInt);
        self.int_int8.del(msg.keyInt);
        self.int_int42.del(msg.keyInt);
        self.int_int256.del(msg.keyInt);
        self.int_uint8.del(msg.keyInt);
        self.int_uint42.del(msg.keyInt);
        self.int_uint256.del(msg.keyInt);
        self.int_coins.del(msg.keyInt);
        self.int_bool.del(msg.keyInt);
        self.int_cell.del(msg.keyInt);
        self.int_address.del(msg.keyInt);
        self.int_struct.del(msg.keyInt);

        self.int8_int.del(msg.keyInt8);
        self.int8_int8.del(msg.keyInt8);
        self.int8_int42.del(msg.keyInt8);
        self.int8_int256.del(msg.keyInt8);
        self.int8_uint8.del(msg.keyInt8);
        self.int8_uint42.del(msg.keyInt8);
        self.int8_uint256.del(msg.keyInt8);
        self.int8_coins.del(msg.keyInt8);
        self.int8_bool.del(msg.keyInt8);
        self.int8_cell.del(msg.keyInt8);
        self.int8_address.del(msg.keyInt8);
        self.int8_struct.del(msg.keyInt8);

        self.int42_int.del(msg.keyInt42);
        self.int42_int8.del(msg.keyInt42);
        self.int42_int42.del(msg.keyInt42);
        self.int42_int256.del(msg.keyInt42);
        self.int42_uint8.del(msg.keyInt42);
        self.int42_uint42.del(msg.keyInt42);
        self.int42_uint256.del(msg.keyInt42);
        self.int42_coins.del(msg.keyInt42);
        self.int42_bool.del(msg.keyInt42);
        self.int42_cell.del(msg.keyInt42);
        self.int42_address.del(msg.keyInt42);
        self.int42_struct.del(msg.keyInt42);

        self.int256_int.del(msg.keyInt256);
        self.int256_int8.del(msg.keyInt256);
        self.int256_int42.del(msg.keyInt256);
        self.int256_int256.del(msg.keyInt256);
        self.int256_uint8.del(msg.keyInt256);
        self.int256_uint42.del(msg.keyInt256);
        self.int256_uint256.del(msg.keyInt256);
        self.int256_coins.del(msg.keyInt256);
        self.int256_bool.del(msg.keyInt256);
        self.int256_cell.del(msg.keyInt256);
        self.int256_address.del(msg.keyInt256);
        self.int256_struct.del(msg.keyInt256);

        self.uint8_int.del(msg.keyUint8);
        self.uint8_int8.del(msg.keyUint8);
        self.uint8_int42.del(msg.keyUint8);
        self.uint8_int256.del(msg.keyUint8);
        self.uint8_uint8.del(msg.keyUint8);
        self.uint8_uint42.del(msg.keyUint8);
        self.uint8_uint256.del(msg.keyUint8);
        self.uint8_coins.del(msg.keyUint8);
        self.uint8_bool.del(msg.keyUint8);
        self.uint8_cell.del(msg.keyUint8);
        self.uint8_address.del(msg.keyUint8);
        self.uint8_struct.del(msg.keyUint8);

        self.uint42_int.del(msg.keyUint42);
        self.uint42_int8.del(msg.keyUint42);
        self.uint42_int42.del(msg.keyUint42);
        self.uint42_int256.del(msg.keyUint42);
        self.uint42_uint8.del(msg.keyUint42);
        self.uint42_uint42.del(msg.keyUint42);
        self.uint42_uint256.del(msg.keyUint42);
        self.uint42_coins.del(msg.keyUint42);
        self.uint42_bool.del(msg.keyUint42);
        self.uint42_cell.del(msg.keyUint42);
        self.uint42_address.del(msg.keyUint42);
        self.uint42_struct.del(msg.keyUint42);

        self.uint256_int.del(msg.keyUint256);
        self.uint256_int8.del(msg.keyUint256);
        self.uint256_int42.del(msg.keyUint256);
        self.uint256_int256.del(msg.keyUint256);
        self.uint256_uint8.del(msg.keyUint256);
        self.uint256_uint42.del(msg.keyUint256);
        self.uint256_uint256.del(msg.keyUint256);
        self.uint256_coins.del(msg.keyUint256);
        self.uint256_bool.del(msg.keyUint256);
        self.uint256_cell.del(msg.keyUint256);
        self.uint256_address.del(msg.keyUint256);
        self.uint256_struct.del(msg.keyUint256);

        // Address Key Maps
        self.address_int.del(msg.keyAddress);
        self.address_int8.del(msg.keyAddress);
        self.address_int42.del(msg.keyAddress);
        self.address_int256.del(msg.keyAddress);
        self.address_uint8.del(msg.keyAddress);
        self.address_uint42.del(msg.keyAddress);
        self.address_uint256.del(msg.keyAddress);
        self.address_coins.del(msg.keyAddress);
        self.address_bool.del(msg.keyAddress);
        self.address_cell.del(msg.keyAddress);
        self.address_address.del(msg.keyAddress);
        self.address_struct.del(msg.keyAddress);
    }

    receive(msg: ReplaceAllMaps) {
        // Integer Key Maps
        self.int_int.replace(msg.keyInt, msg.valueInt);
        self.int_int8.replace(msg.keyInt, msg.valueInt8);
        self.int_int42.replace(msg.keyInt, msg.valueInt42);
        self.int_int256.replace(msg.keyInt, msg.valueInt256);
        self.int_uint8.replace(msg.keyInt, msg.valueUint8);
        self.int_uint42.replace(msg.keyInt, msg.valueUint42);
        self.int_uint256.replace(msg.keyInt, msg.valueUint256);
        self.int_coins.replace(msg.keyInt, msg.valueCoins);
        self.int_bool.replace(msg.keyInt, msg.valueBool);
        self.int_cell.replace(msg.keyInt, msg.valueCell);
        self.int_address.replace(msg.keyInt, msg.valueAddress);
        self.int_struct.replace(msg.keyInt, msg.valueStruct);

        self.int8_int.replace(msg.keyInt8, msg.valueInt);
        self.int8_int8.replace(msg.keyInt8, msg.valueInt8);
        self.int8_int42.replace(msg.keyInt8, msg.valueInt42);
        self.int8_int256.replace(msg.keyInt8, msg.valueInt256);
        self.int8_uint8.replace(msg.keyInt8, msg.valueUint8);
        self.int8_uint42.replace(msg.keyInt8, msg.valueUint42);
        self.int8_uint256.replace(msg.keyInt8, msg.valueUint256);
        self.int8_coins.replace(msg.keyInt8, msg.valueCoins);
        self.int8_bool.replace(msg.keyInt8, msg.valueBool);
        self.int8_cell.replace(msg.keyInt8, msg.valueCell);
        self.int8_address.replace(msg.keyInt8, msg.valueAddress);
        self.int8_struct.replace(msg.keyInt8, msg.valueStruct);

        self.int42_int.replace(msg.keyInt42, msg.valueInt);
        self.int42_int8.replace(msg.keyInt42, msg.valueInt8);
        self.int42_int42.replace(msg.keyInt42, msg.valueInt42);
        self.int42_int256.replace(msg.keyInt42, msg.valueInt256);
        self.int42_uint8.replace(msg.keyInt42, msg.valueUint8);
        self.int42_uint42.replace(msg.keyInt42, msg.valueUint42);
        self.int42_uint256.replace(msg.keyInt42, msg.valueUint256);
        self.int42_coins.replace(msg.keyInt42, msg.valueCoins);
        self.int42_bool.replace(msg.keyInt42, msg.valueBool);
        self.int42_cell.replace(msg.keyInt42, msg.valueCell);
        self.int42_address.replace(msg.keyInt42, msg.valueAddress);
        self.int42_struct.replace(msg.keyInt42, msg.valueStruct);

        self.int256_int.replace(msg.keyInt256, msg.valueInt);
        self.int256_int8.replace(msg.keyInt256, msg.valueInt8);
        self.int256_int42.replace(msg.keyInt256, msg.valueInt42);
        self.int256_int256.replace(msg.keyInt256, msg.valueInt256);
        self.int256_uint8.replace(msg.keyInt256, msg.valueUint8);
        self.int256_uint42.replace(msg.keyInt256, msg.valueUint42);
        self.int256_uint256.replace(msg.keyInt256, msg.valueUint256);
        self.int256_coins.replace(msg.keyInt256, msg.valueCoins);
        self.int256_bool.replace(msg.keyInt256, msg.valueBool);
        self.int256_cell.replace(msg.keyInt256, msg.valueCell);
        self.int256_address.replace(msg.keyInt256, msg.valueAddress);
        self.int256_struct.replace(msg.keyInt256, msg.valueStruct);

        self.uint8_int.replace(msg.keyUint8, msg.valueInt);
        self.uint8_int8.replace(msg.keyUint8, msg.valueInt8);
        self.uint8_int42.replace(msg.keyUint8, msg.valueInt42);
        self.uint8_int256.replace(msg.keyUint8, msg.valueInt256);
        self.uint8_uint8.replace(msg.keyUint8, msg.valueUint8);
        self.uint8_uint42.replace(msg.keyUint8, msg.valueUint42);
        self.uint8_uint256.replace(msg.keyUint8, msg.valueUint256);
        self.uint8_coins.replace(msg.keyUint8, msg.valueCoins);
        self.uint8_bool.replace(msg.keyUint8, msg.valueBool);
        self.uint8_cell.replace(msg.keyUint8, msg.valueCell);
        self.uint8_address.replace(msg.keyUint8, msg.valueAddress);
        self.uint8_struct.replace(msg.keyUint8, msg.valueStruct);

        self.uint42_int.replace(msg.keyUint42, msg.valueInt);
        self.uint42_int8.replace(msg.keyUint42, msg.valueInt8);
        self.uint42_int42.replace(msg.keyUint42, msg.valueInt42);
        self.uint42_int256.replace(msg.keyUint42, msg.valueInt256);
        self.uint42_uint8.replace(msg.keyUint42, msg.valueUint8);
        self.uint42_uint42.replace(msg.keyUint42, msg.valueUint42);
        self.uint42_uint256.replace(msg.keyUint42, msg.valueUint256);
        self.uint42_coins.replace(msg.keyUint42, msg.valueCoins);
        self.uint42_bool.replace(msg.keyUint42, msg.valueBool);
        self.uint42_cell.replace(msg.keyUint42, msg.valueCell);
        self.uint42_address.replace(msg.keyUint42, msg.valueAddress);
        self.uint42_struct.replace(msg.keyUint42, msg.valueStruct);

        self.uint256_int.replace(msg.keyUint256, msg.valueInt);
        self.uint256_int8.replace(msg.keyUint256, msg.valueInt8);
        self.uint256_int42.replace(msg.keyUint256, msg.valueInt42);
        self.uint256_int256.replace(msg.keyUint256, msg.valueInt256);
        self.uint256_uint8.replace(msg.keyUint256, msg.valueUint8);
        self.uint256_uint42.replace(msg.keyUint256, msg.valueUint42);
        self.uint256_uint256.replace(msg.keyUint256, msg.valueUint256);
        self.uint256_coins.replace(msg.keyUint256, msg.valueCoins);
        self.uint256_bool.replace(msg.keyUint256, msg.valueBool);
        self.uint256_cell.replace(msg.keyUint256, msg.valueCell);
        self.uint256_address.replace(msg.keyUint256, msg.valueAddress);
        self.uint256_struct.replace(msg.keyUint256, msg.valueStruct);

        // Address Key Maps
        self.address_int.replace(msg.keyAddress, msg.valueInt);
        self.address_int8.replace(msg.keyAddress, msg.valueInt8);
        self.address_int42.replace(msg.keyAddress, msg.valueInt42);
        self.address_int256.replace(msg.keyAddress, msg.valueInt256);
        self.address_uint8.replace(msg.keyAddress, msg.valueUint8);
        self.address_uint42.replace(msg.keyAddress, msg.valueUint42);
        self.address_uint256.replace(msg.keyAddress, msg.valueUint256);
        self.address_coins.replace(msg.keyAddress, msg.valueCoins);
        self.address_bool.replace(msg.keyAddress, msg.valueBool);
        self.address_cell.replace(msg.keyAddress, msg.valueCell);
        self.address_address.replace(msg.keyAddress, msg.valueAddress);
        self.address_struct.replace(msg.keyAddress, msg.valueStruct);
    }

    receive(msg: ReplaceGetAllMaps) {
        // Integer Key Maps
        self.int_int.replaceGet(msg.keyInt, msg.valueInt);
        self.int_int8.replaceGet(msg.keyInt, msg.valueInt8);
        self.int_int42.replaceGet(msg.keyInt, msg.valueInt42);
        self.int_int256.replaceGet(msg.keyInt, msg.valueInt256);
        self.int_uint8.replaceGet(msg.keyInt, msg.valueUint8);
        self.int_uint42.replaceGet(msg.keyInt, msg.valueUint42);
        self.int_uint256.replaceGet(msg.keyInt, msg.valueUint256);
        self.int_coins.replaceGet(msg.keyInt, msg.valueCoins);
        self.int_bool.replaceGet(msg.keyInt, msg.valueBool);
        self.int_cell.replaceGet(msg.keyInt, msg.valueCell);
        self.int_address.replaceGet(msg.keyInt, msg.valueAddress);
        self.int_struct.replaceGet(msg.keyInt, msg.valueStruct);

        self.int8_int.replaceGet(msg.keyInt8, msg.valueInt);
        self.int8_int8.replaceGet(msg.keyInt8, msg.valueInt8);
        self.int8_int42.replaceGet(msg.keyInt8, msg.valueInt42);
        self.int8_int256.replaceGet(msg.keyInt8, msg.valueInt256);
        self.int8_uint8.replaceGet(msg.keyInt8, msg.valueUint8);
        self.int8_uint42.replaceGet(msg.keyInt8, msg.valueUint42);
        self.int8_uint256.replaceGet(msg.keyInt8, msg.valueUint256);
        self.int8_coins.replaceGet(msg.keyInt8, msg.valueCoins);
        self.int8_bool.replaceGet(msg.keyInt8, msg.valueBool);
        self.int8_cell.replaceGet(msg.keyInt8, msg.valueCell);
        self.int8_address.replaceGet(msg.keyInt8, msg.valueAddress);
        self.int8_struct.replaceGet(msg.keyInt8, msg.valueStruct);

        self.int42_int.replaceGet(msg.keyInt42, msg.valueInt);
        self.int42_int8.replaceGet(msg.keyInt42, msg.valueInt8);
        self.int42_int42.replaceGet(msg.keyInt42, msg.valueInt42);
        self.int42_int256.replaceGet(msg.keyInt42, msg.valueInt256);
        self.int42_uint8.replaceGet(msg.keyInt42, msg.valueUint8);
        self.int42_uint42.replaceGet(msg.keyInt42, msg.valueUint42);
        self.int42_uint256.replaceGet(msg.keyInt42, msg.valueUint256);
        self.int42_coins.replaceGet(msg.keyInt42, msg.valueCoins);
        self.int42_bool.replaceGet(msg.keyInt42, msg.valueBool);
        self.int42_cell.replaceGet(msg.keyInt42, msg.valueCell);
        self.int42_address.replaceGet(msg.keyInt42, msg.valueAddress);
        self.int42_struct.replaceGet(msg.keyInt42, msg.valueStruct);

        self.int256_int.replaceGet(msg.keyInt256, msg.valueInt);
        self.int256_int8.replaceGet(msg.keyInt256, msg.valueInt8);
        self.int256_int42.replaceGet(msg.keyInt256, msg.valueInt42);
        self.int256_int256.replaceGet(msg.keyInt256, msg.valueInt256);
        self.int256_uint8.replaceGet(msg.keyInt256, msg.valueUint8);
        self.int256_uint42.replaceGet(msg.keyInt256, msg.valueUint42);
        self.int256_uint256.replaceGet(msg.keyInt256, msg.valueUint256);
        self.int256_coins.replaceGet(msg.keyInt256, msg.valueCoins);
        self.int256_bool.replaceGet(msg.keyInt256, msg.valueBool);
        self.int256_cell.replaceGet(msg.keyInt256, msg.valueCell);
        self.int256_address.replaceGet(msg.keyInt256, msg.valueAddress);
        self.int256_struct.replaceGet(msg.keyInt256, msg.valueStruct);

        self.uint8_int.replaceGet(msg.keyUint8, msg.valueInt);
        self.uint8_int8.replaceGet(msg.keyUint8, msg.valueInt8);
        self.uint8_int42.replaceGet(msg.keyUint8, msg.valueInt42);
        self.uint8_int256.replaceGet(msg.keyUint8, msg.valueInt256);
        self.uint8_uint8.replaceGet(msg.keyUint8, msg.valueUint8);
        self.uint8_uint42.replaceGet(msg.keyUint8, msg.valueUint42);
        self.uint8_uint256.replaceGet(msg.keyUint8, msg.valueUint256);
        self.uint8_coins.replaceGet(msg.keyUint8, msg.valueCoins);
        self.uint8_bool.replaceGet(msg.keyUint8, msg.valueBool);
        self.uint8_cell.replaceGet(msg.keyUint8, msg.valueCell);
        self.uint8_address.replaceGet(msg.keyUint8, msg.valueAddress);
        self.uint8_struct.replaceGet(msg.keyUint8, msg.valueStruct);

        self.uint42_int.replaceGet(msg.keyUint42, msg.valueInt);
        self.uint42_int8.replaceGet(msg.keyUint42, msg.valueInt8);
        self.uint42_int42.replaceGet(msg.keyUint42, msg.valueInt42);
        self.uint42_int256.replaceGet(msg.keyUint42, msg.valueInt256);
        self.uint42_uint8.replaceGet(msg.keyUint42, msg.valueUint8);
        self.uint42_uint42.replaceGet(msg.keyUint42, msg.valueUint42);
        self.uint42_uint256.replaceGet(msg.keyUint42, msg.valueUint256);
        self.uint42_coins.replaceGet(msg.keyUint42, msg.valueCoins);
        self.uint42_bool.replaceGet(msg.keyUint42, msg.valueBool);
        self.uint42_cell.replaceGet(msg.keyUint42, msg.valueCell);
        self.uint42_address.replaceGet(msg.keyUint42, msg.valueAddress);
        self.uint42_struct.replaceGet(msg.keyUint42, msg.valueStruct);

        self.uint256_int.replaceGet(msg.keyUint256, msg.valueInt);
        self.uint256_int8.replaceGet(msg.keyUint256, msg.valueInt8);
        self.uint256_int42.replaceGet(msg.keyUint256, msg.valueInt42);
        self.uint256_int256.replaceGet(msg.keyUint256, msg.valueInt256);
        self.uint256_uint8.replaceGet(msg.keyUint256, msg.valueUint8);
        self.uint256_uint42.replaceGet(msg.keyUint256, msg.valueUint42);
        self.uint256_uint256.replaceGet(msg.keyUint256, msg.valueUint256);
        self.uint256_coins.replaceGet(msg.keyUint256, msg.valueCoins);
        self.uint256_bool.replaceGet(msg.keyUint256, msg.valueBool);
        self.uint256_cell.replaceGet(msg.keyUint256, msg.valueCell);
        self.uint256_address.replaceGet(msg.keyUint256, msg.valueAddress);
        self.uint256_struct.replaceGet(msg.keyUint256, msg.valueStruct);

        // Address Key Maps
        self.address_int.replaceGet(msg.keyAddress, msg.valueInt);
        self.address_int8.replaceGet(msg.keyAddress, msg.valueInt8);
        self.address_int42.replaceGet(msg.keyAddress, msg.valueInt42);
        self.address_int256.replaceGet(msg.keyAddress, msg.valueInt256);
        self.address_uint8.replaceGet(msg.keyAddress, msg.valueUint8);
        self.address_uint42.replaceGet(msg.keyAddress, msg.valueUint42);
        self.address_uint256.replaceGet(msg.keyAddress, msg.valueUint256);
        self.address_coins.replaceGet(msg.keyAddress, msg.valueCoins);
        self.address_bool.replaceGet(msg.keyAddress, msg.valueBool);
        self.address_cell.replaceGet(msg.keyAddress, msg.valueCell);
        self.address_address.replaceGet(msg.keyAddress, msg.valueAddress);
        self.address_struct.replaceGet(msg.keyAddress, msg.valueStruct);
    }

    // ===============================
    // Getters
    // ===============================

    get fun allMaps(): MapTestContract {
        return self;
    }

    get fun getAllMaps(
        keyInt: Int,
        keyInt8: Int,
        keyInt42: Int,
        keyInt256: Int,
        keyUint8: Int,
        keyUint42: Int,
        keyUint256: Int,
        keyAddress: Address
    ): GetAllMapsResult {
        return GetAllMapsResult {
            // Integer Key Maps
            int_int: self.int_int.get(keyInt),
            int_int8: self.int_int8.get(keyInt),
            int_int42: self.int_int42.get(keyInt),
            int_int256: self.int_int256.get(keyInt),
            int_uint8: self.int_uint8.get(keyInt),
            int_uint42: self.int_uint42.get(keyInt),
            int_uint256: self.int_uint256.get(keyInt),
            int_coins: self.int_coins.get(keyInt),
            int_bool: self.int_bool.get(keyInt),
            int_cell: self.int_cell.get(keyInt),
            int_address: self.int_address.get(keyInt),
            int_struct: self.int_struct.get(keyInt),

            int8_int: self.int8_int.get(keyInt8),
            int8_int8: self.int8_int8.get(keyInt8),
            int8_int42: self.int8_int42.get(keyInt8),
            int8_int256: self.int8_int256.get(keyInt8),
            int8_uint8: self.int8_uint8.get(keyInt8),
            int8_uint42: self.int8_uint42.get(keyInt8),
            int8_uint256: self.int8_uint256.get(keyInt8),
            int8_coins: self.int8_coins.get(keyInt8),
            int8_bool: self.int8_bool.get(keyInt8),
            int8_cell: self.int8_cell.get(keyInt8),
            int8_address: self.int8_address.get(keyInt8),
            int8_struct: self.int8_struct.get(keyInt8),

            int42_int: self.int42_int.get(keyInt42),
            int42_int8: self.int42_int8.get(keyInt42),
            int42_int42: self.int42_int42.get(keyInt42),
            int42_int256: self.int42_int256.get(keyInt42),
            int42_uint8: self.int42_uint8.get(keyInt42),
            int42_uint42: self.int42_uint42.get(keyInt42),
            int42_uint256: self.int42_uint256.get(keyInt42),
            int42_coins: self.int42_coins.get(keyInt42),
            int42_bool: self.int42_bool.get(keyInt42),
            int42_cell: self.int42_cell.get(keyInt42),
            int42_address: self.int42_address.get(keyInt42),
            int42_struct: self.int42_struct.get(keyInt42),

            int256_int: self.int256_int.get(keyInt256),
            int256_int8: self.int256_int8.get(keyInt256),
            int256_int42: self.int256_int42.get(keyInt256),
            int256_int256: self.int256_int256.get(keyInt256),
            int256_uint8: self.int256_uint8.get(keyInt256),
            int256_uint42: self.int256_uint42.get(keyInt256),
            int256_uint256: self.int256_uint256.get(keyInt256),
            int256_coins: self.int256_coins.get(keyInt256),
            int256_bool: self.int256_bool.get(keyInt256),
            int256_cell: self.int256_cell.get(keyInt256),
            int256_address: self.int256_address.get(keyInt256),
            int256_struct: self.int256_struct.get(keyInt256),

            uint8_int: self.uint8_int.get(keyUint8),
            uint8_int8: self.uint8_int8.get(keyUint8),
            uint8_int42: self.uint8_int42.get(keyUint8),
            uint8_int256: self.uint8_int256.get(keyUint8),
            uint8_uint8: self.uint8_uint8.get(keyUint8),
            uint8_uint42: self.uint8_uint42.get(keyUint8),
            uint8_uint256: self.uint8_uint256.get(keyUint8),
            uint8_coins: self.uint8_coins.get(keyUint8),
            uint8_bool: self.uint8_bool.get(keyUint8),
            uint8_cell: self.uint8_cell.get(keyUint8),
            uint8_address: self.uint8_address.get(keyUint8),
            uint8_struct: self.uint8_struct.get(keyUint8),

            uint42_int: self.uint42_int.get(keyUint42),
            uint42_int8: self.uint42_int8.get(keyUint42),
            uint42_int42: self.uint42_int42.get(keyUint42),
            uint42_int256: self.uint42_int256.get(keyUint42),
            uint42_uint8: self.uint42_uint8.get(keyUint42),
            uint42_uint42: self.uint42_uint42.get(keyUint42),
            uint42_uint256: self.uint42_uint256.get(keyUint42),
            uint42_coins: self.uint42_coins.get(keyUint42),
            uint42_bool: self.uint42_bool.get(keyUint42),
            uint42_cell: self.uint42_cell.get(keyUint42),
            uint42_address: self.uint42_address.get(keyUint42),
            uint42_struct: self.uint42_struct.get(keyUint42),

            uint256_int: self.uint256_int.get(keyUint256),
            uint256_int8: self.uint256_int8.get(keyUint256),
            uint256_int42: self.uint256_int42.get(keyUint256),
            uint256_int256: self.uint256_int256.get(keyUint256),
            uint256_uint8: self.uint256_uint8.get(keyUint256),
            uint256_uint42: self.uint256_uint42.get(keyUint256),
            uint256_uint256: self.uint256_uint256.get(keyUint256),
            uint256_coins: self.uint256_coins.get(keyUint256),
            uint256_bool: self.uint256_bool.get(keyUint256),
            uint256_cell: self.uint256_cell.get(keyUint256),
            uint256_address: self.uint256_address.get(keyUint256),
            uint256_struct: self.uint256_struct.get(keyUint256),

            // Address Key Maps
            address_int: self.address_int.get(keyAddress),
            address_int8: self.address_int8.get(keyAddress),
            address_int42: self.address_int42.get(keyAddress),
            address_int256: self.address_int256.get(keyAddress),
            address_uint8: self.address_uint8.get(keyAddress),
            address_uint42: self.address_uint42.get(keyAddress),
            address_uint256: self.address_uint256.get(keyAddress),
            address_coins: self.address_coins.get(keyAddress),
            address_bool: self.address_bool.get(keyAddress),
            address_cell: self.address_cell.get(keyAddress),
            address_address: self.address_address.get(keyAddress),
            address_struct: self.address_struct.get(keyAddress)
        };
    }

    get fun replaceAllMaps(
        keyInt: Int,
        keyInt8: Int,
        keyInt42: Int,
        keyInt256: Int,
        keyUint8: Int,
        keyUint42: Int,
        keyUint256: Int,
        keyAddress: Address,
        valueInt: Int,
        valueInt8: Int,
        valueInt42: Int,
        valueInt256: Int,
        valueUint8: Int,
        valueUint42: Int,
        valueUint256: Int,
        valueCoins: Int,
        valueBool: Bool,
        valueCell: Cell,
        valueAddress: Address,
        valueStruct: SomeStruct
    ): ReplaceAllMapsResult {
        return ReplaceAllMapsResult {
            // Integer Key Maps
            int_int: self.int_int.replace(keyInt, valueInt),
            int_int8: self.int_int8.replace(keyInt, valueInt8),
            int_int42: self.int_int42.replace(keyInt, valueInt42),
            int_int256: self.int_int256.replace(keyInt, valueInt256),
            int_uint8: self.int_uint8.replace(keyInt, valueUint8),
            int_uint42: self.int_uint42.replace(keyInt, valueUint42),
            int_uint256: self.int_uint256.replace(keyInt, valueUint256),
            int_coins: self.int_coins.replace(keyInt, valueCoins),
            int_bool: self.int_bool.replace(keyInt, valueBool),
            int_cell: self.int_cell.replace(keyInt, valueCell),
            int_address: self.int_address.replace(keyInt, valueAddress),
            int_struct: self.int_struct.replace(keyInt, valueStruct),

            int8_int: self.int8_int.replace(keyInt8, valueInt),
            int8_int8: self.int8_int8.replace(keyInt8, valueInt8),
            int8_int42: self.int8_int42.replace(keyInt8, valueInt42),
            int8_int256: self.int8_int256.replace(keyInt8, valueInt256),
            int8_uint8: self.int8_uint8.replace(keyInt8, valueUint8),
            int8_uint42: self.int8_uint42.replace(keyInt8, valueUint42),
            int8_uint256: self.int8_uint256.replace(keyInt8, valueUint256),
            int8_coins: self.int8_coins.replace(keyInt8, valueCoins),
            int8_bool: self.int8_bool.replace(keyInt8, valueBool),
            int8_cell: self.int8_cell.replace(keyInt8, valueCell),
            int8_address: self.int8_address.replace(keyInt8, valueAddress),
            int8_struct: self.int8_struct.replace(keyInt8, valueStruct),

            int42_int: self.int42_int.replace(keyInt42, valueInt),
            int42_int8: self.int42_int8.replace(keyInt42, valueInt8),
            int42_int42: self.int42_int42.replace(keyInt42, valueInt42),
            int42_int256: self.int42_int256.replace(keyInt42, valueInt256),
            int42_uint8: self.int42_uint8.replace(keyInt42, valueUint8),
            int42_uint42: self.int42_uint42.replace(keyInt42, valueUint42),
            int42_uint256: self.int42_uint256.replace(keyInt42, valueUint256),
            int42_coins: self.int42_coins.replace(keyInt42, valueCoins),
            int42_bool: self.int42_bool.replace(keyInt42, valueBool),
            int42_cell: self.int42_cell.replace(keyInt42, valueCell),
            int42_address: self.int42_address.replace(keyInt42, valueAddress),
            int42_struct: self.int42_struct.replace(keyInt42, valueStruct),

            int256_int: self.int256_int.replace(keyInt256, valueInt),
            int256_int8: self.int256_int8.replace(keyInt256, valueInt8),
            int256_int42: self.int256_int42.replace(keyInt256, valueInt42),
            int256_int256: self.int256_int256.replace(keyInt256, valueInt256),
            int256_uint8: self.int256_uint8.replace(keyInt256, valueUint8),
            int256_uint42: self.int256_uint42.replace(keyInt256, valueUint42),
            int256_uint256: self.int256_uint256.replace(keyInt256, valueUint256),
            int256_coins: self.int256_coins.replace(keyInt256, valueCoins),
            int256_bool: self.int256_bool.replace(keyInt256, valueBool),
            int256_cell: self.int256_cell.replace(keyInt256, valueCell),
            int256_address: self.int256_address.replace(keyInt256, valueAddress),
            int256_struct: self.int256_struct.replace(keyInt256, valueStruct),

            uint8_int: self.uint8_int.replace(keyUint8, valueInt),
            uint8_int8: self.uint8_int8.replace(keyUint8, valueInt8),
            uint8_int42: self.uint8_int42.replace(keyUint8, valueInt42),
            uint8_int256: self.uint8_int256.replace(keyUint8, valueInt256),
            uint8_uint8: self.uint8_uint8.replace(keyUint8, valueUint8),
            uint8_uint42: self.uint8_uint42.replace(keyUint8, valueUint42),
            uint8_uint256: self.uint8_uint256.replace(keyUint8, valueUint256),
            uint8_coins: self.uint8_coins.replace(keyUint8, valueCoins),
            uint8_bool: self.uint8_bool.replace(keyUint8, valueBool),
            uint8_cell: self.uint8_cell.replace(keyUint8, valueCell),
            uint8_address: self.uint8_address.replace(keyUint8, valueAddress),
            uint8_struct: self.uint8_struct.replace(keyUint8, valueStruct),

            uint42_int: self.uint42_int.replace(keyUint42, valueInt),
            uint42_int8: self.uint42_int8.replace(keyUint42, valueInt8),
            uint42_int42: self.uint42_int42.replace(keyUint42, valueInt42),
            uint42_int256: self.uint42_int256.replace(keyUint42, valueInt256),
            uint42_uint8: self.uint42_uint8.replace(keyUint42, valueUint8),
            uint42_uint42: self.uint42_uint42.replace(keyUint42, valueUint42),
            uint42_uint256: self.uint42_uint256.replace(keyUint42, valueUint256),
            uint42_coins: self.uint42_coins.replace(keyUint42, valueCoins),
            uint42_bool: self.uint42_bool.replace(keyUint42, valueBool),
            uint42_cell: self.uint42_cell.replace(keyUint42, valueCell),
            uint42_address: self.uint42_address.replace(keyUint42, valueAddress),
            uint42_struct: self.uint42_struct.replace(keyUint42, valueStruct),

            uint256_int: self.uint256_int.replace(keyUint256, valueInt),
            uint256_int8: self.uint256_int8.replace(keyUint256, valueInt8),
            uint256_int42: self.uint256_int42.replace(keyUint256, valueInt42),
            uint256_int256: self.uint256_int256.replace(keyUint256, valueInt256),
            uint256_uint8: self.uint256_uint8.replace(keyUint256, valueUint8),
            uint256_uint42: self.uint256_uint42.replace(keyUint256, valueUint42),
            uint256_uint256: self.uint256_uint256.replace(keyUint256, valueUint256),
            uint256_coins: self.uint256_coins.replace(keyUint256, valueCoins),
            uint256_bool: self.uint256_bool.replace(keyUint256, valueBool),
            uint256_cell: self.uint256_cell.replace(keyUint256, valueCell),
            uint256_address: self.uint256_address.replace(keyUint256, valueAddress),
            uint256_struct: self.uint256_struct.replace(keyUint256, valueStruct),

            // Address Key Maps
            address_int: self.address_int.replace(keyAddress, valueInt),
            address_int8: self.address_int8.replace(keyAddress, valueInt8),
            address_int42: self.address_int42.replace(keyAddress, valueInt42),
            address_int256: self.address_int256.replace(keyAddress, valueInt256),
            address_uint8: self.address_uint8.replace(keyAddress, valueUint8),
            address_uint42: self.address_uint42.replace(keyAddress, valueUint42),
            address_uint256: self.address_uint256.replace(keyAddress, valueUint256),
            address_coins: self.address_coins.replace(keyAddress, valueCoins),
            address_bool: self.address_bool.replace(keyAddress, valueBool),
            address_cell: self.address_cell.replace(keyAddress, valueCell),
            address_address: self.address_address.replace(keyAddress, valueAddress),
            address_struct: self.address_struct.replace(keyAddress, valueStruct)
        };
    }

    get fun replaceGetAllMaps(
        keyInt: Int,
        keyInt8: Int,
        keyInt42: Int,
        keyInt256: Int,
        keyUint8: Int,
        keyUint42: Int,
        keyUint256: Int,
        keyAddress: Address,
        valueInt: Int,
        valueInt8: Int,
        valueInt42: Int,
        valueInt256: Int,
        valueUint8: Int,
        valueUint42: Int,
        valueUint256: Int,
        valueCoins: Int,
        valueBool: Bool,
        valueCell: Cell,
        valueAddress: Address,
        valueStruct: SomeStruct
    ): ReplaceGetAllMapsResult {
        return ReplaceGetAllMapsResult {
            // Integer Key Maps
            int_int: self.int_int.replaceGet(keyInt, valueInt),
            int_int8: self.int_int8.replaceGet(keyInt, valueInt8),
            int_int42: self.int_int42.replaceGet(keyInt, valueInt42),
            int_int256: self.int_int256.replaceGet(keyInt, valueInt256),
            int_uint8: self.int_uint8.replaceGet(keyInt, valueUint8),
            int_uint42: self.int_uint42.replaceGet(keyInt, valueUint42),
            int_uint256: self.int_uint256.replaceGet(keyInt, valueUint256),
            int_coins: self.int_coins.replaceGet(keyInt, valueCoins),
            int_bool: self.int_bool.replaceGet(keyInt, valueBool),
            int_cell: self.int_cell.replaceGet(keyInt, valueCell),
            int_address: self.int_address.replaceGet(keyInt, valueAddress),
            int_struct: self.int_struct.replaceGet(keyInt, valueStruct),

            int8_int: self.int8_int.replaceGet(keyInt8, valueInt),
            int8_int8: self.int8_int8.replaceGet(keyInt8, valueInt8),
            int8_int42: self.int8_int42.replaceGet(keyInt8, valueInt42),
            int8_int256: self.int8_int256.replaceGet(keyInt8, valueInt256),
            int8_uint8: self.int8_uint8.replaceGet(keyInt8, valueUint8),
            int8_uint42: self.int8_uint42.replaceGet(keyInt8, valueUint42),
            int8_uint256: self.int8_uint256.replaceGet(keyInt8, valueUint256),
            int8_coins: self.int8_coins.replaceGet(keyInt8, valueCoins),
            int8_bool: self.int8_bool.replaceGet(keyInt8, valueBool),
            int8_cell: self.int8_cell.replaceGet(keyInt8, valueCell),
            int8_address: self.int8_address.replaceGet(keyInt8, valueAddress),
            int8_struct: self.int8_struct.replaceGet(keyInt8, valueStruct),

            int42_int: self.int42_int.replaceGet(keyInt42, valueInt),
            int42_int8: self.int42_int8.replaceGet(keyInt42, valueInt8),
            int42_int42: self.int42_int42.replaceGet(keyInt42, valueInt42),
            int42_int256: self.int42_int256.replaceGet(keyInt42, valueInt256),
            int42_uint8: self.int42_uint8.replaceGet(keyInt42, valueUint8),
            int42_uint42: self.int42_uint42.replaceGet(keyInt42, valueUint42),
            int42_uint256: self.int42_uint256.replaceGet(keyInt42, valueUint256),
            int42_coins: self.int42_coins.replaceGet(keyInt42, valueCoins),
            int42_bool: self.int42_bool.replaceGet(keyInt42, valueBool),
            int42_cell: self.int42_cell.replaceGet(keyInt42, valueCell),
            int42_address: self.int42_address.replaceGet(keyInt42, valueAddress),
            int42_struct: self.int42_struct.replaceGet(keyInt42, valueStruct),

            int256_int: self.int256_int.replaceGet(keyInt256, valueInt),
            int256_int8: self.int256_int8.replaceGet(keyInt256, valueInt8),
            int256_int42: self.int256_int42.replaceGet(keyInt256, valueInt42),
            int256_int256: self.int256_int256.replaceGet(keyInt256, valueInt256),
            int256_uint8: self.int256_uint8.replaceGet(keyInt256, valueUint8),
            int256_uint42: self.int256_uint42.replaceGet(keyInt256, valueUint42),
            int256_uint256: self.int256_uint256.replaceGet(keyInt256, valueUint256),
            int256_coins: self.int256_coins.replaceGet(keyInt256, valueCoins),
            int256_bool: self.int256_bool.replaceGet(keyInt256, valueBool),
            int256_cell: self.int256_cell.replaceGet(keyInt256, valueCell),
            int256_address: self.int256_address.replaceGet(keyInt256, valueAddress),
            int256_struct: self.int256_struct.replaceGet(keyInt256, valueStruct),

            uint8_int: self.uint8_int.replaceGet(keyUint8, valueInt),
            uint8_int8: self.uint8_int8.replaceGet(keyUint8, valueInt8),
            uint8_int42: self.uint8_int42.replaceGet(keyUint8, valueInt42),
            uint8_int256: self.uint8_int256.replaceGet(keyUint8, valueInt256),
            uint8_uint8: self.uint8_uint8.replaceGet(keyUint8, valueUint8),
            uint8_uint42: self.uint8_uint42.replaceGet(keyUint8, valueUint42),
            uint8_uint256: self.uint8_uint256.replaceGet(keyUint8, valueUint256),
            uint8_coins: self.uint8_coins.replaceGet(keyUint8, valueCoins),
            uint8_bool: self.uint8_bool.replaceGet(keyUint8, valueBool),
            uint8_cell: self.uint8_cell.replaceGet(keyUint8, valueCell),
            uint8_address: self.uint8_address.replaceGet(keyUint8, valueAddress),
            uint8_struct: self.uint8_struct.replaceGet(keyUint8, valueStruct),

            uint42_int: self.uint42_int.replaceGet(keyUint42, valueInt),
            uint42_int8: self.uint42_int8.replaceGet(keyUint42, valueInt8),
            uint42_int42: self.uint42_int42.replaceGet(keyUint42, valueInt42),
            uint42_int256: self.uint42_int256.replaceGet(keyUint42, valueInt256),
            uint42_uint8: self.uint42_uint8.replaceGet(keyUint42, valueUint8),
            uint42_uint42: self.uint42_uint42.replaceGet(keyUint42, valueUint42),
            uint42_uint256: self.uint42_uint256.replaceGet(keyUint42, valueUint256),
            uint42_coins: self.uint42_coins.replaceGet(keyUint42, valueCoins),
            uint42_bool: self.uint42_bool.replaceGet(keyUint42, valueBool),
            uint42_cell: self.uint42_cell.replaceGet(keyUint42, valueCell),
            uint42_address: self.uint42_address.replaceGet(keyUint42, valueAddress),
            uint42_struct: self.uint42_struct.replaceGet(keyUint42, valueStruct),

            uint256_int: self.uint256_int.replaceGet(keyUint256, valueInt),
            uint256_int8: self.uint256_int8.replaceGet(keyUint256, valueInt8),
            uint256_int42: self.uint256_int42.replaceGet(keyUint256, valueInt42),
            uint256_int256: self.uint256_int256.replaceGet(keyUint256, valueInt256),
            uint256_uint8: self.uint256_uint8.replaceGet(keyUint256, valueUint8),
            uint256_uint42: self.uint256_uint42.replaceGet(keyUint256, valueUint42),
            uint256_uint256: self.uint256_uint256.replaceGet(keyUint256, valueUint256),
            uint256_coins: self.uint256_coins.replaceGet(keyUint256, valueCoins),
            uint256_bool: self.uint256_bool.replaceGet(keyUint256, valueBool),
            uint256_cell: self.uint256_cell.replaceGet(keyUint256, valueCell),
            uint256_address: self.uint256_address.replaceGet(keyUint256, valueAddress),
            uint256_struct: self.uint256_struct.replaceGet(keyUint256, valueStruct),

            // Address Key Maps
            address_int: self.address_int.replaceGet(keyAddress, valueInt),
            address_int8: self.address_int8.replaceGet(keyAddress, valueInt8),
            address_int42: self.address_int42.replaceGet(keyAddress, valueInt42),
            address_int256: self.address_int256.replaceGet(keyAddress, valueInt256),
            address_uint8: self.address_uint8.replaceGet(keyAddress, valueUint8),
            address_uint42: self.address_uint42.replaceGet(keyAddress, valueUint42),
            address_uint256: self.address_uint256.replaceGet(keyAddress, valueUint256),
            address_coins: self.address_coins.replaceGet(keyAddress, valueCoins),
            address_bool: self.address_bool.replaceGet(keyAddress, valueBool),
            address_cell: self.address_cell.replaceGet(keyAddress, valueCell),
            address_address: self.address_address.replaceGet(keyAddress, valueAddress),
            address_struct: self.address_struct.replaceGet(keyAddress, valueStruct)
        };
    }

    get fun existsAllMaps(
        keyInt: Int,
        keyInt8: Int,
        keyInt42: Int,
        keyInt256: Int,
        keyUint8: Int,
        keyUint42: Int,
        keyUint256: Int,
        keyAddress: Address
    ): ExistsAllMapsResult {
        return ExistsAllMapsResult {
            // Integer Key Maps
            int_int: self.int_int.exists(keyInt),
            int_int8: self.int_int8.exists(keyInt),
            int_int42: self.int_int42.exists(keyInt),
            int_int256: self.int_int256.exists(keyInt),
            int_uint8: self.int_uint8.exists(keyInt),
            int_uint42: self.int_uint42.exists(keyInt),
            int_uint256: self.int_uint256.exists(keyInt),
            int_coins: self.int_coins.exists(keyInt),
            int_bool: self.int_bool.exists(keyInt),
            int_cell: self.int_cell.exists(keyInt),
            int_address: self.int_address.exists(keyInt),
            int_struct: self.int_struct.exists(keyInt),

            int8_int: self.int8_int.exists(keyInt8),
            int8_int8: self.int8_int8.exists(keyInt8),
            int8_int42: self.int8_int42.exists(keyInt8),
            int8_int256: self.int8_int256.exists(keyInt8),
            int8_uint8: self.int8_uint8.exists(keyInt8),
            int8_uint42: self.int8_uint42.exists(keyInt8),
            int8_uint256: self.int8_uint256.exists(keyInt8),
            int8_coins: self.int8_coins.exists(keyInt8),
            int8_bool: self.int8_bool.exists(keyInt8),
            int8_cell: self.int8_cell.exists(keyInt8),
            int8_address: self.int8_address.exists(keyInt8),
            int8_struct: self.int8_struct.exists(keyInt8),

            int42_int: self.int42_int.exists(keyInt42),
            int42_int8: self.int42_int8.exists(keyInt42),
            int42_int42: self.int42_int42.exists(keyInt42),
            int42_int256: self.int42_int256.exists(keyInt42),
            int42_uint8: self.int42_uint8.exists(keyInt42),
            int42_uint42: self.int42_uint42.exists(keyInt42),
            int42_uint256: self.int42_uint256.exists(keyInt42),
            int42_coins: self.int42_coins.exists(keyInt42),
            int42_bool: self.int42_bool.exists(keyInt42),
            int42_cell: self.int42_cell.exists(keyInt42),
            int42_address: self.int42_address.exists(keyInt42),
            int42_struct: self.int42_struct.exists(keyInt42),

            int256_int: self.int256_int.exists(keyInt256),
            int256_int8: self.int256_int8.exists(keyInt256),
            int256_int42: self.int256_int42.exists(keyInt256),
            int256_int256: self.int256_int256.exists(keyInt256),
            int256_uint8: self.int256_uint8.exists(keyInt256),
            int256_uint42: self.int256_uint42.exists(keyInt256),
            int256_uint256: self.int256_uint256.exists(keyInt256),
            int256_coins: self.int256_coins.exists(keyInt256),
            int256_bool: self.int256_bool.exists(keyInt256),
            int256_cell: self.int256_cell.exists(keyInt256),
            int256_address: self.int256_address.exists(keyInt256),
            int256_struct: self.int256_struct.exists(keyInt256),

            uint8_int: self.uint8_int.exists(keyUint8),
            uint8_int8: self.uint8_int8.exists(keyUint8),
            uint8_int42: self.uint8_int42.exists(keyUint8),
            uint8_int256: self.uint8_int256.exists(keyUint8),
            uint8_uint8: self.uint8_uint8.exists(keyUint8),
            uint8_uint42: self.uint8_uint42.exists(keyUint8),
            uint8_uint256: self.uint8_uint256.exists(keyUint8),
            uint8_coins: self.uint8_coins.exists(keyUint8),
            uint8_bool: self.uint8_bool.exists(keyUint8),
            uint8_cell: self.uint8_cell.exists(keyUint8),
            uint8_address: self.uint8_address.exists(keyUint8),
            uint8_struct: self.uint8_struct.exists(keyUint8),

            uint42_int: self.uint42_int.exists(keyUint42),
            uint42_int8: self.uint42_int8.exists(keyUint42),
            uint42_int42: self.uint42_int42.exists(keyUint42),
            uint42_int256: self.uint42_int256.exists(keyUint42),
            uint42_uint8: self.uint42_uint8.exists(keyUint42),
            uint42_uint42: self.uint42_uint42.exists(keyUint42),
            uint42_uint256: self.uint42_uint256.exists(keyUint42),
            uint42_coins: self.uint42_coins.exists(keyUint42),
            uint42_bool: self.uint42_bool.exists(keyUint42),
            uint42_cell: self.uint42_cell.exists(keyUint42),
            uint42_address: self.uint42_address.exists(keyUint42),
            uint42_struct: self.uint42_struct.exists(keyUint42),

            uint256_int: self.uint256_int.exists(keyUint256),
            uint256_int8: self.uint256_int8.exists(keyUint256),
            uint256_int42: self.uint256_int42.exists(keyUint256),
            uint256_int256: self.uint256_int256.exists(keyUint256),
            uint256_uint8: self.uint256_uint8.exists(keyUint256),
            uint256_uint42: self.uint256_uint42.exists(keyUint256),
            uint256_uint256: self.uint256_uint256.exists(keyUint256),
            uint256_coins: self.uint256_coins.exists(keyUint256),
            uint256_bool: self.uint256_bool.exists(keyUint256),
            uint256_cell: self.uint256_cell.exists(keyUint256),
            uint256_address: self.uint256_address.exists(keyUint256),
            uint256_struct: self.uint256_struct.exists(keyUint256),

            // Address Key Maps
            address_int: self.address_int.exists(keyAddress),
            address_int8: self.address_int8.exists(keyAddress),
            address_int42: self.address_int42.exists(keyAddress),
            address_int256: self.address_int256.exists(keyAddress),
            address_uint8: self.address_uint8.exists(keyAddress),
            address_uint42: self.address_uint42.exists(keyAddress),
            address_uint256: self.address_uint256.exists(keyAddress),
            address_coins: self.address_coins.exists(keyAddress),
            address_bool: self.address_bool.exists(keyAddress),
            address_cell: self.address_cell.exists(keyAddress),
            address_address: self.address_address.exists(keyAddress),
            address_struct: self.address_struct.exists(keyAddress)
        };
    }

    get fun isEmptyAllMaps(): IsEmptyAllMapsResult {
        return IsEmptyAllMapsResult {
            // Integer Key Maps
            int_int: self.int_int.isEmpty(),
            int_int8: self.int_int8.isEmpty(),
            int_int42: self.int_int42.isEmpty(),
            int_int256: self.int_int256.isEmpty(),
            int_uint8: self.int_uint8.isEmpty(),
            int_uint42: self.int_uint42.isEmpty(),
            int_uint256: self.int_uint256.isEmpty(),
            int_coins: self.int_coins.isEmpty(),
            int_bool: self.int_bool.isEmpty(),
            int_cell: self.int_cell.isEmpty(),
            int_address: self.int_address.isEmpty(),
            int_struct: self.int_struct.isEmpty(),

            int8_int: self.int8_int.isEmpty(),
            int8_int8: self.int8_int8.isEmpty(),
            int8_int42: self.int8_int42.isEmpty(),
            int8_int256: self.int8_int256.isEmpty(),
            int8_uint8: self.int8_uint8.isEmpty(),
            int8_uint42: self.int8_uint42.isEmpty(),
            int8_uint256: self.int8_uint256.isEmpty(),
            int8_coins: self.int8_coins.isEmpty(),
            int8_bool: self.int8_bool.isEmpty(),
            int8_cell: self.int8_cell.isEmpty(),
            int8_address: self.int8_address.isEmpty(),
            int8_struct: self.int8_struct.isEmpty(),

            int42_int: self.int42_int.isEmpty(),
            int42_int8: self.int42_int8.isEmpty(),
            int42_int42: self.int42_int42.isEmpty(),
            int42_int256: self.int42_int256.isEmpty(),
            int42_uint8: self.int42_uint8.isEmpty(),
            int42_uint42: self.int42_uint42.isEmpty(),
            int42_uint256: self.int42_uint256.isEmpty(),
            int42_coins: self.int42_coins.isEmpty(),
            int42_bool: self.int42_bool.isEmpty(),
            int42_cell: self.int42_cell.isEmpty(),
            int42_address: self.int42_address.isEmpty(),
            int42_struct: self.int42_struct.isEmpty(),

            int256_int: self.int256_int.isEmpty(),
            int256_int8: self.int256_int8.isEmpty(),
            int256_int42: self.int256_int42.isEmpty(),
            int256_int256: self.int256_int256.isEmpty(),
            int256_uint8: self.int256_uint8.isEmpty(),
            int256_uint42: self.int256_uint42.isEmpty(),
            int256_uint256: self.int256_uint256.isEmpty(),
            int256_coins: self.int256_coins.isEmpty(),
            int256_bool: self.int256_bool.isEmpty(),
            int256_cell: self.int256_cell.isEmpty(),
            int256_address: self.int256_address.isEmpty(),
            int256_struct: self.int256_struct.isEmpty(),

            uint8_int: self.uint8_int.isEmpty(),
            uint8_int8: self.uint8_int8.isEmpty(),
            uint8_int42: self.uint8_int42.isEmpty(),
            uint8_int256: self.uint8_int256.isEmpty(),
            uint8_uint8: self.uint8_uint8.isEmpty(),
            uint8_uint42: self.uint8_uint42.isEmpty(),
            uint8_uint256: self.uint8_uint256.isEmpty(),
            uint8_coins: self.uint8_coins.isEmpty(),
            uint8_bool: self.uint8_bool.isEmpty(),
            uint8_cell: self.uint8_cell.isEmpty(),
            uint8_address: self.uint8_address.isEmpty(),
            uint8_struct: self.uint8_struct.isEmpty(),

            uint42_int: self.uint42_int.isEmpty(),
            uint42_int8: self.uint42_int8.isEmpty(),
            uint42_int42: self.uint42_int42.isEmpty(),
            uint42_int256: self.uint42_int256.isEmpty(),
            uint42_uint8: self.uint42_uint8.isEmpty(),
            uint42_uint42: self.uint42_uint42.isEmpty(),
            uint42_uint256: self.uint42_uint256.isEmpty(),
            uint42_coins: self.uint42_coins.isEmpty(),
            uint42_bool: self.uint42_bool.isEmpty(),
            uint42_cell: self.uint42_cell.isEmpty(),
            uint42_address: self.uint42_address.isEmpty(),
            uint42_struct: self.uint42_struct.isEmpty(),

            uint256_int: self.uint256_int.isEmpty(),
            uint256_int8: self.uint256_int8.isEmpty(),
            uint256_int42: self.uint256_int42.isEmpty(),
            uint256_int256: self.uint256_int256.isEmpty(),
            uint256_uint8: self.uint256_uint8.isEmpty(),
            uint256_uint42: self.uint256_uint42.isEmpty(),
            uint256_uint256: self.uint256_uint256.isEmpty(),
            uint256_coins: self.uint256_coins.isEmpty(),
            uint256_bool: self.uint256_bool.isEmpty(),
            uint256_cell: self.uint256_cell.isEmpty(),
            uint256_address: self.uint256_address.isEmpty(),
            uint256_struct: self.uint256_struct.isEmpty(),

            // Address Key Maps
            address_int: self.address_int.isEmpty(),
            address_int8: self.address_int8.isEmpty(),
            address_int42: self.address_int42.isEmpty(),
            address_int256: self.address_int256.isEmpty(),
            address_uint8: self.address_uint8.isEmpty(),
            address_uint42: self.address_uint42.isEmpty(),
            address_uint256: self.address_uint256.isEmpty(),
            address_coins: self.address_coins.isEmpty(),
            address_bool: self.address_bool.isEmpty(),
            address_cell: self.address_cell.isEmpty(),
            address_address: self.address_address.isEmpty(),
            address_struct: self.address_struct.isEmpty()
        };
    }

    get fun asCellAllMaps(): AsCellAllMapsResult {
        return AsCellAllMapsResult {
            // Integer Key Maps
            int_int: self.int_int.asCell(),
            int_int8: self.int_int8.asCell(),
            int_int42: self.int_int42.asCell(),
            int_int256: self.int_int256.asCell(),
            int_uint8: self.int_uint8.asCell(),
            int_uint42: self.int_uint42.asCell(),
            int_uint256: self.int_uint256.asCell(),
            int_coins: self.int_coins.asCell(),
            int_bool: self.int_bool.asCell(),
            int_cell: self.int_cell.asCell(),
            int_address: self.int_address.asCell(),
            int_struct: self.int_struct.asCell(),

            int8_int: self.int8_int.asCell(),
            int8_int8: self.int8_int8.asCell(),
            int8_int42: self.int8_int42.asCell(),
            int8_int256: self.int8_int256.asCell(),
            int8_uint8: self.int8_uint8.asCell(),
            int8_uint42: self.int8_uint42.asCell(),
            int8_uint256: self.int8_uint256.asCell(),
            int8_coins: self.int8_coins.asCell(),
            int8_bool: self.int8_bool.asCell(),
            int8_cell: self.int8_cell.asCell(),
            int8_address: self.int8_address.asCell(),
            int8_struct: self.int8_struct.asCell(),

            int42_int: self.int42_int.asCell(),
            int42_int8: self.int42_int8.asCell(),
            int42_int42: self.int42_int42.asCell(),
            int42_int256: self.int42_int256.asCell(),
            int42_uint8: self.int42_uint8.asCell(),
            int42_uint42: self.int42_uint42.asCell(),
            int42_uint256: self.int42_uint256.asCell(),
            int42_coins: self.int42_coins.asCell(),
            int42_bool: self.int42_bool.asCell(),
            int42_cell: self.int42_cell.asCell(),
            int42_address: self.int42_address.asCell(),
            int42_struct: self.int42_struct.asCell(),

            int256_int: self.int256_int.asCell(),
            int256_int8: self.int256_int8.asCell(),
            int256_int42: self.int256_int42.asCell(),
            int256_int256: self.int256_int256.asCell(),
            int256_uint8: self.int256_uint8.asCell(),
            int256_uint42: self.int256_uint42.asCell(),
            int256_uint256: self.int256_uint256.asCell(),
            int256_coins: self.int256_coins.asCell(),
            int256_bool: self.int256_bool.asCell(),
            int256_cell: self.int256_cell.asCell(),
            int256_address: self.int256_address.asCell(),
            int256_struct: self.int256_struct.asCell(),

            uint8_int: self.uint8_int.asCell(),
            uint8_int8: self.uint8_int8.asCell(),
            uint8_int42: self.uint8_int42.asCell(),
            uint8_int256: self.uint8_int256.asCell(),
            uint8_uint8: self.uint8_uint8.asCell(),
            uint8_uint42: self.uint8_uint42.asCell(),
            uint8_uint256: self.uint8_uint256.asCell(),
            uint8_coins: self.uint8_coins.asCell(),
            uint8_bool: self.uint8_bool.asCell(),
            uint8_cell: self.uint8_cell.asCell(),
            uint8_address: self.uint8_address.asCell(),
            uint8_struct: self.uint8_struct.asCell(),

            uint42_int: self.uint42_int.asCell(),
            uint42_int8: self.uint42_int8.asCell(),
            uint42_int42: self.uint42_int42.asCell(),
            uint42_int256: self.uint42_int256.asCell(),
            uint42_uint8: self.uint42_uint8.asCell(),
            uint42_uint42: self.uint42_uint42.asCell(),
            uint42_uint256: self.uint42_uint256.asCell(),
            uint42_coins: self.uint42_coins.asCell(),
            uint42_bool: self.uint42_bool.asCell(),
            uint42_cell: self.uint42_cell.asCell(),
            uint42_address: self.uint42_address.asCell(),
            uint42_struct: self.uint42_struct.asCell(),

            uint256_int: self.uint256_int.asCell(),
            uint256_int8: self.uint256_int8.asCell(),
            uint256_int42: self.uint256_int42.asCell(),
            uint256_int256: self.uint256_int256.asCell(),
            uint256_uint8: self.uint256_uint8.asCell(),
            uint256_uint42: self.uint256_uint42.asCell(),
            uint256_uint256: self.uint256_uint256.asCell(),
            uint256_coins: self.uint256_coins.asCell(),
            uint256_bool: self.uint256_bool.asCell(),
            uint256_cell: self.uint256_cell.asCell(),
            uint256_address: self.uint256_address.asCell(),
            uint256_struct: self.uint256_struct.asCell(),

            // Address Key Maps
            address_int: self.address_int.asCell(),
            address_int8: self.address_int8.asCell(),
            address_int42: self.address_int42.asCell(),
            address_int256: self.address_int256.asCell(),
            address_uint8: self.address_uint8.asCell(),
            address_uint42: self.address_uint42.asCell(),
            address_uint256: self.address_uint256.asCell(),
            address_coins: self.address_coins.asCell(),
            address_bool: self.address_bool.asCell(),
            address_cell: self.address_cell.asCell(),
            address_address: self.address_address.asCell(),
            address_struct: self.address_struct.asCell()
        };
    }

    //
    // Edge Cases
    //

    get fun checkNullReference(): Int {
        let m: map<Int, Int> = emptyMap();
        return m.get(0)!!;
    }

    receive(msg: CheckNullReference) {
        let m: map<Int, Int> = emptyMap();
        m.get(0)!!;
    }
}


## masterchain.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/masterchain.tact)
// not reusing previously used 136 and 137 exit codes
// because Tact reserves the codes from 128 to 255
// and now this is user-land checks 
const InvalidAddressExitCode: Int = 1136;
const MasterchainNotEnabled: Int = 1137;

fun verifyAddress(addr: Address, enabledMasterChain: Bool) {
    let addrSlice = addr.asSlice();
    nativeThrowUnless(InvalidAddressExitCode, addrSlice.bits() == 267);
    let h = addrSlice.preloadUint(11);
    if (enabledMasterChain) {
        nativeThrowUnless(InvalidAddressExitCode, (h == 1024) || (h == 1279));
    } else {
        nativeThrowIf(MasterchainNotEnabled, h == 1279);
        nativeThrowUnless(InvalidAddressExitCode, h == 1024);
    }
}

contract MasterchainTester {

    init() {
        
    }
    
    receive("DeployToWorkchain") {
        verifyAddress(sender(), false);
    }

    receive("DeployToMasterchain") {
        verifyAddress(sender(), true);
    }
}


## math.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/math.tact)
import "@stdlib/deploy";

contract MathTester with Deployable {
    init() {

    }

    get fun add(a: Int, b: Int): Int {
        return a + b;
    }

    get fun sub(a: Int, b: Int): Int {
        return a - b;
    }

    get fun mul(a: Int, b: Int): Int {
        return a * b;
    }

    get fun div(a: Int, b: Int): Int {
        return a / b;
    }

    get fun mod(a: Int, b: Int): Int {
        return a % b;
    }

    get fun shr(a: Int, b: Int): Int {
        return a >> b;
    }

    get fun shl(a: Int, b: Int): Int {
        return a << b;
    }

    get fun and(a: Int, b: Int): Int {
        return a & b;
    }

    get fun or(a: Int, b: Int): Int {
        return a | b;
    }

    get fun xor(a: Int, b: Int): Int {
        return a ^ b;
    }
    
    get fun bitwise_not(a: Int): Int {
        return ~a;
    }

    //
    // Augmented assignment
    //

    get fun addAug(a: Int, b: Int): Int {
        a += b;
        return a;
    }

    get fun subAug(a: Int, b: Int): Int {
        a -= b;
        return a;
    }

    get fun mulAug(a: Int, b: Int): Int {
        a *= b;
        return a;
    }

    get fun divAug(a: Int, b: Int): Int {
        a /= b;
        return a;
    }

    get fun modAug(a: Int, b: Int): Int {
        a %= b;
        return a;
    }

    get fun bitwiseOrAug(a: Int, b: Int): Int {
        a |= b;
        return a;
    }

    get fun bitwiseAndAug(a: Int, b: Int): Int {
        a &= b;
        return a;
    }

    get fun bitwiseXorAug(a: Int, b: Int): Int {
        a ^= b;
        return a;
    }

    //
    // Int Compare
    //

    get fun compare1(a: Int, b: Int?): Bool {
        return a == b;
    }

    get fun compare2(a: Int, b: Int?): Bool {
        return a != b;
    }

    get fun compare3(a: Int?, b: Int): Bool {
        return a == b;
    }

    get fun compare4(a: Int?, b: Int): Bool {
        return a != b;
    }

    get fun compare5(a: Int?, b: Int?): Bool {
        return a == b;
    }

    get fun compare6(a: Int?, b: Int?): Bool {
        return a != b;
    }

    get fun compare7(a: Int, b: Int): Bool {
        return a > b;
    }

    get fun compare8(a: Int, b: Int): Bool {
        return a >= b;
    }

    get fun compare9(a: Int, b: Int): Bool {
        return a < b;
    }

    get fun compare10(a: Int, b: Int): Bool {
        return a <= b;
    }

    //
    // Address Compare
    //

    get fun compare11(a: Address, b: Address): Bool {
        return a == b;
    }

    get fun compare12(a: Address, b: Address?): Bool {
        return a == b;
    }

    get fun compare13(a: Address?, b: Address): Bool {
        return a == b;
    }

    get fun compare14(a: Address?, b: Address?): Bool {
        return a == b;
    }

    get fun compare15(a: Address, b: Address): Bool {
        return a != b;
    }

    get fun compare16(a: Address, b: Address?): Bool {
        return a != b;
    }

    get fun compare17(a: Address?, b: Address): Bool {
        return a != b;
    }

    get fun compare18(a: Address?, b: Address?): Bool {
        return a != b;
    }

    //
    // Cell compare
    //

    get fun compare19(a: Cell, b: Cell): Bool {
        return a == b;
    }

    get fun compare20(a: Cell, b: Cell?): Bool {
        return a == b;
    }

    get fun compare21(a: Cell?, b: Cell): Bool {
        return a == b;
    }

    get fun compare22(a: Cell?, b: Cell?): Bool {
        return a == b;
    }

    get fun compare23(a: Cell, b: Cell): Bool {
        return a != b;
    }

    get fun compare24(a: Cell, b: Cell?): Bool {
        return a != b;
    }

    get fun compare25(a: Cell?, b: Cell): Bool {
        return a != b;
    }

    get fun compare26(a: Cell?, b: Cell?): Bool {
        return a != b;
    }

    // Compare dicts

    get fun compare27(a: map<Int, Int>, b: map<Int, Int>): Bool {
        return a == b;
    }

    get fun compare28(a: map<Int, Int>, b: map<Int, Int>): Bool {
        return a != b;
    }

    //
    // Slice compare
    //

    get fun compare29(a: Slice, b: Slice): Bool {
        return a == b;
    }

    get fun compare30(a: Slice, b: Slice?): Bool {
        return a == b;
    }

    get fun compare31(a: Slice?, b: Slice): Bool {
        return a == b;
    }

    get fun compare32(a: Slice?, b: Slice?): Bool {
        return a == b;
    }

    get fun compare33(a: Slice, b: Slice): Bool {
        return a != b;
    }

    get fun compare34(a: Slice, b: Slice?): Bool {
        return a != b;
    }

    get fun compare35(a: Slice?, b: Slice): Bool {
        return a != b;
    }

    get fun compare36(a: Slice?, b: Slice?): Bool {
        return a != b;
    }

    //
    // String compare
    //

    get fun compare37(a: String, b: String): Bool {
        return a == b;
    }

    get fun compare38(a: String, b: String?): Bool {
        return a == b;
    }

    get fun compare39(a: String?, b: String): Bool {
        return a == b;
    }

    get fun compare40(a: String?, b: String?): Bool {
        return a == b;
    }

    get fun compare41(a: String, b: String): Bool {
        return a != b;
    }

    get fun compare42(a: String, b: String?): Bool {
        return a != b;
    }

    get fun compare43(a: String?, b: String): Bool {
        return a != b;
    }

    get fun compare44(a: String?, b: String?): Bool {
        return a != b;
    }

    //
    // IsNull/IsNotNull
    //

    get fun isNull1(a: Int?): Bool {
        return a == null;
    }

    get fun isNotNull1(a: Int?): Bool {
        return a != null;
    }

    get fun isNull2(address: Address?): Bool {
        return address == null;
    }

    get fun isNotNull2(address: Address?): Bool {
        return address != null;
    }

    get fun isNull3(cell: Cell?): Bool {
        return cell == null;
    }

    get fun isNotNull3(cell: Cell?): Bool {
        return cell != null;
    }

    //
    // Advanced Math Operations
    //

    get fun log2(num: Int): Int {
        return log2(num);
    }

    get fun log(num: Int, base: Int): Int {
        return log(num, base);
    }

    get fun pow(base: Int, exp: Int): Int {
        return pow(base, exp);
    }

    get fun pow2(exp: Int): Int {
        return pow2(exp);
    }

    //
    // Precedence
    //

    get fun precedence1(): Int {
        return 5 & 6 | 1 << 5 + 11 * 3 % 12 >> 11;
    }

    get fun precedence2(): Int {
        return 5 & 6 | 1 << (5 + 11) * 3 % 12 >> 11;
    }

    get fun precedence3(): Int {
        return 5 & 6 | 1 << 5 + 11 * (3 % 12) >> 35;
    }

    get fun precedence4(): Int {
        return 5 & 6 | 1 << 5 + (11 * 3) % 12 >> 11;
    }

    get fun precedence5(): Int {
        return 5 | 6 & 8;
    }

    get fun precedence6(): Int {
        return (5 | 6) & 8;
    }

    get fun precedence7(): Int {
        return 5 ^ 6 | 7;
    }

    get fun precedence8(): Int {
        return 5 ^ 6 & 7;
    }

    get fun precedence9(): Int {
        return (5 ^ 6) | 7;
    }

    get fun precedence10(): Int {
        return 5 ^ 6 | 7 & 8;
    }

    get fun precedence11(): Int {
        return (5 ^ 6) | (7 & 8);
    }

    get fun precedence12(): Int {
        return 5 ^ (6 | 7) & 8;
    }

    get fun bitwiseNot1(x: Int): Int {
        return ~~x;
    }

    get fun bitwiseNot2(x: Int): Int {
        return ~~~x;
    }

    get fun bitwiseNot3(x: Int): Int {
        return ~-x;
    }

    get fun bitwiseNot4(x: Int): Int {
        return -~x;
    }

    get fun augmentedAnd(a: Bool, b: Bool): Bool {
        a &&= b;
        return a;
    }

    get fun augmentedOr(a: Bool, b: Bool): Bool {
        a ||= b;
        return a;
    }

    get fun augmentedShiftLeft(a: Int, b: Int): Int {
        a <<= b;
        return a;
    }

    get fun augmentedShiftRight(a: Int, b: Int): Int {
        a >>= b;
        return a;
    }
}


## mutating-methods.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/mutating-methods.tact)
asm(value key self keySize) extends mutates fun nativeUdictStoreUint(self: Cell?, keySize: Int, key: Int, value: Slice) { DICTUSET }

extends mutates fun multiply(self: Int, x: Int): Int {
    self *= x;
    return self;
}

extends fun multiplyExtends(self: Int?, x: Int): Int? {
    if (self == null) {
        return null;
    }
    return self!! * x;
}

struct Foo {
    s: Slice;
}

contract Tester {
    s: Slice;
    
    init() {
        self.s = beginCell().storeUint(3, 2).storeUint(1, 2).endCell().asSlice();
    }
    receive() {}
    
    get fun test1(): Int {
        let x: Int = beginCell().storeUint(0, 1).endCell().beginParse().loadUint(1);
        return x;
    }

    get fun test2(): Int {
        let y: Cell = beginCell().storeUint(0, 1).endCell();
        let x: Slice = beginCell().storeUint(y.beginParse().loadUint(1), 1).endCell().beginParse();
        return x.loadUint(1);
    }

    get fun test3(): Int {
        let x: Int = 3;
        x.multiply(2);
        return x;
    }

    get fun test4(): Int {
        let x: Int = 3;
        return x.multiply(2).multiply(4);
    }

    get fun test5(): Int {
        return "abc".asSlice().loadUint(8);
    }

    get fun test6() {
        emptySlice().loadRef();
    }

    get fun test7(): Int {
        return beginCell().storeInt(42, 7).asSlice().loadInt(7);
    }

    get fun test8(): Int {
        let foo: Foo = Foo {
              s: beginCell()
                 .storeUint(3, 2)
                 .storeUint(1, 2)
                 .endCell().asSlice(),  // bits: 1101
            };
        foo.s.loadBits(1); // should mutate foo.s, making it point to 101
        return foo.s.loadUint(3);  // if the previous line mutated foo.s, should return 5, otherwise 6
    }

    get fun test9(): Int {
        self.s.loadUint(1);
        return self.s.loadUint(3);
    }

    get fun test10(dict: Cell?): Cell? {
        dict.nativeUdictStoreUint(8, 123, rawSlice("456"));
        return dict;
    }

    get fun test11(x: Int?): Int? {
        x.multiplyExtends(2);
        x.multiplyExtends(2).multiplyExtends(3);
        return x.multiplyExtends(2).multiplyExtends(3);
    }
}

## optionals-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/optionals-2.tact)
fun sample3(src: Struct2?): OptStruct {
    return OptStruct{s: src};
}

fun sample4(src: Struct2): OptStruct {
    return OptStruct{s: src};
}

message Struct2 {
    v: Int;
}

struct OptStruct {
    s: Struct2?;
}

contract Opt2 {
    stateInit: StateInit;
    init() {
        self.stateInit = initOf Opt3(Struct2{v: 1});
    }

    receive("Test") {
        self.sample(Struct2{v: 1});
        self.sample(null);
        self.sample2(Struct2{v: 1});
        sample3(Struct2{v: 1});
        sample3(null);
        sample4(Struct2{v: 1});
    }

    fun sample(src: Struct2?) {

    }

    fun sample2(src: Struct2) {

    }
}

contract Opt3 {
    init(arg: Struct2?) {
        
    }
}

message OptAddr {
    x: Int as uint8;
    y: Address?;
    z: Int as uint16;
}

contract Opt4 {
    z: Int = 0;

    init() {}

    // deploy
    receive() {}

    receive(msg: OptAddr) {
        self.z = msg.z;
    }

    get fun z(): Int {
        return self.z;
    }
}


## optionals.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/optionals.tact)
import "./optionals-2.tact";
struct SomeGenericStruct {
    value1: Int;
    value2: Int;
    value3: Int;
    value4: Int;
    value5: Int;
}

struct StructWithOptionals {
    a: Int?;
    b: Bool?;
    c: Cell?;
    d: Address?;
    e: SomeGenericStruct?;
}

message Update {
    a: Int?;
    b: Bool?;
    c: Cell?;
    d: Address?;
    e: SomeGenericStruct?;
    f: StructWithOptionals?;
}

contract ContractWithOptionals {

    a: Int?;
    b: Bool?;
    c: Cell?;
    d: Address?;
    e: SomeGenericStruct?;
    f: StructWithOptionals?;

    init(a: Int?, b: Bool?, c: Cell?, d: Address?, e: SomeGenericStruct?, f: StructWithOptionals?) {
        self.a = a;
        self.b = b;
        self.c = c;
        self.d = d;
        self.e = e;
        self.f = f;

        // abi.dump(self.a);
        // abi.dump(self.b);
        // abi.dump(self.c);
        // abi.dump(self.d);
        // abi.dump(self.e);
        // abi.dump(self.f);
    }

    receive() {
        // Deploy
    }

    receive(msg: Update) {
        self.a = msg.a;
        self.b = msg.b;
        self.c = msg.c;
        self.d = msg.d;
        self.e = msg.e;
        self.f = msg.f;

        // abi.dump(self.a);
        // abi.dump(self.b);
        // abi.dump(self.c);
        // abi.dump(self.d);
        // abi.dump(self.e);
        // abi.dump(self.f);
    }

    get fun isNotNullA(): Bool {
        return self.a != null;
    }
    get fun isNotNullB(): Bool {
        return self.b != null;
    }
    get fun isNotNullC(): Bool {
        return self.c != null;
    }
    get fun isNotNullD(): Bool {
        return self.d != null;
    }
    get fun isNotNullE(): Bool {
        return self.e != null;
    }
    get fun isNotNullF(): Bool {
        return self.f != null;
    }

    get fun nullA(): Int? {
        return self.a;
    }

    get fun nullB(): Bool? {
        return self.b;
    }

    get fun nullC(): Cell? {
        return self.c;
    }

    get fun nullD(): Address? {
        return self.d;
    }

    get fun nullE(): SomeGenericStruct? {
        return self.e;
    }

    get fun nullF(): StructWithOptionals? {
        return self.f;
    }

    get fun notNullA(): Int {
        return self.a!!;
    }

    get fun notNullB(): Bool {
        return self.b!!;
    }

    get fun notNullC(): Cell {
        return self.c!!;
    }

    get fun notNullD(): Address {
        return self.d!!;
    }

    get fun notNullE(): SomeGenericStruct {
        return self.e!!;
    }

    get fun notNullF(): StructWithOptionals {
        // abi.dump(self.a);
        // abi.dump(self.b);
        // abi.dump(self.c);
        // abi.dump(self.d);
        // abi.dump(self.e);
        // abi.dump(self.f);
        return self.f!!;
    }

    get fun testVariables(): SomeGenericStruct {
        let a: SomeGenericStruct? = SomeGenericStruct{value1: 1, value2: 2, value3: 3, value4: 4, value5: 5};
        return a!!;
    }
}

## ordering.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/ordering.tact)
import "@stdlib/deploy";

struct S {
    v1: Int;
    v2: Int;
    v3: Int;
}

mutates extends fun inc(self: Int): Int {
    self = self + 1;
    return self;
}

contract A with Deployable {

    owner: Address;

    init(owner: Address) {
        self.owner = owner;
    }

    get fun create(v: Int): S {
        return S{v3: v.inc(), v2: v.inc(), v1: v.inc()}; // NOTE: Inverted order!
    } 
}

contract B with Deployable {

    get fun create(v: Int): S {
        let v1: Int = v.inc();
        let v2: Int = v.inc();
        let v3: Int = v.inc();
        
        return S{ v1, v2, v3 };
    } 
}


## random.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/random.tact)
import "@stdlib/deploy";

contract RandomContract with Deployable {

    init() {
        // do nothing
    }

    get fun randomInt(): Int {
        return randomInt();
    }

    get fun random(min: Int, max: Int): Int {
        return random(min, max);
    }
}

## receiver-empty.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/receiver-empty.tact)
contract Test {
    receive() { }
    get fun balance(): Int {
        return myBalance()
    }
}


## recursion.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/recursion.tact)
import "@stdlib/deploy";

fun factorial(n: Int): Int {
    if (n == 0) { return 1; }
    return n * factorial(n - 1);
}

contract RecursionTester with Deployable {
    get fun fib(n: Int): Int {
        if (n <= 0) { return 0; }
        if (n == 1) { return 1; }
        return self.fib(n - 1) + self.fib(n - 2); 
    }

    get fun fact(n: Int): Int {
        return factorial(n);
    }
}

## sample-jetton.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/sample-jetton.tact)
import "@stdlib/ownable";

message Mint {
    amount: Int;
    receiver: Address;
}

struct JettonData {
    totalSupply: Int;
    mintable: Bool;
    owner: Address;
    content: Cell;
    walletCode: Cell;
}

contract SampleJetton with Jetton {
    totalSupply: Int as coins;
    max_supply: Int as coins;
    owner: Address;
    content: Cell;
    mintable: Bool;

    init(owner: Address, content: Cell, max_supply: Int) {
        self.totalSupply = 0;
        self.max_supply = max_supply;
        self.owner = owner;
        self.mintable = true;
        self.content = content;
    }

    receive(msg: Mint) {
        let ctx: Context = context();
        require(ctx.sender == self.owner, "Not Owner");
        require(self.mintable, "Can't Mint Anymore");
        self.mint(msg.receiver, msg.amount, self.owner); //(to, amount, response_destination)
    }

    receive("Mint: 100") { // Public Minting
        let ctx: Context = context();
        require(self.mintable, "Can't Mint Anymore");
        self.mint(ctx.sender, 100, self.owner);
    }

    receive("Owner: MintClose") {
        let ctx: Context = context();
        require(ctx.sender == self.owner, "Not Owner");
        self.mintable = false;
    }
} 

// ============================================================================================================ //
@interface("org.ton.jetton.master")
trait Jetton with Ownable {
    totalSupply: Int; // Already set initially 
    max_supply: Int;
    mintable: Bool;
    owner: Address;
    content: Cell;

    receive(msg: TokenUpdateContent) {
        self.requireOwner();                // Allow changing content only by owner
        self.content = msg.content;         // Update content
    }

    receive(msg: TokenBurnNotification) {
        self.requireWallet(msg.owner);                     // Check wallet
        self.totalSupply = self.totalSupply - msg.amount; // Update supply

        if (msg.response_destination != null) { // Cashback
            send(SendParameters{
                to: msg.response_destination!!, 
                value: 0,
                bounce: false,
                mode: SendRemainingValue | SendIgnoreErrors,
                body: TokenExcesses{
                    queryId: msg.queryId
                }.toCell()
            });
        }
    }

    // Private Methods // 
    // @to The Address receive the Jetton token after minting
    // @amount The amount of Jetton token being minted
    // @response_destination The previous owner address
    fun mint(to: Address, amount: Int, response_destination: Address) {

        require(self.totalSupply + amount <= self.max_supply, "The total supply will be overlapping.");
        self.totalSupply = self.totalSupply + amount; // Update total supply

        let wInit: StateInit = self.getJettonWalletInit(to); // Create message
        send(SendParameters{
            to: contractAddress(wInit), 
            value: 0, 
            bounce: false,
            mode: SendRemainingValue,
            body: TokenTransferInternal{ 
                queryId: 0,
                amount: amount,
                from: myAddress(),
                response_destination: response_destination,
                forward_ton_amount: 0,
                forward_payload: emptySlice()
            }.toCell(),
            code: wInit.code,
            data: wInit.data
        });
    }

    fun requireWallet(owner: Address) {
        let ctx: Context = context();
        let wInit: StateInit = self.getJettonWalletInit(owner);
        require(contractAddress(wInit) == ctx.sender, "Invalid sender");
    }

    virtual fun getJettonWalletInit(address: Address): StateInit {
        return initOf JettonDefaultWallet(myAddress(), address);
    }

    // Get Methods //
    get fun get_jetton_data(): JettonData {
        let code: Cell = self.getJettonWalletInit(myAddress()).code;
        return JettonData{ 
            totalSupply: self.totalSupply, 
            mintable: self.mintable, 
            owner: self.owner, 
            content: self.content, 
            walletCode: code
        };
    }

    get fun get_wallet_address(owner: Address): Address {
        let wInit: StateInit = self.getJettonWalletInit(owner);
        return contractAddress(wInit);
    }
}


message(0xf8a7ea5) TokenTransfer {
    queryId: Int as uint64;
    amount: Int as coins;
    destination: Address;
    response_destination: Address?;
    custom_payload: Cell?;
    forward_ton_amount: Int as coins;
    forward_payload: Slice as remaining;
}

message(0x178d4519) TokenTransferInternal {
    queryId: Int as uint64;
    amount: Int as coins;
    from: Address;
    response_destination: Address?;
    forward_ton_amount: Int as coins;
    forward_payload: Slice as remaining;
}

message(0x7362d09c) TokenNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    from: Address;
    forward_payload: Slice as remaining; // Comment Text message when Transfer the jetton 
}

message(0x595f07bc) TokenBurn {
    queryId: Int as uint64;
    amount: Int as coins;
    owner: Address;
    response_destination: Address;
}

message(0x7bdd97de) TokenBurnNotification {
    queryId: Int as uint64;
    amount: Int as coins;
    owner: Address;
    response_destination: Address?;
}

message(0xd53276db) TokenExcesses {
    queryId: Int as uint64;
}

message TokenUpdateContent {
    content: Cell;
}



// ============================================================ //
@interface("org.ton.jetton.wallet")
contract JettonDefaultWallet {
    const minTonsForStorage: Int = ton("0.01");
    const gasConsumption: Int = ton("0.01");

    balance: Int;
    owner: Address;
    master: Address;

    init(master: Address, owner: Address) {
        self.balance = 0;
        self.owner = owner;
        self.master = master;
    }

    receive(msg: TokenTransfer) { // 0xf8a7ea5
        let ctx: Context = context(); // Check sender
        require(ctx.sender == self.owner, "Invalid sender");

        let fwdFee: Int = ctx.readForwardFee() + ctx.readForwardFee();  // Gas checks
        let final: Int =  2 * self.gasConsumption + self.minTonsForStorage + fwdFee;
        require(ctx.value > min(final, ton("0.01")), "Invalid value!!"); 

        self.balance = self.balance - msg.amount; // Update balance
        require(self.balance >= 0, "Invalid balance");

        let init: StateInit = initOf JettonDefaultWallet(self.master, msg.destination);  
        let walletAddress: Address = contractAddress(init);
        send(SendParameters{
                to: walletAddress, 
                value: 0,
                mode: SendRemainingValue, 
                bounce: false,
                body: TokenTransferInternal{
                    queryId: msg.queryId,
                    amount: msg.amount,
                    from: self.owner,
                    response_destination: msg.response_destination,
                    forward_ton_amount: msg.forward_ton_amount,
                    forward_payload: msg.forward_payload
                }.toCell(),
                code: init.code,
                data: init.data
            });
    }

    receive(msg: TokenTransferInternal) { // 0x178d4519
        let ctx: Context = context();

        if (ctx.sender != self.master) {
            let sInit: StateInit = initOf JettonDefaultWallet(self.master, msg.from);
            require(contractAddress(sInit) == ctx.sender, "Invalid sender!");
        }

        self.balance = self.balance + msg.amount;
        require(self.balance >= 0, "Invalid balance"); // Update balance

        if (msg.forward_ton_amount > 0) { 
            send(SendParameters{
                to: self.owner,
                value: msg.forward_ton_amount,
                bounce: false,
                body: TokenNotification { // 0x7362d09c - notify new owner
                    queryId: msg.queryId,
                    amount: msg.amount,
                    from: msg.from,
                    forward_payload: msg.forward_payload
                }.toCell()
            });
        }

        let msgValue: Int = self.msgValue(ctx.value);  // Get value for gas
        let fwdFee: Int = ctx.readForwardFee();
        msgValue = msgValue - msg.forward_ton_amount - fwdFee;
        // msgValue = msgValue - msg.forward_ton_amount - min(fwdFee, ton("0.01"));
        
        if (msg.response_destination != null) { // Cashback
                send(SendParameters {
                    to: msg.response_destination!!, 
                    value: msgValue,  
                    bounce: false,
                    body: TokenExcesses { // 0xd53276db
                        queryId: msg.queryId
                    }.toCell(),
                    mode: SendIgnoreErrors
                });
        }
    }

    get fun msgValue(value: Int): Int {
        let tonBalanceBeforeMsg: Int = myBalance() - value;
        let storageFee: Int = self.minTonsForStorage - min(tonBalanceBeforeMsg, self.minTonsForStorage);
        value -= storageFee + self.gasConsumption;
        return value;
    }

    receive(msg: TokenBurn) {
        let ctx: Context = context();
        require(ctx.sender == self.owner, "Invalid sender");  // Check sender

        self.balance = self.balance - msg.amount; // Update balance
        require(self.balance >= 0, "Invalid balance");

        let fwdFee: Int = ctx.readForwardFee(); // Gas checks
        require(ctx.value > fwdFee + 2 * self.gasConsumption + self.minTonsForStorage, "Invalid value - Burn");

        send(SendParameters{  // Burn tokens
            to: self.master,
            value: 0,
            mode: SendRemainingValue,
            bounce: true,
            body: TokenBurnNotification{
                queryId: msg.queryId,
                amount: msg.amount,
                owner: self.owner,
                response_destination: self.owner
            }.toCell()
        });
    }

    bounced(msg: Slice) {
        let op: Int = msg.loadUint(32);
        let queryId: Int = msg.loadUint(64);
        let jettonAmount: Int = msg.loadCoins();
        require(op == 0x178d4519 || op == 0x7bdd97de, "Invalid bounced message");
        
        self.balance = self.balance + jettonAmount; // Update balance
    }

    get fun get_wallet_data(): JettonWalletData {
        return JettonWalletData{
            balance: self.balance,
            owner: self.owner,
            master: self.master,
            walletCode: (initOf JettonDefaultWallet(self.master, self.owner)).code
        };
    }
}

struct JettonWalletData {
    balance: Int;
    owner: Address;
    master: Address;
    walletCode: Cell;
}

## semantics.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/semantics.tact)
struct SA {
    a1: Int;
    a2: SB;
}

struct SB {
    b1: Bool;
    b2: SC;
    b3: Int;
}

struct SC {
    c1: Int;
}

// Wrapper struct in order to pass maps to mutating functions. See issue #815.
// Also, it is useful for nesting maps inside maps.
struct MapWrapper {
    m: map<Int,SA>
}

/**** Auxiliary functions for structs **********/

fun getNewStruct(s: SA): SA {
    // Reassign the parameter value
    // This does not change the struct passed as parameter to the function
    s = SA {a1: 0, a2: SB {b1: false, b2: SC {c1: 0}, b3: 0}};
    return s;
}

fun copyAndModifyStruct(s: SA): SA {
    // Change some fields in the struct given as parameter
    // Since structs are passed by value, this does not change the struct passed as parameter to the function
    s.a1 += 100;
    s.a2.b2.c1 += 1;
    return s;
}

extends mutates fun reassignStruct(self: SA) {
    // Reassigning the parameter will change the struct given as parameter
    self = SA {a1: 0, a2: SB {b1: false, b2: SC {c1: 0}, b3: 0}};
}

extends mutates fun changeSomeFields(self: SA) {
    // Change some fields in the struct given as parameter
    // This will change the struct passed as parameter to the function
    self.a1 += 100;
    self.a2.b2.c1 += 1;
}

extends fun copyStruct(self: SA): SA {
    // Since structs are passed by value, "self" will be a copy of the struct given as parameter
    return self;
}

// Identity function, just to test chaining of mutating functions.
extends mutates fun reflectStruct(self: SA): SA {
    return self;
}

extends mutates fun incrementIntFields(self: SA): SA {
    self.a1 += 1;
    self.a2.b2.c1 += 1;
    self.a2.b3 += 1;
    return self;
}

extends mutates fun flipBooleanFields(self: SA): SA {
    self.a2.b1 = !self.a2.b1;
    return self;
}


/**** Auxiliary functions for maps **********/

fun getNewMap(m: map<Int,SA>): map<Int,SA> {
    // Reassign the parameter value
    // This does not change the map passed as parameter to the function
    m = emptyMap();
    
    m.set(1, SA {a1: 0, a2: SB {b1: false, b2: SC {c1: 0}, b3: 0}});

    return m;
}

fun copyAndModifyMap(m: map<Int,SA>): map<Int,SA> {
    // Change some entries in the map given as parameter
    // Since maps are passed by value, this does not change the map passed as parameter to the function

    // Note that it is not possible to directly change the struct in entry 1 like 
    // m.get(1)!!.a2.b2.c1 += 40;
    // because the compiler only allows path expressions on the left of assignments.
    // So, we need to read m.get(1) and store it in a variable:

    let c = m.get(1)!!;

    // Then change the struct field here
    c.a2.b2.c1 += 40;

    // And then reassign entry 1
    // If we do not reassign entry 1 in m, the change we did in the previous line
    // to c will not be reflected in the map m, because struct c is a copy!!! (Recall that
    // structs are assigned by value as well).
    // To check the previous claim, this function will return an emptyMap()
    // if m.get(1)!!.a2.b2.c1 == c.a2.b2.c1 at this point (which will not be true):

    if (m.get(1)!!.a2.b2.c1 == c.a2.b2.c1) {
        return emptyMap();
    }

    m.set(1, c);

    // Now delete entries 2 and 3

    m.del(2);
    m.del(3);

    return m;
}

/*
Currently, the compiler does not allow passing maps to extension (and hence mutating) functions 
in their "self" argument.

One workaround is to wrap the map using a struct, since structs are allowed in extension functions 
(see issue #815)
*/

extends mutates fun reassignMap(self: MapWrapper) {
    // Reassigning the parameter will change the map given as parameter
    self = MapWrapper {m: emptyMap()};
    self.m.set(1, SA {a1: 0, a2: SB {b1: false, b2: SC {c1: 0}, b3: 0}});
}

extends mutates fun changeSomeEntries(self: MapWrapper) {
    // Change some entries in the map given as parameter
    // This will change the map passed as parameter to the function

    // Similar to comments in function copyAndModifyMap, it is not possible
    // to directly mutate the struct in entry 1 of the map.
    // So, first make a local copy of the struct.
    
    let c = self.m.get(1)!!;

    // Modify the struct
    c.a2.b2.c1 += 30;

    // And assign it back into entry 1, because c is a copy so far.
    // To check the previous claim, this function will immediately return
    // if self.m.get(1)!!.a2.b2.c1 == c.a2.b2.c1 at this point (which will not be true):

    if (self.m.get(1)!!.a2.b2.c1 == c.a2.b2.c1) {
        return;
    }

    self.m.set(1, c);

    // Now delete entries 2 and 3

    self.m.del(2);
    self.m.del(3);
}

extends fun unwrapAndCopyMap(self: MapWrapper): map<Int,SA> {
    // Since structs are passed by value, "self" will be a copy of the wrapped map given as parameter
    // Hence, the unwrapped map is a copy of the map.
    return self.m;
}

extends mutates fun unwrapMap(self: MapWrapper): map<Int,SA> {
    // Even though "self" is a copy, the mutates function will assign the copy back into "self" once the function finishes.
    // Observe that the function will return a copy of the wrapped map as well.
    // This means that there are actually TWO assignments when one does something like this:
    // m = wm.unwrapMap();
    // After "unwrapMap" finishes execution, wm will be reassigned with the copy of self (which in this case is identical
    // to the input to "unwrapMap"), and m will be assigned with "self.m" (computed using the copy of "self").
    return self.m;
}

// Identity function, just to test chaining of mutating functions.
extends mutates fun reflectMap(self: MapWrapper): MapWrapper {
    return self;
}

/**** Auxiliary functions for contracts **********/

fun copyAndModifyContract(c: SemanticsTester): SemanticsTester {
    // Since contracts are passed by value, this function creates a copy of the contract when called.
    // In other words, c is a copy of the contract passed as parameter to the function.

    // Let us modify some fields in the copy c
    c.uB = SB {b1: true, b2: SC {c1: 99}, b3: 98};
    c.mA.del(1);

    // It is also possible to call contract functions on the copy
    // This call will not change the state of c beyond those changes in the previous lines.
    c.structAssign2();

    return c;
}

extends mutates fun changeSomeContractFields(self: SemanticsTester) {
    // Change some fields in the contract given as parameter
    // This will change the contract passed as parameter to the function
    self.uB = SB {b1: true, b2: SC {c1: 77}, b3: 88};
    self.sA.a2.b2.c1 += 30;
}

// Identity function, but as a simple extends function.
extends fun copyContract(self: SemanticsTester): SemanticsTester {
    return self;
}

// Identity function, just to test chaining of mutating functions.
extends mutates fun reflectContract(self: SemanticsTester): SemanticsTester {
    return self;
}

extends mutates fun incrementIntFieldsInUB(self: SemanticsTester): SemanticsTester {
    self.uB.b2.c1 += 1;
    self.uB.b3 += 1;
    return self;
}

extends mutates fun flipBooleanFieldsInUB(self: SemanticsTester): SemanticsTester {
    self.uB.b1 = !self.uB.b1;
    return self;
}


/**** Auxiliary functions for integers **********/

extends mutates fun multiplyBy2(self: Int): Int {
    self *= 2;
    return self;
}

extends mutates fun increment(self: Int): Int {
    self += 1;
    return self;
}

extends mutates fun doNothing(self: Int): Int {
    return self;
}


/**** Auxiliary functions for boolean expressions **********/

fun infiniteLoop(): Bool {
    while (true) {}
    return true;
}

fun throwException(v: Int): Bool {
    // I cannot use directly throw(v) because of issue #904
    // So, I will generate a division by zero
    return 1 / v > 0;
}


contract SemanticsTester {

    // Currently, declaring fields like this:
    // 
    // sC: SC = SC {c1: 5}; 
    // sB: SB = SB {b1: true, b2: sC, b3: 10};
    // sA: SA = SA {a1: 20, a2: sB};
    //
    // or like this:
    //
    // sC: SC = SC {c1: 5}; 
    // sB: SB = SB {b1: true, b2: self.sC, b3: 10};
    // sA: SA = SA {a1: 20, a2: self.sB};
    //
    // gives a compilation error. So, we need to define the fields like this:

    sC: SC = SC {c1: 5}; 
    sB: SB = SB {b1: true, b2: SC {c1: 5}, b3: 10};
    sA: SA = SA {a1: 20, a2: SB {b1: true, b2: SC {c1: 5}, b3: 10}};
    uB: SB;

    // An alternative would be to assign them in the init() function, which allows the use of self.


    // Declare some maps

    mA: map<Int,SA>;
    mB: map<Int,Bool>;
    mC: map<Int,MapWrapper>;   // Simulate nested maps by wrapping them in a struct, 
                               // "Morally", mC has type map<Int,map<Int,SA>>.


    // Flag storing the result of calling method mutateContractState.
    // So that we can get the result using a getter method

    mutateContractStateResult: Bool = false;

    init() { 

        /***** Structs *****/

        self.uB.b1 = false;       // What is the meaning of this? self.uB is not initialized.
                                  // Is this instantiating a partially constructed struct SB?
                                  // Nevertheless, it is not possible to check if it is a partially initialized
                                  // struct because the compiler will not allow referencing self.uB in an expression
                                  // until self.uB is actually assigned.
        self.uB.b2 = SC {c1: 40};
        self.uB = SB {b1: false, b2: SC {c1: 0}, b3: 11};
        self.uB.b3 = 14;          // Getter structInitCheck later checks that init respects 
                                  // this last assignment

        self.sB.b1 = false;
        self.sB.b2 = SC {c1: 3};

        
        /**** Maps *****/
        
        // Initialize the mA map
        self.mA.set(1, self.sA);     // The compiler does not complain that self.mA is not initialized, because
                                     // map fields in contracts are implicitly initialized as empty.
                                     // Function checkMapInit will later check this.
        
        // Make a copy of sA to assign a different key value pair in the map
        let s = self.sA;
        s.a2.b2.c1 = 100;
        s.a2.b3 = 0;

        self.mA.set(2, s);

        // Modify struct again to insert another key-value pair
        s.a2.b2.c1 = 150;
        s.a1 = 5;
        s.a2.b1 = false;

        self.mA.set(3, s);

        // Initialize the mC map. The nested map will contain a copy of self.sA.
        let nestedMap = MapWrapper {m: emptyMap()};
        nestedMap.m.set(10, self.sA);
        self.mC.set(100, nestedMap);
        
        /****** Contracts *****/

        /* I commented out the following code because 
           reading the self variable inside init should not be allowed. See issue #816.
        
        let contract_copy = self;
        contract_copy.sC = SC {c1: 8};
        */
    }

    receive() { }

    receive("mutate") {
        self.mutateContractStateResult = self.mutateContractState();
    }


    // IMPORTANT: The operator == does not allow comparing two structs.
    // So, to compare if two structs are equal using ==, one needs to compare each
    // field of both structs manually.


    get fun checkAllContractFieldsAreUnchanged(): Bool {
        
        let result = 
               // self.uB is correctly initialized

               self.uB.b1 == false &&
               self.uB.b2.c1 == 0 &&
               self.uB.b3 == 14 &&

               // init does not modify default value of self.sA
               
               self.sA.a1 == 20 && 
               self.sA.a2.b1 == true &&
               self.sA.a2.b2.c1 == 5 &&
               self.sA.a2.b3 == 10 &&

               // init modifies default value of self.sB

               self.sB.b1 == false &&
               self.sB.b2.c1 == 3 &&
               self.sB.b3 == 10 &&

               // init does not change default value of self.sC.

               self.sC.c1 == 5 &&

               // the map self.mB is empty
               // (self.mB == emptyMap()) &&  // Commented out because it causes an internal compiler error (see issue #808)
               self.mB == null &&    // Equivalent way of saying it is empty 
               self.mB.isEmpty() &&   // Another equivalent way of saying it is empty

               // the map self.mA has these three key-value pairs:

               self.mA.get(1)!!.a1 == 20 && 
               self.mA.get(1)!!.a2.b1 == true &&
               self.mA.get(1)!!.a2.b2.c1 == 5 &&
               self.mA.get(1)!!.a2.b3 == 10 &&

               self.mA.get(2)!!.a1 == 20 && 
               self.mA.get(2)!!.a2.b1 == true &&
               self.mA.get(2)!!.a2.b2.c1 == 100 &&
               self.mA.get(2)!!.a2.b3 == 0 &&

               self.mA.get(3)!!.a1 == 5 && 
               self.mA.get(3)!!.a2.b1 == false &&
               self.mA.get(3)!!.a2.b2.c1 == 150 &&
               self.mA.get(3)!!.a2.b3 == 0;

        // And no other entries
        foreach (k, _ in self.mA) {
            result &&= (k == 1 || k == 2 || k == 3);
        }

        // The map self.mC has a single entry 100 -> MapWrapper {m: 10 -> self.sA}.
        foreach (k1, v1 in self.mC) {
            foreach (k2, v2 in v1.m) {
                result &&= 
                         k1 == 100 && 
                         k2 == 10 &&
                         
                         v2.a1 == 20 && 
                         v2.a2.b1 == true &&
                         v2.a2.b2.c1 == 5 &&
                         v2.a2.b3 == 10;
            }
        }

        return result;
    }

    /*************** Structs ********************/

    // Assigning a struct to a variable preserves fields

    get fun structAssign1(): Bool { 
        let s = self.sA;

        // The fields of s and self.sA are equal, and the values did not change
        return s.a1 == self.sA.a1 && 
               s.a2.b1 == self.sA.a2.b1 &&
               s.a2.b2.c1 == self.sA.a2.b2.c1 &&
               s.a2.b3 == self.sA.a2.b3 &&
               s.a1 == 20 && 
               s.a2.b1 == true &&
               s.a2.b2.c1 == 5 &&
               s.a2.b3 == 10 &&
               self.checkAllContractFieldsAreUnchanged();
    }

    // Assignment of structs is done by value

    get fun structAssign2(): Bool { 
        // Make a local copy of the struct
        let s = self.sA;

        // Modify two fields in the local copy
        s.a1 = 50;
        s.a2.b2.c1 = 70;

        // Make a copy of an internal struct of s
        let t = s.a2;

        // Modify the copy
        t.b3 = 100;
        
        // self.sA remains unchanged,
        // the copy t inherits the value b2.c1 = 70 modified by s,
        // the copy s does not change its b3 field.
        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 50 && 
               s.a2.b1 == true &&
               s.a2.b2.c1 == 70 &&
               s.a2.b3 == 10 &&
               t.b1 == true &&
               t.b2.c1 == 70 &&
               t.b3 == 100;
    }

    get fun paramStruct1(): Bool {
        
        // This should not modify self.sA.

        let s = getNewStruct(self.sA);

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 0 && 
               s.a2.b1 == false &&
               s.a2.b2.c1 == 0 &&
               s.a2.b3 == 0;
    }

    get fun paramStruct2(): Bool {
        
        // This should not modify self.sA.

        let s = copyAndModifyStruct(self.sA);

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 120 && 
               s.a2.b1 == true &&
               s.a2.b2.c1 == 6 &&
               s.a2.b3 == 10;
    }

    get fun mutateParamStruct1(): Bool {

        let s = self.sA;

        // This should reassign s, but leave self.sA unchanged.

        s.reassignStruct();

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 0 && 
               s.a2.b1 == false &&
               s.a2.b2.c1 == 0 &&
               s.a2.b3 == 0;
    }

    get fun mutateParamStruct2(): Bool {

        let s = self.sA;

        // This should mutate some fields of s, but leave self.sA unchanged.
        
        s.changeSomeFields();

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 120 && 
               s.a2.b1 == true &&
               s.a2.b2.c1 == 6 &&
               s.a2.b3 == 10;
    }

    get fun testReturnedStructs(): Bool {
        // The call to the non-mutating extends function "copyStruct" always makes a copy
        // of the parameter struct. Therefore, passing the result to the mutating function 
        // "changeSomeFields" will modify the copy, not the original struct. 
    
        self.sA.copyStruct().changeSomeFields();

        let result = 
               self.checkAllContractFieldsAreUnchanged();

        // For the following test, make a copy of self.sA.
        let s = self.sA;

        // What is the effect of executing the following line?

        s.reflectStruct().changeSomeFields();

        // First, reflectStruct makes a copy of s. When reflectStruct finalizes, it assigns the copy back into
        // s. Additionally, reflectStruct returns the copy of s, call it s'. 
        // s' is then passed to changeSomeFields, which makes again a copy of s', call it s''.
        // changeSomeFields changes some fields of s'' and reassigns s' with this changed s''. 
        // Additionally changeSomeFields returns the changed s''.
        // Note that the only place where s is reassigned is after reflectStruct executes.
        // This means that the above expression does NOT change s.

        result &&=
               self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 20 &&    
               s.a2.b1 == true &&
               s.a2.b2.c1 == 5 && 
               s.a2.b3 == 10;

        // Therefore, if we actually want to change s using changeSomeFields, we 
        // should split the chain steps:

        s.reflectStruct();   // Each step changes s
        s.changeSomeFields();

        // Note that doing the trick of assigning back s
        // 
        // s = s.reflectStruct().changeSomeFields();
        //
        // is not possible because changeSomeFields has void return type.

        // s is now changed by changeSomeFields, and the rest remains the same
        result &&=
               self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 120 &&   
               s.a2.b1 == true &&
               s.a2.b2.c1 == 6 &&   
               s.a2.b3 == 10;

        // For further examples of chaining of mutating functions, see the tests mutatesChainStruct

        return result;
    }

    /*
    The following functions exemplify how to properly chain mutating functions.
    Each function in the chain returns a copy to the next function in the chain.
    Hence, to change the original variable, we need to reassign the value returned 
    from the last mutating function.
    */

    get fun mutatesChainStruct1(): Bool {
        let s = self.sA;
        s.reflectStruct().incrementIntFields().flipBooleanFields();  // s changed only by the first function
        
        let t = self.sA;
        t = t.reflectStruct().incrementIntFields().flipBooleanFields(); // Assign back to t the struct returned by the last function
        
        // The less confusing solution is to simply break the chain.
        // This solution even works when the last function in the chain has void return type.
        // Each step changes z
        let z = self.sA;
        z.reflectStruct();
        z.incrementIntFields();
        z.flipBooleanFields();

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 20 &&    
               s.a2.b1 == true &&   
               s.a2.b2.c1 == 5 &&   
               s.a2.b3 == 10 &&     

               t.a1 == 21 &&    
               t.a2.b1 == false &&   
               t.a2.b2.c1 == 6 &&    
               t.a2.b3 == 11 &&

               z.a1 == 21 &&    
               z.a2.b1 == false &&   
               z.a2.b2.c1 == 6 &&    
               z.a2.b3 == 11;                

    }

    get fun mutatesChainStruct2(): Bool {
        let s = self.sA;
        s.reflectStruct().flipBooleanFields().incrementIntFields();
        
        let t = self.sA;
        t = t.reflectStruct().flipBooleanFields().incrementIntFields();
        
        let z = self.sA;
        z.reflectStruct();
        z.flipBooleanFields();
        z.incrementIntFields();

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 20 &&    
               s.a2.b1 == true &&   
               s.a2.b2.c1 == 5 &&   
               s.a2.b3 == 10 &&     

               t.a1 == 21 &&    
               t.a2.b1 == false &&   
               t.a2.b2.c1 == 6 &&    
               t.a2.b3 == 11 &&

               z.a1 == 21 &&    
               z.a2.b1 == false &&   
               z.a2.b2.c1 == 6 &&    
               z.a2.b3 == 11;
    }

    get fun mutatesChainStruct3(): Bool {
        let s = self.sA;
        s.incrementIntFields().reflectStruct().flipBooleanFields();

        let t = self.sA;
        t = t.incrementIntFields().reflectStruct().flipBooleanFields();
        
        let z = self.sA;
        z.incrementIntFields();
        z.reflectStruct();
        z.flipBooleanFields();

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 21 &&    
               s.a2.b1 == true &&   
               s.a2.b2.c1 == 6 &&   
               s.a2.b3 == 11 &&     

               t.a1 == 21 &&    
               t.a2.b1 == false &&   
               t.a2.b2.c1 == 6 &&    
               t.a2.b3 == 11 &&

               z.a1 == 21 &&    
               z.a2.b1 == false &&   
               z.a2.b2.c1 == 6 &&    
               z.a2.b3 == 11;
    }

    get fun mutatesChainStruct4(): Bool {
        let s = self.sA;
        s.incrementIntFields().flipBooleanFields().reflectStruct();

        let t = self.sA;
        t = t.incrementIntFields().flipBooleanFields().reflectStruct();

        let z = self.sA;
        z.incrementIntFields();
        z.flipBooleanFields();
        z.reflectStruct();

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 21 &&    
               s.a2.b1 == true &&   
               s.a2.b2.c1 == 6 &&   
               s.a2.b3 == 11 &&     

               t.a1 == 21 &&    
               t.a2.b1 == false &&   
               t.a2.b2.c1 == 6 &&    
               t.a2.b3 == 11 &&

               z.a1 == 21 &&    
               z.a2.b1 == false &&   
               z.a2.b2.c1 == 6 &&    
               z.a2.b3 == 11;
    }    

    get fun mutatesChainStruct5(): Bool {
        let s = self.sA;
        s.flipBooleanFields().incrementIntFields().reflectStruct();

        let t = self.sA;
        t = t.flipBooleanFields().incrementIntFields().reflectStruct();

        let z = self.sA;
        z.flipBooleanFields();
        z.incrementIntFields();
        z.reflectStruct();

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 20 &&    
               s.a2.b1 == false &&   
               s.a2.b2.c1 == 5 &&   
               s.a2.b3 == 10 &&     

               t.a1 == 21 &&    
               t.a2.b1 == false &&   
               t.a2.b2.c1 == 6 &&    
               t.a2.b3 == 11 &&

               z.a1 == 21 &&    
               z.a2.b1 == false &&   
               z.a2.b2.c1 == 6 &&    
               z.a2.b3 == 11;
    }

    get fun mutatesChainStruct6(): Bool {
        let s = self.sA;
        s.flipBooleanFields().reflectStruct().incrementIntFields();

        let t = self.sA;
        t = t.flipBooleanFields().reflectStruct().incrementIntFields();

        let z = self.sA;
        z.flipBooleanFields();
        z.reflectStruct();
        z.incrementIntFields();

        return self.checkAllContractFieldsAreUnchanged() &&
               s.a1 == 20 &&    
               s.a2.b1 == false &&   
               s.a2.b2.c1 == 5 &&   
               s.a2.b3 == 10 &&     

               t.a1 == 21 &&    
               t.a2.b1 == false &&   
               t.a2.b2.c1 == 6 &&    
               t.a2.b3 == 11 &&

               z.a1 == 21 &&    
               z.a2.b1 == false &&   
               z.a2.b2.c1 == 6 &&    
               z.a2.b3 == 11;
    }


    /*************** Maps ********************/

    // Assigning a map to a variable preserves contents

    get fun mapAssign1(): Bool { 
        let s = self.mA;

        // The entries of s and self.mA are equal, and the values did not change
        let result = 
               self.mA.get(1)!!.a1 == s.get(1)!!.a1 && 
               self.mA.get(1)!!.a2.b1 == s.get(1)!!.a2.b1 &&
               self.mA.get(1)!!.a2.b2.c1 == s.get(1)!!.a2.b2.c1 &&
               self.mA.get(1)!!.a2.b3 == s.get(1)!!.a2.b3 &&

               self.mA.get(2)!!.a1 == s.get(2)!!.a1 && 
               self.mA.get(2)!!.a2.b1 == s.get(2)!!.a2.b1 &&
               self.mA.get(2)!!.a2.b2.c1 == s.get(2)!!.a2.b2.c1 &&
               self.mA.get(2)!!.a2.b3 == s.get(2)!!.a2.b3 &&

               self.mA.get(3)!!.a1 == s.get(3)!!.a1 && 
               self.mA.get(3)!!.a2.b1 == s.get(3)!!.a2.b1 &&
               self.mA.get(3)!!.a2.b2.c1 == s.get(3)!!.a2.b2.c1 &&
               self.mA.get(3)!!.a2.b3 == s.get(3)!!.a2.b3 &&

               s.get(1)!!.a1 == 20 && 
               s.get(1)!!.a2.b1 == true &&
               s.get(1)!!.a2.b2.c1 == 5 &&
               s.get(1)!!.a2.b3 == 10 &&

               s.get(2)!!.a1 == 20 && 
               s.get(2)!!.a2.b1 == true &&
               s.get(2)!!.a2.b2.c1 == 100 &&
               s.get(2)!!.a2.b3 == 0 &&

               s.get(3)!!.a1 == 5 && 
               s.get(3)!!.a2.b1 == false &&
               s.get(3)!!.a2.b2.c1 == 150 &&
               s.get(3)!!.a2.b3 == 0 &&
               self.checkAllContractFieldsAreUnchanged();
        
        // And no other entries
        foreach (k, _ in s) {
            result &&= (k == 1 || k == 2 || k == 3);
        }

        return result;
    }

    // Assignment of maps is done by value

    get fun mapAssign2(): Bool { 
        // Make a local copy of the map
        let s = self.mA;

        // Modify an entry in the local copy
        s.set(1, SA {a1: 0, a2: SB {b1: false, b2: self.sC, b3: 2}});

        // The compiler does not allow directly changing the contents of a struct inside an entry:
        // s.get(2)!!.a2.b2.c1 = 7;
        // Only path expressions are allowed on the left of the assignment operator =
        
        // self.mA remains unchanged (including the rest of fields)
        // The rest of the entries in s remain identical to self.mA.
        let result = 
               self.checkAllContractFieldsAreUnchanged() &&
               
               s.get(1)!!.a1 == 0 && 
               s.get(1)!!.a2.b1 == false &&
               s.get(1)!!.a2.b2.c1 == 5 &&
               s.get(1)!!.a2.b3 == 2 &&

               s.get(2)!!.a1 == 20 && 
               s.get(2)!!.a2.b1 == true &&
               s.get(2)!!.a2.b2.c1 == 100 &&
               s.get(2)!!.a2.b3 == 0 &&

               s.get(3)!!.a1 == 5 && 
               s.get(3)!!.a2.b1 == false &&
               s.get(3)!!.a2.b2.c1 == 150 &&
               s.get(3)!!.a2.b3 == 0;

        // And no other entries
        foreach (k, _ in s) {
            result &&= (k == 1 || k == 2 || k == 3);
        }

        return result;
    }

    get fun paramMap1(): Bool {
        
        // This should not modify self.mA.

        let s = getNewMap(self.mA);

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&
               s.get(1)!!.a1 == 0 && 
               s.get(1)!!.a2.b1 == false &&
               s.get(1)!!.a2.b2.c1 == 0 &&
               s.get(1)!!.a2.b3 == 0;
        
        // And no other entries 
        foreach (k, _ in s) {
            result &&= k == 1;
        }

        return result;
    }

    get fun paramMap2(): Bool {
        
        // This should not modify self.mA.
        // In the copy: it will delete entries 2 and 3 and modify entry 1.
        let s = copyAndModifyMap(self.mA);

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&
               s.get(1)!!.a1 == 20 && 
               s.get(1)!!.a2.b1 == true &&
               s.get(1)!!.a2.b2.c1 == 45 &&
               s.get(1)!!.a2.b3 == 10;
        
        // And no other entries 
        foreach (k, _ in s) {
            result &&= k == 1;
        }

        return result;
    }

    get fun mutateParamMap1(): Bool {

        let s = MapWrapper {m: self.mA};

        // This should reassign s.m, but leave self.mA unchanged.

        s.reassignMap();

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&
               s.m.get(1)!!.a1 == 0 && 
               s.m.get(1)!!.a2.b1 == false &&
               s.m.get(1)!!.a2.b2.c1 == 0 &&
               s.m.get(1)!!.a2.b3 == 0;
        
        // And no other entries 
        foreach (k, _ in s.m) {
            result &&= k == 1;
        }

        return result;
    }

    get fun mutateParamMap2(): Bool {

        let s = MapWrapper {m: self.mA};

        // This should mutate entry 1 in s.m, and delete entries 2 and 3, but leave self.mA unchanged.
        
        s.changeSomeEntries();

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&
               s.m.get(1)!!.a1 == 20 && 
               s.m.get(1)!!.a2.b1 == true &&
               s.m.get(1)!!.a2.b2.c1 == 35 &&
               s.m.get(1)!!.a2.b3 == 10;
        
        // And no other entries 
        foreach (k, _ in s.m) {
            result &&= k == 1;
        }

        return result;
    }

    get fun testReturnedMaps1(): Bool {
        // The "get" function for maps always creates a copy of the input map 
        // because "get" is a non-mutating function. This means that
        // the following expression will not change the struct in entry 2 of self.mA,
        // even if "changeSomeFields" is a mutating function for structs.
        // The mutating function "changeSomeFields" is changing the copy
        // returned by "get".

        self.mA.get(2)!!.changeSomeFields();

        // Everything remains the same

        return self.checkAllContractFieldsAreUnchanged();
    } 

    /* 
    The following test cannot be carried out because FunC reports errors. See issue #866.
    But the comments inside the test are good hypotheses of what I expect it will happen 
    when the issue is resolved, because this is what happens in the case of structs (see 
    function testReturnedStructs).

    get fun testReturnedMaps2(): Bool {
        // The call to the non-mutating extends function "unwrapAndCopyMap" always makes a copy
        // of the parameter. Therefore, passing the result to the mutating function 
        // "del" will modify the copy, not the original. 

        let wm = MapWrapper {m: self.mA};

        wm.unwrapAndCopyMap().del(1);  // FunC error: issue #866

        // The contract fields remain the same and also wm
        let result = 
               self.checkAllContractFieldsAreUnchanged() &&
               wm.m.get(1)!!.a1 == 20 && 
               wm.m.get(1)!!.a2.b1 == true &&
               wm.m.get(1)!!.a2.b2.c1 == 5 &&
               wm.m.get(1)!!.a2.b3 == 10 &&

               wm.m.get(2)!!.a1 == 20 && 
               wm.m.get(2)!!.a2.b1 == true &&
               wm.m.get(2)!!.a2.b2.c1 == 100 &&
               wm.m.get(2)!!.a2.b3 == 0 &&

               wm.m.get(3)!!.a1 == 5 && 
               wm.m.get(3)!!.a2.b1 == false &&
               wm.m.get(3)!!.a2.b2.c1 == 150 &&
               wm.m.get(3)!!.a2.b3 == 0;

        foreach (k, _ in wm.m) {
            result &&= (k == 1 || k == 2 || k == 3);
        }

        // Instead, passing "wm" to the mutating function "unwrapMap", 
        // will return a copy of "wm.m", which is then given as input to "del".
        // This means that the following expression does not delete entry 1
        // from wm.m, but deleted from the copy of wm.m:

        wm.unwrapMap().del(1);  // FunC error: issue #866

        // The contract fields remain the same and also wm
        result &&=
               self.checkAllContractFieldsAreUnchanged() &&
               wm.m.get(1)!!.a1 == 20 && 
               wm.m.get(1)!!.a2.b1 == true &&
               wm.m.get(1)!!.a2.b2.c1 == 5 &&
               wm.m.get(1)!!.a2.b3 == 10 &&

               wm.m.get(2)!!.a1 == 20 && 
               wm.m.get(2)!!.a2.b1 == true &&
               wm.m.get(2)!!.a2.b2.c1 == 100 &&
               wm.m.get(2)!!.a2.b3 == 0 &&

               wm.m.get(3)!!.a1 == 5 && 
               wm.m.get(3)!!.a2.b1 == false &&
               wm.m.get(3)!!.a2.b2.c1 == 150 &&
               wm.m.get(3)!!.a2.b3 == 0;

        foreach (k, _ in wm.m) {
            result &&= (k == 1 || k == 2 || k == 3);
        }

        // Since unwrapMap always returns a copy of wm.m, it is not possible 
        // to delete entries indirectly through the use of unwrapMap.
        // Therefore, the only way is to directly unwrap the map:

        wm.m.del(1);

        // The contract fields remain the same and wm only lost entry 1
        result &&=
               self.checkAllContractFieldsAreUnchanged() &&

               wm.m.get(2)!!.a1 == 20 && 
               wm.m.get(2)!!.a2.b1 == true &&
               wm.m.get(2)!!.a2.b2.c1 == 100 &&
               wm.m.get(2)!!.a2.b3 == 0 &&

               wm.m.get(3)!!.a1 == 5 && 
               wm.m.get(3)!!.a2.b1 == false &&
               wm.m.get(3)!!.a2.b2.c1 == 150 &&
               wm.m.get(3)!!.a2.b3 == 0;

        foreach (k, _ in wm.m) {
            result &&= (k == 2 || k == 3);
        }

        // Hence, chaining mutating functions to attempt to delete another entry,
        // will not change wm, because those functions always return copies:

        wm.reflectMap().unwrapMap().del(2);  // FunC error: issue #866

        // The contract fields remain the same and wm remains as in the previous step
        result &&=
               self.checkAllContractFieldsAreUnchanged() &&

               wm.m.get(2)!!.a1 == 20 && 
               wm.m.get(2)!!.a2.b1 == true &&
               wm.m.get(2)!!.a2.b2.c1 == 100 &&
               wm.m.get(2)!!.a2.b3 == 0 &&

               wm.m.get(3)!!.a1 == 5 && 
               wm.m.get(3)!!.a2.b1 == false &&
               wm.m.get(3)!!.a2.b2.c1 == 150 &&
               wm.m.get(3)!!.a2.b3 == 0;

        foreach (k, _ in wm.m) {
            result &&= (k == 2 || k == 3);
        }

        return result;
    }
    
    FINISHES Test that cannot be carried out.
    */

    get fun mutateNestedMap1(): Bool {
        // Make a local copy of self.mC for the tests.
        let m = self.mC;

        // The map m has the single entry 100 -> MapWrap {m: 10 -> copy of self.sA}
        
        // Modify the internal struct in m 
        // This should not change self.mC.

        // Note that it is not possible to change the internal struct directly using:

        // m.get(100)!!.m.get(10)!!.a2.b2.c1 = XXX;
        
        // because the left side of an assignment must be a path expression.
        // Hence, we need to assign the struct first into a variable:

        let s = m.get(100)!!.m.get(10)!!;

        // But recall that s is a COPY of the struct inside the nested map (since assignments are always by value).
        // Indeed, if we change s, the nested map in m does not change.

        s.a2.b2.c1 = 1000;

        // Check that s does change 

        let result = s.a1 == 20 && 
                     s.a2.b1 == true &&
                     s.a2.b2.c1 == 1000 &&
                     s.a2.b3 == 10;

        // But m does not change
        foreach (k1, v1 in m) {
            foreach (k2, v2 in v1.m) {
                result &&=
                         k1 == 100 && 
                         k2 == 10 &&
                         
                         v2.a1 == 20 && 
                         v2.a2.b1 == true &&
                         v2.a2.b2.c1 == 5 &&
                         v2.a2.b3 == 10;
            }
        }

        // Hence, we need to assign s back into m

        // However, the following expression will not work,
        // because the "get" function always makes a copy of "m" (see test "testReturnedMaps1" above).
        // m.get(100)!!.m.set(10, s);

        // This means we are forced to update the entire entry for key 100. 
        
        // The fact that "get" always returns copies of nested structures has one big consequence: 
        // it is not possible to update a deeply nested map without rebuilding the map of the root
        // key that leads to the updated nested map, i.e.,
        // if the map is:
        // key1 -> [
        //          key1.1 -> [key1.1.1 -> val1], 
        //          key1.2 -> [key1.2.1 -> val2]
        //         ]
        // Then, updating the entry key1.1.1 with value val3 would require 
        // updating key1 with 
        //         [
        //          key1.1 -> [key1.1.1 -> val3], 
        //          key1.2 -> [key1.2.1 -> val2]
        //         ]

        // First build the map containing the updated s and wrap it
        let nestedMap1: map<Int,SA> = emptyMap();
        nestedMap1.set(10, s);
        let wrappedNested1 = MapWrapper {m: nestedMap1};

        // As a side note: we can also achieve the same result by doing this:
        let wrappedNested2 = MapWrapper {m: emptyMap()};
        wrappedNested2.m.set(10, s);

        // Indeed, wrappedNested1 and wrappedNested2 are equal

        foreach (k2, v2 in wrappedNested1.m) {
                result &&=
                k2 == 10 &&
                         
                v2.a1 == 20 && 
                v2.a2.b1 == true &&
                v2.a2.b2.c1 == 1000 &&
                v2.a2.b3 == 10;
        }

        foreach (k2, v2 in wrappedNested2.m) {
                result &&=
                k2 == 10 &&
                         
                v2.a1 == 20 && 
                v2.a2.b1 == true &&
                v2.a2.b2.c1 == 1000 &&
                v2.a2.b3 == 10;
        }

        // Finally, assign the wrapped map to the key 100
        m.set(100, wrappedNested1);

        // Check that m changed

        foreach (k1, v1 in m) {
            foreach (k2, v2 in v1.m) {
                result &&=
                         k1 == 100 && 
                         k2 == 10 &&
                         
                         v2.a1 == 20 && 
                         v2.a2.b1 == true &&
                         v2.a2.b2.c1 == 1000 &&
                         v2.a2.b3 == 10;
            }
        }

        // The rest of the fields in the contract did not change (including self.mC).
        result &&= self.checkAllContractFieldsAreUnchanged();

        return result;
    }

    /*************** Contracts ********************/

    get fun contractAssign1(): Bool {
        
        // Contract assignment works by value, which means that a copy of the contract is created 
        // during assignment.
        
        let c = self;

        // What does it mean that c is a copy? It does NOT mean that 
        // there is a new contract c deployed in the TON network. In fact, both c and self
        // have the same address. Why? An address is determined by the initial state and code
        // of the contract, and since c was created from the state of self AFTER self was deployed,
        // c must have the same address. Indeed, there is a test in "semantics.spec.ts" testing that
        // the address of "self" does not change after "self" is reassigned with a modified copy of itself.
        
        // Even though the states of c and self may diverge from this moment 
        // (for example, by explicitly changing a field in c),
        // the state of c does not have existence beyond the execution of the TVM, i.e.,
        // as long as "self = c" is never executed, the state of c will be lost as soon as 
        // the TVM finishes executing the transaction, because the state of c will never 
        // be persisted back into the network. So, in a sense, c is like a struct storing temporal values 
        // for the fields in self.

        // Nevertheless, it is possible to call declared contract functions on c.
        // For example, getter checkAllContractFieldsAreUnchanged is called both on self
        // and c below, which implies that both self and c have identical state so far.

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&

               // Note that this will check that the state of the copy is identical to self.
               c.checkAllContractFieldsAreUnchanged();

        return result;
    }

    get fun contractAssign2(): Bool {
        
        // Contract assignment works by value, which means that a copy of the contract is created 
        // during assignment.
        
        let c = self;

        // Delete entries 1 and 2 in c.mA. This should not affect self.
        c.mA.del(1);
        c.mA.del(2);

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&
               
               c.uB.b1 == false &&
               c.uB.b2.c1 == 0 &&
               c.uB.b3 == 14 &&
               
               c.sA.a1 == 20 && 
               c.sA.a2.b1 == true &&
               c.sA.a2.b2.c1 == 5 &&
               c.sA.a2.b3 == 10 &&

               c.sB.b1 == false &&
               c.sB.b2.c1 == 3 &&
               c.sB.b3 == 10 &&

               c.sC.c1 == 5 &&

               c.mB.isEmpty() && 

               // the map c.mA has one key-value pair:

               c.mA.get(3)!!.a1 == 5 && 
               c.mA.get(3)!!.a2.b1 == false &&
               c.mA.get(3)!!.a2.b2.c1 == 150 &&
               c.mA.get(3)!!.a2.b3 == 0;

        // And no other entries
        foreach (k, _ in c.mA) {
            result &&= k == 3;
        }

        return result;
    }


    get fun paramContract(): Bool {
        
        // This should not modify self.
        // This function will copy self and do the following changes to the copy: 
        // Change the uB field and delete entry 1 in mA.

        let c = copyAndModifyContract(self);

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&
               
               c.uB.b1 == true &&
               c.uB.b2.c1 == 99 &&
               c.uB.b3 == 98 &&
               
               c.sA.a1 == 20 && 
               c.sA.a2.b1 == true &&
               c.sA.a2.b2.c1 == 5 &&
               c.sA.a2.b3 == 10 &&

               c.sB.b1 == false &&
               c.sB.b2.c1 == 3 &&
               c.sB.b3 == 10 &&

               c.sC.c1 == 5 &&

               c.mB.isEmpty() && 

               // the map c.mA has two key-value pairs:

               c.mA.get(2)!!.a1 == 20 && 
               c.mA.get(2)!!.a2.b1 == true &&
               c.mA.get(2)!!.a2.b2.c1 == 100 &&
               c.mA.get(2)!!.a2.b3 == 0 &&

               c.mA.get(3)!!.a1 == 5 && 
               c.mA.get(3)!!.a2.b1 == false &&
               c.mA.get(3)!!.a2.b2.c1 == 150 &&
               c.mA.get(3)!!.a2.b3 == 0;

        // And no other entries
        foreach (k, _ in c.mA) {
            result &&= (k == 2 || k == 3);
        }

        return result;
    }

    get fun mutateParamContract(): Bool {

        // First, make a copy of the contract
        let c = self;
        
        // This should not modify self.
        // In the copy: it will change the uB field and the sA.a2.b2.c1 field.
        
        c.changeSomeContractFields();

        /* If we were not in a getter function we could persist the changes in the copy 
           back into persistent storage, by writing:
           
           self = c;
           
           Nevertheless, the compiler does not report such line as an error inside a getter 
           function: see issue #818
        */

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&

               c.uB.b1 == true &&
               c.uB.b2.c1 == 77 &&
               c.uB.b3 == 88 &&

               c.sA.a1 == 20 && 
               c.sA.a2.b1 == true &&
               c.sA.a2.b2.c1 == 35 &&
               c.sA.a2.b3 == 10 &&

               c.sB.b1 == false &&
               c.sB.b2.c1 == 3 &&
               c.sB.b3 == 10 &&

               c.sC.c1 == 5 &&

               c.mB.isEmpty() && 

               c.mA.get(1)!!.a1 == 20 && 
               c.mA.get(1)!!.a2.b1 == true &&
               c.mA.get(1)!!.a2.b2.c1 == 5 &&
               c.mA.get(1)!!.a2.b3 == 10 &&

               c.mA.get(2)!!.a1 == 20 && 
               c.mA.get(2)!!.a2.b1 == true &&
               c.mA.get(2)!!.a2.b2.c1 == 100 &&
               c.mA.get(2)!!.a2.b3 == 0 &&

               c.mA.get(3)!!.a1 == 5 && 
               c.mA.get(3)!!.a2.b1 == false &&
               c.mA.get(3)!!.a2.b2.c1 == 150 &&
               c.mA.get(3)!!.a2.b3 == 0;

        // And no other entries
        foreach (k, _ in c.mA) {
            result &&= (k == 1 || k == 2 || k == 3);
        }

        return result;
    }

    get fun address(): Address {
        return myAddress();
    }

    // Check if fields uB and sA.a2.b2.c1 are equal to the provided parameters,
    // and that the rest of fields remained unchanged.

    fun checkFieldsEqualTo(sB: SB, n: Int): Bool {
        let result = 
               self.uB.b1 == sB.b1 &&
               self.uB.b2.c1 == sB.b2.c1 &&
               self.uB.b3 == sB.b3 &&

               self.sA.a1 == 20 && 
               self.sA.a2.b1 == true &&
               self.sA.a2.b2.c1 == n &&
               self.sA.a2.b3 == 10 &&

               self.sB.b1 == false &&
               self.sB.b2.c1 == 3 &&
               self.sB.b3 == 10 &&

               self.sC.c1 == 5 &&

               self.mB.isEmpty() && 

               self.mA.get(1)!!.a1 == 20 && 
               self.mA.get(1)!!.a2.b1 == true &&
               self.mA.get(1)!!.a2.b2.c1 == 5 &&
               self.mA.get(1)!!.a2.b3 == 10 &&

               self.mA.get(2)!!.a1 == 20 && 
               self.mA.get(2)!!.a2.b1 == true &&
               self.mA.get(2)!!.a2.b2.c1 == 100 &&
               self.mA.get(2)!!.a2.b3 == 0 &&

               self.mA.get(3)!!.a1 == 5 && 
               self.mA.get(3)!!.a2.b1 == false &&
               self.mA.get(3)!!.a2.b2.c1 == 150 &&
               self.mA.get(3)!!.a2.b3 == 0;

        // And no other entries
        foreach (k, _ in self.mA) {
            result &&= (k == 1 || k == 2 || k == 3);
        }

        // The map self.mC has a single entry 100 -> MapWrapper {m: 10 -> original self.sA}.
        foreach (k1, v1 in self.mC) {
            foreach (k2, v2 in v1.m) {
                result &&=
                         k1 == 100 && 
                         k2 == 10 &&
                         
                         v2.a1 == 20 && 
                         v2.a2.b1 == true &&
                         v2.a2.b2.c1 == 5 &&
                         v2.a2.b3 == 10;
            }
        }

        return result;
    }

    fun mutateContractState(): Bool {
        // First, make a copy of the contract
        let c = self;
        
        // In the copy, change the uB field and the sA.a2.b2.c1 field.
        
        c.changeSomeContractFields();

        let result = 
               self.checkAllContractFieldsAreUnchanged() &&

               // This line tests that method calls on copies actually use the state of the copy.
               c.checkFieldsEqualTo(SB {b1: true, b2: SC {c1: 77}, b3: 88}, 35);

        // Persist the copy into self
        
        self = c;

        // Now, check that the changes in c are now in self.
        // Note that checkFieldsEqualTo is called on self now.

        result &&= self.checkFieldsEqualTo(SB {b1: true, b2: SC {c1: 77}, b3: 88}, 35);

        return result;
    }

    get fun testReturnedContracts(): Bool {
        // The call to the non-mutating extends function "copyContract" always makes a copy
        // of the parameter contract. Therefore, passing the result to the mutating function 
        // "changeSomeContractFields" will modify the copy, not the original contract. 
    
        self.copyContract().changeSomeContractFields();

        let result = 
               self.checkAllContractFieldsAreUnchanged();

        // For the following test, make a copy of self.
        let c = self;

        // Now consider this expression:

        c.reflectContract().changeSomeContractFields();

        // Again, passing "c" to the mutating function "reflectContract",
        // will reassign back to c a copy of c, but it will also pass the copy of c to 
        // changeSomeContractFields.
        // This means that the above expression will not modify c.
        // Note that since the return type of changeSomeContractFields is void,
        // we cannot use the trick:
        // 
        // c = c.reflectContract().changeSomeContractFields();
        //
        // to actually update c. Hence, the only ways are to directly call 
        // changeSomeContractFields or divide the expression into steps:
        // 
        // c.changeSomeContractFields();
        // 
        // or:
        // 
        // c.reflectContract();  
        // c.changeSomeContractFields();

        // Nothing changed
        result &&=
               self.checkAllContractFieldsAreUnchanged() &&
               c.checkAllContractFieldsAreUnchanged();

        // When chaining mutating functions, one needs to reassign c in order to mutate it,
        // because the chain passes copies to the next mutating function,
        // and the copy returned by the last mutating function will be lost 
        // if not reassigned back into c:
        
        c = c.reflectContract().incrementIntFieldsInUB().flipBooleanFieldsInUB();

        // c is now changed, the rest remains the same.
        result &&=
               self.checkAllContractFieldsAreUnchanged() &&
               c.checkFieldsEqualTo(SB {b1: true, b2: SC {c1: 1}, b3: 15}, 5);

        return result;

    }

    get fun mutateContractStateFlag(): Bool {   
        return self.mutateContractStateResult;
    }

    get fun changesPersisted(): Bool {
        return self.checkFieldsEqualTo(SB {b1: true, b2: SC {c1: 77}, b3: 88}, 35);
    }


    /*************** Integers ********************/

    /*
    The following functions exemplify how to properly chain mutating functions.
    Each function in the chain returns a copy to the next function in the chain.
    Hence, to change the original variable, we need to reassign the value returned 
    from the last mutating function.

    Another way that is actually less confusing, is to simply break the chain
    into single steps.

    */
    get fun mutatesChainInt1(): Bool {
        let s = 2;
        s.multiplyBy2().increment().doNothing();  // s is changed only by the first mutating function.
        
        let t = 2;
        t = t.multiplyBy2().increment().doNothing(); // t reassigned with the value returned by the last function.
        
        // The less confusing solution is to simply break the chain.
        // This solution even works when the last function in the chain has void return type.
        // Each step changes z

        let z = 2;
        z.multiplyBy2();
        z.increment();
        z.doNothing();

        return s == 4 && t == 5 && z == 5;
    }

    get fun mutatesChainInt2(): Bool {
        let s = 2;
        s.multiplyBy2().doNothing().increment();
        
        let t = 2;
        t = t.multiplyBy2().doNothing().increment();  
        
        let z = 2;
        z.multiplyBy2();
        z.doNothing();
        z.increment();  

        return s == 4 && t == 5 && z == 5;
    }

    get fun mutatesChainInt3(): Bool {
        let s = 2;
        s.doNothing().multiplyBy2().increment();

        let t = 2;
        t = t.doNothing().multiplyBy2().increment();
        
        let z = 2;
        z.doNothing();
        z.multiplyBy2();
        z.increment();

        return s == 2 && t == 5 && z == 5;
    }

    get fun mutatesChainInt4(): Bool {
        let s = 2;
        s.doNothing().increment().multiplyBy2();

        let t = 2;
        t = t.doNothing().increment().multiplyBy2();

        let z = 2;
        z.doNothing();
        z.increment();
        z.multiplyBy2();

        return s == 2 && t == 6 && z == 6;
    }    

    get fun mutatesChainInt5(): Bool {
        let s = 2;
        s.increment().doNothing().multiplyBy2();

        let t = 2;
        t = t.increment().doNothing().multiplyBy2();

        let z = 2;
        z.increment();
        z.doNothing();
        z.multiplyBy2();

        return s == 3 && t == 6 && z == 6;
    }

    get fun mutatesChainInt6(): Bool {
        let s = 2;
        s.increment().multiplyBy2().doNothing();

        let t = 2;
        t = t.increment().multiplyBy2().doNothing();

        let z = 2;
        z.increment();
        z.multiplyBy2();
        z.doNothing();

        return s == 3 && t == 6 && z == 6;
    }

    /*************** Boolean Expressions ********************/

    /*** Tests && short-circuiting with mutating functions ***/
    get fun andMutateShortCircuit(): Bool {

        let s = 1;

        // It will evaluate the full expression to false and increment s to 2
        let m1 = true && s.increment() > 2;

        let result = s == 2;

        // Short-circuits to false, so that s should not be incremented.
        let m2 = false && s.increment() > 2;

        result &&= s == 2;

        // Short-circuits to false, so that s should not be incremented.
        let m3 = s > 2 && s.increment() > 2;

        result &&= s == 2;

        // It will evaluate the first and second conjuncts and short-circuit at the 
        // second conjunct to false. So s will be incremented at the second conjunct to 3, 
        // but it should not be incremented to 4 in the third conjunct.
        let m4 = s == 2 && s.increment() > 3 && s.increment() > 3;

        result &&= s == 3;

        // It will evaluate the entire expression to true. So, s should be incremented twice.
        let m5 = s == 3 && s.increment() > 3 && s.increment() > 4;
        
        result &&= s == 5;

        // It will evaluate the first and second conjuncts and short-circuit at the 
        // second conjunct to false. So s will be incremented at the second conjunct to 6, 
        // but it should not be incremented to 7 in the third conjunct or to 8 in the 
        // fourth conjunct.
        let m6 = s == 5 && s.increment() > 6 && s.increment() > 6 && s.increment() > 6;

        result &&= s == 6;

        result &&= !m1 && !m2 && !m3 && !m4 && m5 && !m6;

        return result;
    }

    /*** Tests && short-circuiting with infinite loops ***/
    get fun andInfiniteLoopShortCircuit(): Bool {

        let s = 1;

        // Short-circuits to false, so no infinite loop happens.
        // Note this implicitly tests the interpreter as well, because the 
        // interpreter will be able to simplify the expression.
        let l1 = false && infiniteLoop();

        // Short-circuits to false, so no infinite loop happens.
        let l2 = s > 1 && infiniteLoop();

        // It will evaluate the first and second conjuncts and short-circuit at the 
        // second conjunct to false. So s will be incremented at the second conjunct to 2, 
        // And no infinite loop happens in the third conjunct.
        let l3 = s == 1 && s.increment() > 2 && infiniteLoop();

        let result = s == 2;

        // It will evaluate the first and second conjuncts and short-circuit at the 
        // second conjunct to false. So s will be incremented at the second conjunct to 3, 
        // And no infinite loop happens in the third conjunct and no increment happens at 
        // the fourth conjunct.
        let l4 = s == 2 && s.increment() > 3 && infiniteLoop() && s.increment() > 3;

        result &&= s == 3;

        result &&= !l1 && !l2 && !l3 && !l4;

        return result;
    }

    /*** Tests && short-circuiting with exception throwing ***/
    get fun andExceptionShortCircuit(): Bool {

        let s = 1;

        // Short-circuits to false, so no exception thrown.
        let t1 = false && throwException(s-1);

        // Short-circuits to false, so no exception thrown.
        let t2 = s > 1 && throwException(s-1);

        // It will evaluate the first and second conjuncts and short-circuit at the 
        // second conjunct to false. So s will be incremented at the second conjunct to 2, 
        // And no exception happens in the third conjunct.
        let t3 = s == 1 && s.increment() > 2 && throwException(s-2);

        let result = s == 2;

        // It will evaluate the first and second conjuncts and short-circuit at the 
        // second conjunct to false. So s will be incremented at the second conjunct to 3, 
        // And no exception happens in the third conjunct and no increment happens at 
        // the fourth conjunct.
        let t4 = s == 2 && s.increment() > 3 && throwException(s-3) && s.increment() > 3;

        result &&= s == 3;

        result &&= !t1 && !t2 && !t3 && !t4;

        return result;
    }

    /*** Tests || short-circuiting with mutating functions ***/
    get fun orMutateShortCircuit(): Bool {

        let s = 1;

        // It will evaluate the full expression to true and increment s to 2
        let m1 = false || s.increment() >= 2;

        let result = s == 2;

        // Short-circuits to true, so that s should not be incremented.
        let m2 = true || s.increment() > 2;

        result &&= s == 2;

        // Short-circuits to true, so that s should not be incremented.
        let m3 = s >= 2 || s.increment() > 2;

        result &&= s == 2;

        // It will evaluate the first and second disjuncts and short-circuit at the 
        // second disjunct to true. So s will be incremented at the second disjunct to 3, 
        // but it should not be incremented to 4 in the third one.
        let m4 = s != 2 || s.increment() >= 3 || s.increment() > 3;

        result &&= s == 3;

        // It will evaluate the entire expression to false. So, s should be incremented twice.
        let m5 = s != 3 || s.increment() < 3 || s.increment() < 4;
        
        result &&= s == 5;

        // It will evaluate the first and second disjuncts and short-circuit at the 
        // second disjunct to true. So s will be incremented at the second disjunct to 6, 
        // but it should not be incremented to 7 in the third disjunct or to 8 in the 
        // fourth one.
        let m6 = s != 5 || s.increment() >= 6 || s.increment() > 6 || s.increment() > 6;

        result &&= s == 6;

        result &&= m1 && m2 && m3 && m4 && !m5 && m6;

        return result;
    }

    /*** Tests || short-circuiting with infinite loops ***/
    get fun orInfiniteLoopShortCircuit(): Bool {

        let s = 1;

        // Short-circuits to true, so no infinite loop happens.
        // Note this implicitly tests the interpreter as well, because the 
        // interpreter will be able to simplify the expression.
        let l1 = true || infiniteLoop();

        // Short-circuits to true, so no infinite loop happens.
        let l2 = s >= 1 || infiniteLoop();

        // It will evaluate the first and second disjuncts and short-circuit at the 
        // second disjunct to true. So s will be incremented at the second disjunct to 2, 
        // And no infinite loop happens in the third disjunct.
        let l3 = s != 1 || s.increment() >= 2 || infiniteLoop();

        let result = s == 2;

        // It will evaluate the first and second disjuncts and short-circuit at the 
        // second disjunct to true. So s will be incremented at the second disjunct to 3, 
        // And no infinite loop happens in the third disjunct and no increment happens at 
        // the fourth one.
        let l4 = s != 2 || s.increment() >= 3 || infiniteLoop() || s.increment() > 3;

        result &&= s == 3;

        result &&= l1 && l2 && l3 && l4;

        return result;
    }

    /*** Tests || short-circuiting with exception throwing ***/
    get fun orExceptionShortCircuit(): Bool {

        let s = 1;

        // Short-circuits to true, so no exception thrown.
        let t1 = true || throwException(s-1);

        // Short-circuits to true, so no exception thrown.
        let t2 = s >= 1 || throwException(s-1);

        // It will evaluate the first and second disjuncts and short-circuit at the 
        // second disjunct to true. So s will be incremented at the second disjunct to 2, 
        // And no exception happens in the third disjunct.
        let t3 = s != 1 || s.increment() >= 2 || throwException(s-2);

        let result = s == 2;

        // It will evaluate the first and second disjuncts and short-circuit at the 
        // second disjunct to true. So s will be incremented at the second disjunct to 3, 
        // And no exception happens in the third disjunct and no increment happens at 
        // the fourth one.
        let t4 = s != 2 || s.increment() >= 3 || throwException(s-3) || s.increment() > 3;

        result &&= s == 3;

        result &&= t1 && t2 && t3 && t4;

        return result;
    }
}


## send.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/send.tact)
import "@stdlib/deploy";

contract SendTester with Deployable {

    init() {
        emit("Deploy success".asComment());
    }

    receive("Hello") {
        self.reply("World".asComment());
        emit("Something".asComment());
    }
}

## serialization-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/serialization-2.tact)
struct Vars {
    a: Int;
    b: Int;
    c: Int;
    d: Int;
    e: Int;
}

struct Both {
    a: Vars;
    b: Vars;
}

message Update {
    a: Vars;
    b: Vars;
}

contract SerializationTester2 {

    a: Vars;
    b: Vars;

    init(a: Vars, b: Vars) {
        self.a = a;
        self.b = b;
        
        // abi.dump(self.a.a);
        // abi.dump(self.a.b);
        // abi.dump(self.a.c);
        // abi.dump(self.a.d);
        // abi.dump(self.a.e);
        // abi.dump(self.b.a);
        // abi.dump(self.b.b);
        // abi.dump(self.b.c);
        // abi.dump(self.b.d);
        // abi.dump(self.b.e);
    }

    receive() {
        // Deploy
    }

    receive(msg: Update) {
        self.a = msg.a;
        self.b = msg.b;

        // abi.dump(self.a.a);
        // abi.dump(self.a.b);
        // abi.dump(self.a.c);
        // abi.dump(self.a.d);
        // abi.dump(self.a.e);
        // abi.dump(self.b.a);
        // abi.dump(self.b.b);
        // abi.dump(self.b.c);
        // abi.dump(self.b.d);
        // abi.dump(self.b.e);
    }

    get fun getA(): Vars {
        return self.a;
    }

    get fun getAOpt(): Vars? {
        return self.a;
    }

    get fun getB(): Vars {
        return self.b;
    }

    get fun getBOpt(): Vars? {
        return self.b;
    }

    get fun getBoth():Both {
        return Both{a: self.a, b: self.b};
    }

    get fun getBothOpt():Both? {
        return Both{a: self.a, b: self.b};
    }

    get fun process(src: Vars, both: Both, both2: Both?): Vars {
        return Vars{a: src.a + 1, b: src.b + 2, c: src.c + 3, d: src.d + 4, e: src.e + 5};
    }
}

## serialization-3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/serialization-3.tact)
message Update {
    a: Int;
    b: Bool;
    c: Cell;
    d: Slice;
    e: Builder;
    f: String;
}

contract SerializationTester3 {

    a: Int;
    b: Bool;
    c: Cell;
    d: Slice;
    e: Builder;
    f: String;

    init(a: Int, b: Bool, c: Cell, d: Slice, e: Builder, f: String) {
        self.a = a;
        self.b = b;
        self.c = c;
        self.d = d;
        self.e = e;
        self.f = f;
    }

    receive() {
        // Deploy
    }

    receive(msg: Update) {
        self.a = msg.a;
        self.b = msg.b;
        self.c = msg.c;
        self.d = msg.d;
        self.e = msg.e;
        self.f = msg.f;
    }

    get fun getA(): Int {
        return self.a;
    }
    get fun getB(): Bool {
        return self.b;
    }
    get fun getC(): Cell {
        return self.c;
    }
    get fun getD(): Slice {
        return self.d;
    }
    get fun getE(): Builder {
        return self.e;
    }
    get fun getF(): String {
        return self.f;
    }
}

## serialization.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/serialization.tact)
message Update {
    a: Int;
    b: Int;
    c: Int;
    d: Int;
    e: Int;
    f: Int;
    g: Int;
    h: Int;
    i: Int;
}

contract SerializationTester {

    a: Int;
    b: Int;
    c: Int;
    d: Int;
    e: Int;
    f: Int;
    g: Int;
    h: Int;
    i: Int;

    init(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int, g: Int, h: Int, i: Int) {
        self.a = a;
        self.b = b;
        self.c = c;
        self.d = d;
        self.e = e;
        self.f = f;
        self.g = g;
        self.h = h;
        self.i = i;

        // abi.dump(self.a);
        // abi.dump(self.b);
        // abi.dump(self.c);
        // abi.dump(self.d);
        // abi.dump(self.e);
        // abi.dump(self.f);
        // abi.dump(self.g);
        // abi.dump(self.h);
        // abi.dump(self.i);
    }

    receive() {
        // Deploy
    }

    receive(msg: Update) {
        self.a = msg.a;
        self.b = msg.b;
        self.c = msg.c;
        self.d = msg.d;
        self.e = msg.e;
        self.f = msg.f;
        self.h = msg.h;
        self.i = msg.i;

        // abi.dump(self.a);
        // abi.dump(self.b);
        // abi.dump(self.c);
        // abi.dump(self.d);
        // abi.dump(self.e);
        // abi.dump(self.f);
        // abi.dump(self.g);
        // abi.dump(self.h);
        // abi.dump(self.i);
    }

    get fun getA(): Int {
        return self.a;
    }
    get fun getB(): Int {
        return self.b;
    }
    get fun getC(): Int {
        return self.c;
    }
    get fun getD(): Int {
        return self.d;
    }
    get fun getE(): Int {
        return self.e;
    }
    get fun getF(): Int {
        return self.f;
    }
    get fun getG(): Int {
        return self.g;
    }
    get fun getH(): Int {
        return self.h;
    }
    get fun getI(): Int {
        return self.i;
    }
}

## stdlib.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/stdlib.tact)
contract StdlibTest {

    v: Int = 0;

    init() {
        // Nothing to do
    }

    receive() {
        // Deploy
    }

    get fun sliceEmpty(sc: Slice): Bool {
        return sc.empty();
    }

    get fun sliceBits(sc: Slice): Int {
        return sc.bits();
    }

    get fun sliceRefs(sc: Slice): Int {
        return sc.refs();
    }
    
    get fun storeBool(bl: Builder, b: Bool): Builder {
        return bl.storeBool(b);
    }

    get fun loadBool(sc: Slice): Bool {
        return sc.loadBool();
    }

    get fun storeBit(bl: Builder, b: Bool): Builder {
        return bl.storeBit(b);
    }

    get fun loadBit(sc: Slice): Bool {
        return sc.loadBit();
    }

    
    get fun tvm_2023_07_upgrade(): Int {
        return gasConsumed();
    }

    get fun tvm_2024_04_upgrade(): Int {
        return getComputeFee(1000, false) + getStorageFee(1000, 1000, 1000, false) + getForwardFee(1000, 1000, false) + getSimpleComputeFee(1000, false) + getSimpleForwardFee(1000, 1000, false) + getOriginalFwdFee(1000, false) + myStorageDue();
    }

    get fun storeMaybeRef(bl: Builder, c: Cell?): Builder {
        return bl.storeMaybeRef(c);
    }

    get fun parseStdAddress(slice: Slice): StdAddress {
        return parseStdAddress(slice);
    }

    get fun parseVarAddress(slice: Slice): VarAddress {
        return parseVarAddress(slice);
    }
}

## strings.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/strings.tact)
contract StringsTester {
    init() {
        
    }
    
    receive() {
        // Deploy
    }

    receive("backtick-test") {
        require(1 == 2, "condition can`t be...");
    }

    get fun constantString(): String {
        return "test string";
    }

    get fun constantStringUnicode(): String {
        return "привет мир 👀";
    }

    get fun constantStringUnicodeLong(): String {
        return "привет мир 👀 привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀";
    }

    get fun dynamicStringCell(): Cell {
        let b: StringBuilder = beginString();
        b.append("Hello!");
        return b.toCell();
    }

    get fun dynamicStringCell2(): Cell {
        let b: StringBuilder = beginString();
        b = b.concat("Hello,").concat(" ").concat("World!");
        return b.toCell();
    }

    get fun dynamicCommentCell(): Cell {
        let b: StringBuilder = beginComment();
        b.append("Something something world!");
        return b.toCell();
    }

    get fun dynamicCommentCellLarge(): Cell {
        let b: StringBuilder = beginString();
        b.append("Hello!");
        b.append("привет мир 👀 привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀");
        return b.toCell();
    }

    get fun dynamicCommentStringLarge(): String {
        let b: StringBuilder = beginString();
        b.append("Hello!");
        b.append("привет мир 👀 привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀привет мир 👀");
        return b.toString();
    }

    get fun stringWithNumber(): String {
        let b: StringBuilder = beginString();
        b.append("Hello, your balance: ");
        b.append(123.toString());
        return b.toString();
    }

    get fun stringWithNegativeNumber(): String {
        let b: StringBuilder = beginString();
        b.append("Hello, your balance: ");
        b.append((-123).toString());
        return b.toString();
    }

    get fun stringWithLargeNumber(): String {
        let b: StringBuilder = beginString();
        b.append("Hello, your balance: ");
        b.append(1000000000000000000000000000000000000000000000000000000000000.toString());
        return b.toString();
    }

    get fun stringWithFloat(): String {
        return 95.toFloatString(1);
    }

    get fun base64(): Slice {
        return "TWFueSBoYW5kcyBtYWtlIGxpZ2h0IHdvcmsu".fromBase64();
    }

    get fun processBase64(src: String): Slice {
        return src.fromBase64();
    }

    get fun stringWithEscapedChars1(): String {
        return "test \n \n \\ \\\n \"string\"";
    }

    get fun stringWithEscapedChars2(): String {
        return "test \n test \t test \r test \b test \f test \" test ' test \\ \\\\ \"_\" \"\" test";
    }

    get fun stringWithEscapedChars3(): String {
        return "test \\n test \\t test \\r test \\\\b\b test \\f test \\\" test \\' test \v \v \\\\ \\\\\\\\ \\\"_\\\" \\\"\\\" test";
    }

    get fun stringWithEscapedChars4(): String {
        return "\u{2028}\u{2029} \u0044 \x41\x42\x43";
    }

    get fun stringWithEscapedChars5(): String {
        return "\u{0} \u{00} \u{000} \u{0000} \u{00000} \u{000000} \u0000 \x00";
    }

    get fun stringWithEscapedChars6(): String {
        // https://en.m.wikipedia.org/wiki/List_of_Unicode_characters#Control_codes
        return beginCell()
            .storeUint(0x7F, 8) // DEL, 127
            .storeUint(0x1F, 8) // US,  31
            .storeUint(0x0A, 8) // LF,  10
            .storeUint(0x00, 8) // NUL, 0
            .storeUint(32, 8) // Space
            .storeUint(84, 8) // "T"
            .storeUint(65, 8) // "A"
            .storeUint(67, 8) // "C"
            .storeUint(84, 8) // "T"
            .asSlice()
            .asString();
    }

    get fun stringWithAddress(): String {
        return address("EQBKgXCNLPexWhs2L79kiARR1phGH1LwXxRbNsCFF9doc2lN").toString();
    }
}

## structs.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/structs.tact)
struct S {
    a: Bool;
    b: Int;
}

struct T {
    a: Int;
    s: S;
}

struct MyStruct1 {
    a: Int;
    b: Int as uint32;
    c: Int?;
}

struct MyStruct2 {
    m: map<Int, Int as uint64>;
    s: MyStruct1?;
}

struct MyStruct3 {
    s: String;
}

const globalConstStruct: MyStruct3 = MyStruct3 { s: "global const struct test" };

message MyMessage1 {
    a: Int;
    s: MyStruct2;
}

struct Coin {
    first: Int as coins;
    second: Int as uint32;
}

struct IntFields {
    i1: Int as int1;
    i2: Int as int2;
    i3: Int as int3;
    i255: Int as int255;
    i256: Int as int256;
    i257: Int as int257;
}

message(0xea01f469 + 1) UintFields {
    u1: Int as uint1;
    u2: Int as uint2;
    u3: Int as uint3;
    u254: Int as uint254;
    u255: Int as uint255;
    u256: Int as uint256;
}

fun directParse(payload: Cell): Coin {
    return Coin.fromCell(payload);
}

struct LongStruct15 {
    x1: Int;
    x2: Int;
    x3: Int;
    x4: Int;
    x5: Int;
    x6: Int;
    x7: Int;
    x8: Int;
    x9: Int;
    x10: Int;
    x11: Int;
    x12: Int;
    x13: Int;
    x14: Int;
    x15: Int;
}

struct LongStruct16 {
    x1: Int;
    x2: Int;
    x3: Int;
    x4: Int;
    x5: Int;
    x6: Int;
    x7: Int;
    x8: Int;
    x9: Int;
    x10: Int;
    x11: Int;
    x12: Int;
    x13: Int;
    x14: Int;
    x15: Int;
    x16: Int;
}

struct LongStruct32 {
    x1: Int;
    x2: Int;
    x3: Int;
    x4: Int;
    x5: Int;
    x6: Int;
    x7: Int;
    x8: Int;
    x9: Int;
    x10: Int;
    x11: Int;
    x12: Int;
    x13: Int;
    x14: Int;
    x15: Int;
    x16: Int;
    x17: Int;
    x18: Int;
    x19: Int;
    x20: Int;
    x21: Int;
    x22: Int;
    x23: Int;
    x24: Int;
    x25: Int;
    x26: Int;
    x27: Int;
    x28: Int;
    x29: Int;
    x30: Int;
    x31: Int;
    x32: Int;
}

struct LongNestedStruct {
    x1: Int;
    x2: Int;
    x3: Int;
    x4: Int;
    x5: Int;
    x6: Int;
    x7: Int;
    x8: Int;
    x9: Int;
    x10: Int;
    x11: Int;
    x12: Int;
    x13: Int;
    x14: Int;
    x15: Int;
    x16: Int;
    x17: Int;
    x18: Int;
    x19: Int;
    x20: Int;

    s1: LongStruct15;
    s2: LongStruct16;
    s3: LongStruct32;
}

struct LongNestedStructWithOpts {
    x1: Int;
    x2: Int;
    x3: Int;
    x4: Int;
    x5: Int;
    x6: Int;
    x7: Int;
    x8: Int;
    x9: Int;
    x10: Int;
    x11: Int;
    x12: Int;
    x13: Int;
    x14: Int;
    x15: Int;
    x16: Int;
    x17: Int;
    x18: Int?;
    x19: Int;
    x20: Int;

    s1: LongStruct15?;
    s2: LongStruct16;
    s3: LongStruct32?;
}

struct Point {
    x: Int as int64;
    y: Int as int64;
}

struct Line {
    start: Point;
    end: Point;
}

struct Location {
    idx: Int;
    line1: Line;
    line2: Line?;
}

struct DoubleNestedStructOpt {
    a: Int;
    s: MyStruct1?;
}

struct TripleNestedStructOpt {
    a: Int;
    s: DoubleNestedStructOpt?;
}

struct LongAndDeepNestedStruct {
    x1: Int;
    x2: Int;
    x3: Int;
    x4: Int;
    x5: Int;
    x6: Int;
    x7: Int;
    x8: Int;
    x9: Int;
    x10: Int;
    x11: Int;
    x12: Int;
    x13: Int;
    x14: Int;
    x15: Int;
    x16: Int;
    s1: TripleNestedStructOpt;
    s2: TripleNestedStructOpt;
    s3: TripleNestedStructOpt?;
    s4: TripleNestedStructOpt?;
}

message(42) Foo {
    s: Slice as remaining;
}

struct Dict {
    m: map<Int as uint8, Int as coins>;
}

struct OptionalFields {
    nickname: String?;
    avatar: String?;
}

struct S1 {
    a: Int;
    b: Int;
    c: Int;
}

fun destructuringTest1(): Int {
    let s = S {
        a: true,
        b: 42
    };

    let S {a, b} = s;

    return (a ? 1 : 0) + b;
}

fun destructuringTest2(): Int {
    let s = S {
        a: true,
        b: 42
    };

    let S {a: _, b} = s;

    return b;
}

fun destructuringTest3(): Int {
    let s = S {
        a: true,
        b: 42
    };

    let S {b, a} = s;

    return (a ? 1 : 0) + b;
}

fun destructuringTest4(): Int {
    let s = S {
        a: true,
        b: 42
    };

    let S {b: b, a: a} = s;

    return (a ? 1 : 0) + b;
}

fun destructuringTest5(): Int {
    let s = S {
        a: true,
        b: 42
    };

    let S {b: a, a: b} = s;

    return (b ? 1 : 0) + a;
}

fun destructuringTest6(): Int {
    let s = S1 { a: 1, b: 2, c: 3 };
    let S1 { c: e, b, a } = s;
    return a + b + e;
}

fun destructuringTest7(): S1 {
    let s = S1 { a: 1, b: 2, c: 3 };
    let S1 { a, c: e, b: b } = s;
    return S1 {a: e, b: b, c: a};
}

fun destructuringTest8(): Int {
    let s = S {
        a: true,
        b: 42
    };

    let S {b, ..} = s;

    return b;
}

contract StructsTester {
    s1: S = S {a: false, b: 21 + 21};
    s2: S;
    t1: T = T {a: 43, s: S {a: true, b: 44}};
    t2: T;
    mapWithLongStructs15: map<Int, LongStruct15> = emptyMap();
    mapWithLongStructs16: map<Int, LongStruct16> = emptyMap();
    mapWithLongStructs32: map<Int, LongStruct32> = emptyMap();
    // let's also test contract fields
    x1: Int = 1;
    x2: Int = 2;
    x3: Int = 3;
    x4: Int = 4;
    x5: Int = 5;
    x6: Int = 6;
    x7: Int = 7;
    x8: Int = 8;
    x9: Int = 9;
    x10: Int = 10;
    x11: Int = 11;
    x12: Int = 12;
    x13: Int = 13;
    x14: Int = 14;
    x15: Int = 15;
    x16: Int = 16;
    x17: Int = 17;
    x18: Int = 18;
    x19: Int = 19;
    x20: Int = 20;

    const contractStructConst: MyStruct3 = MyStruct3 { s: "contract const struct test" };

    init() {
        self.s2 = S {a: false || false, b: 42};
        self.t2 = T {a: 40 + 3, s: S {a: true && true, b: 44 | 4}};
    }

    // Deploy
    receive() { }

    receive(msg: Foo) {
        let d = Dict.fromSlice(msg.s);
        send(SendParameters{
            bounce: false,
            to: sender(),
            value: ton("0.01"),
            mode: SendPayGasSeparately,
            body: d.toCell()
        });
    }

    get fun structInitializerTest(): Bool {
        return self.s1.a == self.s2.a && self.s1.b == self.s2.b &&
               self.t1.a == self.t2.a &&
               self.t1.s.a == self.t2.s.a && self.t1.s.b == self.t2.s.b;
    }

    get fun toCell1(s: MyStruct1): Cell {
        return s.toCell();
    }

    get fun toSlice1(s: MyStruct1): Slice {
        return s.toSlice();
    }

    get fun fromCell1(src: Cell): MyStruct1 {
        let s = MyStruct1.fromCell(src);
        return s;
    }

    get fun fromSlice1(src: Slice): MyStruct1 {
        return MyStruct1.fromSlice(src);
    }

    get fun toCell2(s: MyStruct2): Cell {
        return s.toCell();
    }

    get fun fromCell2(src: Cell): MyStruct2 {
        let s: MyStruct2 = MyStruct2.fromCell(src);
        return s;
    }

    get fun fromSlice2(src: Slice): MyStruct2 {
        let s: MyStruct2 = MyStruct2.fromSlice(src);
        return s;
    }

    get fun test1(s1: MyStruct1, s2: MyStruct2): Cell {
        let c: Cell = beginCell().storeRef(s1.toCell()).storeRef(s2.toCell()).endCell();
        let s: Slice = c.beginParse();
        let s1_: MyStruct1 = MyStruct1.fromCell(s.loadRef());
        let s2_: MyStruct2 = MyStruct2.fromSlice(s.loadRef().beginParse());
        return beginCell().storeRef(s1_.toCell()).storeRef(s2_.toCell()).endCell();
    }

    get fun toCellMessage1(m: MyMessage1): Cell {
        return m.toCell();
    }

    get fun fromCellMessage1(src: Cell): MyMessage1 {
        return MyMessage1.fromCell(src);
    }

    get fun fromSliceMessage1(src: Slice): MyMessage1 {
        return MyMessage1.fromSlice(src);
    }

    get fun contractStructConstantImmediate(): MyStruct3 {
        return self.contractStructConst;
    }

    get fun globalConstStructConstantImmediate(): MyStruct3 {
        return globalConstStruct;
    }

    get fun contractStructConstantFieldImmediate(): String {
        return self.contractStructConst.s;
    }

    get fun globalConstStructConstantFieldImmediate(): String {
        return globalConstStruct.s;
    }

    get fun contractStructConstantViaVar(): MyStruct3 {
        let s = self.contractStructConst;
        return s;
    }

    get fun globalConstStructConstantViaVar(): MyStruct3 {
        let s = globalConstStruct;
        return s;
    }

    get fun contractStructConstantFieldViaVar(): String {
        let s = self.contractStructConst.s;
        return s;
    }

    get fun globalConstStructConstantFieldViaVar(): String {
        let s = globalConstStruct.s;
        return s;
    }

    receive("example") {
        let coin = directParse(
            beginCell()
            .storeCoins(42)
            .storeUint(35, 31)
            .endCell()
        );
        dump(coin.first);
        dump(coin.second);
    }

    get fun longStruct15Test(): LongStruct15 {
        let s = LongStruct15 {
            x1: 1,
            x2: 2,
            x3: 3,
            x4: 4,
            x5: 5,
            x6: 6,
            x7: 7,
            x8: 8,
            x9: 9,
            x10: 10,
            x11: 11,
            x12: 12,
            x13: 13,
            x14: 14,
            x15: 15
        };

        s.x1 = 1;
        s.x15 = 15;

        self.mapWithLongStructs15.set(1, s);
        return self.mapWithLongStructs15.get(1)!!;
    }

    get fun longStruct16Test(): LongStruct16 {
        let s = LongStruct16 {
            x1: 1,
            x2: 2,
            x3: 3,
            x4: 4,
            x5: 5,
            x6: 6,
            x7: 7,
            x8: 8,
            x9: 9,
            x10: 10,
            x11: 11,
            x12: 12,
            x13: 13,
            x14: 14,
            x15: 15,
            x16: 16
        };

        s.x1 = 1;
        s.x16 = 16;

        self.mapWithLongStructs16.set(1, s);
        return self.mapWithLongStructs16.get(1)!!;
    }

    get fun longStruct32Test(): LongStruct32 {
        let s = LongStruct32 {
            x1: 1,
            x2: 2,
            x3: 3,
            x4: 4,
            x5: 5,
            x6: 6,
            x7: 7,
            x8: 8,
            x9: 9,
            x10: 10,
            x11: 11,
            x12: 12,
            x13: 13,
            x14: 14,
            x15: 15,
            x16: 16,
            x17: 17,
            x18: 18,
            x19: 19,
            x20: 20,
            x21: 21,
            x22: 22,
            x23: 23,
            x24: 24,
            x25: 25,
            x26: 26,
            x27: 27,
            x28: 28,
            x29: 29,
            x30: 30,
            x31: 31,
            x32: 32
        };

        s.x1 = 1;
        s.x32 = 32;

        self.mapWithLongStructs32.set(1, s);
        return self.mapWithLongStructs32.get(1)!!;
    }

    get fun longNestedStructTest(): LongNestedStruct {
        let s = LongNestedStruct {
            x1: 1,
            x2: 2,
            x3: 3,
            x4: 4,
            x5: 5,
            x6: 6,
            x7: 7,
            x8: 8,
            x9: 9,
            x10: 10,
            x11: 11,
            x12: 12,
            x13: 13,
            x14: 14,
            x15: 15,
            x16: 16,
            x17: 17,
            x18: 18,
            x19: 19,
            x20: 20,
            s1: LongStruct15 {
                x1: 1,
                x2: 2,
                x3: 3,
                x4: 4,
                x5: 5,
                x6: 6,
                x7: 7,
                x8: 8,
                x9: 9,
                x10: 10,
                x11: 11,
                x12: 12,
                x13: 13,
                x14: 14,
                x15: 15
            },
            s2: LongStruct16 {
                x1: 1,
                x2: 2,
                x3: 3,
                x4: 4,
                x5: 5,
                x6: 6,
                x7: 7,
                x8: 8,
                x9: 9,
                x10: 10,
                x11: 11,
                x12: 12,
                x13: 13,
                x14: 14,
                x15: 15,
                x16: 16
            },
            s3: LongStruct32 {
                x1: 1,
                x2: 2,
                x3: 3,
                x4: 4,
                x5: 5,
                x6: 6,
                x7: 7,
                x8: 8,
                x9: 9,
                x10: 10,
                x11: 11,
                x12: 12,
                x13: 13,
                x14: 14,
                x15: 15,
                x16: 16,
                x17: 17,
                x18: 18,
                x19: 19,
                x20: 20,
                x21: 21,
                x22: 22,
                x23: 23,
                x24: 24,
                x25: 25,
                x26: 26,
                x27: 27,
                x28: 28,
                x29: 29,
                x30: 30,
                x31: 31,
                x32: 32
            }
        };

        return s;
    }

    get fun longNestedStructWithOptsTest(): LongNestedStructWithOpts {
        let s = LongNestedStructWithOpts {
            x1: 1,
            x2: 2,
            x3: 3,
            x4: 4,
            x5: 5,
            x6: 6,
            x7: 7,
            x8: 8,
            x9: 9,
            x10: 10,
            x11: 11,
            x12: 12,
            x13: 13,
            x14: 14,
            x15: 15,
            x16: 16,
            x17: 17,
            x18: 18,
            x19: 19,
            x20: 20,
            s1: null,
            s2: LongStruct16 {
                x1: 1,
                x2: 2,
                x3: 3,
                x4: 4,
                x5: 5,
                x6: 6,
                x7: 7,
                x8: 8,
                x9: 9,
                x10: 10,
                x11: 11,
                x12: 12,
                x13: 13,
                x14: 14,
                x15: 15,
                x16: 16
            },
            s3: LongStruct32 {
                x1: 1,
                x2: 2,
                x3: 3,
                x4: 4,
                x5: 5,
                x6: 6,
                x7: 7,
                x8: 8,
                x9: 9,
                x10: 10,
                x11: 11,
                x12: 12,
                x13: 13,
                x14: 14,
                x15: 15,
                x16: 16,
                x17: 17,
                x18: 18,
                x19: 19,
                x20: 20,
                x21: 21,
                x22: 22,
                x23: 23,
                x24: 24,
                x25: 25,
                x26: 26,
                x27: 27,
                x28: 28,
                x29: 29,
                x30: 30,
                x31: 31,
                x32: 32
            }
        };

        return s;
    }

    get fun longContractTest(): Int {
        return self.x1 + self.x2 + self.x3 + self.x4 + self.x5 + self.x6 + self.x7 + self.x8 + self.x9 + self.x10 +
               self.x11 + self.x12 + self.x13 + self.x14 + self.x15 + self.x16 + self.x17 + self.x18 + self.x19 + self.x20;
    }

    // https://github.com/tact-lang/tact/issues/690

    get fun location1(): Location {
        let start: Point = Point{ x: 1, y: 2};
        let end: Point = Point{ x: 3, y: 4};

        return Location {
            idx: 1,
            line1: Line {start: start, end: end},
            line2: null
        }
    }

    get fun location2(): Location {
        let start: Point = Point{ x: 1, y: 2};
        let end: Point = Point{ x: 3, y: 4};

        return Location {
            idx: 2,
            line1: Line {start: start, end: end},
            line2: Line {start: start, end: end}
        }
    }

    get fun tripleNestedStructOpt1(): TripleNestedStructOpt {
        return TripleNestedStructOpt {
            a: 1,
            s: DoubleNestedStructOpt {
                a: 2,
                s: MyStruct1 {
                    a: 3,
                    b: 4,
                    c: 5
                }
            }
        }
    }

    get fun tripleNestedStructOpt2(): TripleNestedStructOpt {
        return TripleNestedStructOpt {
            a: 1,
            s: null
        }
    }

    get fun tripleNestedStructOpt3(): TripleNestedStructOpt {
        return TripleNestedStructOpt {
            a: 1,
            s: DoubleNestedStructOpt {
                a: 2,
                s: null
            }
        }
    }

    get fun longAndDeepNestedStruct1(): LongAndDeepNestedStruct {
        return LongAndDeepNestedStruct {
            x1: 1,
            x2: 2,
            x3: 3,
            x4: 4,
            x5: 5,
            x6: 6,
            x7: 7,
            x8: 8,
            x9: 9,
            x10: 10,
            x11: 11,
            x12: 12,
            x13: 13,
            x14: 14,
            x15: 15,
            x16: 16,
            s1: TripleNestedStructOpt {
                a: 1,
                s: DoubleNestedStructOpt {
                    a: 2,
                    s: MyStruct1 {
                        a: 3,
                        b: 4,
                        c: 5
                    }
                }
            },
            s2: TripleNestedStructOpt {
                a: 6,
                s: DoubleNestedStructOpt {
                    a: 7,
                    s: MyStruct1 {
                        a: 8,
                        b: 9,
                        c: 10
                    }
                }
            },
            s3: null,
            s4: null
        }
    }

    get fun longAndDeepNestedStruct2(): LongAndDeepNestedStruct {
        return LongAndDeepNestedStruct {
            x1: 1,
            x2: 2,
            x3: 3,
            x4: 4,
            x5: 5,
            x6: 6,
            x7: 7,
            x8: 8,
            x9: 9,
            x10: 10,
            x11: 11,
            x12: 12,
            x13: 13,
            x14: 14,
            x15: 15,
            x16: 16,
            s1: TripleNestedStructOpt {
                a: 1,
                s: DoubleNestedStructOpt {
                    a: 2,
                    s: MyStruct1 {
                        a: 3,
                        b: 4,
                        c: 5
                    }
                }
            },
            s2: TripleNestedStructOpt {
                a: 6,
                s: DoubleNestedStructOpt {
                    a: 7,
                    s: MyStruct1 {
                        a: 8,
                        b: 9,
                        c: 10
                    }
                }
            },
            s3: TripleNestedStructOpt {
                a: 11,
                s: DoubleNestedStructOpt {
                    a: 12,
                    s: MyStruct1 {
                        a: 13,
                        b: 14,
                        c: 15
                    }
                }
            },
            s4: TripleNestedStructOpt {
                a: 16,
                s: DoubleNestedStructOpt {
                    a: 17,
                    s: MyStruct1 {
                        a: 18,
                        b: 19,
                        c: 20
                    }
                }
            }
        }
    }

    get fun longAndDeepNestedStruct3(): LongAndDeepNestedStruct {
        return LongAndDeepNestedStruct {
            x1: 1,
            x2: 2,
            x3: 3,
            x4: 4,
            x5: 5,
            x6: 6,
            x7: 7,
            x8: 8,
            x9: 9,
            x10: 10,
            x11: 11,
            x12: 12,
            x13: 13,
            x14: 14,
            x15: 15,
            x16: 16,
            s1: TripleNestedStructOpt {
                a: 1,
                s: DoubleNestedStructOpt {
                    a: 2,
                    s: MyStruct1 {
                        a: 3,
                        b: 4,
                        c: 5
                    }
                }
            },
            s2: TripleNestedStructOpt {
                a: 6,
                s: DoubleNestedStructOpt {
                    a: 7,
                    s: MyStruct1 {
                        a: 8,
                        b: 9,
                        c: 10
                    }
                }
            },
            s3: null,
            s4: TripleNestedStructOpt {
                a: 16,
                s: DoubleNestedStructOpt {
                    a: 17,
                    s: MyStruct1 {
                        a: 18,
                        b: 19,
                        c: 20
                    }
                }
            }
        }
    }

    get fun intFieldsStruct(): IntFields {
        return IntFields{
            i1: -1,
            i2: -2,
            i3: -4,
            i255: -pow(2, 254),
            i256: -pow(2, 255),
            i257: -pow(2, 255) - pow(2, 255),
        };
    }

    get fun intFieldsFromCell(src: Cell): IntFields {
        return IntFields.fromCell(src);
    }

    get fun uintFieldsMessage(): UintFields {
        return UintFields{
            u1: 1,
            u2: 3,
            u3: 7,
            u254: pow(2, 254) - 1,
            u255: pow(2, 255) - 1,
            u256: pow(2, 255) - 1 + pow(2, 255),
        };
    }

    get fun uintFieldsFromCell(src: Cell): UintFields {
        return UintFields.fromCell(src);
    }

    get fun optionalFields(): OptionalFields {
        return OptionalFields {
            nickname: null,
            avatar: "non-null string",
        }
    }

    get fun destructuringTest1(): Int {
        let s = S {
            a: true,
            b: 42
        };

        let S {a, b} = s;

        return (a ? 1 : 0) + b;
    }

    get fun destructuringTest1Const(): Int {
        return destructuringTest1();
    }

    get fun destructuringTest2(): Int {
        let s = S {
            a: true,
            b: 42
        };

        let S {a: _, b} = s;

        return b;
    }

    get fun destructuringTest2Const(): Int {
        return destructuringTest2();
    }

    get fun destructuringTest3(): Int {
        let s = S {
            a: true,
            b: 42
        };

        let S {b, a} = s;

        return (a ? 1 : 0) + b;
    }

    get fun destructuringTest3Const(): Int {
        return destructuringTest3();
    }

    get fun destructuringTest4(): Int {
        let s = S {
            a: true,
            b: 42
        };

        let S {b: b, a: a} = s;

        return (a ? 1 : 0) + b;
    }

    get fun destructuringTest4Const(): Int {
        return destructuringTest4();
    }

    get fun destructuringTest5(): Int {
        let s = S {
            a: true,
            b: 42
        };

        let S {b: a, a: b} = s;

        return (b ? 1 : 0) + a;
    }

    get fun destructuringTest5Const(): Int {
        return destructuringTest5();
    }

    get fun destructuringTest6(): Int {
        let s = S1 { a: 1, b: 2, c: 3 };
        let S1 { c: e, b, a } = s;
        return a + b + e;
    }

    get fun destructuringTest6Const(): Int {
        return destructuringTest6();
    }
    
    get fun destructuringTest7(): S1 {
        let s = S1 { a: 1, b: 2, c: 3 };
        let S1 { a, c: e, b: b } = s;
        return S1 {a: e, b: b, c: a};
    }

    get fun destructuringTest7Const(): S1 {
        return destructuringTest7();
    }

    get fun destructuringTest8(): Int {
        let s = S {
            a: true,
            b: 42
        };

        let S {b, ..} = s;

        return b;
    }

    get fun destructuringTest8Const(): Int {
        return destructuringTest8();
    }
}


## ternary.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/ternary.tact)
contract TernaryTester {

    init() {
        
    }
    
    receive() {
        // Deploy
    }

    get fun test1(a: Int): Int {
        return a == 123 ? 1 : 2;
    }

    get fun test2(a: Int): Int {
        return a == 123 ? a * 2 : a * 3;
    }

    get fun test3(a: Int, b: Int): Int {
        return a == b ? 1 : 2;
    }

    get fun test4(a: Int, b: Int): Int {
        return a == 123 ? (b == 456 ? 1 : 2) : (b == 789 ? 3 : 4);
    }

    // ternary operator is right-associative (see the next test)
    // returns 1
    get fun test5(): Int {
        return true ? 1 : false ? 2 : 3;
    }

    // the following parentheses are actually not needed
    // returns 1
    get fun test6(): Int {
        return true ? 1 : (false ? 2 : 3);
    }

    // returns 2
    get fun test7(): Int {
        return false ? 1 : true ? 2 : 3;
    }

    // returns 3
    get fun test8(): Int {
        return false ? 1 : false ? 2 : 3;
    }

    // returns 3
    get fun test9(): Int {
        return (true ? false : true) ? 2 : 3;
    }

    // the following is equivalent to an `if ... else if ... else if ... else ...` chain
    get fun test10(a: Int): Int {
        return
              (a == 1) ? 42
            : (a == 2) ? 43
            : (a == 3) ? 44
            : 45;
    }
}

## text-message-receivers.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/text-message-receivers.tact)
import "@stdlib/deploy";

contract TextMessageReceivers with Deployable {
    counter: Int = 0;

    receive("increment'") {
        self.counter += 1;
    }

    receive("increment-2\"") {
        self.counter += 2;
    }

    receive("increment-3`") {
        self.counter += 3;
    }

    receive("\\increment-4\\") {
        self.counter += 4;
    }

    get fun getCounter(): Int {
        return self.counter;
    }
}


## traits.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/traits.tact)
trait Animal {
    abstract fun getType(): String;
    abstract fun getSound(): String;

    get fun say(): String {
        return beginString()
          .concat("I am a ")
          .concat(self.getType())
          .concat(" and I say ")
          .concat(self.getSound())
          .toString();
    }
    receive("make sound") {
        self.reply(self.say().asComment());
    }
}

trait Dog with Animal {
    override fun getType(): String {
        return "Dog";
    }
    override fun getSound(): String {
        return "Woof";
    }
}

trait Laika with Dog {
    override fun getType(): String {
        return "Laika";
    }
    receive() {
        // deploy
    }
}

contract LaikaContract with Laika {
    // empty contract, we just inherit everything from the traits
}



## try-catch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/try-catch.tact)
contract TryCatchTester {
    counter: Int = 0;

    receive() {}

    receive("increment") {
        self.counter += 1;
    }

    receive("incrementTryCatch") {
        try {
            self.counter += 1;
            nativeThrow(123);
        }
    }

    receive("tryCatchRegisters") {
        self.counter += 1;
        self.reply("hello world 1".asComment());
        try {
            self.counter += 1;
            self.reply("hello world 2".asComment());
            emit("Something".asComment());
            nativeThrow(123);
        }
    }

    get fun getCounter(): Int {
        return self.counter;
    }

    get fun testTryCatch1(): Int {
        try {
            nativeThrowUnless(101, false);
            return 42;
        }
        return 7;
    }

    get fun testTryCatch2(): Int {
        try {
            nativeThrowIf(101, true);
            return 42;
        } catch (e) {
            return e;
        }
    }

    get fun testTryCatch3(): Int {
        try {
            let xs: Slice = beginCell().storeUint(0, 1).endCell().beginParse();
            let x: Int = xs.loadUint(1);
            try {
                nativeThrowUnless(101, false);
            } catch (e) {
                return e / x; // division by zero, exit code = 4
            }
            let e: Int = 123;
            return e;
        } catch (e) {
            return e;
        }
    }
}


## underscore-variable.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/e2e-emulated/contracts/underscore-variable.tact)
contract UnderscoreVariableTestContract {
    something: Int;

    init() {
        self.something = 0;
    }

    receive() {
        // Nothing to do
    }

    fun increaseSomething(): Int {
        self.something += 1;
        return 123;
    }

    get fun test1(): Int {
        try {
            nativeThrowIf(1, true);
        } catch (_) {
            return 0;
        }
        return 1;
    }

    get fun test2(): Int {
        let m: map<Int, Int> = emptyMap();
        m.set(1, 2);
        m.set(2, 4);
        m.set(3, 6);
        let x: Int = 0;
        foreach (_, v in m) {
            x += v;
        }
        return x;
    }

    get fun test3(): Int {
        let m: map<Int, Int> = emptyMap();
        m.set(1, 2);
        m.set(2, 4);
        m.set(3, 6);
        let x: Int = 0;
        foreach (k, _ in m) {
            x += k;
        }
        return x;
    }

    get fun test4(): Int {
        let _: Int = self.increaseSomething();
        let _: Int = self.increaseSomething();
        let _ = self.increaseSomething();
        let _ = self.increaseSomething();
        return self.something;
    }
}

## compute-phase-errors.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/exit-codes/compute-phase-errors.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import {
    ComputePhaseErrorsTester as TestContract,
    ExitCode4,
} from "./contracts/output/compute-phase-errors_ComputePhaseErrorsTester";
import "@ton/test-utils";

describe("compute phase errors", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<TestContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure", {
            resetBalanceIfZero: true,
        });

        contract = blockchain.openContract(await TestContract.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10000") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    // 0: success
    it("should test exit code 0", async () => {
        await testComputePhaseExitCode(0, contract, treasure);
    });

    // 1: alt. success code
    it("should test exit code 1", async () => {
        await testComputePhaseExitCode(1, contract, treasure);
    });

    // 2: stack underflow
    it("should test exit code 2", async () => {
        await testComputePhaseExitCode(2, contract, treasure);
    });

    // 3: Stack overflow
    it("should test exit code 3", async () => {
        await testComputePhaseExitCode(3, contract, treasure);
    });

    // 4: Integer overflow
    it("should test exit code 4", async () => {
        await testComputePhaseExitCode(4, contract, treasure);
    });

    // 5: Integer out of range
    it("should test exit code 5", async () => {
        await testComputePhaseExitCode(5, contract, treasure);
    });

    // 6: Invalid opcode
    it("should test exit code 6", async () => {
        await testComputePhaseExitCode(8, contract, treasure);
    });

    // 7: Type check error
    it("should test exit code 7", async () => {
        await testComputePhaseExitCode(7, contract, treasure);
    });

    // 8: Cell overflow
    it("should test exit code 8", async () => {
        await testComputePhaseExitCode(8, contract, treasure);
    });

    // 9: Cell underflow
    it("should test exit code 9", async () => {
        await testComputePhaseExitCode(9, contract, treasure);
    });

    // 10: Dictionary error
    it("should test exit code 10", async () => {
        await testComputePhaseExitCode(10, contract, treasure);
    });

    // 11: "Unknown" error
    // NOTE: Thrown in various unrelated cases
    it("should test exit code 11", async () => {
        await testComputePhaseExitCode(11, contract, treasure);
    });

    // 12: Fatal error
    // NOTE: thrown by TVM in situations deemed impossible

    // 13 (actually, -14): Out of gas
    it("should test exit code 13", async () => {
        await testComputePhaseExitCode(13, contract, treasure);
    });

    // 14: Virtualization error
    // NOTE: Reserved, but never thrown
});

async function testComputePhaseExitCode(
    code: number,
    contract: SandboxContract<TestContract>,
    treasure: SandboxContract<TreasuryContract>,
) {
    expect(code).toBeGreaterThanOrEqual(0);
    expect(code).toBeLessThan(128);
    expect([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13]).toContain(code);
    type testedExitCodes =
        | "0"
        | "1"
        | "2"
        | "3"
        | ExitCode4
        | "5"
        | "6"
        | "7"
        | "8"
        | "9"
        | "10"
        | "11"
        | "13";

    const sendResult = await contract.send(
        treasure.getSender(),
        { value: toNano("10") },
        code === 4
            ? {
                  $$type: "ExitCode4",
                  val0: BigInt(0),
                  val1: BigInt(1),
              }
            : (code.toString(10) as testedExitCodes),
    );

    expect(sendResult.transactions).toHaveTransaction({
        from: treasure.address,
        to: contract.address,
        success: code === 0 || code === 1 ? true : false,
        exitCode: code === 13 ? -14 : code,
    });
}


## repeat-range.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/exit-codes/repeat-range.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { RepeatRangeTester as TestContract } from "./contracts/output/repeat-range_RepeatRangeTester";
import "@ton/test-utils";

describe("repeat range", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<TestContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure", {
            resetBalanceIfZero: true,
        });

        contract = blockchain.openContract(await TestContract.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    it("should test repeat range boundaries", async () => {
        // ignored range
        expect(await contract.getTestIgnoredRange()).toEqual(true);

        // invalid range
        expect(await contract.getTestInvalidRange()).toEqual(true);

        // min effective range
        expect(await contract.getTestMinEffectiveRange()).toEqual(true);

        // max effective range
        const sendResult = await contract.send(
            treasure.getSender(),
            { value: toNano("10") },
            "testMaxEffectiveRange",
        );
        expect(sendResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: false,
            exitCode: -14,
        });
    });
});


## tact-reserved-contract-errors.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/exit-codes/tact-reserved-contract-errors.spec.ts)
import { toNano } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import { ReservedContractErrorsTester as TestContract } from "./contracts/output/tact-reserved-contract-errors_ReservedContractErrorsTester";
import "@ton/test-utils";

describe("Tact-reserved contract errors", () => {
    let blockchain: Blockchain;
    let treasure: SandboxContract<TreasuryContract>;
    let contract: SandboxContract<TestContract>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();
        blockchain.verbosity.print = false;
        treasure = await blockchain.treasury("treasure", {
            resetBalanceIfZero: true,
        });

        contract = blockchain.openContract(await TestContract.fromInit());

        const deployResult = await contract.send(
            treasure.getSender(),
            { value: toNano("100000") },
            null,
        );

        expect(deployResult.transactions).toHaveTransaction({
            from: treasure.address,
            to: contract.address,
            success: true,
            deploy: true,
        });
    });

    // 128: Null reference exception
    it("should test exit code 128", async () => {
        await testReservedExitCode(128, contract, treasure);
    });

    // 129: Invalid serialization prefix
    // NOTE: Reserved, but due to a number of prior checks it cannot be thrown unless one hijacks
    //       the contract code before deployment and changes the opcodes of the Messages expected
    //       to be received in the contract

    // 130: Invalid incoming message
    it("should test exit code 130", async () => {
        await testReservedExitCode(130, contract, treasure);
    });

    // 131: Constraints error
    // NOTE: Reserved, but never thrown anywhere, can't repro

    // 132: Access denied
    it("should test exit code 132", async () => {
        await testReservedExitCode(132, contract, treasure);
    });

    // 133: Contract stopped
    // NOTE: Reserved, but never thrown anywhere, can't repro

    // 134: Invalid argument
    it("should test exit code 134", async () => {
        await testReservedExitCode(134, contract, treasure);
    });

    // 135: Code of a contract was not found
    // NOTE: Reserved, but one has to replace the contract code to trigger it
});

async function testReservedExitCode(
    code: number,
    contract: SandboxContract<TestContract>,
    treasure: SandboxContract<TreasuryContract>,
) {
    expect(code).toBeGreaterThanOrEqual(128);
    expect(code).toBeLessThan(256);
    expect([128, 130, 132, 134]).toContain(code);
    type testedExitCodes = "128" | "130" | "132" | "134";

    const sendResult = await contract.send(
        treasure.getSender(),
        { value: toNano("10") },
        code.toString(10) as testedExitCodes,
    );

    expect(sendResult.transactions).toHaveTransaction({
        from: code === 130 ? contract.address : treasure.address,
        to: contract.address,
        success: false,
        exitCode: code,
    });
}


## compute-phase-errors.fc (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/exit-codes/contracts/compute-phase-errors.fc)
() stack_overflow() impure asm """
    <{
    }>CONT // c
    0 SETNUMARGS // c'
    2 PUSHINT // c' 2
    SWAP // 2 c'
    1 -1 SETCONTARGS
""";


## compute-phase-errors.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/exit-codes/contracts/compute-phase-errors.tact)
import "./compute-phase-errors.fc";

contract ComputePhaseErrorsTester {
    // Used for storing temporary values
    tmpI: Int = 0;
    tmpC: Cell = cell("te6cckEBAQEAAgAAAEysuc0="); // empty cell

    /// To handle deployment
    receive() {}

    /// Exit code 0
    receive("0") {
        throw(0); // Yes, that still counts as a success
    }

    /// Exit code 1
    receive("1") {
        throw(1); // Yes, that still counts as a success
    }

    /// Exit code 2
    receive("2") {
        // Removes 100 elements from the stack, causing an underflow
        repeat (100) {
            drop();
        }
    }

    /// Exit code 3
    receive("3") {
        stackOverflow();
    }

    /// Exit code 4
    receive(msg: ExitCode4) {
        // Setup
        let targetCode = 4;
        let failed = true;

        // Addition
        try {
            self.tmpI = pow(2, 255) - 1 + pow(2, 255) + msg.val1;
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Addition didn't cause an integer overflow");

        // Subtraction
        try {
            self.tmpI = -pow(2, 255) - pow(2, 255) - msg.val1;
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Subtraction didn't cause an integer overflow");

        // Negation
        try {
            self.tmpI = -(-pow(2, 255) - pow(2, 255) + msg.val0);
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Negation didn't cause an integer overflow");

        // Multiplication
        try {
            self.tmpI = pow(2, 255) * (msg.val1 + 1);
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Multiplication didn't cause an integer overflow");

        // Division
        try {
            self.tmpI = (-pow(2, 255) - pow(2, 255)) / (-msg.val1);
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Division didn't cause an integer overflow");

        // Division by zero
        try {
            self.tmpI = 1 / msg.val0;
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Division by zero didn't cause an integer overflow");

        // Modulo by zero
        try {
            self.tmpI = 1 % msg.val0;
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Modulo by zero didn't cause an integer overflow");

        // As we got here, everything above caused the target exit code,
        // so let's throw it explicitly now for the tests on Blueprint's side
        throw(targetCode);
    }

    /// Exit code 5
    receive("5") {
        // Builder.storeUint() function can only use up to 256 bits,
        // so 512 is too much and the negative value cannot be stored either
        self.tmpC = beginCell().storeUint(-1, 512).endCell();
    }

    // Exit code 6
    receive("6") {
        invalidOpcode();
    }

    /// Exit code 7
    receive("7") {
        typeCheckError().get(0)!!;
    }

    /// Exit code 8
    receive("8") {
        // Setup
        let targetCode = 8;
        let failed = true;

        // Cell overflow (data)
        try {
            self.tmpC = beginCell()
                .storeInt(0, 250)
                .storeInt(0, 250)
                .storeInt(0, 250)
                .storeInt(0, 250)
                .storeInt(0, 24) // 1024 bits!
                .endCell();
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "1024 bits didn't cause the cell overflow");

        // Cell overflow (refs)
        try {
            self.tmpC = beginCell()
                .storeRef(emptyCell())
                .storeRef(emptyCell())
                .storeRef(emptyCell())
                .storeRef(emptyCell())
                .storeRef(emptyCell()) // 5 refs!
                .endCell();
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "5 refs didn't cause the cell overflow");

        // As we got here, everything above caused the target exit code,
        // so let's throw it explicitly now for the tests on Blueprint's side
        throw(targetCode);
    }

    /// Exit code 9
    receive("9") {
        // Setup
        let targetCode = 9;
        let failed = true;

        // Cell underflow (data)
        try {
            self.tmpI = emptySlice().loadInt(1);
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Loading 1 bit from an empty Slice didn't cause the cell underflow");

        // Cell underflow (refs)
        try {
            self.tmpC = emptySlice().loadRef();
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Loading 1 ref from an empty Slice didn't cause the cell underflow");

        // As we got here, everything above caused the target exit code,
        // so let's throw it explicitly now for the tests on Blueprint's side
        throw(targetCode);
    }

    /// Exit code 10
    receive("10") {
        // The Int to Int dictionary is being misinterpreted as a map<Int, Cell>
        let m: map<Int, Cell> = toMapIntCell(cellWithDictIntInt.beginParse());

        // And the error happens only when we touch it
        self.tmpC = m.get(0)!!;
    }

    /// Exit code 11
    receive("11") {
        // Unlike nativeSendMessage which uses SENDRAWMSG, this one uses SENDMSG,
        // and therefore fails in Compute phase when the message is ill-formed
        nativeSendMessageReturnForwardFee(emptyCell(), 0);
    }

    /// Exit code 13 (-14, to be precise)
    receive("13") {
        let counter = 0;
        repeat (pow(2, 31) - 1) {
            counter += 1;
        }
    }
}

/// Exit code 4
message(4) ExitCode4 {
    val0: Int as uint2 = 0;
    val1: Int as uint2 = 1;
}

/// Pre-computed Int to Int dictionary with two entries — 0: 0 and 1: 1
const cellWithDictIntInt: Cell = cell("te6cckEBBAEAUAABAcABAgPQCAIDAEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMLMbT1U=");

/// Tries to preload a dictionary from a Slice as a map<Int, Int>
asm fun toMapIntInt(x: Slice): map<Int, Int> { PLDDICT }

/// Tries to preload a dictionary from a Slice as a map<Int, Cell>
asm fun toMapIntCell(x: Slice): map<Int, Cell> { PLDDICT }

/// Non-existent opcode
asm fun invalidOpcode() { x{D7FF} @addop }

/// DROP
asm fun drop() { DROP }

/// Stack overflow
@name(stack_overflow)
native stackOverflow();

/// Type check error
asm fun typeCheckError(): map<Int, Int> { 42 PUSHINT }


## repeat-range.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/exit-codes/contracts/repeat-range.tact)
contract RepeatRangeTester {
    /// To handle deployment
    receive() {}

    /// from -2^{256} to 0, including both ends
    get fun testIgnoredRange(): Bool {
        let counter = 0;

        repeat ((-pow(2, 255)) * 2) { counter += 1 }
        repeat (-1) { counter += 1 }
        repeat (0) { counter += 1 }

        return counter == 0;
    }

    /// from 2^{31} to +∞ — repeat range is too big
    get fun testInvalidRange(): Bool {
        try {
            let counter = 0;
            repeat (pow(2, 31)) { counter += 1 }

            return false;
        } catch (exitCode) {
            return exitCode == 5;
        }
    }

    /// from 1 to 2^{31} - 1, including both ends
    get fun testMinEffectiveRange(): Bool {
        let counter = 0;
        repeat (1) { counter += 1 }

        return counter == 1;
    }
    
    /// from 1 to 2^{31} - 1, including both ends
    receive("testMaxEffectiveRange") {
        let counter = pow(2, 31) - 1;

        // This will cause exit code -14 in Compute phase (as expected)
        repeat (pow(2, 31) - 1) { counter += 1 }
    }
}


## tact-reserved-contract-errors.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/exit-codes/contracts/tact-reserved-contract-errors.tact)
import "@stdlib/ownable";
import "@stdlib/dns";

message(1478) SpanishInquisition {}

contract ReservedContractErrorsTester with Ownable {
    /// To make Ownable work
    owner: Address;

    /// Setups address of this contract to be its owner
    init() { self.owner = myAddress() }

    /// To handle deployment
    receive() {}

    /// Exit code 128
    receive("128") {
        let gotcha: String? = null;
        dump(gotcha!!);
    }

    /// Exit code 130
    receive("130") {
        send(SendParameters{
            to: myAddress(), // Send a message back to this contract
            value: 0,
            mode: SendRemainingValue | SendIgnoreErrors,
            body: SpanishInquisition{}.toCell(), // Nobody expects it!
        });
    }

    /// Exit code 132
    receive("132") {
        self.requireOwner();
    }

    /// Exit code 134
    receive("134") {
        // Setup
        let targetCode = 134;
        let failed = true;

        // Case 1
        try {
            // 0 is code of NUL in ASCII and it is not valid Base64
            dump(beginCell()
                .storeUint(0, 8)
                .asSlice()
                .fromBase64());
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Slice.fromBase64() didn't error on invalid Base64");

        // Case 2
        try {
            // 0 is code of NUL in ASCII and it is not valid Base64
            dump("\x00".fromBase64());
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "String.fromBase64() didn't error on invalid Base64");

        // Case 3
        try {
            dump((42).toFloatString(-1));
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Int.toFloatString() didn't error on digits -1");

        // Case 4
        try {
            dump((42).toFloatString(78));
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "Int.toFloatString() didn't error on digits 78");

        // Case 5
        try {
            // Refs in the passed Slice are prohibited
            let sliceWithRef = beginCell().storeRef(emptyCell()).asSlice();
            dump(dnsInternalNormalize(sliceWithRef));
            failed = false;
        } catch (exitCode) {
            nativeThrowIf(exitCode, exitCode != targetCode);
        }
        require(failed, "dnsInternalNormalize() didn't error on Slice with refs");

        // As we got here, everything above caused the target exit code,
        // so let's throw it explicitly now for the tests on Blueprint's side
        throw(targetCode);
    }
}


## randomAddress.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/test/utils/randomAddress.ts)
import Prando from "prando";
import { Address } from "@ton/core";

export function randomAddress(workchain: number, seed: string) {
    const random = new Prando(seed);
    const hash = Buffer.alloc(32);
    for (let i = 0; i < hash.length; i++) {
        hash[i] = random.nextInt(0, 255);
    }
    return new Address(workchain, hash);
}


## getSupportedInterfaces.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/getSupportedInterfaces.ts)
import { enabledDebug } from "../config/features";
import { CompilerContext } from "../context";
import { TypeDescription } from "./types";

export function getSupportedInterfaces(
    type: TypeDescription,
    ctx: CompilerContext,
) {
    const interfaces: string[] = [];
    interfaces.push("org.ton.abi.ipfs.v0");
    interfaces.push("org.ton.deploy.lazy.v0");
    if (enabledDebug(ctx)) {
        interfaces.push("org.ton.debug.v0");
    }
    type.interfaces.forEach((iface) => interfaces.push(iface));
    return interfaces;
}


## isRuntimeType.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/isRuntimeType.ts)
import { TypeRef } from "./types";

export function isRuntimeType(src: TypeRef): boolean {
    if (src.kind === "null") {
        return true;
    }
    if (src.kind === "ref_bounced") {
        return true;
    }
    return false;
}


## resolveABITypeRef.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/resolveABITypeRef.ts)
import { ABITypeRef } from "@ton/core";
import {
    AstFieldDecl,
    AstTypeId,
    eqNames,
    idText,
    isAddress,
    isBool,
    isBuilder,
    isCell,
    isInt,
    isSlice,
    isString,
    isStringBuilder,
} from "../grammar/ast";
import {
    idTextErr,
    throwCompilationError,
    throwInternalCompilerError,
} from "../errors";
import { TypeRef } from "./types";
import { CompilerContext } from "../context";
import { getType } from "./resolveDescriptors";
import { SrcInfo } from "../grammar";

type FormatDef = Record<
    string,
    { type: string; format: string | number } | undefined
>;

const uintOptions: FormatDef = Object.fromEntries(
    [...Array(257).keys()]
        .slice(1)
        .map((key) => [`uint${key}`, { type: "uint", format: key }]),
);

const intOptions: FormatDef = Object.fromEntries(
    [...Array(257).keys()]
        .slice(1)
        .map((key) => [`int${key}`, { type: "int", format: key }]),
);

const intFormats: FormatDef = {
    ...uintOptions,
    ...intOptions,
    int257: { type: "int", format: 257 },
    coins: { type: "uint", format: "coins" },
};

export const intMapFormats: FormatDef = { ...intFormats };

const cellFormats: FormatDef = {
    remaining: { type: "cell", format: "remainder" },
};

const sliceFormats: FormatDef = {
    remaining: { type: "slice", format: "remainder" },
    bytes32: { type: "fixed-bytes", format: 32 },
    bytes64: { type: "fixed-bytes", format: 64 },
};

const builderFormats: FormatDef = {
    remaining: { type: "builder", format: "remainder" },
};

export function resolveABIType(src: AstFieldDecl): ABITypeRef {
    if (
        src.type.kind === "type_id" ||
        (src.type.kind === "optional_type" &&
            src.type.typeArg.kind == "type_id")
    ) {
        //
        // Primitive types
        //

        const typeId: AstTypeId =
            src.type.kind === "type_id"
                ? src.type
                : src.type.typeArg.kind === "type_id"
                  ? src.type.typeArg
                  : throwInternalCompilerError(
                        "Only optional type identifiers are supported now",
                        src.type.typeArg.loc,
                    );

        if (isInt(typeId)) {
            if (src.as) {
                const fmt = intFormats[idText(src.as)];
                if (!fmt) {
                    throwCompilationError(
                        `Unsupported format ${idTextErr(src.as)}`,
                        src.loc,
                    );
                }
                return {
                    kind: "simple",
                    type: fmt.type,
                    optional: src.type.kind === "optional_type",
                    format: fmt.format,
                };
            }
            return {
                kind: "simple",
                type: "int",
                optional: src.type.kind === "optional_type",
                format: 257,
            }; // Default is maximum size int
        }
        if (isBool(typeId)) {
            if (src.as) {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.as)}`,
                    src.loc,
                );
            }
            return {
                kind: "simple",
                type: "bool",
                optional: src.type.kind === "optional_type",
            };
        }
        if (isCell(typeId)) {
            if (src.as) {
                const fmt = cellFormats[idText(src.as)];
                if (!fmt) {
                    throwCompilationError(
                        `Unsupported format ${idTextErr(src.as)}`,
                        src.loc,
                    );
                }
                return {
                    kind: "simple",
                    type: fmt.type,
                    optional: src.type.kind === "optional_type",
                    format: fmt.format,
                };
            }
            return {
                kind: "simple",
                type: "cell",
                optional: src.type.kind === "optional_type",
            };
        }
        if (isSlice(typeId)) {
            if (src.as) {
                const fmt = sliceFormats[idText(src.as)];
                if (!fmt) {
                    throwCompilationError(
                        `Unsupported format ${idTextErr(src.as)}`,
                        src.loc,
                    );
                }
                return {
                    kind: "simple",
                    type: fmt.type,
                    optional: src.type.kind === "optional_type",
                    format: fmt.format,
                };
            }
            return {
                kind: "simple",
                type: "slice",
                optional: src.type.kind === "optional_type",
            };
        }
        if (isBuilder(typeId)) {
            if (src.as) {
                const fmt = builderFormats[idText(src.as)];
                if (!fmt) {
                    throwCompilationError(
                        `Unsupported format ${idTextErr(src.as)}`,
                        src.loc,
                    );
                }
                return {
                    kind: "simple",
                    type: fmt.type,
                    optional: src.type.kind === "optional_type",
                    format: fmt.format,
                };
            }
            return {
                kind: "simple",
                type: "builder",
                optional: src.type.kind === "optional_type",
            };
        }
        if (isAddress(typeId)) {
            if (src.as) {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.as)}`,
                    src.loc,
                );
            }
            return {
                kind: "simple",
                type: "address",
                optional: src.type.kind === "optional_type",
            };
        }
        if (isString(typeId)) {
            if (src.as) {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.as)}`,
                    src.loc,
                );
            }
            return {
                kind: "simple",
                type: "string",
                optional: src.type.kind === "optional_type",
            };
        }
        if (isStringBuilder(typeId)) {
            throwCompilationError(`Unsupported type StringBuilder`, src.loc);
        }

        //
        // Structs
        //

        if (src.as) {
            if (eqNames(src.as, "reference")) {
                return {
                    kind: "simple",
                    type: idText(typeId),
                    optional: src.type.kind === "optional_type",
                    format: "ref",
                };
            } else {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.as)}`,
                    src.loc,
                );
            }
        }
        return {
            kind: "simple",
            type: idText(typeId),
            optional: src.type.kind === "optional_type",
        };
    }

    //
    // Map
    //

    if (src.type.kind === "map_type") {
        let key: string;
        let keyFormat: string | number | undefined = undefined;
        let value: string;
        let valueFormat: string | number | undefined = undefined;

        // Resolve key type
        if (isInt(src.type.keyType)) {
            key = "int";
            if (src.type.keyStorageType) {
                const format = intMapFormats[idText(src.type.keyStorageType)];
                if (!format || format.format === "coins") {
                    throwCompilationError(
                        `Unsupported format ${idTextErr(src.type.keyStorageType)} for map key`,
                        src.loc,
                    );
                }
                key = format.type;
                keyFormat = format.format;
            }
        } else if (isAddress(src.type.keyType)) {
            key = "address";
            if (src.type.keyStorageType) {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.type.keyStorageType)} for map key`,
                    src.loc,
                );
            }
        } else {
            throwCompilationError(
                `Unsupported map key type ${idTextErr(src.type.keyType)}`,
                src.loc,
            );
        }

        // Resolve value type
        if (isInt(src.type.valueType)) {
            value = "int";
            if (src.type.valueStorageType) {
                const format = intMapFormats[idText(src.type.valueStorageType)];
                if (!format) {
                    throwCompilationError(
                        `Unsupported format ${idText(src.type.valueStorageType)} for map value`,
                        src.loc,
                    );
                }
                value = format.type;
                valueFormat = format.format;
            }
        } else if (isBool(src.type.valueType)) {
            value = "bool";
            if (src.type.valueStorageType) {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.type.valueStorageType)} for map value`,
                    src.loc,
                );
            }
        } else if (isCell(src.type.valueType)) {
            value = "cell";
            valueFormat = "ref";
            if (
                src.type.valueStorageType &&
                eqNames(src.type.valueStorageType, "reference")
            ) {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.type.valueStorageType)} for map value`,
                    src.loc,
                );
            }
        } else if (isSlice(src.type.valueType)) {
            throwCompilationError(
                `Unsupported map value type ${idTextErr(src.type.valueType)}`,
                src.loc,
            );
        } else if (isAddress(src.type.valueType)) {
            value = "address";
            if (src.type.valueStorageType) {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.type.valueStorageType)} for map value`,
                    src.loc,
                );
            }
        } else if (isString(src.type.valueType)) {
            throwCompilationError(
                `Unsupported map value type ${idTextErr(src.type.valueType)}`,
                src.loc,
            );
        } else if (
            isStringBuilder(src.type.valueType) ||
            isBuilder(src.type.valueType)
        ) {
            throwCompilationError(
                `Unsupported map value type ${idTextErr(src.type.valueType)}`,
                src.loc,
            );
        } else {
            value = idText(src.type.valueType);
            valueFormat = "ref";
            if (
                src.type.valueStorageType &&
                eqNames(src.type.valueStorageType, "reference")
            ) {
                throwCompilationError(
                    `Unsupported format ${idTextErr(src.type.valueStorageType)} for map value`,
                    src.loc,
                );
            }
        }

        return { kind: "dict", key, keyFormat, value, valueFormat };
    }

    throwCompilationError(`Unsupported type`, src.loc);
}

export function createABITypeRefFromTypeRef(
    ctx: CompilerContext,
    src: TypeRef,
    loc: SrcInfo,
): ABITypeRef {
    if (src.kind === "ref") {
        // Primitives
        if (src.name === "Int") {
            return {
                kind: "simple",
                type: "int",
                optional: src.optional,
                format: 257,
            }; // Default is maximum size int
        }
        if (src.name === "Bool") {
            return { kind: "simple", type: "bool", optional: src.optional };
        }
        if (src.name === "Cell") {
            return { kind: "simple", type: "cell", optional: src.optional };
        }
        if (src.name === "Slice") {
            return { kind: "simple", type: "slice", optional: src.optional };
        }
        if (src.name === "Builder") {
            return { kind: "simple", type: "builder", optional: src.optional };
        }
        if (src.name === "Address") {
            return { kind: "simple", type: "address", optional: src.optional };
        }
        if (src.name === "String") {
            return { kind: "simple", type: "string", optional: src.optional };
        }
        if (src.name === "StringBuilder") {
            throwInternalCompilerError(`Unsupported type "${src.name}"`);
        }

        // Structs
        const type = getType(ctx, src.name);
        if (type.kind === "contract") {
            return {
                kind: "simple",
                type: src.name + "$Data",
                optional: src.optional,
            };
        } else {
            return { kind: "simple", type: src.name, optional: src.optional };
        }
    }

    if (src.kind === "map") {
        let key: string;
        let keyFormat: string | number | undefined = undefined;
        let value: string;
        let valueFormat: string | number | undefined = undefined;

        // Resolve key type
        if (src.key === "Int") {
            key = "int";
            if (src.keyAs) {
                const format = intMapFormats[src.keyAs];
                if (!format || src.keyAs === "coins") {
                    throwCompilationError(
                        `Unsupported format ${src.keyAs} for map key`,
                        loc,
                    );
                }
                key = format.type;
                keyFormat = format.format;
            }
        } else if (src.key === "Address") {
            key = "address";
            if (src.keyAs) {
                throwCompilationError(
                    `Unsupported format ${src.keyAs} for map key`,
                    loc,
                );
            }
        } else {
            throwInternalCompilerError(`Unsupported map key type "${src.key}"`);
        }

        // Resolve value type
        if (src.value === "Int") {
            value = "int";
            if (src.valueAs) {
                const format = intMapFormats[src.valueAs];
                if (!format) {
                    throwCompilationError(
                        `Unsupported format ${src.valueAs} for map value`,
                        loc,
                    );
                }
                value = format.type;
                valueFormat = format.format;
            }
        } else if (src.value === "Bool") {
            value = "bool";
            if (src.valueAs) {
                throwCompilationError(
                    `Unsupported format ${src.valueAs} for map value`,
                    loc,
                );
            }
        } else if (src.value === "Cell") {
            value = "cell";
            valueFormat = "ref";
            if (src.valueAs && src.valueAs !== "reference") {
                throwCompilationError(
                    `Unsupported format ${src.valueAs} for map value`,
                    loc,
                );
            }
        } else if (src.value === "Slice") {
            throwInternalCompilerError(
                `Unsupported map value type "${src.value}"`,
            );
        } else if (src.value === "Address") {
            value = "address";
            if (src.valueAs) {
                throwCompilationError(
                    `Unsupported format ${src.valueAs} for map value`,
                    loc,
                );
            }
        } else if (src.value === "String") {
            throwInternalCompilerError(
                `Unsupported map value type "${src.value}"`,
            );
        } else if (src.value === "StringBuilder" || src.value === "Builder") {
            throwInternalCompilerError(
                `Unsupported map value type "${src.value}"`,
            );
        } else {
            value = src.value;
            valueFormat = "ref";
            if (src.valueAs && src.valueAs !== "reference") {
                throwCompilationError(
                    `Unsupported format ${src.valueAs} for map value`,
                    loc,
                );
            }
        }

        return { kind: "dict", key, keyFormat, value, valueFormat };
    }

    if (src.kind === "ref_bounced") {
        throwInternalCompilerError("Unexpected bounced reference");
    }

    throwInternalCompilerError(`Unsupported type`);
}


## resolveDescriptors.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/resolveDescriptors.spec.ts)
import { CompilerContext } from "../context";
import {
    getAllStaticFunctions,
    getAllTypes,
    resolveDescriptors,
} from "./resolveDescriptors";
import { resolveSignatures } from "./resolveSignatures";
import { loadCases } from "../utils/loadCases";
import { openContext } from "../grammar/store";
import { featureEnable } from "../config/features";
import { getParser, SrcInfo } from "../grammar";
import { getAstFactory } from "../grammar/ast";
import { isSrcInfo } from "../grammar/src-info";

expect.addSnapshotSerializer({
    test: (src) => isSrcInfo(src),
    print: (src) => (src as SrcInfo).contents,
});

describe("resolveDescriptors", () => {
    for (const r of loadCases(__dirname + "/test/")) {
        it("should resolve descriptors for " + r.name, () => {
            const Ast = getAstFactory();
            let ctx = openContext(
                new CompilerContext(),
                [{ code: r.code, path: "<unknown>", origin: "user" }],
                [],
                getParser(Ast),
            );
            ctx = featureEnable(ctx, "external");
            ctx = resolveDescriptors(ctx, Ast);
            ctx = resolveSignatures(ctx);
            expect(getAllTypes(ctx)).toMatchSnapshot();
            expect(getAllStaticFunctions(ctx)).toMatchSnapshot();
        });
    }
    for (const r of loadCases(__dirname + "/test-failed/")) {
        it("should fail descriptors for " + r.name, () => {
            const Ast = getAstFactory();
            let ctx = openContext(
                new CompilerContext(),
                [{ code: r.code, path: "<unknown>", origin: "user" }],
                [],
                getParser(Ast),
            );
            ctx = featureEnable(ctx, "external");
            expect(() => {
                ctx = resolveDescriptors(ctx, Ast);
                ctx = resolveSignatures(ctx);
            }).toThrowErrorMatchingSnapshot();
        });
    }
});


## resolveDescriptors.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/resolveDescriptors.ts)
import {
    AstConstantDef,
    AstFieldDecl,
    AstContractInit,
    AstNativeFunctionDecl,
    AstNode,
    AstType,
    idText,
    AstId,
    eqNames,
    AstFunctionDef,
    isSelfId,
    isSlice,
    AstFunctionDecl,
    AstConstantDecl,
    AstExpression,
    AstMapType,
    AstTypeId,
    AstAsmFunctionDef,
    FactoryAst,
} from "../grammar/ast";
import { traverse } from "../grammar/iterators";
import {
    idTextErr,
    throwCompilationError,
    throwInternalCompilerError,
} from "../errors";
import { CompilerContext, Store, createContextStore } from "../context";
import {
    ConstantDescription,
    FieldDescription,
    FunctionParameter,
    FunctionDescription,
    InitParameter,
    InitDescription,
    printTypeRef,
    ReceiverSelector,
    receiverSelectorName,
    TypeDescription,
    TypeRef,
    typeRefEquals,
} from "./types";
import { getRawAST } from "../grammar/store";
import { cloneNode } from "../grammar/clone";
import { crc16 } from "../utils/crc16";
import { isSubsetOf } from "../utils/isSubsetOf";
import { evalConstantExpression } from "../constEval";
import { resolveABIType, intMapFormats } from "./resolveABITypeRef";
import { enabledExternals } from "../config/features";
import { isRuntimeType } from "./isRuntimeType";
import { GlobalFunctions } from "../abi/global";
import { ItemOrigin } from "../grammar";
import { getExpType, resolveExpression } from "./resolveExpression";
import { emptyContext } from "./resolveStatements";
import { isAssignable } from "./subtyping";

const store = createContextStore<TypeDescription>();
const staticFunctionsStore = createContextStore<FunctionDescription>();
const staticConstantsStore = createContextStore<ConstantDescription>();

// this function does not handle the case of structs
function verifyMapAsAnnotationsForPrimitiveTypes(
    type: AstTypeId,
    asAnnotation: AstId | null,
): void {
    switch (idText(type)) {
        case "Int": {
            if (
                asAnnotation !== null &&
                !Object.keys(intMapFormats).includes(idText(asAnnotation))
            ) {
                throwCompilationError(
                    'Invalid `as`-annotation for type "Int" type',
                    asAnnotation.loc,
                );
            }
            return;
        }
        case "Address":
        case "Bool":
        case "Cell": {
            if (asAnnotation !== null) {
                throwCompilationError(
                    `${idTextErr(type)} type cannot have as-annotation`,
                    asAnnotation.loc,
                );
            }
            return;
        }
        default: {
            throwInternalCompilerError("Unsupported map type", type.loc);
        }
    }
}

function verifyMapTypes(
    typeId: AstTypeId,
    asAnnotation: AstId | null,
    allowedTypeNames: string[],
): void {
    if (!allowedTypeNames.includes(idText(typeId))) {
        throwCompilationError(
            "Invalid map type. Check https://docs.tact-lang.org/book/maps#allowed-types",
            typeId.loc,
        );
    }
    verifyMapAsAnnotationsForPrimitiveTypes(typeId, asAnnotation);
}

function verifyMapType(mapTy: AstMapType, isValTypeStruct: boolean) {
    // optional and other compound key and value types are disallowed at the level of grammar

    // check allowed key types
    verifyMapTypes(mapTy.keyType, mapTy.keyStorageType, ["Int", "Address"]);

    // check allowed value types
    if (isValTypeStruct && mapTy.valueStorageType === null) {
        return;
    }
    // the case for struct/message is already checked
    verifyMapTypes(mapTy.valueType, mapTy.valueStorageType, [
        "Int",
        "Address",
        "Bool",
        "Cell",
    ]);
}

export const toBounced = (type: string) => `${type}%%BOUNCED%%`;

export function resolveTypeRef(ctx: CompilerContext, type: AstType): TypeRef {
    switch (type.kind) {
        case "type_id": {
            const t = getType(ctx, idText(type));
            return {
                kind: "ref",
                name: t.name,
                optional: false,
            };
        }
        case "optional_type": {
            if (type.typeArg.kind !== "type_id") {
                throwInternalCompilerError(
                    "Only optional type identifiers are supported now",
                    type.typeArg.loc,
                );
            }
            const t = getType(ctx, idText(type.typeArg));
            return {
                kind: "ref",
                name: t.name,
                optional: true,
            };
        }
        case "map_type": {
            const keyTy = getType(ctx, idText(type.keyType));
            const valTy = getType(ctx, idText(type.valueType));
            verifyMapType(type, valTy.kind === "struct");
            return {
                kind: "map",
                key: keyTy.name,
                keyAs:
                    type.keyStorageType !== null
                        ? idText(type.keyStorageType)
                        : null,
                value: valTy.name,
                valueAs:
                    type.valueStorageType !== null
                        ? idText(type.valueStorageType)
                        : null,
            };
        }
        case "bounced_message_type": {
            const t = getType(ctx, idText(type.messageType));
            return {
                kind: "ref_bounced",
                name: t.name,
            };
        }
    }
}

function buildTypeRef(
    type: AstType,
    types: Map<string, TypeDescription>,
): TypeRef {
    switch (type.kind) {
        case "type_id": {
            if (!types.has(idText(type))) {
                throwCompilationError(
                    `Type ${idTextErr(type)} not found`,
                    type.loc,
                );
            }
            return {
                kind: "ref",
                name: idText(type),
                optional: false,
            };
        }
        case "optional_type": {
            if (type.typeArg.kind !== "type_id") {
                throwInternalCompilerError(
                    "Only optional type identifiers are supported now",
                    type.typeArg.loc,
                );
            }
            if (!types.has(idText(type.typeArg))) {
                throwCompilationError(
                    `Type ${idTextErr(type.typeArg)} not found`,
                    type.loc,
                );
            }
            return {
                kind: "ref",
                name: idText(type.typeArg),
                optional: true,
            };
        }
        case "map_type": {
            if (!types.has(idText(type.keyType))) {
                throwCompilationError(
                    `Type ${idTextErr(type.keyType)} not found`,
                    type.loc,
                );
            }
            if (!types.has(idText(type.valueType))) {
                throwCompilationError(
                    `Type ${idTextErr(type.valueType)} not found`,
                    type.loc,
                );
            }
            const valTy = types.get(idText(type.valueType))!;
            verifyMapType(type, valTy.kind === "struct");
            return {
                kind: "map",
                key: idText(type.keyType),
                keyAs:
                    type.keyStorageType !== null
                        ? idText(type.keyStorageType)
                        : null,
                value: idText(type.valueType),
                valueAs:
                    type.valueStorageType !== null
                        ? idText(type.valueStorageType)
                        : null,
            };
        }
        case "bounced_message_type": {
            return {
                kind: "ref_bounced",
                name: idText(type.messageType),
            };
        }
    }
}

function uidForName(name: string, types: Map<string, TypeDescription>) {
    // Resolve unique typeid from crc16
    let uid = crc16(name);
    while (Array.from(types.values()).find((v) => v.uid === uid)) {
        uid = (uid + 1) % 65536;
    }
    return uid;
}

export function resolveDescriptors(ctx: CompilerContext, Ast: FactoryAst) {
    const types: Map<string, TypeDescription> = new Map();
    const staticFunctions: Map<string, FunctionDescription> = new Map();
    const staticConstants: Map<string, ConstantDescription> = new Map();
    const ast = getRawAST(ctx);

    //
    // Register types
    //

    for (const a of ast.types) {
        if (types.has(idText(a.name))) {
            throwCompilationError(
                `Type "${idText(a.name)}" already exists`,
                a.loc,
            );
        }

        const uid = uidForName(idText(a.name), types);

        switch (a.kind) {
            case "primitive_type_decl":
                {
                    types.set(idText(a.name), {
                        kind: "primitive_type_decl",
                        origin: a.loc.origin,
                        name: idText(a.name),
                        uid,
                        fields: [],
                        traits: [],
                        header: null,
                        tlb: null,
                        signature: null,
                        functions: new Map(),
                        receivers: [],
                        dependsOn: [],
                        init: null,
                        ast: a,
                        interfaces: [],
                        constants: [],
                        partialFieldCount: 0,
                    });
                }
                break;
            case "contract":
                {
                    types.set(idText(a.name), {
                        kind: "contract",
                        origin: a.loc.origin,
                        name: idText(a.name),
                        uid,
                        header: null,
                        tlb: null,
                        fields: [],
                        traits: [],
                        signature: null,
                        functions: new Map(),
                        receivers: [],
                        dependsOn: [],
                        init: null,
                        ast: a,
                        interfaces: a.attributes.map((v) => v.name.value),
                        constants: [],
                        partialFieldCount: 0,
                    });
                }
                break;
            case "struct_decl":
            case "message_decl":
                {
                    types.set(idText(a.name), {
                        kind: "struct",
                        origin: a.loc.origin,
                        name: idText(a.name),
                        uid,
                        header: null,
                        tlb: null,
                        signature: null,
                        fields: [],
                        traits: [],
                        functions: new Map(),
                        receivers: [],
                        dependsOn: [],
                        init: null,
                        ast: a,
                        interfaces: [],
                        constants: [],
                        partialFieldCount: 0,
                    });
                }
                break;
            case "trait": {
                types.set(idText(a.name), {
                    kind: "trait",
                    origin: a.loc.origin,
                    name: idText(a.name),
                    uid,
                    header: null,
                    tlb: null,
                    signature: null,
                    fields: [],
                    traits: [],
                    functions: new Map(),
                    receivers: [],
                    dependsOn: [],
                    init: null,
                    ast: a,
                    interfaces: a.attributes.map((v) => v.name.value),
                    constants: [],
                    partialFieldCount: 0,
                });
            }
        }
    }

    //
    // Resolve fields
    //

    function buildFieldDescription(
        src: AstFieldDecl,
        index: number,
    ): FieldDescription {
        const fieldTy = buildTypeRef(src.type, types);

        // Check if field is runtime type
        if (isRuntimeType(fieldTy)) {
            throwCompilationError(
                printTypeRef(fieldTy) +
                    " is a runtime only type and can't be used as field",
                src.loc,
            );
        }

        // Resolve abi type
        const type = resolveABIType(src);

        return {
            name: idText(src.name),
            type: fieldTy,
            index,
            as: src.as !== null ? idText(src.as) : null,
            default: undefined, // initializer will be evaluated after typechecking
            loc: src.loc,
            ast: src,
            abi: { name: idText(src.name), type },
        };
    }

    function buildConstantDescription(
        src: AstConstantDef | AstConstantDecl,
    ): ConstantDescription {
        const constDeclTy = buildTypeRef(src.type, types);
        return {
            name: idText(src.name),
            type: constDeclTy,
            value: undefined, // initializer will be evaluated after typechecking
            loc: src.loc,
            ast: src,
        };
    }

    for (const a of ast.types) {
        // Contract
        if (a.kind === "contract") {
            for (const f of a.declarations) {
                if (f.kind === "field_decl") {
                    if (
                        types
                            .get(idText(a.name))!
                            .fields.find((v) => eqNames(v.name, f.name))
                    ) {
                        throwCompilationError(
                            `Field ${idTextErr(f.name)} already exists`,
                            f.loc,
                        );
                    }
                    if (
                        types
                            .get(idText(a.name))!
                            .constants.find((v) => eqNames(v.name, f.name))
                    ) {
                        throwCompilationError(
                            `Constant ${idText(f.name)} already exists`,
                            f.loc,
                        );
                    }
                    types
                        .get(idText(a.name))!
                        .fields.push(
                            buildFieldDescription(
                                f,
                                types.get(idText(a.name))!.fields.length,
                            ),
                        );
                } else if (f.kind === "constant_def") {
                    if (
                        types
                            .get(idText(a.name))!
                            .fields.find((v) => eqNames(v.name, f.name))
                    ) {
                        throwCompilationError(
                            `Field ${idTextErr(f.name)} already exists`,
                            f.loc,
                        );
                    }
                    if (
                        types
                            .get(idText(a.name))!
                            .constants.find((v) => eqNames(v.name, f.name))
                    ) {
                        throwCompilationError(
                            `Constant ${idTextErr(f.name)} already exists`,
                            f.loc,
                        );
                    }
                    if (f.attributes.find((v) => v.type !== "override")) {
                        throwCompilationError(
                            `Constant can be only overridden`,
                            f.loc,
                        );
                    }
                    types
                        .get(idText(a.name))!
                        .constants.push(buildConstantDescription(f));
                }
            }
        }

        // Struct
        if (a.kind === "struct_decl" || a.kind === "message_decl") {
            for (const f of a.fields) {
                if (
                    types
                        .get(idText(a.name))!
                        .fields.find((v) => eqNames(v.name, f.name))
                ) {
                    throwCompilationError(
                        `Field ${idTextErr(f.name)} already exists`,
                        f.loc,
                    );
                }
                types
                    .get(idText(a.name))!
                    .fields.push(
                        buildFieldDescription(
                            f,
                            types.get(idText(a.name))!.fields.length,
                        ),
                    );
            }
            if (a.fields.length === 0 && a.kind === "struct_decl") {
                throwCompilationError(
                    `Struct ${idTextErr(a.name)} must have at least one field`,
                    a.loc,
                );
            }
        }

        // Trait
        if (a.kind === "trait") {
            for (const traitDecl of a.declarations) {
                if (traitDecl.kind === "field_decl") {
                    if (
                        types
                            .get(idText(a.name))!
                            .fields.find((v) => eqNames(v.name, traitDecl.name))
                    ) {
                        throwCompilationError(
                            `Field ${idTextErr(traitDecl.name)} already exists`,
                            traitDecl.loc,
                        );
                    }
                    if (traitDecl.as) {
                        throwCompilationError(
                            `Trait field cannot have serialization specifier`,
                            traitDecl.loc,
                        );
                    }
                    if (traitDecl.initializer) {
                        throwCompilationError(
                            `Trait field cannot have an initializer`,
                            traitDecl.initializer.loc,
                        );
                    }
                    types
                        .get(idText(a.name))!
                        .fields.push(
                            buildFieldDescription(
                                traitDecl,
                                types.get(idText(a.name))!.fields.length,
                            ),
                        );
                } else if (
                    traitDecl.kind === "constant_def" ||
                    traitDecl.kind === "constant_decl"
                ) {
                    if (
                        types
                            .get(idText(a.name))!
                            .fields.find((v) => eqNames(v.name, traitDecl.name))
                    ) {
                        throwCompilationError(
                            `Field ${idTextErr(traitDecl.name)} already exists`,
                            traitDecl.loc,
                        );
                    }
                    if (
                        types
                            .get(idText(a.name))!
                            .constants.find((v) =>
                                eqNames(v.name, traitDecl.name),
                            )
                    ) {
                        throwCompilationError(
                            `Constant ${idTextErr(traitDecl.name)} already exists`,
                            traitDecl.loc,
                        );
                    }
                    if (
                        traitDecl.attributes.find((v) => v.type === "override")
                    ) {
                        throwCompilationError(
                            `Trait constant cannot be overridden`,
                            traitDecl.loc,
                        );
                    }
                    types
                        .get(idText(a.name))!
                        .constants.push(buildConstantDescription(traitDecl));
                }
            }
        }
    }

    //
    // Populate partial serialization info
    //

    for (const t of types.values()) {
        t.partialFieldCount = resolvePartialFields(ctx, t);
    }

    //
    // Resolve contract functions
    //

    function resolveFunctionDescriptor(
        optSelf: TypeRef | null,
        a:
            | AstFunctionDef
            | AstNativeFunctionDecl
            | AstFunctionDecl
            | AstAsmFunctionDef,
        origin: ItemOrigin,
    ): FunctionDescription {
        let self = optSelf;

        // Resolve return
        let returns: TypeRef = { kind: "void" };
        if (a.return) {
            returns = buildTypeRef(a.return, types);
        }

        let params: FunctionParameter[] = [];
        for (const r of a.params) {
            params.push({
                name: r.name,
                type: buildTypeRef(r.type, types),
                loc: r.loc,
            });
        }

        // Resolve flags
        const isGetter = a.attributes.find((a) => a.type === "get");
        const isMutating = a.attributes.find((a) => a.type === "mutates");
        const isExtends = a.attributes.find((a) => a.type === "extends");
        const isVirtual = a.attributes.find((a) => a.type === "virtual");
        const isOverride = a.attributes.find((a) => a.type === "override");
        const isInline = a.attributes.find((a) => a.type === "inline");
        const isAbstract = a.attributes.find((a) => a.type === "abstract");

        // Check for native
        if (a.kind === "native_function_decl") {
            if (isGetter) {
                throwCompilationError(
                    "Native functions cannot be getters",
                    isGetter.loc,
                );
            }
            if (self) {
                throwCompilationError(
                    "Native functions cannot be declared within a contract",
                    a.loc,
                );
            }
            if (isVirtual) {
                throwCompilationError(
                    "Native functions cannot be virtual",
                    isVirtual.loc,
                );
            }
            if (isOverride) {
                throwCompilationError(
                    "Native functions cannot be overridden",
                    isOverride.loc,
                );
            }
        }

        // Check virtual and override
        if (isVirtual && isExtends) {
            throwCompilationError(
                "Extend functions cannot be virtual",
                isVirtual.loc,
            );
        }
        if (isOverride && isExtends) {
            throwCompilationError(
                "Extend functions cannot be overridden",
                isOverride.loc,
            );
        }
        if (isAbstract && isExtends) {
            throwCompilationError(
                "Extend functions cannot be abstract",
                isAbstract.loc,
            );
        }
        if (!self && isVirtual) {
            throwCompilationError(
                "Virtual functions must be defined within a contract or a trait",
                isVirtual.loc,
            );
        }
        if (!self && isOverride) {
            throwCompilationError(
                "Overrides functions must be defined within a contract or a trait",
                isOverride.loc,
            );
        }
        if (!self && isAbstract) {
            throwCompilationError(
                "Abstract functions must be defined within a trait",
                isAbstract.loc,
            );
        }
        if (isVirtual && isAbstract) {
            throwCompilationError(
                "Abstract functions cannot be virtual",
                isAbstract.loc,
            );
        }
        if (isVirtual && isOverride) {
            throwCompilationError(
                "Overrides functions cannot be virtual",
                isOverride.loc,
            );
        }
        if (isAbstract && isOverride) {
            throwCompilationError(
                "Overrides functions cannot be abstract",
                isOverride.loc,
            );
        }

        // Check virtual
        if (isVirtual) {
            if (self?.kind !== "ref") {
                throwInternalCompilerError(
                    "Virtual functions must have a self parameter",
                    isVirtual.loc,
                );
            }
            const t = types.get(self.name!)!;
            if (t.kind !== "trait") {
                throwCompilationError(
                    "Virtual functions must be defined within a trait",
                    isVirtual.loc,
                );
            }
        }

        // Check abstract
        if (isAbstract) {
            if (self?.kind !== "ref") {
                throwInternalCompilerError(
                    "Abstract functions must have a self parameter",
                    isAbstract.loc,
                );
            }
            const t = types.get(self.name!)!;
            if (t.kind !== "trait") {
                throwCompilationError(
                    "Abstract functions must be defined within a trait",
                    isAbstract.loc,
                );
            }
        }

        if (isOverride) {
            if (self?.kind !== "ref") {
                throwInternalCompilerError(
                    "Override functions must have a self parameter",
                    isOverride.loc,
                );
            }
            const t = types.get(self.name!)!;
            if (!["contract", "trait"].includes(t.kind)) {
                throwCompilationError(
                    "Overridden functions must be defined within a contract or a trait",
                    isOverride.loc,
                );
            }
        }

        // Check for common
        if (a.kind === "function_def") {
            if (isGetter && !self) {
                throwCompilationError(
                    "Getters must be defined within a contract",
                    isGetter.loc,
                );
            }
        }

        // Check for getter
        if (isInline && isGetter) {
            throwCompilationError("Getters cannot be inline", isInline.loc);
        }

        // Validate mutating
        if (isExtends) {
            if (self) {
                throwCompilationError(
                    "Extend functions cannot be defined within a contract",
                    isExtends.loc,
                );
            }
            if (params.length === 0) {
                throwCompilationError(
                    "Extend functions must have at least one parameter",
                    isExtends.loc,
                );
            }
            const firstParam = params[0]!;
            if (!isSelfId(firstParam.name)) {
                throwCompilationError(
                    'Extend function must have first parameter named "self"',
                    firstParam.loc,
                );
            }
            if (firstParam.type.kind !== "ref") {
                throwCompilationError(
                    "Extend functions must have a reference type as the first parameter",
                    firstParam.loc,
                );
            }
            if (!types.has(firstParam.type.name)) {
                throwCompilationError(
                    "Type " + firstParam.type.name + " not found",
                    firstParam.loc,
                );
            }

            // Update self and remove first parameter
            self = firstParam.type;
            params = params.slice(1);
        }

        // Check for mutating and extends
        if (isMutating && !isExtends) {
            throwCompilationError(
                "Mutating functions must be extend functions",
                isMutating.loc,
            );
        }

        // Check parameter names
        const exNames: Set<string> = new Set();
        for (const param of params) {
            if (isSelfId(param.name)) {
                throwCompilationError(
                    'Parameter name "self" is reserved',
                    param.loc,
                );
            }
            if (exNames.has(idText(param.name))) {
                throwCompilationError(
                    `Parameter name ${idTextErr(param.name)} is already used`,
                    param.loc,
                );
            }
            exNames.add(idText(param.name));
        }

        // Check for runtime types in getters
        if (isGetter) {
            for (const param of params) {
                if (isRuntimeType(param.type)) {
                    throwCompilationError(
                        printTypeRef(param.type) +
                            " is a runtime-only type and can't be used as a getter parameter",
                        param.loc,
                    );
                }
            }
            if (isRuntimeType(returns)) {
                throwCompilationError(
                    printTypeRef(returns) +
                        " is a runtime-only type and can't be used as getter return type",
                    a.loc,
                );
            }
        }

        // check asm shuffle
        if (a.kind === "asm_function_def") {
            // check arguments shuffle
            if (a.shuffle.args.length !== 0) {
                const shuffleArgSet = new Set(
                    a.shuffle.args.map((id) => idText(id)),
                );
                if (shuffleArgSet.size !== a.shuffle.args.length) {
                    throwCompilationError(
                        "asm argument rearrangement cannot have duplicates",
                        a.loc,
                    );
                }
                const paramSet = new Set(
                    a.params.map((typedId) => idText(typedId.name)),
                );
                if (!isSubsetOf(paramSet, shuffleArgSet)) {
                    throwCompilationError(
                        "asm argument rearrangement must mention all function parameters",
                        a.loc,
                    );
                }
                if (!isSubsetOf(shuffleArgSet, paramSet)) {
                    throwCompilationError(
                        "asm argument rearrangement must mention only function parameters",
                        a.loc,
                    );
                }
            }

            // check return shuffle
            if (a.shuffle.ret.length !== 0) {
                const shuffleRetSet = new Set(
                    a.shuffle.ret.map((num) => Number(num.value)),
                );
                if (shuffleRetSet.size !== a.shuffle.ret.length) {
                    throwCompilationError(
                        "asm return rearrangement cannot have duplicates",
                        a.loc,
                    );
                }

                let retTupleSize = 0;
                switch (returns.kind) {
                    case "ref":
                        {
                            const ty = types.get(returns.name)!;
                            switch (ty.kind) {
                                case "struct":
                                case "contract":
                                    retTupleSize = ty.fields.length;
                                    break;
                                case "primitive_type_decl":
                                    retTupleSize = 1;
                                    break;
                                case "trait":
                                    throwInternalCompilerError(
                                        "A trait cannot be returned from a function",
                                        a.loc,
                                    );
                            }
                        }
                        break;
                    case "null":
                    case "map":
                        retTupleSize = 1;
                        break;
                    case "ref_bounced":
                        throwInternalCompilerError(
                            "A <bounced> type cannot be returned from a function",
                            a.loc,
                        );
                        break;
                    case "void":
                        retTupleSize = 0;
                        break;
                }
                // mutating functions also return `self` arg (implicitly in Tact, but explicitly in FunC)
                retTupleSize += isMutating ? 1 : 0;
                const returnValueSet = new Set([...Array(retTupleSize).keys()]);
                if (!isSubsetOf(returnValueSet, shuffleRetSet)) {
                    throwCompilationError(
                        `asm return rearrangement must mention all return position numbers: [0..${retTupleSize - 1}]`,
                        a.loc,
                    );
                }
                if (!isSubsetOf(shuffleRetSet, returnValueSet)) {
                    throwCompilationError(
                        `asm return rearrangement must mention only valid return position numbers: [0..${retTupleSize - 1}]`,
                        a.loc,
                    );
                }
            }
        }

        // Register function
        return {
            name: idText(a.name),
            self: self,
            origin,
            params,
            returns,
            ast: a,
            isMutating: !!isMutating || !!optSelf /* && !isGetter */, // Mark all contract functions as mutating
            isGetter: !!isGetter,
            isVirtual: !!isVirtual,
            isOverride: !!isOverride,
            isInline: !!isInline,
            isAbstract: !!isAbstract,
            methodId: null,
        };
    }

    function resolveInitFunction(ast: AstContractInit): InitDescription {
        const params: InitParameter[] = [];
        for (const r of ast.params) {
            params.push({
                name: r.name,
                type: buildTypeRef(r.type, types),
                as: null,
                loc: r.loc,
            });
        }

        // Check if runtime types are used
        for (const a of params) {
            if (isRuntimeType(a.type)) {
                throwCompilationError(
                    printTypeRef(a.type) +
                        " is a runtime-only type and can't be used as a init function parameter",
                    a.loc,
                );
            }
        }

        return {
            params,
            ast,
        };
    }

    for (const a of ast.types) {
        if (a.kind === "contract" || a.kind === "trait") {
            const s = types.get(idText(a.name))!;
            for (const d of a.declarations) {
                if (
                    d.kind === "function_def" ||
                    d.kind === "function_decl" ||
                    d.kind === "asm_function_def"
                ) {
                    const f = resolveFunctionDescriptor(
                        {
                            kind: "ref",
                            name: s.name,
                            optional: false,
                        },
                        d,
                        s.origin,
                    );
                    if (f.self?.kind !== "ref" || f.self.name !== s.name) {
                        throwInternalCompilerError(
                            `Function self must be ${s.name}`,
                        ); // Impossible
                    }
                    if (s.functions.has(f.name)) {
                        throwCompilationError(
                            `Function "${f.name}" already exists in type "${s.name}"`,
                            s.ast.loc,
                        );
                    }
                    s.functions.set(f.name, f);
                }
                if (d.kind === "contract_init") {
                    if (s.init) {
                        throwCompilationError(
                            "Init function already exists",
                            d.loc,
                        );
                    }
                    s.init = resolveInitFunction(d);
                }
                if (d.kind === "receiver") {
                    // Check if externals are enabled
                    if (
                        d.selector.kind.startsWith("external-") &&
                        !enabledExternals(ctx)
                    ) {
                        throwCompilationError(
                            "External functions are not enabled",
                            d.loc,
                        );
                    }

                    switch (d.selector.kind) {
                        case "internal-simple":
                        case "external-simple":
                            {
                                const param = d.selector.param;
                                const internal =
                                    d.selector.kind === "internal-simple";

                                if (param.type.kind !== "type_id") {
                                    throwCompilationError(
                                        "Receive function can only accept non-optional message types",
                                        d.loc,
                                    );
                                }
                                const t = types.get(idText(param.type));
                                if (!t) {
                                    throwCompilationError(
                                        `Type ${idTextErr(param.type)} not found`,
                                        d.loc,
                                    );
                                }

                                // Raw receiver
                                if (t.kind === "primitive_type_decl") {
                                    if (t.name === "Slice") {
                                        // Check for existing receiver
                                        if (
                                            s.receivers.find(
                                                (v) =>
                                                    v.selector.kind ===
                                                    (internal
                                                        ? "internal-fallback"
                                                        : "external-fallback"),
                                            )
                                        ) {
                                            throwCompilationError(
                                                `Fallback receive function already exists`,
                                                d.loc,
                                            );
                                        }

                                        // Persist receiver
                                        s.receivers.push({
                                            selector: {
                                                kind: internal
                                                    ? "internal-fallback"
                                                    : "external-fallback",
                                                name: param.name,
                                            },
                                            ast: d,
                                        });
                                    } else if (t.name === "String") {
                                        // Check for existing receiver
                                        if (
                                            s.receivers.find(
                                                (v) =>
                                                    v.selector.kind ===
                                                    (internal
                                                        ? "internal-comment-fallback"
                                                        : "external-comment-fallback"),
                                            )
                                        ) {
                                            throwCompilationError(
                                                "Comment fallback receive function already exists",
                                                d.loc,
                                            );
                                        }

                                        // Persist receiver
                                        s.receivers.push({
                                            selector: {
                                                kind: internal
                                                    ? "internal-comment-fallback"
                                                    : "external-comment-fallback",
                                                name: param.name,
                                            },
                                            ast: d,
                                        });
                                    } else {
                                        throwCompilationError(
                                            "Receive function can only accept message, Slice or String",
                                            d.loc,
                                        );
                                    }
                                } else {
                                    // Check type
                                    if (t.kind !== "struct") {
                                        throwCompilationError(
                                            "Receive function can only accept message",
                                            d.loc,
                                        );
                                    }
                                    if (t.ast.kind !== "message_decl") {
                                        throwCompilationError(
                                            "Receive function can only accept message",
                                            d.loc,
                                        );
                                    }

                                    // Check for duplicate
                                    const n = idText(param.type);
                                    if (
                                        s.receivers.find(
                                            (v) =>
                                                v.selector.kind ===
                                                    (internal
                                                        ? "internal-binary"
                                                        : "external-binary") &&
                                                eqNames(v.selector.type, n),
                                        )
                                    ) {
                                        throwCompilationError(
                                            `Receive function for ${idTextErr(param.type)} already exists`,
                                            param.loc,
                                        );
                                    }

                                    // Persist receiver
                                    s.receivers.push({
                                        selector: {
                                            kind: internal
                                                ? "internal-binary"
                                                : "external-binary",
                                            name: param.name,
                                            type: idText(param.type),
                                        },
                                        ast: d,
                                    });
                                }
                            }
                            break;
                        case "internal-comment":
                        case "external-comment":
                            {
                                const internal =
                                    d.selector.kind === "internal-comment";
                                if (d.selector.comment.value === "") {
                                    throwCompilationError(
                                        "To use empty comment receiver, just remove parameter instead of passing empty string",
                                        d.loc,
                                    );
                                }
                                const c = d.selector.comment.value;
                                if (
                                    s.receivers.find(
                                        (v) =>
                                            v.selector.kind ===
                                                (internal
                                                    ? "internal-comment"
                                                    : "external-comment") &&
                                            v.selector.comment === c,
                                    )
                                ) {
                                    throwCompilationError(
                                        `Receive function for ${idTextErr(c)} already exists`,
                                        d.loc,
                                    );
                                }
                                s.receivers.push({
                                    selector: {
                                        kind: internal
                                            ? "internal-comment"
                                            : "external-comment",
                                        comment: c,
                                    },
                                    ast: d,
                                });
                            }
                            break;
                        case "internal-fallback":
                        case "external-fallback":
                            {
                                const internal =
                                    d.selector.kind === "internal-fallback";
                                // Handle empty
                                if (
                                    s.receivers.find(
                                        (v) =>
                                            v.selector.kind ===
                                            (internal
                                                ? "internal-empty"
                                                : "external-empty"),
                                    )
                                ) {
                                    throwCompilationError(
                                        "Empty receive function already exists",
                                        d.loc,
                                    );
                                }
                                s.receivers.push({
                                    selector: {
                                        kind: internal
                                            ? "internal-empty"
                                            : "external-empty",
                                    },
                                    ast: d,
                                });
                            }
                            break;
                        case "bounce": {
                            const param = d.selector.param;

                            if (param.type.kind === "type_id") {
                                if (isSlice(param.type)) {
                                    if (
                                        s.receivers.find(
                                            (v) =>
                                                v.selector.kind ===
                                                "bounce-fallback",
                                        )
                                    ) {
                                        throwCompilationError(
                                            `Fallback bounce receive function already exists`,
                                            d.loc,
                                        );
                                    }

                                    s.receivers.push({
                                        selector: {
                                            kind: "bounce-fallback",
                                            name: param.name,
                                        },
                                        ast: d,
                                    });
                                } else {
                                    const type = types.get(idText(param.type));
                                    if (type === undefined) {
                                        throwCompilationError(
                                            `Unknown bounced receiver parameter type: ${idTextErr(param.type)}`,
                                            param.type.loc,
                                        );
                                    }
                                    if (type.ast.kind !== "message_decl") {
                                        throwCompilationError(
                                            "Bounce receive function can only accept bounced message, message or Slice",
                                            d.loc,
                                        );
                                    }
                                    if (
                                        type.fields.length !==
                                        type.partialFieldCount
                                    ) {
                                        throwCompilationError(
                                            `This message is too big for bounce receiver, you need to wrap it to a bounced<${idTextErr(param.type)}>.`,
                                            d.loc,
                                        );
                                    }
                                    if (
                                        s.receivers.find(
                                            (v) =>
                                                v.selector.kind ===
                                                    "bounce-binary" &&
                                                v.selector.type === type.name,
                                        )
                                    ) {
                                        throwCompilationError(
                                            `Bounce receive function for ${idTextErr(param.type)} already exists`,
                                            param.loc,
                                        );
                                    }
                                    s.receivers.push({
                                        selector: {
                                            kind: "bounce-binary",
                                            name: param.name,
                                            type: idText(param.type),
                                            bounced: false,
                                        },
                                        ast: d,
                                    });
                                }
                            } else if (param.type.kind === "optional_type") {
                                throwCompilationError(
                                    "Bounce receive function cannot have optional parameter",
                                    d.loc,
                                );
                            } else if (
                                param.type.kind === "bounced_message_type"
                            ) {
                                const t = types.get(
                                    idText(param.type.messageType),
                                );
                                if (t === undefined) {
                                    throwCompilationError(
                                        `Unknown bounced receiver parameter type: ${idTextErr(param.type.messageType)}`,
                                        param.type.loc,
                                    );
                                }
                                if (t.kind !== "struct") {
                                    throwCompilationError(
                                        "Bounce receive function can only accept bounced<T> struct types",
                                        d.loc,
                                    );
                                }
                                if (t.ast.kind !== "message_decl") {
                                    throwCompilationError(
                                        "Bounce receive function can only accept bounced<T> message types",
                                        d.loc,
                                    );
                                }
                                if (
                                    s.receivers.find(
                                        (v) =>
                                            v.selector.kind ===
                                                "bounce-binary" &&
                                            v.selector.type === t.name,
                                    )
                                ) {
                                    throwCompilationError(
                                        `Bounce receive function for ${idTextErr(t.name)} already exists`,
                                        d.loc,
                                    );
                                }
                                if (t.fields.length === t.partialFieldCount) {
                                    throwCompilationError(
                                        "This message is small enough for bounce receiver, you need to remove bounced modifier.",
                                        d.loc,
                                    );
                                }
                                s.receivers.push({
                                    selector: {
                                        kind: "bounce-binary",
                                        name: param.name,
                                        type: idText(param.type.messageType),
                                        bounced: true,
                                    },
                                    ast: d,
                                });
                            } else {
                                throwCompilationError(
                                    "Bounce receive function can only accept bounced<T> struct parameters or Slice",
                                    d.loc,
                                );
                            }
                        }
                    }
                }
            }
        }
    }

    //
    // Check for missing init methods
    //

    for (const t of types.values()) {
        if (t.kind === "contract") {
            if (!t.init) {
                t.init = {
                    params: [],
                    ast: Ast.createNode({
                        kind: "contract_init",
                        params: [],
                        statements: [],
                        loc: t.ast.loc,
                    }) as AstContractInit,
                };
            }
        }
    }

    //
    // Flatten and resolve traits
    //

    for (const t of types.values()) {
        if (t.ast.kind === "trait" || t.ast.kind === "contract") {
            // Check there are no duplicates in the _immediately_ inherited traits
            const traitSet: Set<string> = new Set(t.ast.traits.map(idText));
            if (traitSet.size !== t.ast.traits.length) {
                const aggregateType =
                    t.ast.kind === "contract" ? "contract" : "trait";
                throwCompilationError(
                    `The list of inherited traits for ${aggregateType} "${t.name}" has duplicates`,
                    t.ast.loc,
                );
            }
            // Flatten traits
            const traits: TypeDescription[] = [];
            const visited: Set<string> = new Set();
            visited.add(t.name);
            // eslint-disable-next-line no-inner-declarations
            function visit(name: string) {
                if (visited.has(name)) {
                    return;
                }
                const tt = types.get(name);
                if (!tt) {
                    throwCompilationError(
                        "Trait " + name + " not found",
                        t.ast.loc,
                    );
                }
                visited.add(name);
                traits.push(tt);
                if (tt.ast.kind === "trait") {
                    for (const s of tt.ast.traits) {
                        visit(idText(s));
                    }
                    for (const f of tt.traits) {
                        visit(f.name);
                    }
                } else {
                    throwCompilationError(
                        "Type " + name + " is not a trait",
                        t.ast.loc,
                    );
                }
            }
            visit("BaseTrait");
            for (const s of t.ast.traits) {
                visit(idText(s));
            }

            // Assign traits
            t.traits = traits;
        }
    }

    //
    // Verify trait fields
    //

    for (const t of types.values()) {
        for (const tr of t.traits) {
            // Check that trait is valid
            if (!types.has(tr.name)) {
                throwCompilationError(
                    "Trait " + tr.name + " not found",
                    t.ast.loc,
                );
            }
            if (types.get(tr.name)!.kind !== "trait") {
                throwCompilationError(
                    "Type " + tr.name + " is not a trait",
                    t.ast.loc,
                );
            }

            // Check that trait has all required fields
            const ttr = types.get(tr.name)!;
            for (const f of ttr.fields) {
                // Check if field exists
                const ex = t.fields.find((v) => v.name === f.name);
                if (!ex) {
                    throwCompilationError(
                        `Trait "${tr.name}" requires field "${f.name}"`,
                        t.ast.loc,
                    );
                }

                // Check type
                if (!typeRefEquals(f.type, ex.type)) {
                    throwCompilationError(
                        `Trait "${tr.name}" requires field "${f.name}" of type "${printTypeRef(f.type)}"`,
                        t.ast.loc,
                    );
                }
            }
        }
    }

    //
    // Copy Trait functions and constants
    //

    function copyTraits(contractOrTrait: TypeDescription) {
        for (const inheritedTrait of contractOrTrait.traits) {
            // Copy functions
            for (const traitFunction of inheritedTrait.functions.values()) {
                const funInContractOrTrait = contractOrTrait.functions.get(
                    traitFunction.name,
                );
                if (!funInContractOrTrait && traitFunction.isAbstract) {
                    throwCompilationError(
                        `Trait "${inheritedTrait.name}" requires function "${traitFunction.name}"`,
                        contractOrTrait.ast.loc,
                    );
                }

                if (funInContractOrTrait?.isOverride) {
                    if (
                        traitFunction.isGetter &&
                        !funInContractOrTrait.isGetter
                    ) {
                        throwCompilationError(
                            `Overridden function "${traitFunction.name}" must be a getter`,
                            funInContractOrTrait.ast.loc,
                        );
                    }
                    if (
                        traitFunction.isMutating !==
                        funInContractOrTrait.isMutating
                    ) {
                        throwCompilationError(
                            `Overridden function "${traitFunction.name}" should have same mutability`,
                            funInContractOrTrait.ast.loc,
                        );
                    }
                    if (
                        !typeRefEquals(
                            traitFunction.returns,
                            funInContractOrTrait.returns,
                        )
                    ) {
                        throwCompilationError(
                            `Overridden function "${traitFunction.name}" should have same return type`,
                            funInContractOrTrait.ast.loc,
                        );
                    }
                    if (
                        traitFunction.params.length !==
                        funInContractOrTrait.params.length
                    ) {
                        throwCompilationError(
                            `Overridden function "${traitFunction.name}" should have same number of parameters`,
                            funInContractOrTrait.ast.loc,
                        );
                    }
                    for (let i = 0; i < traitFunction.params.length; i++) {
                        const a = funInContractOrTrait.params[i]!;
                        const b = traitFunction.params[i]!;
                        if (!typeRefEquals(a.type, b.type)) {
                            throwCompilationError(
                                `Overridden function "${traitFunction.name}" should have same parameter types`,
                                funInContractOrTrait.ast.loc,
                            );
                        }
                    }
                    continue; // Ignore overridden functions
                }

                // Check duplicates
                if (funInContractOrTrait) {
                    if (traitFunction.isVirtual) {
                        throwCompilationError(
                            `Function "${traitFunction.name}" is defined as virtual in trait "${inheritedTrait.name}": you are probably missing "override" keyword`,
                            funInContractOrTrait.ast.loc,
                        );
                    }
                    throwCompilationError(
                        `Function "${traitFunction.name}" is already defined in trait "${inheritedTrait.name}"`,
                        funInContractOrTrait.ast.loc,
                    );
                }

                // Register function
                contractOrTrait.functions.set(traitFunction.name, {
                    ...traitFunction,
                    self: {
                        kind: "ref",
                        name: contractOrTrait.name,
                        optional: false,
                    },
                    ast: cloneNode(traitFunction.ast, Ast),
                });
            }

            // Copy constants
            for (const traitConstant of inheritedTrait.constants) {
                const constInContractOrTrait = contractOrTrait.constants.find(
                    (v) => v.name === traitConstant.name,
                );
                if (
                    !constInContractOrTrait &&
                    traitConstant.ast.attributes.find(
                        (v) => v.type === "abstract",
                    )
                ) {
                    throwCompilationError(
                        `Trait "${inheritedTrait.name}" requires constant "${traitConstant.name}"`,
                        contractOrTrait.ast.loc,
                    );
                }

                if (
                    constInContractOrTrait?.ast.attributes.find(
                        (v) => v.type === "override",
                    )
                ) {
                    if (
                        !typeRefEquals(
                            traitConstant.type,
                            constInContractOrTrait.type,
                        )
                    ) {
                        throwCompilationError(
                            `Overridden constant "${traitConstant.name}" should have same type`,
                            constInContractOrTrait.ast.loc,
                        );
                    }
                    continue;
                }

                // Check duplicates
                if (constInContractOrTrait) {
                    if (
                        traitConstant.ast.attributes.find(
                            (v) => v.type === "virtual",
                        )
                    ) {
                        throwCompilationError(
                            `Constant "${traitConstant.name}" is defined as virtual in trait "${inheritedTrait.name}": you are probably missing "override" keyword`,
                            constInContractOrTrait.ast.loc,
                        );
                    }
                    throwCompilationError(
                        `Constant "${traitConstant.name}" is already defined in trait "${inheritedTrait.name}"`,
                        constInContractOrTrait.ast.loc,
                    );
                }
                const contractField = contractOrTrait.fields.find(
                    (v) => v.name === traitConstant.name,
                );
                if (contractField) {
                    // a trait constant has the same name as a contract field
                    throwCompilationError(
                        `Contract ${contractOrTrait.name} inherits constant "${traitConstant.name}" from its traits and hence cannot have a storage variable with the same name`,
                        contractField.loc,
                    );
                }

                // Register constant
                contractOrTrait.constants.push({
                    ...traitConstant,
                    ast: cloneNode(traitConstant.ast, Ast),
                });
            }

            // Copy receivers
            for (const f of inheritedTrait.receivers) {
                // eslint-disable-next-line no-inner-declarations
                function sameReceiver(
                    a: ReceiverSelector,
                    b: ReceiverSelector,
                ) {
                    if (
                        a.kind === "internal-comment" &&
                        b.kind === "internal-comment"
                    ) {
                        return a.comment === b.comment;
                    }
                    if (
                        a.kind === "internal-binary" &&
                        b.kind === "internal-binary"
                    ) {
                        return a.type === b.type;
                    }
                    if (
                        a.kind === "bounce-fallback" &&
                        b.kind === "bounce-fallback"
                    ) {
                        return true; // Could be only one
                    }
                    if (
                        a.kind === "bounce-binary" &&
                        b.kind === "bounce-binary"
                    ) {
                        return a.type === b.type;
                    }
                    if (
                        a.kind === "internal-empty" &&
                        b.kind === "internal-empty"
                    ) {
                        return true;
                    }
                    if (
                        a.kind === "internal-fallback" &&
                        b.kind === "internal-fallback"
                    ) {
                        return true;
                    }
                    if (
                        a.kind === "internal-comment-fallback" &&
                        b.kind === "internal-comment-fallback"
                    ) {
                        return true;
                    }
                    return false;
                }
                if (
                    contractOrTrait.receivers.find((v) =>
                        sameReceiver(v.selector, f.selector),
                    )
                ) {
                    throwCompilationError(
                        `Receive function for ${idTextErr(receiverSelectorName(f.selector))} already exists`,
                        contractOrTrait.ast.loc,
                    );
                }
                contractOrTrait.receivers.push({
                    selector: f.selector,
                    ast: cloneNode(f.ast, Ast),
                });
            }

            // Copy interfaces
            for (const i of inheritedTrait.interfaces) {
                if (!contractOrTrait.interfaces.find((v) => v === i)) {
                    contractOrTrait.interfaces.push(i);
                }
            }
        }
    }

    // Copy to non-traits to avoid duplicates

    const processed: Set<string> = new Set();
    const processing: Set<string> = new Set();

    function processType(name: string) {
        // Check if processed
        if (processed.has(name)) {
            return;
        }
        if (processing.has(name)) {
            throwCompilationError(
                `Circular dependency detected for type "${name}"`,
                types.get(name)!.ast.loc,
            );
        }
        processing.has(name);

        // Process dependencies first
        const dependencies = Array.from(types.values()).filter((v) =>
            v.traits.find((v2) => v2.name === name),
        );
        for (const d of dependencies) {
            processType(d.name);
        }

        // Copy traits
        copyTraits(types.get(name)!);

        // Mark as processed
        processed.add(name);
        processing.delete(name);
    }
    for (const k of types.keys()) {
        processType(k);
    }

    //
    // Register dependencies
    //

    for (const [k, t] of types) {
        const dependsOn: Set<string> = new Set();
        const handler = (src: AstNode) => {
            if (src.kind === "init_of") {
                if (!types.has(idText(src.contract))) {
                    throwCompilationError(
                        `Type ${idTextErr(src.contract)} not found`,
                        src.loc,
                    );
                }
                dependsOn.add(idText(src.contract));
            }
        };

        // Traverse functions
        for (const f of t.functions.values()) {
            traverse(f.ast, handler);
        }
        for (const f of t.receivers) {
            traverse(f.ast, handler);
        }
        if (t.init) traverse(t.init.ast, handler);

        // Add dependencies
        for (const s of dependsOn) {
            if (s !== k) {
                t.dependsOn.push(types.get(s)!);
            }
        }
    }

    //
    // Register transient dependencies
    //

    function collectTransient(name: string, to: Set<string>) {
        const t = types.get(name)!;
        for (const d of t.dependsOn) {
            if (to.has(d.name)) {
                continue;
            }
            to.add(d.name);
            collectTransient(d.name, to);
        }
    }
    for (const k of types.keys()) {
        const dependsOn: Set<string> = new Set();
        dependsOn.add(k);
        collectTransient(k, dependsOn);
        for (const s of dependsOn) {
            if (s !== k && !types.get(k)!.dependsOn.find((v) => v.name === s)) {
                types.get(k)!.dependsOn.push(types.get(s)!);
            }
        }
    }

    //
    // Resolve static functions
    //

    for (const a of ast.functions) {
        const r = resolveFunctionDescriptor(null, a, a.loc.origin);
        if (r.self) {
            if (r.self.kind !== "ref") {
                throwCompilationError(
                    `Wrong self type "${r.name}" for static function`,
                    r.ast.loc,
                );
            }
            if (types.get(r.self.name)!.functions.has(r.name)) {
                throwCompilationError(
                    `Function "${r.name}" already exists in type "${r.self.name}"`,
                    r.ast.loc,
                );
            }
            types.get(r.self.name)!.functions.set(r.name, r);
        } else {
            if (staticFunctions.has(r.name) || GlobalFunctions.has(r.name)) {
                throwCompilationError(
                    `Static function "${r.name}" already exists`,
                    r.ast.loc,
                );
            }
            if (staticConstants.has(r.name)) {
                throwCompilationError(
                    `Static constant "${r.name}" already exists`,
                    a.loc,
                );
            }
            staticFunctions.set(r.name, r);
        }
    }

    //
    // Resolve static constants
    //

    for (const a of ast.constants) {
        if (staticConstants.has(idText(a.name))) {
            throwCompilationError(
                `Static constant ${idTextErr(a.name)} already exists`,
                a.loc,
            );
        }
        if (
            staticFunctions.has(idText(a.name)) ||
            GlobalFunctions.has(idText(a.name))
        ) {
            throwCompilationError(
                `Static function ${idTextErr(a.name)} already exists`,
                a.loc,
            );
        }
        staticConstants.set(idText(a.name), buildConstantDescription(a));
    }

    //
    // Register types and functions in context
    //

    for (const [k, t] of types) {
        ctx = store.set(ctx, k, t);
    }
    for (const [k, t] of staticFunctions) {
        ctx = staticFunctionsStore.set(ctx, k, t);
    }
    for (const [k, t] of staticConstants) {
        ctx = staticConstantsStore.set(ctx, k, t);
    }

    // A pass that initializes constants and default field values
    ctx = initializeConstantsAndDefaultContractAndStructFields(ctx);

    // detect self-referencing or mutually-recursive types
    checkRecursiveTypes(ctx);

    return ctx;
}

export function getType(
    ctx: CompilerContext,
    ident: AstId | AstTypeId | string,
): TypeDescription {
    const name = typeof ident === "string" ? ident : idText(ident);
    const r = store.get(ctx, name);
    if (!r) {
        throwInternalCompilerError(`Type ${name} not found`);
    }
    return r;
}

function getTypeStore(ctx: CompilerContext): Store<TypeDescription> {
    return store.all(ctx);
}

export function getAllTypes(ctx: CompilerContext): TypeDescription[] {
    return Array.from(getTypeStore(ctx).values());
}

export function getContracts(ctx: CompilerContext): string[] {
    return getAllTypes(ctx)
        .filter((v) => v.kind === "contract")
        .map((v) => v.name);
}

export function getStaticFunction(
    ctx: CompilerContext,
    name: string,
): FunctionDescription {
    const r = staticFunctionsStore.get(ctx, name);
    if (!r) {
        throwInternalCompilerError(`Static function ${name} not found`);
    }
    return r;
}

export function hasStaticFunction(ctx: CompilerContext, name: string) {
    return !!staticFunctionsStore.get(ctx, name);
}

export function getStaticConstant(
    ctx: CompilerContext,
    name: string,
): ConstantDescription {
    const r = staticConstantsStore.get(ctx, name);
    if (!r) {
        throwInternalCompilerError(`Static constant ${name} not found`);
    }
    return r;
}

export function hasStaticConstant(ctx: CompilerContext, name: string) {
    return !!staticConstantsStore.get(ctx, name);
}

function getStaticFunctionStore(
    ctx: CompilerContext,
): Store<FunctionDescription> {
    return staticFunctionsStore.all(ctx);
}

export function getAllStaticFunctions(
    ctx: CompilerContext,
): FunctionDescription[] {
    return Array.from(getStaticFunctionStore(ctx).values());
}

function getStaticConstantStore(
    ctx: CompilerContext,
): Store<ConstantDescription> {
    return staticConstantsStore.all(ctx);
}

export function getAllStaticConstants(
    ctx: CompilerContext,
): ConstantDescription[] {
    return Array.from(getStaticConstantStore(ctx).values());
}

function resolvePartialFields(ctx: CompilerContext, type: TypeDescription) {
    if (type.kind !== "struct") return 0;

    let partialFieldsCount = 0;

    let remainingBits = 224;

    for (const f of type.fields) {
        // dicts are unsupported
        if (f.abi.type.kind !== "simple") break;

        let fieldBits = f.abi.type.optional ? 1 : 0;

        // TODO handle fixed-bytes
        if (Number.isInteger(f.abi.type.format)) {
            fieldBits += f.abi.type.format as number;
        } else if (f.abi.type.format === "coins") {
            fieldBits += 124;
        } else if (f.abi.type.type === "address") {
            fieldBits += 267;
        } else if (f.abi.type.type === "bool") {
            fieldBits += 1;
        } else {
            // Unsupported - all others (slice, builder, nested structs, maps)
            break;
        }

        if (remainingBits - fieldBits >= 0) {
            remainingBits -= fieldBits;
            partialFieldsCount++;
        } else {
            break;
        }
    }

    return partialFieldsCount;
}

function checkInitializerType(
    name: string,
    kind: "Constant" | "Struct field",
    declTy: TypeRef,
    initializer: AstExpression,
    ctx: CompilerContext,
): CompilerContext {
    const stmtCtx = emptyContext(initializer.loc, null, declTy);
    ctx = resolveExpression(initializer, stmtCtx, ctx);
    const initTy = getExpType(ctx, initializer);
    if (!isAssignable(initTy, declTy)) {
        throwCompilationError(
            `${kind} ${idTextErr(name)} has declared type "${printTypeRef(declTy)}", but its initializer has incompatible type "${printTypeRef(initTy)}"`,
            initializer.loc,
        );
    }
    return ctx;
}

function initializeConstants(
    constants: ConstantDescription[],
    ctx: CompilerContext,
): CompilerContext {
    for (const constant of constants) {
        if (constant.ast.kind === "constant_def") {
            ctx = checkInitializerType(
                constant.name,
                "Constant",
                constant.type,
                constant.ast.initializer,
                ctx,
            );
            constant.value = evalConstantExpression(
                constant.ast.initializer,
                ctx,
            );
        }
    }
    return ctx;
}

function initializeConstantsAndDefaultContractAndStructFields(
    ctx: CompilerContext,
): CompilerContext {
    for (const aggregateTy of getAllTypes(ctx)) {
        switch (aggregateTy.kind) {
            case "primitive_type_decl":
                break;
            case "trait":
            case "contract":
            case "struct": {
                {
                    for (const field of aggregateTy.fields) {
                        if (field.ast.initializer !== null) {
                            ctx = checkInitializerType(
                                field.name,
                                "Struct field",
                                field.type,
                                field.ast.initializer,
                                ctx,
                            );
                            field.default = evalConstantExpression(
                                field.ast.initializer,
                                ctx,
                            );
                        } else {
                            // if a field has optional type and it is missing an explicit initializer
                            // we consider it to be initialized with the null value

                            field.default =
                                field.type.kind === "ref" && field.type.optional
                                    ? null
                                    : undefined;
                        }
                    }

                    // constants need to be processed after structs because
                    // see more detail below
                    ctx = initializeConstants(aggregateTy.constants, ctx);
                }
                break;
            }
        }
    }

    // constants need to be processed after structs because
    // constants might use default field values: `const x: Int = S{}.f`, where `struct S {f: Int = 42}`
    // and the default field values are filled in during struct field initializers processing
    ctx = initializeConstants(getAllStaticConstants(ctx), ctx);

    return ctx;
}

function checkRecursiveTypes(ctx: CompilerContext): void {
    // the implementation is basically Tarjan's algorithm,
    // which removes trivial SCCs, i.e. nodes (structs) that do not refer to themselves
    // and terminates early if a non-trivial SCC is detected
    // https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm

    const structs = getAllTypes(ctx).filter(
        (aggregate) => aggregate.kind === "struct",
    );
    let index = 0;
    const stack: AstId[] = [];
    // `string` here means "struct name"
    const indices: Map<string, number> = new Map();
    const lowLinks: Map<string, number> = new Map();
    const onStack: Set<string> = new Set();
    const selfReferencingVertices: Set<string> = new Set();

    for (const struct of structs) {
        if (!indices.has(struct.name)) {
            const cycle = strongConnect(struct);
            if (cycle.length === 1) {
                const tyId = cycle[0]!;
                throwCompilationError(
                    `Self-referencing types are not supported: type ${idTextErr(tyId)} refers to itself in its definition`,
                    tyId.loc,
                );
            } else if (cycle.length > 1) {
                const tyIds = cycle.map((tyId) => idTextErr(tyId)).join(", ");
                throwCompilationError(
                    `Mutually recursive types are not supported: types ${tyIds} form a cycle`,
                    cycle[0]!.loc,
                );
            }
        }
    }

    function strongConnect(struct: TypeDescription) {
        // Set the depth index for v to the smallest unused index
        indices.set(struct.name, index);
        lowLinks.set(struct.name, index);
        index += 1;
        stack.push(struct.ast.name);
        onStack.add(struct.name);

        const processPossibleSuccessor = (successorName: string) => {
            const fieldTy = getType(ctx, successorName);
            if (fieldTy.name === struct.name) {
                selfReferencingVertices.add(struct.name);
            }
            if (fieldTy.kind === "struct") {
                // successor
                if (!indices.has(fieldTy.name)) {
                    strongConnect(fieldTy);
                    lowLinks.set(
                        struct.name,
                        Math.min(
                            lowLinks.get(struct.name)!,
                            lowLinks.get(fieldTy.name)!,
                        ),
                    );
                } else if (onStack.has(fieldTy.name)) {
                    lowLinks.set(
                        struct.name,
                        Math.min(
                            lowLinks.get(struct.name)!,
                            indices.get(fieldTy.name)!,
                        ),
                    );
                }
            }
        };

        // process the successors of the current node
        for (const field of struct.fields) {
            switch (field.type.kind) {
                case "ref":
                case "ref_bounced":
                    processPossibleSuccessor(field.type.name);
                    break;
                case "map":
                    processPossibleSuccessor(field.type.value);
                    break;
                // do nothing
                case "void":
                case "null":
                    break;
            }
        }

        if (lowLinks.get(struct.name) === indices.get(struct.name)) {
            const cycle: AstId[] = [];
            let e = "";
            do {
                const last = stack.pop()!;
                e = idText(last);
                onStack.delete(e);
                cycle.push(last);
            } while (e !== struct.name);

            if (cycle.length > 1) {
                return cycle.reverse();
            } else if (cycle.length === 1) {
                if (selfReferencingVertices.has(struct.name)) {
                    // filter out trivial SCCs
                    return cycle;
                }
            }
        }
        return [];
    }
}


## resolveErrors.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/resolveErrors.ts)
import { sha256_sync } from "@ton/crypto";
import { CompilerContext, createContextStore } from "../context";
import { AstNode, isRequire } from "../grammar/ast";
import { traverse } from "../grammar/iterators";
import { evalConstantExpression } from "../constEval";
import { throwInternalCompilerError } from "../errors";
import {
    getAllStaticFunctions,
    getAllTypes,
    getAllStaticConstants,
} from "./resolveDescriptors";

type Exception = { value: string; id: number };

const exceptions = createContextStore<Exception>();

function stringId(src: string): number {
    return sha256_sync(src).readUInt32BE(0);
}

function exceptionId(src: string): number {
    return (stringId(src) % 63000) + 1000;
}

function resolveStringsInAST(ast: AstNode, ctx: CompilerContext) {
    traverse(ast, (node) => {
        if (node.kind === "static_call" && isRequire(node.function)) {
            if (node.args.length !== 2) {
                return;
            }
            const resolved = evalConstantExpression(
                node.args[1]!,
                ctx,
            ) as string;
            if (!exceptions.get(ctx, resolved)) {
                const id = exceptionId(resolved);
                if (
                    Array.from(exceptions.all(ctx).values()).find(
                        (v) => v.id === id,
                    )
                ) {
                    throwInternalCompilerError(
                        `Duplicate error id: "${resolved}"`,
                    );
                }
                ctx = exceptions.set(ctx, resolved, { value: resolved, id });
            }
        }
    });
    return ctx;
}

export function resolveErrors(ctx: CompilerContext) {
    // Process all static functions
    for (const f of getAllStaticFunctions(ctx)) {
        ctx = resolveStringsInAST(f.ast, ctx);
    }

    // Process all static constants
    for (const f of getAllStaticConstants(ctx)) {
        ctx = resolveStringsInAST(f.ast, ctx);
    }

    // Process all types
    for (const t of getAllTypes(ctx)) {
        // Process fields
        for (const f of t.fields) {
            ctx = resolveStringsInAST(f.ast, ctx);
        }

        // Process constants
        for (const f of t.constants) {
            ctx = resolveStringsInAST(f.ast, ctx);
        }

        // Process init
        if (t.init) {
            ctx = resolveStringsInAST(t.init.ast, ctx);
        }

        // Process receivers
        for (const f of t.receivers) {
            ctx = resolveStringsInAST(f.ast, ctx);
        }

        // Process functions
        for (const f of t.functions.values()) {
            ctx = resolveStringsInAST(f.ast, ctx);
        }
    }

    return ctx;
}

export function getAllErrors(ctx: CompilerContext): Exception[] {
    return Array.from(exceptions.all(ctx).values());
}

export function getErrorId(value: string, ctx: CompilerContext) {
    const ex = exceptions.get(ctx, value);
    if (!ex) {
        throwInternalCompilerError(`Error not found: ${value}`);
    }
    return ex.id;
}


## resolveExpression.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/resolveExpression.ts)
import {
    AstBoolean,
    AstExpression,
    AstInitOf,
    AstNull,
    AstNumber,
    AstOpBinary,
    AstMethodCall,
    AstStaticCall,
    AstFieldAccess,
    AstStructInstance,
    AstOpUnary,
    AstString,
    AstConditional,
    eqNames,
    idText,
    isWildcard,
} from "../grammar/ast";
import { idTextErr, throwCompilationError } from "../errors";
import { CompilerContext, createContextStore } from "../context";
import {
    getAllTypes,
    getStaticConstant,
    getStaticFunction,
    getType,
    hasStaticConstant,
    hasStaticFunction,
} from "./resolveDescriptors";
import { printTypeRef, TypeRef, typeRefEquals } from "./types";
import { StatementContext } from "./resolveStatements";
import { MapFunctions } from "../abi/map";
import { GlobalFunctions } from "../abi/global";
import { isAssignable, moreGeneralType } from "./subtyping";
import { throwInternalCompilerError } from "../errors";
import { StructFunctions } from "../abi/struct";
import { prettyPrint } from "../prettyPrinter";

const store = createContextStore<{
    ast: AstExpression;
    description: TypeRef;
}>();

export function getExpType(ctx: CompilerContext, exp: AstExpression) {
    const t = store.get(ctx, exp.id);
    if (!t) {
        throwInternalCompilerError(`Expression ${exp.id} not found`);
    }
    return t.description;
}

function registerExpType(
    ctx: CompilerContext,
    exp: AstExpression,
    description: TypeRef,
): CompilerContext {
    const ex = store.get(ctx, exp.id);
    if (ex) {
        if (typeRefEquals(ex.description, description)) {
            return ctx;
        }
        throwInternalCompilerError(
            `Expression ${prettyPrint(exp)} with exp.id = ${exp.id} already has registered type "${printTypeRef(ex.description)}" but the typechecker is trying to re-register it as "${printTypeRef(description)}"`,
            exp.loc,
        );
    }
    return store.set(ctx, exp.id, { ast: exp, description });
}

function resolveBooleanLiteral(
    exp: AstBoolean,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    return registerExpType(ctx, exp, {
        kind: "ref",
        name: "Bool",
        optional: false,
    });
}

function resolveIntLiteral(
    exp: AstNumber,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    return registerExpType(ctx, exp, {
        kind: "ref",
        name: "Int",
        optional: false,
    });
}

function resolveNullLiteral(
    exp: AstNull,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    return registerExpType(ctx, exp, { kind: "null" });
}

function resolveStringLiteral(
    exp: AstString,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    return registerExpType(ctx, exp, {
        kind: "ref",
        name: "String",
        optional: false,
    });
}

function resolveStructNew(
    exp: AstStructInstance,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    // Get type
    const tp = getType(ctx, exp.type);

    if (tp.kind !== "struct") {
        throwCompilationError(
            `Invalid type ${idTextErr(exp.type)} for construction`,
            exp.loc,
        );
    }

    // Process fields
    const processed: Set<string> = new Set();
    for (const e of exp.args) {
        // Check duplicates
        if (processed.has(idText(e.field))) {
            throwCompilationError(
                `Duplicate fields ${idTextErr(e.field)}`,
                e.loc,
            );
        }
        processed.add(idText(e.field));

        // Check existing
        const f = tp.fields.find((v) => eqNames(v.name, e.field));
        if (!f) {
            throwCompilationError(
                `Unknown fields ${idTextErr(e.field)} in type ${idTextErr(tp.name)}`,
                e.loc,
            );
        }

        // Resolve expression
        ctx = resolveExpression(e.initializer, sctx, ctx);

        // Check expression type
        const expressionType = getExpType(ctx, e.initializer);
        if (!isAssignable(expressionType, f.type)) {
            throwCompilationError(
                `Invalid type "${printTypeRef(expressionType)}" for field ${idTextErr(e.field)} with type "${printTypeRef(f.type)}" in type "${tp.name}"`,
                e.loc,
            );
        }
    }

    // Check missing fields
    for (const f of tp.fields) {
        if (
            !processed.has(f.name) &&
            f.ast.initializer === null &&
            !(f.type.kind === "ref" && f.type.optional)
        ) {
            throwCompilationError(
                `Missing field "${f.name}" in type "${tp.name}"`,
                exp.loc,
            );
        }
    }

    // Register result
    return registerExpType(ctx, exp, {
        kind: "ref",
        name: tp.name,
        optional: false,
    });
}

function resolveBinaryOp(
    exp: AstOpBinary,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    // Resolve left and right expressions
    ctx = resolveExpression(exp.left, sctx, ctx);
    ctx = resolveExpression(exp.right, sctx, ctx);
    const le = getExpType(ctx, exp.left);
    const re = getExpType(ctx, exp.right);

    // Check operands
    let resolved: TypeRef;
    switch (exp.op) {
        case "-":
        case "+":
        case "*":
        case "/":
        case "%":
        case ">>":
        case "<<":
        case "&":
        case "|":
        case "^":
            {
                if (le.kind !== "ref" || le.optional || le.name !== "Int") {
                    throwCompilationError(
                        `Invalid type "${printTypeRef(le)}" for binary operator "${exp.op}"`,
                        exp.loc,
                    );
                }
                if (re.kind !== "ref" || re.optional || re.name !== "Int") {
                    throwCompilationError(
                        `Invalid type "${printTypeRef(re)}" for binary operator "${exp.op}"`,
                        exp.loc,
                    );
                }
                resolved = { kind: "ref", name: "Int", optional: false };
            }
            break;
        case "<":
        case "<=":
        case ">":
        case ">=":
            {
                if (le.kind !== "ref" || le.optional || le.name !== "Int") {
                    throwCompilationError(
                        `Invalid type "${printTypeRef(le)}" for binary operator "${exp.op}"`,
                        exp.loc,
                    );
                }
                if (re.kind !== "ref" || re.optional || re.name !== "Int") {
                    throwCompilationError(
                        `Invalid type "${printTypeRef(re)}" for binary operator "${exp.op}"`,
                        exp.loc,
                    );
                }
                resolved = { kind: "ref", name: "Bool", optional: false };
            }
            break;
        case "==":
        case "!=":
            {
                // any inhabitant of an optional type can be compared to null
                if (
                    (le.kind === "ref" && le.optional && re.kind === "null") ||
                    (re.kind === "ref" && re.optional && le.kind === "null")
                ) {
                    resolved = { kind: "ref", name: "Bool", optional: false };
                    break;
                }
                if (!isEqualityType(ctx, le)) {
                    throwCompilationError(
                        `Expressions of "${printTypeRef(le)}" type cannot be used for (non)equality operator "${exp.op}"\n See https://docs.tact-lang.org/book/operators#binary-equality`,
                        exp.loc,
                    );
                }
                if (!isEqualityType(ctx, re)) {
                    throwCompilationError(
                        `Expressions of "${printTypeRef(re)}" type cannot be used for (non)equality operator "${exp.op}"\nSee https://docs.tact-lang.org/book/operators#binary-equality`,
                        exp.loc,
                    );
                }
                if (!isAssignable(le, re) && !isAssignable(re, le)) {
                    throwCompilationError(
                        `Incompatible types "${printTypeRef(le)}" and "${printTypeRef(re)}" for binary operator "${exp.op}"`,
                        exp.loc,
                    );
                }
                resolved = { kind: "ref", name: "Bool", optional: false };
            }
            break;
        case "&&":
        case "||": {
            if (le.kind !== "ref" || le.optional || le.name !== "Bool") {
                throwCompilationError(
                    `Invalid type "${printTypeRef(le)}" for binary operator "${exp.op}"`,
                    exp.loc,
                );
            }
            if (re.kind !== "ref" || re.optional || re.name !== "Bool") {
                throwCompilationError(
                    `Invalid type "${printTypeRef(re)}" for binary operator "${exp.op}"`,
                    exp.loc,
                );
            }
            resolved = { kind: "ref", name: "Bool", optional: false };
        }
    }

    // Register result
    return registerExpType(ctx, exp, resolved);
}

function isEqualityType(ctx: CompilerContext, ty: TypeRef): boolean {
    switch (ty.kind) {
        case "ref": {
            const type = getType(ctx, ty.name);
            if (type.kind === "primitive_type_decl") {
                return (
                    ty.name === "Int" ||
                    ty.name === "Bool" ||
                    ty.name === "Address" ||
                    ty.name === "Cell" ||
                    ty.name === "Slice" ||
                    ty.name === "String"
                );
            } else {
                return false;
            }
        }
        case "null":
        case "map":
            return true;
        case "void":
        case "ref_bounced":
            return false;
    }
}

function resolveUnaryOp(
    exp: AstOpUnary,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    // Resolve right side
    ctx = resolveExpression(exp.operand, sctx, ctx);

    // Check right type dependent on operator
    let resolvedType = getExpType(ctx, exp.operand);
    switch (exp.op) {
        case "-":
        case "+":
        case "~":
            {
                if (
                    resolvedType.kind !== "ref" ||
                    resolvedType.optional ||
                    resolvedType.name !== "Int"
                ) {
                    throwCompilationError(
                        `Invalid type "${printTypeRef(resolvedType)}" for unary operator "${exp.op}"`,
                        exp.loc,
                    );
                }
            }
            break;
        case "!":
            {
                if (
                    resolvedType.kind !== "ref" ||
                    resolvedType.optional ||
                    resolvedType.name !== "Bool"
                ) {
                    throwCompilationError(
                        `Invalid type "${printTypeRef(resolvedType)}" for unary operator "${exp.op}"`,
                        exp.loc,
                    );
                }
            }
            break;
        case "!!": {
            if (resolvedType.kind !== "ref" || !resolvedType.optional) {
                throwCompilationError(
                    `Type "${printTypeRef(resolvedType)}" is not optional`,
                    exp.loc,
                );
            }
            resolvedType = {
                kind: "ref",
                name: resolvedType.name,
                optional: false,
            };
        }
    }

    // Register result
    return registerExpType(ctx, exp, resolvedType);
}

function resolveFieldAccess(
    exp: AstFieldAccess,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    // Resolve expression
    ctx = resolveExpression(exp.aggregate, sctx, ctx);

    // Find target type and check for type
    const src = getExpType(ctx, exp.aggregate);

    if ((src.kind !== "ref" || src.optional) && src.kind !== "ref_bounced") {
        throwCompilationError(
            `Invalid type "${printTypeRef(src)}" for field access`,
            exp.loc,
        );
    }

    // Check if field initialized
    if (
        sctx.requiredFields.length > 0 &&
        exp.aggregate.kind === "id" &&
        exp.aggregate.text === "self"
    ) {
        if (sctx.requiredFields.find((v) => eqNames(v, exp.field))) {
            throwCompilationError(
                `Field ${idTextErr(exp.field)} is not initialized`,
                exp.field.loc,
            );
        }
    }

    // Find field
    const srcT = getType(ctx, src.name);

    const fieldIndex = srcT.fields.findIndex((v) => eqNames(v.name, exp.field));
    const field = fieldIndex !== -1 ? srcT.fields[fieldIndex] : undefined;

    // If we found a field of bounced<T>, check if the field doesn't fit in 224 bytes and cannot be accessed
    if (
        src.kind === "ref_bounced" &&
        field &&
        fieldIndex >= srcT.partialFieldCount
    ) {
        if (srcT.fields.length === 1) {
            throwCompilationError(
                `Maximum size of the bounced message is 224 bytes, but the ${idTextErr(exp.field)} field of type ${idTextErr(src.name)} cannot fit into it because its too big, so it cannot be accessed. Reduce the type of this field so that it fits into 224 bytes`,
                exp.field.loc,
            );
        }

        throwCompilationError(
            `Maximum size of the bounced message is 224 bytes, but the ${idTextErr(exp.field)} field of type ${idTextErr(src.name)} cannot fit into it due to the size of previous fields or its own size, so it cannot be accessed. Make the type of the fields before this one smaller, or reduce the type of this field so that it fits into 224 bytes`,
            exp.field.loc,
        );
    }

    const cst = srcT.constants.find((v) => eqNames(v.name, exp.field));
    if (!field && !cst) {
        const typeStr =
            src.kind === "ref_bounced"
                ? `bounced<${idTextErr(src.name)}>`
                : idTextErr(src.name);

        if (src.kind === "ref" && !src.optional) {
            // Check for struct methods
            if (
                (srcT.kind === "struct" &&
                    StructFunctions.has(idText(exp.field))) ||
                srcT.functions.has(idText(exp.field))
            ) {
                throwCompilationError(
                    `Type ${typeStr} does not have a field named "${exp.field.text}", did you mean "${exp.field.text}()" instead?`,
                    exp.loc,
                );
            }
        }

        throwCompilationError(
            `Type ${typeStr} does not have a field named ${idTextErr(exp.field)}`,
            exp.field.loc,
        );
    }

    // Register result type
    if (field) {
        return registerExpType(ctx, exp, field.type);
    } else {
        return registerExpType(ctx, exp, cst!.type);
    }
}

function resolveStaticCall(
    exp: AstStaticCall,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    // Check if abi global function
    if (GlobalFunctions.has(idText(exp.function))) {
        const f = GlobalFunctions.get(idText(exp.function))!;

        // Resolve arguments
        for (const e of exp.args) {
            ctx = resolveExpression(e, sctx, ctx);
        }

        // Resolve return type
        const resolved = f.resolve(
            ctx,
            exp.args.map((v) => getExpType(ctx, v)),
            exp.loc,
        );

        // Register return type
        return registerExpType(ctx, exp, resolved);
    }

    // Check if function exists
    if (!hasStaticFunction(ctx, idText(exp.function))) {
        // check if there is a method with the same name
        if (
            getAllTypes(ctx).find(
                (ty) => ty.functions.get(idText(exp.function)) !== undefined,
            ) !== undefined
        ) {
            throwCompilationError(
                `Static function ${idTextErr(exp.function)} does not exist. Perhaps you meant to call ".${idText(exp.function)}(...)" extension function?`,
                exp.loc,
            );
        }

        throwCompilationError(
            `Static function ${idTextErr(exp.function)} does not exist`,
            exp.loc,
        );
    }

    // Get static function
    const f = getStaticFunction(ctx, idText(exp.function));

    // Resolve call arguments
    for (const e of exp.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }

    // Check arguments
    if (f.params.length !== exp.args.length) {
        throwCompilationError(
            `Function ${idTextErr(exp.function)} expects ${f.params.length} arguments, got ${exp.args.length}`,
            exp.loc,
        );
    }
    for (const [i, a] of f.params.entries()) {
        const e = exp.args[i]!;
        const t = getExpType(ctx, e);
        if (!isAssignable(t, a.type)) {
            throwCompilationError(
                `Invalid type "${printTypeRef(t)}" for argument ${idTextErr(a.name)}`,
                e.loc,
            );
        }
    }

    // Resolve return type
    return registerExpType(ctx, exp, f.returns);
}

function resolveCall(
    exp: AstMethodCall,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    // Resolve expression
    ctx = resolveExpression(exp.self, sctx, ctx);

    // Check if self is initialized
    if (
        exp.self.kind === "id" &&
        exp.self.text === "self" &&
        sctx.requiredFields.length > 0
    ) {
        throwCompilationError("Cannot access self before init", exp.loc);
    }

    // Resolve args
    for (const e of exp.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }

    // Resolve return value
    const src = getExpType(ctx, exp.self);

    // Handle ref
    if (src.kind === "ref") {
        // Register return type
        const srcT = getType(ctx, src.name);

        // Check struct ABI
        if (srcT.kind === "struct") {
            if (StructFunctions.has(idText(exp.method))) {
                const abi = StructFunctions.get(idText(exp.method))!;
                const resolved = abi.resolve(
                    ctx,
                    [src, ...exp.args.map((v) => getExpType(ctx, v))],
                    exp.loc,
                );
                return registerExpType(ctx, exp, resolved);
            }
        }

        const f = srcT.functions.get(idText(exp.method));
        if (f) {
            // Check arguments
            if (f.params.length !== exp.args.length) {
                throwCompilationError(
                    `Function ${idTextErr(exp.method)} expects ${f.params.length} arguments, got ${exp.args.length}`,
                    exp.loc,
                );
            }
            for (const [i, a] of f.params.entries()) {
                const e = exp.args[i]!;
                const t = getExpType(ctx, e);
                if (!isAssignable(t, a.type)) {
                    throwCompilationError(
                        `Invalid type "${printTypeRef(t)}" for argument ${idTextErr(a.name)}`,
                        e.loc,
                    );
                }
            }

            return registerExpType(ctx, exp, f.returns);
        }

        // Check if a field with the same name exists
        const field = srcT.fields.find((v) => eqNames(v.name, exp.method));
        if (field) {
            throwCompilationError(
                `Type "${src.name}" does not have a function named "${exp.method.text}()", did you mean field "${exp.method.text}" instead?`,
                exp.loc,
            );
        }

        throwCompilationError(
            `Type "${src.name}" does not have a function named ${idTextErr(exp.method)}`,
            exp.loc,
        );
    }

    // Handle map
    if (src.kind === "map") {
        if (!MapFunctions.has(idText(exp.method))) {
            throwCompilationError(
                `Map function ${idTextErr(exp.method)} not found`,
                exp.loc,
            );
        }
        const abf = MapFunctions.get(idText(exp.method))!;
        const resolved = abf.resolve(
            ctx,
            [src, ...exp.args.map((v) => getExpType(ctx, v))],
            exp.loc,
        );
        return registerExpType(ctx, exp, resolved);
    }

    if (src.kind === "ref_bounced") {
        throwCompilationError(`Cannot call function on bounced value`, exp.loc);
    }

    throwCompilationError(
        `Invalid type "${printTypeRef(src)}" for function call`,
        exp.loc,
    );
}

function resolveInitOf(
    ast: AstInitOf,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    // Resolve type
    const type = getType(ctx, ast.contract);
    if (type.kind !== "contract") {
        throwCompilationError(
            `Type ${idTextErr(ast.contract)} is not a contract`,
            ast.loc,
        );
    }
    if (!type.init) {
        throwCompilationError(
            `Contract ${idTextErr(ast.contract)} does not have an init function`,
            ast.loc,
        );
    }

    // Resolve args
    for (const e of ast.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }

    // Check arguments
    if (type.init.params.length !== ast.args.length) {
        throwCompilationError(
            `Init function of "${type.name}" expects ${type.init.params.length} arguments, got ${ast.args.length}`,
            ast.loc,
        );
    }
    for (const [i, a] of type.init.params.entries()) {
        const e = ast.args[i]!;
        const t = getExpType(ctx, e);
        if (!isAssignable(t, a.type)) {
            throwCompilationError(
                `Invalid type "${printTypeRef(t)}" for argument ${idTextErr(a.name)}`,
                e.loc,
            );
        }
    }

    // Register return type
    return registerExpType(ctx, ast, {
        kind: "ref",
        name: "StateInit",
        optional: false,
    });
}

function resolveConditional(
    ast: AstConditional,
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    ctx = resolveExpression(ast.condition, sctx, ctx);
    const conditionType = getExpType(ctx, ast.condition);
    if (
        conditionType.kind !== "ref" ||
        conditionType.optional ||
        conditionType.name !== "Bool"
    ) {
        throwCompilationError(
            `Invalid type "${printTypeRef(conditionType)}" for ternary condition`,
            ast.condition.loc,
        );
    }

    ctx = resolveExpression(ast.thenBranch, sctx, ctx);
    ctx = resolveExpression(ast.elseBranch, sctx, ctx);
    const thenType = getExpType(ctx, ast.thenBranch);
    const elseType = getExpType(ctx, ast.elseBranch);

    const resultType = moreGeneralType(thenType, elseType);
    if (resultType) {
        if (resultType.kind == "void") {
            throwCompilationError(
                `Expressions of "<void>" type cannot be used for conditional expression`,
                ast.loc,
            );
        }
        return registerExpType(ctx, ast, resultType);
    }

    throwCompilationError(
        `Non-matching types "${printTypeRef(thenType)}" and "${printTypeRef(elseType)}" for ternary branches`,
        ast.elseBranch.loc,
    );
}

export function resolveExpression(
    exp: AstExpression,
    sctx: StatementContext,
    ctx: CompilerContext,
) {
    switch (exp.kind) {
        case "boolean": {
            return resolveBooleanLiteral(exp, sctx, ctx);
        }
        case "number": {
            return resolveIntLiteral(exp, sctx, ctx);
        }
        case "null": {
            return resolveNullLiteral(exp, sctx, ctx);
        }
        case "string": {
            return resolveStringLiteral(exp, sctx, ctx);
        }
        case "struct_instance": {
            return resolveStructNew(exp, sctx, ctx);
        }
        case "op_binary": {
            return resolveBinaryOp(exp, sctx, ctx);
        }
        case "op_unary": {
            return resolveUnaryOp(exp, sctx, ctx);
        }
        case "id": {
            // Find variable
            const v = sctx.vars.get(exp.text);
            if (!v) {
                if (!hasStaticConstant(ctx, exp.text)) {
                    if (isWildcard(exp)) {
                        throwCompilationError(
                            "Wildcard variable name '_' cannot be accessed",
                            exp.loc,
                        );
                    }

                    // Handle static struct method calls
                    try {
                        const t = getType(ctx, exp.text);
                        if (t.kind === "struct") {
                            return registerExpType(ctx, exp, {
                                kind: "ref",
                                name: t.name,
                                optional: false,
                            });
                        }
                    } catch {
                        // Ignore
                    }

                    // Handle possible field access and suggest to use self.field instead
                    const self = sctx.vars.get("self");
                    if (self && self.kind === "ref") {
                        const t = getType(ctx, self.name);
                        if (t.kind === "contract" || t.kind === "trait") {
                            const field = t.fields.find(
                                (f) => f.name == exp.text,
                            );
                            if (field) {
                                throwCompilationError(
                                    `Unable to resolve id '${exp.text}', did you mean 'self.${exp.text}'?`,
                                    exp.loc,
                                );
                            }
                        }
                    }

                    throwCompilationError(
                        `Unable to resolve id '${exp.text}'`,
                        exp.loc,
                    );
                } else {
                    const cc = getStaticConstant(ctx, exp.text);
                    return registerExpType(ctx, exp, cc.type);
                }
            }

            return registerExpType(ctx, exp, v);
        }
        case "field_access": {
            return resolveFieldAccess(exp, sctx, ctx);
        }
        case "static_call": {
            return resolveStaticCall(exp, sctx, ctx);
        }
        case "method_call": {
            return resolveCall(exp, sctx, ctx);
        }
        case "init_of": {
            return resolveInitOf(exp, sctx, ctx);
        }
        case "conditional": {
            return resolveConditional(exp, sctx, ctx);
        }
    }
}

export function getAllExpressionTypes(ctx: CompilerContext) {
    const res: [string, string][] = [];
    store.all(ctx).forEach((val, _key) => {
        res.push([val.ast.loc.contents, printTypeRef(val.description)]);
    });
    return res;
}


## resolveSignatures.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/resolveSignatures.ts)
import * as changeCase from "change-case";
import { ABIField, beginCell } from "@ton/core";
import { CompilerContext } from "../context";
import { idToHex } from "../utils/idToHex";
import {
    idTextErr,
    throwConstEvalError,
    throwInternalCompilerError,
} from "../errors";
import { getType, getAllTypes } from "./resolveDescriptors";
import {
    BinaryReceiverSelector,
    CommentReceiverSelector,
    ReceiverDescription,
} from "./types";
import { throwCompilationError } from "../errors";
import { AstNumber, AstReceiver } from "../grammar/ast";
import { commentPseudoOpcode } from "../generator/writers/writeRouter";
import { sha256_sync } from "@ton/crypto";
import { dummySrcInfo } from "../grammar";
import { ensureInt } from "../interpreter";
import { evalConstantExpression } from "../constEval";

export function resolveSignatures(ctx: CompilerContext) {
    const signatures: Map<
        string,
        { signature: string; tlb: string; id: AstNumber | null }
    > = new Map();
    function createTypeFormat(
        type: string,
        format: string | number | boolean | null,
    ) {
        if (type === "int") {
            if (typeof format === "number") {
                return `int${format}`;
            } else if (format !== null) {
                throwInternalCompilerError(`Unsupported int format: ${format}`);
            }
            return `int`;
        } else if (type === "uint") {
            if (typeof format === "number") {
                return `uint${format}`;
            } else if (format === "coins") {
                return `coins`;
            } else if (format !== null) {
                throwInternalCompilerError(
                    `Unsupported uint format: ${format}`,
                );
            }
            return `uint`;
        } else if (type === "bool") {
            if (format !== null) {
                throwInternalCompilerError(
                    `Unsupported bool format: ${format}`,
                );
            }
            return "bool";
        } else if (type === "address") {
            if (format !== null) {
                throwInternalCompilerError(
                    `Unsupported address format: ${format}`,
                );
            }
            return "address";
        } else if (type === "cell") {
            if (format === "remainder") {
                return "remainder<cell>";
            } else if (format === "ref") {
                return "^cell";
            }
            if (format !== null) {
                throwInternalCompilerError(
                    `Unsupported cell format: ${format}`,
                );
            }
            return "^cell";
        } else if (type === "slice") {
            if (format === "remainder") {
                return "remainder<slice>";
            } else if (format === "ref") {
                return "^slice";
            } else if (format !== null) {
                throwInternalCompilerError(
                    `Unsupported slice format: ${format}`,
                );
            }
            return "^slice";
        } else if (type === "builder") {
            if (format === "remainder") {
                return "remainder<builder>";
            } else if (format === "ref") {
                return "^slice";
            } else if (format !== null) {
                throwInternalCompilerError(
                    `Unsupported builder format: ${format}`,
                );
            }
            return "^builder";
        } else if (type === "string") {
            if (format !== null) {
                throwInternalCompilerError(
                    `Unsupported builder format: ${format}`,
                );
            }
            return "^string";
        } else if (type === "fixed-bytes") {
            if (typeof format === "number") {
                return `fixed_bytes${format}`;
            } else if (format !== null) {
                throwInternalCompilerError(
                    `Unsupported fixed-bytes format: ${format}`,
                );
            }
            throwInternalCompilerError("Missing fixed-bytes format");
        }

        // Struct types
        const t = getType(ctx, type);
        if (t.kind !== "struct") {
            throwInternalCompilerError(`Unsupported type: ${type}`);
        }
        const s = createTupleSignature(type);
        if (format === "ref") {
            return `^${s.signature}`;
        } else if (format !== null) {
            throwInternalCompilerError(`Unsupported struct format: ${format}`);
        }
        return s.signature;
    }

    function createTLBField(src: ABIField) {
        switch (src.type.kind) {
            case "simple": {
                let base = createTypeFormat(
                    src.type.type,
                    src.type.format ? src.type.format : null,
                );
                if (src.type.optional) {
                    base = "Maybe " + base;
                }
                return src.name + ":" + base;
            }
            case "dict": {
                if (src.type.format !== null && src.type.format !== undefined) {
                    throwInternalCompilerError(
                        `Unsupported map format: ${src.type.format}`,
                    );
                }
                if (src.type.keyFormat === "coins") {
                    throwCompilationError(
                        `Unsupported format ${src.type.keyFormat} for map key`,
                    );
                }
                const key = createTypeFormat(
                    src.type.key,
                    src.type.keyFormat ? src.type.keyFormat : null,
                );
                const value = createTypeFormat(
                    src.type.value,
                    src.type.valueFormat ? src.type.valueFormat : null,
                );
                return src.name + ":dict<" + key + ", " + value + ">";
            }
        }
    }

    function createTupleSignature(name: string): {
        signature: string;
        tlb: string;
        id: AstNumber | null;
    } {
        if (signatures.has(name)) {
            return signatures.get(name)!;
        }
        const t = getType(ctx, name);
        if (t.kind !== "struct") {
            throwInternalCompilerError(`Unsupported type: ${name}`);
        }

        // Check for no "remainder" in the middle of the struct
        for (const field of t.fields.slice(0, -1)) {
            if (field.as === "remaining") {
                throwCompilationError(
                    `The "remainder" field can only be the last field of the struct`,
                );
            }
        }

        const fields = t.fields.map((v) => createTLBField(v.abi));

        // Calculate signature and method id
        const signature = name + "{" + fields.join(",") + "}";
        let id: AstNumber | null = null;
        if (t.ast.kind === "message_decl") {
            if (t.ast.opcode !== null) {
                // Currently, message opcode expressions do not get typechecked, so
                // ```
                // message(true ? 42 : false) TypeError { }
                // ```
                // WILL NOT result in error
                const opCode = ensureInt(
                    evalConstantExpression(t.ast.opcode, ctx),
                    t.ast.opcode.loc,
                );
                if (opCode === 0n) {
                    throwConstEvalError(
                        `Opcode of message ${idTextErr(t.ast.name)} is zero: those are reserved for text comments and cannot be used for message structs`,
                        true,
                        t.ast.opcode.loc,
                    );
                }
                if (opCode < 0) {
                    throwConstEvalError(
                        `Opcode of message ${idTextErr(t.ast.name)} is negative ('${opCode}') which is not allowed`,
                        true,
                        t.ast.opcode.loc,
                    );
                }
                if (opCode > 0xffff_ffff) {
                    throwConstEvalError(
                        `Opcode of message ${idTextErr(t.ast.name)} is too large ('${opCode}'): it must fit into 32 bits`,
                        true,
                        t.ast.opcode.loc,
                    );
                }
                id =
                    t.ast.opcode.kind === "number"
                        ? t.ast.opcode
                        : {
                              kind: "number",
                              base: 10,
                              value: opCode,
                              id: 0,
                              loc: dummySrcInfo,
                          };
            } else {
                id = newMessageOpcode(signature);
                if (id.value === 0n) {
                    throwCompilationError(
                        `Auto-generated opcode for message "${idTextErr(t.ast.name)}" is zero which is reserved for text comments.\nTry changing names of the message type or its fields to get a non-zero opcode.\nOr consider specifying the opcode explicitly.`,
                        t.ast.loc,
                    );
                }
            }
        }

        // Calculate TLB
        const tlbHeader =
            id !== null
                ? `${changeCase.snakeCase(name)}#${idToHex(Number(id.value))}`
                : "_";
        const tlb = tlbHeader + " " + fields.join(" ") + " = " + name;

        signatures.set(name, { signature, id, tlb });
        return { signature, id, tlb };
    }

    getAllTypes(ctx).forEach((t) => {
        if (t.kind === "struct") {
            const r = createTupleSignature(t.name);
            t.tlb = r.tlb;
            t.signature = r.signature;
            t.header = r.id;
        }
    });

    checkMessageOpcodesUnique(ctx);

    return ctx;
}

function newMessageOpcode(signature: string): AstNumber {
    return {
        kind: "number",
        base: 10,
        value: BigInt(
            beginCell()
                .storeBuffer(sha256_sync(signature))
                .endCell()
                .beginParse()
                .loadUint(32),
        ),
        id: 0,
        loc: dummySrcInfo,
    };
}

type messageType = string;
type binOpcode = number;

function checkBinaryMessageReceiver(
    rcv: BinaryReceiverSelector,
    rcvAst: AstReceiver,
    usedOpcodes: Map<binOpcode, messageType>,
    ctx: CompilerContext,
) {
    const msgType = getType(ctx, rcv.type);
    const opcode = msgType.header!;
    if (usedOpcodes.has(Number(opcode.value))) {
        throwCompilationError(
            `Receive functions of a contract or trait cannot process messages with the same opcode: opcodes of message types "${rcv.type}" and "${usedOpcodes.get(Number(opcode.value))}" are equal`,
            rcvAst.loc,
        );
    } else {
        usedOpcodes.set(Number(opcode.value), rcv.type);
    }
}

type commentOpcode = string;

// "opcode" clashes are highly unlikely in this case, of course
function checkCommentMessageReceiver(
    rcv: CommentReceiverSelector,
    rcvAst: AstReceiver,
    usedOpcodes: Map<commentOpcode, messageType>,
) {
    const opcode = commentPseudoOpcode(rcv.comment);
    if (usedOpcodes.has(opcode)) {
        throwCompilationError(
            `Receive functions of a contract or trait cannot process comments with the same hashes: hashes of comment strings "${rcv.comment}" and "${usedOpcodes.get(opcode)}" are equal`,
            rcvAst.loc,
        );
    } else {
        usedOpcodes.set(opcode, rcv.comment);
    }
}

function checkMessageOpcodesUniqueInContractOrTrait(
    receivers: ReceiverDescription[],
    ctx: CompilerContext,
) {
    const binBouncedRcvUsedOpcodes: Map<binOpcode, messageType> = new Map();
    const binExternalRcvUsedOpcodes: Map<binOpcode, messageType> = new Map();
    const binInternalRcvUsedOpcodes: Map<binOpcode, messageType> = new Map();

    const commentExternalRcvUsedOpcodes: Map<commentOpcode, messageType> =
        new Map();
    const commentInternalRcvUsedOpcodes: Map<commentOpcode, messageType> =
        new Map();

    for (const rcv of receivers) {
        switch (rcv.selector.kind) {
            case "internal-binary":
                checkBinaryMessageReceiver(
                    rcv.selector,
                    rcv.ast,
                    binInternalRcvUsedOpcodes,
                    ctx,
                );
                break;
            case "bounce-binary":
                checkBinaryMessageReceiver(
                    rcv.selector,
                    rcv.ast,
                    binBouncedRcvUsedOpcodes,
                    ctx,
                );
                break;
            case "external-binary":
                checkBinaryMessageReceiver(
                    rcv.selector,
                    rcv.ast,
                    binExternalRcvUsedOpcodes,
                    ctx,
                );
                break;
            case "internal-comment":
                checkCommentMessageReceiver(
                    rcv.selector,
                    rcv.ast,
                    commentInternalRcvUsedOpcodes,
                );
                break;
            case "external-comment":
                checkCommentMessageReceiver(
                    rcv.selector,
                    rcv.ast,
                    commentExternalRcvUsedOpcodes,
                );
                break;
            default:
                break;
        }
    }
}

function checkMessageOpcodesUnique(ctx: CompilerContext) {
    getAllTypes(ctx).forEach((aggregate) => {
        switch (aggregate.kind) {
            case "contract":
            case "trait":
                checkMessageOpcodesUniqueInContractOrTrait(
                    aggregate.receivers,
                    ctx,
                );
                break;
            default:
                break;
        }
    });
}


## resolveStatements.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/resolveStatements.spec.ts)
import { getAllExpressionTypes } from "./resolveExpression";
import { resolveDescriptors } from "./resolveDescriptors";
import { loadCases } from "../utils/loadCases";
import { openContext } from "../grammar/store";
import { resolveStatements } from "./resolveStatements";
import { CompilerContext } from "../context";
import { featureEnable } from "../config/features";
import { getParser } from "../grammar";
import { getAstFactory } from "../grammar/ast";

describe("resolveStatements", () => {
    for (const r of loadCases(__dirname + "/stmts/")) {
        it("should resolve statements for " + r.name, () => {
            const Ast = getAstFactory();
            let ctx = openContext(
                new CompilerContext(),
                [{ code: r.code, path: "<unknown>", origin: "user" }],
                [],
                getParser(Ast),
            );
            ctx = featureEnable(ctx, "external");
            ctx = resolveDescriptors(ctx, Ast);
            ctx = resolveStatements(ctx);
            expect(getAllExpressionTypes(ctx)).toMatchSnapshot();
        });
    }
    for (const r of loadCases(__dirname + "/stmts-failed/")) {
        it("should fail statements for " + r.name, () => {
            const Ast = getAstFactory();
            let ctx = openContext(
                new CompilerContext(),
                [{ code: r.code, path: "<unknown>", origin: "user" }],
                [],
                getParser(Ast),
            );
            ctx = featureEnable(ctx, "external");
            ctx = resolveDescriptors(ctx, Ast);
            expect(() => resolveStatements(ctx)).toThrowErrorMatchingSnapshot();
        });
    }
});


## resolveStatements.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/resolveStatements.ts)
import { CompilerContext } from "../context";
import {
    AstCondition,
    AstStatement,
    tryExtractPath,
    AstId,
    idText,
    isWildcard,
    selfId,
    isSelfId,
    eqNames,
} from "../grammar/ast";
import { isAssignable } from "./subtyping";
import {
    idTextErr,
    throwCompilationError,
    throwConstEvalError,
    throwInternalCompilerError,
} from "../errors";
import {
    getAllStaticFunctions,
    getStaticConstant,
    getType,
    hasStaticConstant,
    resolveTypeRef,
    getAllTypes,
} from "./resolveDescriptors";
import { getExpType, resolveExpression } from "./resolveExpression";
import { FunctionDescription, printTypeRef, TypeRef } from "./types";
import { evalConstantExpression } from "../constEval";
import { ensureInt } from "../interpreter";
import { crc16 } from "../utils/crc16";
import { SrcInfo } from "../grammar";

export type StatementContext = {
    root: SrcInfo;
    funName: string | null;
    returns: TypeRef;
    vars: Map<string, TypeRef>;
    requiredFields: string[];
};

export function emptyContext(
    root: SrcInfo,
    funName: string | null,
    returns: TypeRef,
): StatementContext {
    return {
        root,
        funName,
        returns,
        vars: new Map(),
        requiredFields: [],
    };
}

function checkVariableExists(
    ctx: CompilerContext,
    sctx: StatementContext,
    name: AstId,
): void {
    if (sctx.vars.has(idText(name))) {
        throwCompilationError(
            `Variable already exists: ${idTextErr(name)}`,
            name.loc,
        );
    }
    // Check if the user tries to shadow the current function name
    if (sctx.funName === idText(name)) {
        throwCompilationError(
            `Variable cannot have the same name as its enclosing function: ${idTextErr(name)}`,
            name.loc,
        );
    }
    if (hasStaticConstant(ctx, idText(name))) {
        if (name.loc.origin === "stdlib") {
            const constLoc = getStaticConstant(ctx, idText(name)).loc;
            throwCompilationError(
                `Constant ${idTextErr(name)} is shadowing an identifier defined in the Tact standard library: pick a different constant name`,
                constLoc,
            );
        } else {
            throwCompilationError(
                `Variable ${idTextErr(name)} is trying to shadow an existing constant with the same name`,
                name.loc,
            );
        }
    }
}

function addRequiredVariables(
    name: string,
    src: StatementContext,
): StatementContext {
    if (src.requiredFields.find((v) => v === name)) {
        throwInternalCompilerError(`Variable already exists: ${name}`); // Should happen earlier
    }
    return {
        ...src,
        requiredFields: [...src.requiredFields, name],
    };
}

function removeRequiredVariable(
    name: string,
    src: StatementContext,
): StatementContext {
    if (!src.requiredFields.find((v) => v === name)) {
        throwInternalCompilerError(`Variable is not required: ${name}`); // Should happen earlier
    }
    const filtered = src.requiredFields.filter((v) => v !== name);
    return {
        ...src,
        requiredFields: filtered,
    };
}

function addVariable(
    name: AstId,
    ref: TypeRef,
    ctx: CompilerContext,
    sctx: StatementContext,
): StatementContext {
    checkVariableExists(ctx, sctx, name); // Should happen earlier
    if (isWildcard(name)) {
        return sctx;
    }
    return {
        ...sctx,
        vars: new Map(sctx.vars).set(idText(name), ref),
    };
}

function processCondition(
    condition: AstCondition,
    sctx: StatementContext,
    ctx: CompilerContext,
): {
    ctx: CompilerContext;
    sctx: StatementContext;
    returnAlwaysReachable: boolean;
} {
    // Process expression
    ctx = resolveExpression(condition.condition, sctx, ctx);
    let initialCtx = sctx;

    // Simple if
    if (condition.falseStatements === null && condition.elseif === null) {
        const r = processStatements(condition.trueStatements, initialCtx, ctx);
        ctx = r.ctx;
        return { ctx, sctx: initialCtx, returnAlwaysReachable: false };
    }

    // Simple if-else
    const processedCtx: StatementContext[] = [];
    const returnAlwaysReachableInAllBranches: boolean[] = [];

    // Process true branch
    const r = processStatements(condition.trueStatements, initialCtx, ctx);
    ctx = r.ctx;
    processedCtx.push(r.sctx);
    returnAlwaysReachableInAllBranches.push(r.returnAlwaysReachable);

    // Process else/elseif branch
    if (condition.falseStatements !== null && condition.elseif === null) {
        // if-else
        const r = processStatements(condition.falseStatements, initialCtx, ctx);
        ctx = r.ctx;
        processedCtx.push(r.sctx);
        returnAlwaysReachableInAllBranches.push(r.returnAlwaysReachable);
    } else if (
        condition.falseStatements === null &&
        condition.elseif !== null
    ) {
        // if-else if
        const r = processCondition(condition.elseif, initialCtx, ctx);

        ctx = r.ctx;
        processedCtx.push(r.sctx);
        returnAlwaysReachableInAllBranches.push(r.returnAlwaysReachable);
    } else {
        throwInternalCompilerError("Impossible");
    }

    // Merge statement contexts
    const removed: string[] = [];
    for (const f of initialCtx.requiredFields) {
        let found = false;
        for (const c of processedCtx) {
            if (c.requiredFields.find((v) => v === f)) {
                found = true;
                break;
            }
        }
        if (!found) {
            removed.push(f);
        }
    }
    for (const r of removed) {
        initialCtx = removeRequiredVariable(r, initialCtx);
    }

    return {
        ctx,
        sctx: initialCtx,
        returnAlwaysReachable: returnAlwaysReachableInAllBranches.every(
            (x) => x,
        ),
    };
}

// Precondition: `self` here means a contract or a trait,
// and not a `self` parameter of a mutating method
export function isLvalue(path: AstId[], ctx: CompilerContext): boolean {
    const headId = path[0]!;
    if (isSelfId(headId) && path.length > 1) {
        // we can be dealing with a contract/trait constant `self.constFoo`
        const selfTypeRef = getExpType(ctx, headId);
        if (selfTypeRef.kind == "ref") {
            const contractTypeDescription = getType(ctx, selfTypeRef.name);
            return (
                contractTypeDescription.constants.findIndex((constDescr) =>
                    eqNames(path[1]!, constDescr.name),
                ) === -1
            );
        } else {
            return true;
        }
    } else {
        // if the head path symbol is a global constant, then the whole path expression is a constant
        return !hasStaticConstant(ctx, idText(headId));
    }
}

function processStatements(
    statements: AstStatement[],
    sctx: StatementContext,
    ctx: CompilerContext,
): {
    ctx: CompilerContext;
    sctx: StatementContext;
    returnAlwaysReachable: boolean;
} {
    // Process statements

    let returnAlwaysReachable = false;
    for (const s of statements) {
        // Check for unreachable
        if (returnAlwaysReachable) {
            throwCompilationError("Unreachable statement", s.loc);
        }

        // Process statement
        switch (s.kind) {
            case "statement_let":
                {
                    // Process expression
                    ctx = resolveExpression(s.expression, sctx, ctx);

                    // Check variable name
                    checkVariableExists(ctx, sctx, s.name);

                    // Check type
                    const expressionType = getExpType(ctx, s.expression);
                    if (s.type !== null) {
                        const variableType = resolveTypeRef(ctx, s.type);
                        if (!isAssignable(expressionType, variableType)) {
                            throwCompilationError(
                                `Type mismatch: "${printTypeRef(expressionType)}" is not assignable to "${printTypeRef(variableType)}"`,
                                s.loc,
                            );
                        }
                        sctx = addVariable(s.name, variableType, ctx, sctx);
                    } else {
                        if (expressionType.kind === "null") {
                            throwCompilationError(
                                `Cannot infer type for ${idTextErr(s.name)}`,
                                s.loc,
                            );
                        }
                        if (expressionType.kind === "void") {
                            throwCompilationError(
                                `The inferred type of variable ${idTextErr(s.name)} is "void", which is not allowed`,
                                s.loc,
                            );
                        }
                        sctx = addVariable(s.name, expressionType, ctx, sctx);
                    }
                }
                break;
            case "statement_assign":
                {
                    const tempSctx = { ...sctx, requiredFields: [] };
                    // Process lvalue
                    ctx = resolveExpression(s.path, tempSctx, ctx);
                    const path = tryExtractPath(s.path);
                    if (path === null) {
                        throwCompilationError(
                            `Assignments are allowed only into path expressions, i.e. identifiers, or sequences of direct contract/struct/message accesses, like "self.foo" or "self.structure.field"`,
                            s.path.loc,
                        );
                    }
                    if (!isLvalue(path, ctx)) {
                        throwCompilationError(
                            "Modifications of constant expressions are not allowed",
                            s.path.loc,
                        );
                    }

                    // Process expression
                    ctx = resolveExpression(s.expression, sctx, ctx);

                    // Check type
                    const expressionType = getExpType(ctx, s.expression);
                    const tailType = getExpType(ctx, s.path);
                    if (!isAssignable(expressionType, tailType)) {
                        throwCompilationError(
                            `Type mismatch: "${printTypeRef(expressionType)}" is not assignable to "${printTypeRef(tailType)}"`,
                            s.loc,
                        );
                    }

                    // Mark as assigned
                    if (path.length === 2 && path[0]!.text === "self") {
                        const field = path[1]!.text;
                        if (
                            sctx.requiredFields.findIndex((v) => v === field) >=
                            0
                        ) {
                            sctx = removeRequiredVariable(field, sctx);
                        }
                    }
                }
                break;
            case "statement_augmentedassign":
                {
                    // Process lvalue
                    const tempSctx = { ...sctx, requiredFields: [] };
                    ctx = resolveExpression(s.path, tempSctx, ctx);
                    const path = tryExtractPath(s.path);
                    if (path === null) {
                        throwCompilationError(
                            `Assignments are allowed only into path expressions, i.e. identifiers, or sequences of direct contract/struct/message accesses, like "self.foo" or "self.structure.field"`,
                            s.path.loc,
                        );
                    }
                    if (!isLvalue(path, ctx)) {
                        throwCompilationError(
                            "Modifications of constant expressions are not allowed",
                            s.path.loc,
                        );
                    }

                    // Process expression
                    ctx = resolveExpression(s.expression, sctx, ctx);

                    // Check type
                    const tailType = getExpType(ctx, s.path);
                    const expressionType = getExpType(ctx, s.expression);

                    // Check if any of the types is not ref or is optional or types themselves don't match
                    if (tailType.kind !== "ref" || tailType.optional) {
                        throwCompilationError(
                            `Type error: invalid type ${printTypeRef(tailType)} for augmented assignment`,
                            s.path.loc,
                        );
                    }
                    if (
                        expressionType.kind !== "ref" ||
                        expressionType.optional
                    ) {
                        throwCompilationError(
                            `Type error: invalid type ${printTypeRef(expressionType)} for augmented assignment`,
                            s.expression.loc,
                        );
                    }

                    if (s.op === "&&" || s.op === "||") {
                        if (tailType.name !== "Bool") {
                            throwCompilationError(
                                `Type error: Augmented assignment ${s.op}= is only allowed for Bool type`,
                                s.path.loc,
                            );
                        }
                        if (expressionType.name !== "Bool") {
                            throwCompilationError(
                                `Type error: Augmented assignment ${s.op}= is only allowed for Bool type`,
                                s.expression.loc,
                            );
                        }
                    } else {
                        if (tailType.name !== "Int") {
                            throwCompilationError(
                                `Type error: Augmented assignment ${s.op}= is only allowed for Int type`,
                                s.path.loc,
                            );
                        }
                        if (expressionType.name !== "Int") {
                            throwCompilationError(
                                `Type error: Augmented assignment ${s.op}= is only allowed for Int type`,
                                s.expression.loc,
                            );
                        }
                    }
                }
                break;
            case "statement_expression":
                {
                    // Process expression
                    ctx = resolveExpression(s.expression, sctx, ctx);
                    // take `throw` and `throwNative` into account when doing
                    // return-reachability analysis
                    if (
                        s.expression.kind === "static_call" &&
                        ["throw", "nativeThrow"].includes(
                            idText(s.expression.function),
                        )
                    ) {
                        returnAlwaysReachable = true;
                    }
                }
                break;
            case "statement_condition":
                {
                    // Process condition (expression resolved inside)
                    const r = processCondition(s, sctx, ctx);
                    ctx = r.ctx;
                    sctx = r.sctx;
                    returnAlwaysReachable ||= r.returnAlwaysReachable;

                    // Check type
                    const expressionType = getExpType(ctx, s.condition);
                    if (
                        expressionType.kind !== "ref" ||
                        expressionType.name !== "Bool" ||
                        expressionType.optional
                    ) {
                        throwCompilationError(
                            `Type mismatch: "${printTypeRef(expressionType)}" is not assignable to "Bool"`,
                            s.loc,
                        );
                    }
                }
                break;
            case "statement_return":
                {
                    if (s.expression) {
                        // Process expression
                        ctx = resolveExpression(s.expression, sctx, ctx);

                        // Check type
                        const expressionType = getExpType(ctx, s.expression);

                        // Actually, we might relax the following restriction in the future
                        // Because `return foo()` means `foo(); return` for a void-returning function
                        // And `return foo()` looks nicer when the user needs early exit from a function
                        // right after executing `foo()`
                        if (expressionType.kind == "void") {
                            throwCompilationError(
                                `'return' statement can only be used with non-void types`,
                                s.loc,
                            );
                        }
                        if (!isAssignable(expressionType, sctx.returns)) {
                            throwCompilationError(
                                `Type mismatch: "${printTypeRef(expressionType)}" is not assignable to "${printTypeRef(sctx.returns)}"`,
                                s.loc,
                            );
                        }
                    } else {
                        if (sctx.returns.kind !== "void") {
                            throwCompilationError(
                                `The function fails to return a result of type "${printTypeRef(sctx.returns)}"`,
                                s.loc,
                            );
                        }
                    }

                    // Check if all required variables are assigned
                    if (sctx.requiredFields.length > 0) {
                        if (sctx.requiredFields.length === 1) {
                            throwCompilationError(
                                `Field "${sctx.requiredFields[0]}" is not set`,
                                sctx.root,
                            );
                        } else {
                            throwCompilationError(
                                `Fields ${sctx.requiredFields.map((x) => '"' + x + '"').join(", ")} are not set`,
                                sctx.root,
                            );
                        }
                    }

                    returnAlwaysReachable = true;
                }
                break;
            case "statement_repeat":
                {
                    // Process expression
                    ctx = resolveExpression(s.iterations, sctx, ctx);

                    // Process statements
                    const r = processStatements(s.statements, sctx, ctx);
                    ctx = r.ctx;

                    // Check type
                    const expressionType = getExpType(ctx, s.iterations);
                    if (
                        expressionType.kind !== "ref" ||
                        expressionType.name !== "Int" ||
                        expressionType.optional
                    ) {
                        throwCompilationError(
                            `Type mismatch: "${printTypeRef(expressionType)}" is not assignable to "Int"`,
                            s.loc,
                        );
                    }
                }
                break;
            case "statement_until":
                {
                    // Process expression
                    ctx = resolveExpression(s.condition, sctx, ctx);

                    // Process statements
                    const r = processStatements(s.statements, sctx, ctx);
                    ctx = r.ctx;
                    // XXX a do-until loop is a weird place to always return from a function
                    // so we might want to issue a warning here
                    returnAlwaysReachable ||= r.returnAlwaysReachable;

                    // Check type
                    const expressionType = getExpType(ctx, s.condition);
                    if (
                        expressionType.kind !== "ref" ||
                        expressionType.name !== "Bool" ||
                        expressionType.optional
                    ) {
                        throwCompilationError(
                            `Type mismatch: "${printTypeRef(expressionType)}" is not assignable to "Bool"`,
                            s.loc,
                        );
                    }
                }
                break;
            case "statement_while":
                {
                    // Process expression
                    ctx = resolveExpression(s.condition, sctx, ctx);

                    // Process statements
                    const r = processStatements(s.statements, sctx, ctx);
                    ctx = r.ctx;
                    // a while loop might be executed zero times, so
                    // even if its body always returns from a function
                    // we don't care

                    // Check type
                    const expressionType = getExpType(ctx, s.condition);
                    if (
                        expressionType.kind !== "ref" ||
                        expressionType.name !== "Bool" ||
                        expressionType.optional
                    ) {
                        throwCompilationError(
                            `Type mismatch: "${printTypeRef(expressionType)}" is not assignable to "Bool"`,
                            s.loc,
                        );
                    }
                }
                break;
            case "statement_try":
                {
                    // Process inner statements
                    const r = processStatements(s.statements, sctx, ctx);
                    ctx = r.ctx;
                    sctx = r.sctx;
                    // try-statement might not return from the current function
                    // because the control flow can go to the empty catch block
                }
                break;
            case "statement_try_catch":
                {
                    let initialSctx = sctx;

                    // Process inner statements
                    const r = processStatements(s.statements, sctx, ctx);
                    ctx = r.ctx;

                    let catchCtx = sctx;

                    // Process catchName variable for exit code
                    checkVariableExists(ctx, initialSctx, s.catchName);
                    catchCtx = addVariable(
                        s.catchName,
                        { kind: "ref", name: "Int", optional: false },
                        ctx,
                        initialSctx,
                    );

                    // Process catch statements
                    const rCatch = processStatements(
                        s.catchStatements,
                        catchCtx,
                        ctx,
                    );
                    ctx = rCatch.ctx;
                    catchCtx = rCatch.sctx;
                    // if both catch- and try- blocks always return from the current function
                    // we mark the whole try-catch statement as always returning
                    returnAlwaysReachable ||=
                        r.returnAlwaysReachable && rCatch.returnAlwaysReachable;

                    // Merge statement contexts
                    const removed: string[] = [];
                    for (const f of initialSctx.requiredFields) {
                        if (!catchCtx.requiredFields.find((v) => v === f)) {
                            removed.push(f);
                        }
                    }
                    for (const r of removed) {
                        initialSctx = removeRequiredVariable(r, initialSctx);
                    }
                }
                break;
            case "statement_foreach": {
                let initialSctx = sctx; // Preserve initial context to use later for merging

                // Resolve map expression
                ctx = resolveExpression(s.map, sctx, ctx);
                const mapPath = tryExtractPath(s.map);
                if (mapPath === null) {
                    throwCompilationError(
                        `foreach is only allowed over maps that are path expressions, i.e. identifiers, or sequences of direct contract/struct/message accesses, like "self.foo" or "self.structure.field"`,
                        s.map.loc,
                    );
                }

                // Check if map is valid
                const mapType = getExpType(ctx, s.map);
                if (mapType.kind !== "map") {
                    throwCompilationError(
                        `foreach can only be used on maps, but "${mapPath.map((id) => id.text).join(".")}" has type "${printTypeRef(mapType)}"`,
                        s.map.loc,
                    );
                }

                let foreachSctx = sctx;

                // Add key and value to statement context
                if (!isWildcard(s.keyName)) {
                    checkVariableExists(ctx, initialSctx, s.keyName);
                    foreachSctx = addVariable(
                        s.keyName,
                        { kind: "ref", name: mapType.key, optional: false },
                        ctx,
                        initialSctx,
                    );
                }
                if (!isWildcard(s.valueName)) {
                    checkVariableExists(ctx, foreachSctx, s.valueName);
                    foreachSctx = addVariable(
                        s.valueName,
                        { kind: "ref", name: mapType.value, optional: false },
                        ctx,
                        foreachSctx,
                    );
                }

                // Process inner statements
                const r = processStatements(s.statements, foreachSctx, ctx);
                ctx = r.ctx;
                foreachSctx = r.sctx;

                // Merge statement contexts (similar to catch block merging)
                const removed: string[] = [];
                for (const f of initialSctx.requiredFields) {
                    if (!foreachSctx.requiredFields.find((v) => v === f)) {
                        removed.push(f);
                    }
                }
                for (const r of removed) {
                    initialSctx = removeRequiredVariable(r, initialSctx);
                }

                sctx = initialSctx; // Re-assign the modified initial context back to sctx after merging
                break;
            }
            case "statement_destruct": {
                // Process expression
                ctx = resolveExpression(s.expression, sctx, ctx);

                // Check variable names
                for (const [_, name] of s.identifiers.values()) {
                    checkVariableExists(ctx, sctx, name);
                }

                // Check type
                const expressionType = getExpType(ctx, s.expression);
                if (expressionType.kind !== "ref") {
                    throwCompilationError(
                        `Type '${printTypeRef(expressionType)}' cannot be destructured`,
                        s.expression.loc,
                    );
                }
                if (expressionType.optional) {
                    throwCompilationError(
                        `Type '${printTypeRef(expressionType)}' is optional and cannot be destructured`,
                        s.expression.loc,
                    );
                }
                const ty = getType(ctx, expressionType.name);
                if (ty.kind !== "struct") {
                    throwCompilationError(
                        `Type '${printTypeRef(expressionType)}' cannot be destructured`,
                        s.expression.loc,
                    );
                }

                // Check variables count
                if (
                    !s.ignoreUnspecifiedFields &&
                    s.identifiers.size !== ty.fields.length
                ) {
                    throwCompilationError(
                        `Expected ${ty.fields.length} fields, but got ${s.identifiers.size}`,
                        s.loc,
                    );
                }

                // Compare type with the specified one
                const typeRef = resolveTypeRef(ctx, s.type);
                if (typeRef.kind !== "ref") {
                    throwInternalCompilerError(
                        `Unexpected type kind: '${typeRef.kind}'`,
                        s.type.loc,
                    );
                }
                if (expressionType.name !== typeRef.name) {
                    throwCompilationError(
                        `Type mismatch: "${printTypeRef(expressionType)}" is not assignable to "${printTypeRef(typeRef)}"`,
                        s.expression.loc,
                    );
                }

                // Add variables
                s.identifiers.forEach(([field, name], _) => {
                    const f = ty.fields.find((f) => eqNames(f.name, field));
                    if (!f) {
                        throwCompilationError(
                            `Field '${idTextErr(field)}' not found in type '${expressionType.name}'`,
                            field.loc,
                        );
                    }
                    if (name.text !== "_") {
                        sctx = addVariable(name, f.type, ctx, sctx);
                    }
                });

                break;
            }
        }
    }

    return { ctx, sctx, returnAlwaysReachable };
}

function processFunctionBody(
    statements: AstStatement[],
    sctx: StatementContext,
    ctx: CompilerContext,
): CompilerContext {
    const res = processStatements(statements, sctx, ctx);

    // Check if a non-void function always returns a value
    if (sctx.returns.kind !== "void" && !res.returnAlwaysReachable) {
        throwCompilationError(
            `Function does not always return a result. Adding 'return' statement(s) should fix the issue.`,
            res.sctx.root,
        );
    }

    // Check if all required variables are assigned
    if (res.sctx.requiredFields.length > 0) {
        if (res.sctx.requiredFields.length === 1) {
            throwCompilationError(
                `Field "${res.sctx.requiredFields[0]}" is not set`,
                res.sctx.root,
            );
        } else {
            throwCompilationError(
                `Fields ${res.sctx.requiredFields.map((x) => '"' + x + '"').join(", ")} are not set`,
                res.sctx.root,
            );
        }
    }

    return res.ctx;
}

export function resolveStatements(ctx: CompilerContext) {
    // Process all static functions
    for (const f of getAllStaticFunctions(ctx)) {
        if (f.ast.kind === "function_def") {
            // Build statement context
            let sctx = emptyContext(f.ast.loc, f.name, f.returns);
            for (const p of f.params) {
                sctx = addVariable(p.name, p.type, ctx, sctx);
            }

            ctx = processFunctionBody(f.ast.statements, sctx, ctx);
        }
    }

    // Process all types
    for (const t of getAllTypes(ctx)) {
        // Process init
        if (t.init) {
            // Build statement context
            let sctx = emptyContext(t.init.ast.loc, null, { kind: "void" });

            // Self
            sctx = addVariable(
                selfId,
                { kind: "ref", name: t.name, optional: false },
                ctx,
                sctx,
            );

            // Required variables
            for (const f of t.fields) {
                if (f.default !== undefined) {
                    // NOTE: undefined is important here
                    continue;
                }
                if (isAssignable({ kind: "null" }, f.type)) {
                    continue;
                }
                sctx = addRequiredVariables(f.name, sctx);
            }

            // Args
            for (const p of t.init.params) {
                sctx = addVariable(p.name, p.type, ctx, sctx);
            }

            // Process
            ctx = processFunctionBody(t.init.ast.statements, sctx, ctx);
        }

        // Process receivers
        for (const f of t.receivers) {
            // Build statement context
            let sctx = emptyContext(f.ast.loc, null, { kind: "void" });
            sctx = addVariable(
                selfId,
                { kind: "ref", name: t.name, optional: false },
                ctx,
                sctx,
            );
            switch (f.selector.kind) {
                case "internal-binary":
                case "external-binary":
                    {
                        sctx = addVariable(
                            f.selector.name,
                            {
                                kind: "ref",
                                name: f.selector.type,
                                optional: false,
                            },
                            ctx,
                            sctx,
                        );
                    }
                    break;
                case "internal-empty":
                case "external-empty":
                case "external-comment":
                case "internal-comment":
                    // Nothing to add to context
                    break;
                case "internal-comment-fallback":
                case "external-comment-fallback":
                    {
                        sctx = addVariable(
                            f.selector.name,
                            { kind: "ref", name: "String", optional: false },
                            ctx,
                            sctx,
                        );
                    }
                    break;
                case "internal-fallback":
                case "external-fallback":
                    {
                        sctx = addVariable(
                            f.selector.name,
                            { kind: "ref", name: "Slice", optional: false },
                            ctx,
                            sctx,
                        );
                    }
                    break;
                case "bounce-fallback":
                    {
                        sctx = addVariable(
                            f.selector.name,
                            { kind: "ref", name: "Slice", optional: false },
                            ctx,
                            sctx,
                        );
                    }
                    break;
                case "bounce-binary":
                    {
                        sctx = addVariable(
                            f.selector.name,
                            f.selector.bounced
                                ? { kind: "ref_bounced", name: f.selector.type }
                                : {
                                      kind: "ref",
                                      name: f.selector.type,
                                      optional: false,
                                  },
                            ctx,
                            sctx,
                        );
                    }
                    break;
            }
            // Process
            ctx = processFunctionBody(f.ast.statements, sctx, ctx);
        }

        // Process functions
        const methodIds: Map<number, string> = new Map();
        for (const f of t.functions.values()) {
            if (
                f.ast.kind !== "native_function_decl" &&
                f.ast.kind !== "function_decl" &&
                f.ast.kind !== "asm_function_def"
            ) {
                // Build statement context
                let sctx = emptyContext(f.ast.loc, f.name, f.returns);

                if (f.self === null) {
                    throwInternalCompilerError(
                        "Self is null where it should not be",
                    );
                }
                sctx = addVariable(selfId, f.self, ctx, sctx);

                // Check for collisions in getter method IDs
                if (f.isGetter) {
                    const methodId = getMethodId(f, ctx, sctx);
                    const existing = methodIds.get(methodId);
                    if (existing) {
                        throwCompilationError(
                            `Method ID collision: getter '${f.name}' has the same method ID ${methodId} as getter '${existing}'\nPick a different getter name or explicit method ID to avoid collisions`,
                            f.ast.name.loc,
                        );
                    } else {
                        f.methodId = methodId;
                        methodIds.set(methodId, f.name);
                    }
                }

                for (const a of f.params) {
                    sctx = addVariable(a.name, a.type, ctx, sctx);
                }

                ctx = processFunctionBody(f.ast.statements, sctx, ctx);
            }
        }
    }

    return ctx;
}

function checkMethodId(methodId: bigint, loc: SrcInfo) {
    // method ids are 19-bit signed integers
    if (methodId < -(2n ** 18n) || methodId >= 2n ** 18n) {
        throwConstEvalError(
            "method ids must fit 19-bit signed integer range",
            true,
            loc,
        );
    }
    // method ids -4, -3, -2, -1, 0 ... 2^14 - 1 (inclusive) are kind of reserved by TVM
    // for the upper bound see F12_n (CALL) TVM instruction
    // and many small ids will be taken by internal procedures
    //
    // also, some ids are taken by the getters generated by Tact:
    // supported_interfaces -> 113617
    // lazy_deployment_completed -> 115390
    // get_abi_ipfs -> 121275
    if (-4n <= methodId && methodId < 2n ** 14n) {
        throwConstEvalError(
            "method ids cannot overlap with the TVM reserved ids: -4, -3, -2, -1, 0 ... 2^14 - 1",
            true,
            loc,
        );
    }
    const tactGeneratedGetterMethodIds = [113617n, 115390n, 121275n];
    if (tactGeneratedGetterMethodIds.includes(methodId)) {
        throwConstEvalError(
            `method ids cannot overlap with Tact reserved method ids: ${tactGeneratedGetterMethodIds.map((n) => n.toString()).join(", ")}`,
            true,
            loc,
        );
    }
}

function getMethodId(
    funcDescr: FunctionDescription,
    ctx: CompilerContext,
    sctx: StatementContext,
): number {
    const optMethodId = funcDescr.ast.attributes.find(
        (attr) => attr.type === "get",
    )?.methodId;

    if (optMethodId) {
        ctx = resolveExpression(optMethodId, sctx, ctx);
        const ty = getExpType(ctx, optMethodId);
        if (!(ty.kind === "ref" && ty.name === "Int")) {
            throwCompilationError(
                `Getter's method id expression must be of type "Int" but it has type "${printTypeRef(ty)}"`,
                optMethodId.loc,
            );
        }

        const methodId = ensureInt(
            evalConstantExpression(optMethodId, ctx),
            optMethodId.loc,
        );
        checkMethodId(methodId, optMethodId.loc);
        return Number(methodId);
    } else {
        const methodId = (crc16(funcDescr.name) & 0xffff) | 0x10000;
        checkMethodId(BigInt(methodId), funcDescr.ast.loc);
        return methodId;
    }
}


## subtyping.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/subtyping.ts)
import { TypeRef } from "./types";

export function isAssignable(src: TypeRef, to: TypeRef): boolean {
    // If both are refs
    if (src.kind === "ref" && to.kind === "ref") {
        // Cannot assign optional to non-optional
        if (!to.optional && src.optional) {
            return false;
        }

        // Check types
        return src.name === to.name;
    }

    // If both are maps
    if (src.kind === "map" && to.kind === "map") {
        return (
            src.key === to.key &&
            src.value === to.value &&
            src.keyAs === to.keyAs &&
            src.valueAs === to.valueAs
        );
    }

    // Bounced types
    if (src.kind === "ref_bounced" && to.kind === "ref_bounced") {
        return src.name === to.name;
    }

    // Allow assigning null to map
    if (src.kind === "null" && to.kind === "map") {
        return true;
    }

    if (src.kind === "void" && to.kind === "void") {
        return true;
    }

    // Check null
    if (src.kind === "null" && to.kind === "ref") {
        return to.optional;
    }
    if (src.kind === "null" && to.kind === "null") {
        return true;
    }

    // All other options are not assignable
    return false;
}

export function moreGeneralType(
    type1: TypeRef,
    type2: TypeRef,
): TypeRef | null {
    // This takes care of sub-typing for optionals and maps/null
    if (isAssignable(type1, type2)) return type2;
    if (isAssignable(type2, type1)) return type1;
    // generalize to a more general optional type
    // if we have a non-optional and null types
    if (type1.kind === "ref" && !type1.optional && type2.kind === "null") {
        return { ...type1, optional: true };
    }
    if (type2.kind === "ref" && !type2.optional && type1.kind === "null") {
        return { ...type2, optional: true };
    }
    return null;
}


## types.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/types.ts)
import { ABIField, Address, Cell, Slice } from "@ton/core";
import { throwInternalCompilerError } from "../errors";
import {
    AstConstantDef,
    AstFunctionDef,
    AstContractInit,
    AstNativeFunctionDecl,
    AstReceiver,
    AstTypeDecl,
    AstId,
    AstFunctionDecl,
    AstConstantDecl,
    AstFieldDecl,
    AstAsmFunctionDef,
    AstNumber,
} from "../grammar/ast";
import { dummySrcInfo, ItemOrigin, SrcInfo } from "../grammar";

export type TypeDescription = {
    kind: "struct" | "primitive_type_decl" | "contract" | "trait";
    origin: ItemOrigin;
    name: string;
    uid: number;
    header: AstNumber | null;
    tlb: string | null;
    signature: string | null;
    fields: FieldDescription[];
    partialFieldCount: number; // Max number of fields that can be parsed when message is bounced
    traits: TypeDescription[];
    functions: Map<string, FunctionDescription>;
    receivers: ReceiverDescription[];
    init: InitDescription | null;
    ast: AstTypeDecl;
    dependsOn: TypeDescription[];
    interfaces: string[];
    constants: ConstantDescription[];
};

export type TypeRef =
    | {
          kind: "ref";
          name: string;
          optional: boolean;
      }
    | {
          kind: "map";
          key: string;
          keyAs: string | null;
          value: string;
          valueAs: string | null;
      }
    | {
          kind: "ref_bounced";
          name: string;
      }
    | {
          kind: "void";
      }
    | {
          kind: "null";
      };

// https://github.com/microsoft/TypeScript/issues/35164 and
// https://github.com/microsoft/TypeScript/pull/57293
// eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style
export type StructValue = {
    [key: string]: Value;
};

export class CommentValue {
    constructor(public readonly comment: string) {}
}

export type Value =
    | bigint
    | boolean
    | string
    | Address
    | Cell
    | Slice
    | null
    | CommentValue
    | StructValue;

export function showValue(val: Value): string {
    if (typeof val === "bigint") {
        return val.toString(10);
    } else if (typeof val === "string") {
        return val;
    } else if (typeof val === "boolean") {
        return val ? "true" : "false";
    } else if (Address.isAddress(val)) {
        return val.toRawString();
    } else if (val instanceof Cell || val instanceof Slice) {
        return val.toString();
    } else if (val === null) {
        return "null";
    } else if (val instanceof CommentValue) {
        return val.comment;
    } else if (typeof val === "object" && "$tactStruct" in val) {
        const assocList = Object.entries(val).map(([key, value]) => {
            return `${key}: ${showValue(value)}`;
        });
        return `{${assocList.join(",")}}`;
    } else {
        throwInternalCompilerError("Invalid value", dummySrcInfo);
    }
}

export type FieldDescription = {
    name: string;
    index: number;
    type: TypeRef;
    as: string | null;
    default: Value | undefined;
    loc: SrcInfo;
    ast: AstFieldDecl;
    abi: ABIField;
};

export type ConstantDescription = {
    name: string;
    type: TypeRef;
    value: Value | undefined;
    loc: SrcInfo;
    ast: AstConstantDef | AstConstantDecl;
};

export type FunctionParameter = {
    name: AstId;
    type: TypeRef;
    loc: SrcInfo;
};

export type InitParameter = {
    name: AstId;
    type: TypeRef;
    as: string | null;
    loc: SrcInfo;
};

export type FunctionDescription = {
    name: string;
    origin: ItemOrigin;
    isGetter: boolean;
    methodId: number | null;
    isMutating: boolean;
    isOverride: boolean;
    isVirtual: boolean;
    isAbstract: boolean;
    isInline: boolean;
    self: TypeRef | null;
    returns: TypeRef;
    params: FunctionParameter[];
    ast:
        | AstFunctionDef
        | AstNativeFunctionDecl
        | AstFunctionDecl
        | AstAsmFunctionDef;
};

export type BinaryReceiverSelector =
    | {
          kind: "internal-binary";
          type: string;
          name: AstId;
      }
    | {
          kind: "bounce-binary";
          name: AstId;
          type: string;
          bounced: boolean;
      }
    | {
          kind: "external-binary";
          type: string;
          name: AstId;
      };

export type CommentReceiverSelector =
    | {
          kind: "internal-comment";
          comment: string;
      }
    | {
          kind: "external-comment";
          comment: string;
      };

type EmptyReceiverSelector =
    | {
          kind: "internal-empty";
      }
    | {
          kind: "external-empty";
      };

type FallbackReceiverSelector =
    | {
          kind: "internal-comment-fallback";
          name: AstId;
      }
    | {
          kind: "internal-fallback";
          name: AstId;
      }
    | {
          kind: "bounce-fallback";
          name: AstId;
      }
    | {
          kind: "external-comment-fallback";
          name: AstId;
      }
    | {
          kind: "external-fallback";
          name: AstId;
      };

export type ReceiverSelector =
    | BinaryReceiverSelector
    | CommentReceiverSelector
    | EmptyReceiverSelector
    | FallbackReceiverSelector;

// TODO: improve this for empty and fallbacks
export function receiverSelectorName(selector: ReceiverSelector): string {
    switch (selector.kind) {
        case "internal-binary":
        case "bounce-binary":
        case "external-binary":
            return selector.type;
        case "internal-comment":
        case "external-comment":
            return selector.comment;
        case "internal-empty":
        case "external-empty":
            return selector.kind;
        case "internal-fallback":
        case "bounce-fallback":
        case "external-fallback":
            return selector.kind;
        case "internal-comment-fallback":
        case "external-comment-fallback":
            return selector.kind;
    }
}

export type ReceiverDescription = {
    selector: ReceiverSelector;
    ast: AstReceiver;
};

export type InitDescription = {
    params: InitParameter[];
    ast: AstContractInit;
};

export function printTypeRef(src: TypeRef): string {
    switch (src.kind) {
        case "ref":
            return `${src.name}${src.optional ? "?" : ""}`;
        case "map":
            return `map<${src.key + (src.keyAs ? " as " + src.keyAs : "")}, ${src.value + (src.valueAs ? " as " + src.valueAs : "")}>`;
        case "void":
            return "<void>";
        case "null":
            return "<null>";
        case "ref_bounced":
            return `bounced<${src.name}>`;
    }
}

export function typeRefEquals(a: TypeRef, b: TypeRef) {
    if (a.kind !== b.kind) {
        return false;
    }
    if (a.kind === "ref" && b.kind === "ref") {
        return a.name === b.name && a.optional === b.optional;
    }
    if (a.kind === "map" && b.kind === "map") {
        return a.key === b.key && a.value === b.value;
    }
    if (a.kind === "ref_bounced" && b.kind === "ref_bounced") {
        return a.name === b.name;
    }
    if (a.kind === "null" && b.kind === "null") {
        return true;
    }
    if (a.kind === "void" && b.kind === "void") {
        return true;
    }
    return false;
}


## assign-augmented-const-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/assign-augmented-const-contract.tact)
primitive Int;
trait BaseTrait { }

contract Test {
    const foo: Int = 42;

    fun bar() {
        self.foo += 1 // <-- trying to assign to a constant
    }
}

## assign-augmented-const-global.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/assign-augmented-const-global.tact)
primitive Int;

const foo: Int = 42;

fun bar() {
    foo += 1 // <-- trying to assign to a constant
}

## assign-augmented-const-struct-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/assign-augmented-const-struct-contract.tact)
primitive Int;
trait BaseTrait { }

struct Foo {x: Int; y: Int}

contract Test {
    const foo: Foo = Foo {x: 42, y: 43};
    baz: Foo = Foo {x: 42, y: 43};

    fun bar() {
        self.baz.x += 1; // ok
        self.foo.y -= 1 // <-- trying to assign to a constant
    }
}

## assign-augmented-const-struct-global.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/assign-augmented-const-struct-global.tact)
primitive Int;

struct Foo {x: Int; y: Int}

const foo: Foo = Foo {x: 42, y: 43};

fun bar() {
    let baz: Foo = Foo {x: 42, y: 43};
    baz.x += 1; // ok
    foo.y -= 1 // <-- trying to assign to a constant
}

## assign-const-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/assign-const-contract.tact)
primitive Int;
trait BaseTrait { }

contract Test {
    const foo: Int = 42;

    fun bar() {
        self.foo = 43 // <-- trying to assign to a constant
    }
}

## assign-const-global.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/assign-const-global.tact)
primitive Int;

const foo: Int = 42;

fun bar() {
    foo = 43 // <-- trying to assign to a constant
}

## assign-const-struct-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/assign-const-struct-contract.tact)
primitive Int;
trait BaseTrait { }

struct Foo {x: Int; y: Int}

contract Test {
    const foo: Foo = Foo {x: 42, y: 43};
    baz: Foo = Foo {x: 42, y: 43};

    fun bar() {
        self.baz.x = 1; // ok
        self.foo.y = 42 // <-- trying to assign to a constant
    }
}

## assign-const-struct-global.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/assign-const-struct-global.tact)
primitive Int;

struct Foo {x: Int; y: Int}

const foo: Foo = Foo {x: 42, y: 43};

fun bar() {
    let baz: Foo = Foo {x: 42, y: 43};
    baz.x = 1; // ok
    foo.y = 42 // <-- trying to assign to a constant
}

## bounced-type-is-smaller.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/bounced-type-is-smaller.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

message A {
  a: Int as uint32;
  b: Bool;
  c: Int as uint256;
}

contract Test {
  init() {}
  receive(src: A) {
    
  }
  
  bounced(src: bounced<A>) {
    let x: Int = src.a;
    let y: Bool = src.b;
    let z: Int = src.c;
  }
}

## contract-getter-with-method-id-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/contract-getter-with-method-id-1.tact)
primitive Int;
trait BaseTrait { }

contract Test {
    get(crc32("crc32") + "42") fun test(): Int {
        return 0
    }
}


## contract-getter-with-method-id-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/contract-getter-with-method-id-2.tact)
primitive Int;
trait BaseTrait { }

contract Test {
    get(true) fun test(): Int {
        return 0
    }
}


## contract-initof-wrong-arg.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/contract-initof-wrong-arg.tact)
primitive Int;
primitive Cell;

trait BaseTrait {
    
}

struct StateInit {
    code: Cell;
    data: Cell;
}

contract A {
    owner: Int;
    init(owner: Int) {
        self.owner = owner;
    }
}

contract B {
    init() {

    }

    get fun newInit(): StateInit {
        return initOf A("hello");
    }
}

## expr-bitwise-not-bool.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-bitwise-not-bool.tact)
primitive Int;
primitive Bool;

fun test(a: Bool): Int {
    return ~a;
}

## expr-conditional-branch-mismatch-nested1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-conditional-branch-mismatch-nested1.tact)
primitive Int;
primitive Bool;

fun sample(): Int {
    return (true ? 1 : false) ? 2 : 3;
}


## expr-conditional-branch-mismatch-nested2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-conditional-branch-mismatch-nested2.tact)
primitive Int;
primitive Bool;

fun sample(): Int {
    return true ? 1 : (false ? true : 2);
}


## expr-conditional-branch-mismatch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-conditional-branch-mismatch.tact)
primitive Int;
primitive Bool;

fun sample(): Int {
    return (true ? true : false) ? true : 3;
}


## expr-conditional-non-optional-result-expected1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-conditional-non-optional-result-expected1.tact)
primitive Int;
primitive Bool;

fun foo(x: Int?): Int {
    let cond: Bool = true;
    return cond ? 42 : x;
}


## expr-conditional-non-optional-result-expected2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-conditional-non-optional-result-expected2.tact)
primitive Int;
primitive Bool;

fun foo(x: Int?): Int {
    let cond: Bool = true;
    return cond ? x : 42;
}


## expr-conditional-non-optional-result-expected3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-conditional-non-optional-result-expected3.tact)
primitive Int;
primitive Bool;

fun foo3(): Int {
    let cond: Bool = true;
    let baz: Int = cond ? 42 : null;
    return baz!!;
}


## expr-conditional-result-mismatch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-conditional-result-mismatch.tact)
primitive Int;
primitive Bool;

fun sample(): Int {
    return (true ? true : false) ? true : false;
}


## expr-conditional-void-branches copy.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-conditional-void-branches copy.tact)
primitive Int;

fun foo() { return }

fun bar(): Int {
    let voidVar = true ? foo() : foo();
    return 42;
}


## expr-eq-bounced.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-bounced.tact)
primitive Int;
primitive Bool;
struct S { f : Int }

fun foo(b: bounced<S>): Bool {
  return b == b;
}



## expr-eq-builder.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-builder.tact)
primitive Bool;
primitive Builder;
trait BaseTrait {}

contract Test {
    get fun foo(s: Builder): Bool {
        return s == s;
    }
}


## expr-eq-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-contract.tact)
primitive Bool;
primitive Int;
trait BaseTrait {}

contract Test {
    x: Int = 42;
    y: Int = 0;

    get fun foo(): Bool {
        return self == self;
    }
}


## expr-eq-int-bool.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-int-bool.tact)
primitive Int;
primitive Bool;

fun foo(x: Int): Bool {
    return x == true;
}


## expr-eq-map-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-map-map.tact)
primitive Int;
primitive Address;
primitive Bool;

fun foo(m1: map<Int, Address>, m2: map<Address, Int>): Bool {
    return m1 == m2;
}


## expr-eq-null-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-null-1.tact)
primitive Int;

struct S {
    a: Int;
    b: Int;
}

trait BaseTrait {}

contract TestContract {
    s: S;

    init() {
        self.s = S {a: 0, b: 0};
    }

    get fun test(): Int {
        if (self.s != null) {
            return self.s.a;
        } else {
            return 0;
        }
    }
}

## expr-eq-null-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-null-2.tact)
primitive Int;

struct S {
    a: Int;
    b: Int;
}

trait BaseTrait {}

contract TestContract {
    s: S;

    init() {
        self.s = S {a: 0, b: 0};
    }

    get fun test(): Int {
        if (null != self.s) {
            return self.s.a;
        } else {
            return 0;
        }
    }
}

## expr-eq-null-3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-null-3.tact)
primitive Int;

fun foo() {
    let x: Int = 42;
    if (null == x) { return }
}


## expr-eq-null-bounced.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-null-bounced.tact)
primitive Int;
primitive Bool;

struct S { f : Int }

fun foo(b: bounced<S>): Bool {
  return b == null;
}



## expr-eq-optional-builder.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-optional-builder.tact)
primitive Bool;
primitive Builder;
trait BaseTrait {}

contract Test {
    get fun foo(s: Builder?): Bool {
        return s == s;
    }
}


## expr-eq-optional-stringbuilder.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-optional-stringbuilder.tact)
primitive Bool;
primitive StringBuilder;
trait BaseTrait {}

contract Test {
    get fun foo(s: StringBuilder?): Bool {
        return s == s;
    }
}


## expr-eq-optional-struct-null.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-optional-struct-null.tact)
primitive Int;
primitive Bool;
struct S { f: Int }

fun foo(s: S?): Bool {
    if (s != null) {
        return s!! == null
    }
    return false;
}



## expr-eq-optional-struct.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-optional-struct.tact)
primitive Bool;
primitive Int;
trait BaseTrait {}

struct S { x: Int; y: Int }

contract Test {
    get fun foo(): Bool {
        let s: S? = S {x: 42, y: 0};
        return s == s;
    }
}


## expr-eq-stringbuilder.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-stringbuilder.tact)
primitive Bool;
primitive StringBuilder;
trait BaseTrait {}

contract Test {
    get fun foo(s: StringBuilder): Bool {
        return s == s;
    }
}


## expr-eq-struct.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-struct.tact)
primitive Bool;
primitive Int;
trait BaseTrait {}

struct S { x: Int; y: Int }

contract Test {
    get fun foo(): Bool {
        let s: S = S {x: 42, y: 0};
        return s == s;
    }
}


## expr-eq-void-null.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-void-null.tact)
primitive Bool;

fun foo() { return }

fun baz(): Bool {
    return foo() == null
}


## expr-eq-void1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-void1.tact)
primitive Bool;

fun foo() { return }
fun bar() { return }

fun baz(): Bool {
    return foo() == bar()
}


## expr-eq-void2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-eq-void2.tact)
primitive Bool;

fun foo() { return }
fun bar() { return }

fun baz(): Bool {
    return foo() != bar()
}


## expr-field-does-not-exist-but-method-does.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-field-does-not-exist-but-method-does.tact)
primitive Slice;
primitive String;
primitive Int;

trait BaseTrait {

}

@name(__tact_str_to_slice)
extends native asSlice(self: String): Slice;

@name(slice_bits)
extends native bits(self: Slice): Int;

fun function() {
    let s: Slice = "123".asSlice();
    s.bits;
}

## expr-field-does-not-exist.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-field-does-not-exist.tact)
primitive Slice;
primitive String;
primitive Int;

trait BaseTrait {

}

@name(__tact_str_to_slice)
extends native asSlice(self: String): Slice;

fun function() {
    let s: Slice = "123".asSlice();
    s.bits;
}

## expr-internal-fun-call-bool-param.tact.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-internal-fun-call-bool-param.tact.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Main {

    v: Int = 0;
    init() {
        
    }

    fun f1(a: Int, b: Int): Int {
        return a + b;
    }

    fun f2(a: Int): Int {
        return self.f1(a, true);
    }
}

## expr-map-del-method-is-non-void.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-map-del-method-is-non-void.tact)
primitive Int;

fun testFunction1() {
    let m: map<Int, Int> = emptyMap();
    m.set(1, 2);
    return m.del(1);
}

## expr-map-exists-method-not-bool.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-map-exists-method-not-bool.tact)
primitive Int;
primitive Bool;

fun testFunction1(): Int {
    let m: map<Int, Int> = emptyMap();
    m.set(1, 2);
    return m.exists(1);
}

fun testFunction2(): Int {
    let m: map<Int, Int as uint8> = emptyMap();
    m.set(1, 2);
    return m.exists(2);
}

## expr-map-exists-method-on-not-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-map-exists-method-on-not-map.tact)
primitive Bool;
primitive Int;

fun test(): Bool {
    return 42.exists(1);
}

## expr-method-does-not-exist-but-field-does.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-method-does-not-exist-but-field-does.tact)
primitive Int;

trait BaseTrait {

}

struct S {
    x: Int;
}

fun function() {
    let s: S = S{ x: 1 };
    s.x();
}

## expr-module-fun-call-bool-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-module-fun-call-bool-param.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun f1(a: Int, b: Int): Int {
    return a + b;
}

fun f2(a: Int): Int {
    return f1(a, true);
}

## expr-struct-duplicate-field.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-struct-duplicate-field.tact)
primitive Int;
primitive Bool;
primitive Cell;

trait BaseTrait {
    
}

struct SomeStruct {
    a: Int;
    b: Int;
}

fun main() {
    let a: SomeStruct = SomeStruct{
        a: 1,
        a: 2,
        b: 3
    };
}


## expr-struct-impossible-field-punning.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-struct-impossible-field-punning.tact)
primitive Int;
trait BaseTrait {
}

struct A {
    x: Int;
    y: Int;
}

const a: Int = 5;
const b: Int = 6;

fun function() {
    let D: A = A { x: a, b };
}

## expr-struct-missing-field.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-struct-missing-field.tact)
primitive Int;
primitive Bool;
primitive Cell;

trait BaseTrait {
    
}

struct SomeStruct {
    a: Int;
    b: Int;
    c: Int;
}

fun main() {
    let a: SomeStruct = SomeStruct{
        a: 1,
        b: 3
    };
}


## expr-struct-wrong-field-type.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-struct-wrong-field-type.tact)
primitive Int;
primitive Bool;
primitive Cell;

trait BaseTrait {
    
}

struct SomeStruct {
    a: Int;
    b: Int;
}

fun main() {
    let a: SomeStruct = SomeStruct{
        a: 1,
        b: false // Invalid type
    };
}


## expr-var-int-bool.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-var-int-bool.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int): Bool {
    return x;
}

## expr-wrong-arity-internal-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-wrong-arity-internal-fun.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Main {

    v: Int = 0;

    init() {

    }
    fun f1(a: Int, b: Int): Int {
        return a + b;
    }

    fun f2(a: Int): Int {
        return self.f1(a);
    }
}

## expr-wrong-arity-module-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/expr-wrong-arity-module-fun.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun f1(a: Int, b: Int): Int {
    return a + b;
}

fun f2(a: Int): Int {
    return f1(a);
}

## getter-collision-trait.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision-trait.tact)
trait BaseTrait { }

trait T {
    get fun getter1() {
        return;
    }

    get fun pko() {
        return;
    }
}


## getter-collision-with-reserved1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision-with-reserved1.tact)
primitive String;

trait BaseTrait { }

contract TestContract {
    get fun getter1() {
        return;
    }

    get fun lazy_deployment_completed(): String{
        return "not ok";
    }
}


## getter-collision-with-reserved2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision-with-reserved2.tact)
primitive Int;

trait BaseTrait { }

contract TestContract {
    get fun getter1() {
        return;
    }

    get fun get_abi_ipfs(): Int{
        return 123;
    }
}


## getter-collision-with-reserved3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision-with-reserved3.tact)
primitive String;

trait BaseTrait { }

contract TestContract {
    get fun getter1() {
        return;
    }

    get fun supported_interfaces(): String{
        return "ok";
    }
}


## getter-collision-with-reserved_opt1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision-with-reserved_opt1.tact)
primitive String;

trait BaseTrait { }

contract TestContract {
    get fun getter1() {
        return;
    }

    get(115390) fun _lazy_deployment_completed(): String{
        return "not ok";
    }
}


## getter-collision-with-reserved_opt2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision-with-reserved_opt2.tact)
primitive Int;

trait BaseTrait { }

contract TestContract {
    get fun getter1() {
        return;
    }

    get(121275) fun _get_abi_ipfs(): Int{
        return 123;
    }
}


## getter-collision-with-reserved_opt3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision-with-reserved_opt3.tact)
primitive String;

trait BaseTrait { }

contract TestContract {
    get fun getter1() {
        return;
    }

    get(113617) fun _supported_interfaces(): String{
        return "ok";
    }
}


## getter-collision-with-trait.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision-with-trait.tact)
trait BaseTrait { }

trait T {
    get fun pko() {
        return;
    }
}

contract TestContract with T {
    get fun getter1() {
        return;
    }
}


## getter-collision.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/getter-collision.tact)
trait BaseTrait { }

contract TestContract {
    get fun getter1() {
        return;
    }

    get fun pko() {
        return;
    }
}


## init-vars-analysis-if.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-if.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Contract {
    value: Int;
    init(arg: Bool) {
        if (arg) {
            self.value = 1;
        }
    }
}

## init-vars-analysis-implicit-init.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-implicit-init.tact)
primitive Int;
trait BaseTrait {}

contract MyContract {
    counter: Int = 0;
    test_field: Int;

    receive("increment") {
        self.counter += 1;
    }

    get fun getCounter(): Int {
        return self.counter;
    }

    get fun getTestField(): Int {
        return self.test_field;
    }
}

## init-vars-analysis-missing-storage-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-missing-storage-var.tact)
primitive Int;
primitive Cell;

trait BaseTrait {
    
}

contract Contract {
    value: Int;
    init() {

    }
}

## init-vars-analysis-used-uninit-storage-augmented-assign1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-used-uninit-storage-augmented-assign1.tact)
primitive Int;

trait BaseTrait { }

contract Contract {
    value: Int;
    init() {
        self.value = self.value + 1;
    }
}

## init-vars-analysis-used-uninit-storage-augmented-assign2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-used-uninit-storage-augmented-assign2.tact)
primitive Int;

trait BaseTrait { }

contract Contract {
    value: Int;
    init() {
        self.value += 1;
    }
}

## init-vars-analysis-used-uninit-storage-override-fun-call.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-used-uninit-storage-override-fun-call.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

trait AbstractTrait {
    abstract fun execute(): Int;
}

contract Contract {
    value: Int;
    init(arg: Bool) {
        self.execute();
        self.value = 1;
    }

    override fun execute(): Int {
        self.value = self.value + 1;
        return self.value;
    }
}

## init-vars-analysis-used-uninit-storage-struct1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-used-uninit-storage-struct1.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

struct A {
    a: Int;
    b: Int;
}

contract Contract {
    value: Int;
    value2: A;
    init(arg: Bool) {
        self.value = self.value2.a + 1;
        self.value2 = A{ a: 1, b: 2 };
    }
}

## init-vars-analysis-used-uninit-storage-struct2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-used-uninit-storage-struct2.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

struct A {
    a: Int;
    b: Int;
}

contract Contract {
    value: Int;
    value2: A;
    init(arg: Bool) {
        self.value2 = A{ a: 1, b: self.value };
        self.value = self.value2.a + 1;
    }
}

## init-vars-analysis-used-uninit-storage-var-fun-call.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-used-uninit-storage-var-fun-call.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

struct A {
    a: Int;
    b: Int;
}

contract Contract {
    value: Int;
    init(arg: Bool) {
        self.update();
        self.value = 1;
    }

    fun update() {
        self.value = self.value + 1;
    }
}

## init-vars-analysis-used-uninit-storage-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-used-uninit-storage-var.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Contract {
    value: Int;
    value2: Int;
    init(arg: Bool) {
        self.value = self.value2 + 1;
        self.value2 = 10;
    }
}

## init-vars-analysis-with-if-else.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-with-if-else.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Contract {
    value: Int;
    init(arg: Bool) {
        if (arg) {
            // Nothing
        } else {
            self.value = 1;
        }
    }
}

## init-vars-analysis-with-if-elseif.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/init-vars-analysis-with-if-elseif.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Contract {
    value: Int;
    init(arg: Bool) {
        if (arg) {
            self.value = 1;
        } else if (!arg) {
            self.value = 1;
        }
    }
}

## return-analysis-catch-if.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-catch-if.tact)
primitive Int;
primitive Bool;

fun notAlwaysReachableReturn(b: Bool): Int {
    try {
        return 42;
    } catch(e) {
        if (b) {return 43;}
    }
}


## return-analysis-do-if.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-do-if.tact)
primitive Int;
primitive Bool;

fun notAlwaysReachableReturn(b: Bool): Int {
    do {
        if (b) {return 42;}
    } until (!b);
}


## return-analysis-if.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-if.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

contract Foo {
    get fun notAlwaysReachableReturn(b: Bool): Int {
        if b {
            return 42;
        }
        // ERROR: no return statement
    }
}


## return-analysis-non-void1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-non-void1.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

contract Foo {
    get fun noReturn(): Int {
        // ERROR: no return statement
    }
}


## return-analysis-non-void2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-non-void2.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

contract Foo {
    get fun noReturn(): Int {
        let x: Int = 42;
        x += 1;
        // ERROR: no return statement
    }
}


## return-analysis-repeat.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-repeat.tact)
primitive Int;
primitive Bool;

fun notAlwaysReachableReturn(n: Int): Int {
    repeat (n) {
        return 42;
    }
}


## return-analysis-separate-ifs.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-separate-ifs.tact)
primitive Int;
primitive Bool;

fun notAlwaysReachableReturn(b: Bool): Int {
    if (b) {
        return 42;
    }
    if (!b) {
        return 43;
    }
    // This is actually a fine program,
    // but our return-reachability analysis is too imprecise
    // to understand it
    // ERROR: no return statement
}


## return-analysis-throw-wrapped.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-throw-wrapped.tact)
primitive Int;
primitive Bool;

@name(throw)
native throw(code: Int);

// This demonstrates that we don't do inter-procedural analysis
// to determine a function always throws,
// but we might do it in the future, then this negative
// test will be moved to the set of positive tests.
fun throwWrapped(code: Int) {
    throw(code);
}

fun notAlwaysReachableReturn(b: Bool): Int {
    throwWrapped(42);
}


## return-analysis-try1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-try1.tact)
primitive Int;
primitive Bool;

fun notAlwaysReachableReturn(b: Bool): Int {
    try {
        return 42;
    }
}


## return-analysis-try2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-try2.tact)
primitive Int;
primitive Bool;

@name(throw)
native throw(code: Int);

fun notAlwaysReachableReturn(b: Bool): Int {
    try {
        throw(42);
    }
}


## return-analysis-while.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/return-analysis-while.tact)
primitive Int;
primitive Bool;

fun notAlwaysReachableReturn(b: Bool): Int {
    while (b) {
        try {
            return 42;
        } catch(e) {
            return 43;
        }
    }
}


## stmt-assgn-int-string.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-assgn-int-string.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int): Bool {
    x = "hello world";
    return true;
}

## stmt-augmented-assgn-bool-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-augmented-assgn-bool-int.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun test(x: Bool): Bool {
    x += 1;
    return x;
}

## stmt-augmented-assgn-bool.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-augmented-assgn-bool.tact)
primitive Bool;

fun test(): Bool {
    let a: Bool = false;
    a %= true;
    return a;
}

## stmt-augmented-assgn-int-bool.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-augmented-assgn-int-bool.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun test(x: Int): Int {
    x &&= true;
    return x;
}

## stmt-augmented-assgn-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-augmented-assgn-int.tact)
primitive Int;

fun test(): Int {
    let a: Int = 1;
    a &&= 1;
    return a;
}

## stmt-augmented-assgn-not-matching.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-augmented-assgn-not-matching.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun test(): Int {
    let x: Int = 42;
    x += true;
    return x;
}

## stmt-augmented-assgn-string.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-augmented-assgn-string.tact)
primitive String;

fun test(): String {
    let a: String = "foo";
    a %= "bar";
    return a;
}

## stmt-conditional-expr-stmt-void1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-conditional-expr-stmt-void1.tact)
fun foo() { return }
fun bar() { return }

fun baz() {
    true ? foo() : bar();
}

## stmt-destructuring-fields-duplicate-id.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-duplicate-id.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a: x, b: x, c: y } = s;
    return x + y;
}

## stmt-destructuring-fields-non-destructable-opt.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-non-destructable-opt.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s: S? = S{ a: 1, b: 2, c: 3 };
    let S { a, b, c } = s;
    return a + b + c;
}

## stmt-destructuring-fields-non-destructable.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-non-destructable.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let m: map<Int, Int> = emptyMap();
    let S { a, b, c } = m;
    return a + b + c;
}

## stmt-destructuring-fields-non-destructable2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-non-destructable2.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

contract Test {
    fun testFunc(): Int {
        let s = S{ a: 1, b: 2, c: 3 };
        let S { a, b, c } = self;
        return a + b + c;
    }
}

## stmt-destructuring-fields-non-existing-punned.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-non-existing-punned.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a, bb, c } = s;
    return a + bb + c;
}

## stmt-destructuring-fields-non-existing-punned2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-non-existing-punned2.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a, b, d } = s;
    return a + b + d;
}

## stmt-destructuring-fields-non-existing-underscore.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-non-existing-underscore.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S {_, b, c} =  s;
    return b + c;
}

## stmt-destructuring-fields-non-existing.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-non-existing.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a, b, d: e } = s;
    return a + b + e;
}

## stmt-destructuring-fields-shadowed-const-id.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-shadowed-const-id.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

const x: Int = 5;

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a: x, b: b, c: c } = s;
    return x + b + c;
}

## stmt-destructuring-fields-shadowed-id.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-shadowed-id.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let x = 0;
    let S { a: x, b: b, c: c } = s;
    return x + b + c;
}

## stmt-destructuring-fields-wrong-count.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-wrong-count.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a, b } = s;
    return a + b;
}

## stmt-destructuring-fields-wrong-count2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-wrong-count2.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a, b, c, d } = s;
    return a + b + c + d;
}

## stmt-destructuring-fields-wrong-type.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-destructuring-fields-wrong-type.tact)
primitive Int;

trait BaseTrait {
    
}

struct S1 {
    x: Int;
    y: Int;
}

struct S2 {
    x: Int;
    y: Int;
}

fun testFunc(): Int {
    let S1 {x, y} = S2 {x: 42, y: 43};
    return x + y;
}

## stmt-do-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-do-int.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int): Bool {
    do {
        x = x + 1;
    } until(x);
    return true;
}

## stmt-foreach-non-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-foreach-non-map.tact)
primitive Int;

trait BaseTrait {
    
}

fun foo(x: Int) {
    foreach (k, v in x) {
        throw(1042);
    }
    return;
}

## stmt-foreach-non-path-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-foreach-non-path-map.tact)
primitive Int;

trait BaseTrait {
    
}

fun mapFun(): map<Int, Int> {
    return emptyMap();
}

fun foo(x: Int) {
    foreach (k, v in mapFun()) {
        throw(1042);
    }
    return;
}

## stmt-if-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-if-int.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int): Bool {
    if (x) {
        x = x + 1;
    }
    return true;
}

## stmt-let-unknown-type-inference.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-let-unknown-type-inference.tact)
primitive Int;

trait BaseTrait {
    
}

fun test() {
    let a = null;
}

## stmt-let-unknown-type-inference2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-let-unknown-type-inference2.tact)
primitive Int;

trait BaseTrait {
    
}

fun test() {
    let a = emptyMap();
}

## stmt-let-void-inference.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-let-void-inference.tact)
primitive Int;

trait BaseTrait {
    
}

fun foo() { return }

contract Foo {

    get fun foo(): Int {
        let voidVar = foo();
        return 42;
    }
}

## stmt-let-wrong-rhs.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-let-wrong-rhs.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun f1() {
    let a: Int = 0;
    let b: Bool = 0;
}

## stmt-repeat-bool.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-repeat-bool.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int): Bool {
    repeat(true) {
        x = x + 1;
    }
    return true;
}

## stmt-return-from-try-and-catch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-return-from-try-and-catch.tact)
primitive Int;
primitive String;

fun test(): String {
    try {
        return "qwe";
    } catch (e) {
        return e;
    }
    return "test";
}

## stmt-return-void1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-return-void1.tact)
fun foo() { return }

fun bar() {
    return foo()
}

## stmt-return-void2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-return-void2.tact)
primitive Int;

fun foo(): Int { return 42 }

fun bar() {
    return foo()
}

## stmt-return-void3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-return-void3.tact)
primitive Int;

fun bar(): Int { return }


## stmt-unboxing-expr-stmt-void.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-unboxing-expr-stmt-void.tact)
fun foo() { return }

fun bar() {
    foo()!!
}

## stmt-while-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/stmt-while-int.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int): Bool {
    while(x) {
        x = x + 1;
    }
    return true;
}

## usage-of-bounced-field-in-type-that-is-too-big-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/usage-of-bounced-field-in-type-that-is-too-big-2.tact)
primitive Int;
trait BaseTrait { }

message Withdraw {
    data128: Int as uint128; // 128
    data64: Int as uint64; // 192
    data16: Int as uint16; // 208
    data8: Int as uint8; // 216
    data4: Int as uint4; // 220
    data4_2: Int as uint4; // 224

    amount: Int as uint128;
}

contract Fund {
    balance: Int as uint256 = 0;

    bounced(msg: bounced<Withdraw>){
        self.balance += msg.data128; // ok
        self.balance += msg.data64; // ok
        self.balance += msg.data16; // ok
        self.balance += msg.data8; // ok
        self.balance += msg.data4; // ok
        self.balance += msg.data4_2; // ok

        self.balance += msg.amount;
    }
}


## usage-of-bounced-field-in-type-that-is-too-big.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/usage-of-bounced-field-in-type-that-is-too-big.tact)
primitive Int;
trait BaseTrait { }

message Withdraw {
    data: Int as uint128;
    amount: Int as uint128; // exceeds 224 bytes
}

contract Fund {
    balance: Int as uint256 = 0;

    bounced(msg: bounced<Withdraw>){
        self.balance += msg.data; // ok
        self.balance += msg.amount;
    }
}


## usage-of-bounced-field-that-is-too-big.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/usage-of-bounced-field-that-is-too-big.tact)
primitive Int;
trait BaseTrait { }

message Withdraw {
    amount: Int as uint256; // too big
}

contract Fund {
    balance: Int as uint256 = 0;

    bounced(msg: bounced<Withdraw>){
        self.balance += msg.amount;
    }
}


## var-does-not-exist.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-does-not-exist.tact)
trait BaseTrait { }

contract Test {
    receive() {
        nonExistentVariable = 42;
    }
}


## var-does-not-exist2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-does-not-exist2.tact)
primitive Int;

trait BaseTrait { }

contract Test {
    someField: Int;

    init() {
        self.someField = 42;
    }

    receive() {
        someField = 42;
    }
}


## var-does-not-exist3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-does-not-exist3.tact)
primitive Int;

trait BaseTrait { }

trait TestTrait {
    someField: Int;
}

contract Test with TestTrait {
    someField: Int;

    init() {
        self.someField = 42;
    }

    receive() {
        someField = 42;
    }
}


## var-does-not-exist4.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-does-not-exist4.tact)
primitive Int;

trait BaseTrait { }

trait TestTrait {
    someField: Int;

    receive() {
        someField = 42;
    }
}

## var-scope-catch-does-not-shadow-outer-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-catch-does-not-shadow-outer-const.tact)
primitive Int;
primitive String;

const e: String = "qwe";

fun test(): String {   
    try {
        return e;
    } catch (err) {
        let e: String = "rty";
        return e;
    }
}

## var-scope-catch-does-not-shadow-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-catch-does-not-shadow-outer-var.tact)
primitive Int;
primitive String;

fun test(): String {
    let e: String = "qwe";
    try {
        return e;
    } catch (err) {
        let e: String = "rty";
        return "err";
    }
}

## var-scope-catch-param-does-not-shadow-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-catch-param-does-not-shadow-outer-var.tact)
primitive Int;
primitive String;

fun test(): String {
    let e: String = "qwe";
    try {
        return e;
    } catch (e) {
        return e;
    }
    return "test";
}

## var-scope-catch-param-is-not-visible-in-try.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-catch-param-is-not-visible-in-try.tact)
primitive Int;

fun test() {
    try {
        return e;
    } catch (e) {

    }
}

## var-scope-const-shadowing-catch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-const-shadowing-catch.tact)
primitive Int;

const foo: Int = 42;

fun bar(): Int {
    try { }
    catch (foo) {   // <-- `foo` shadows global const `foo`
    }
    return foo;
}



## var-scope-const-shadowing-external-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-const-shadowing-external-param.tact)
primitive Int;
trait BaseTrait {}

message Message {}

const foo: Int = 42;

contract Test {
    external (foo: Message) { // <-- `foo` shadows global const `foo`
    }
}


## var-scope-const-shadowing-foreach.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-const-shadowing-foreach.tact)
primitive Int;

const foo: Int = 42;

fun bar() {
    let m: map<Int, Int> = null;
    foreach (foo, _ in m) {  // <--- attempt to shadow `foo` const
        // do nothing
    }
}

## var-scope-const-shadowing-fun-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-const-shadowing-fun-param.tact)
primitive Int;

const foo: Int = 42;

fun bar(foo: Int): Int {  // <-- fun param `foo` shadows global const `foo`
    return foo;
}


## var-scope-const-shadowing-let.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-const-shadowing-let.tact)
primitive Int;

const foo: Int = 42;

fun bar(): Int {
    let foo = 43;  // <-- local var `foo` shadows global const `foo`
    return foo;
}



## var-scope-const-shadowing-receiver-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-const-shadowing-receiver-param.tact)
primitive Int;
trait BaseTrait {}

message Message {}

const foo: Int = 42;

contract Test {
    receive (foo: Message) { // <-- `foo` shadows global const `foo`
    }
}


## var-scope-do-until-shadows-outer-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-do-until-shadows-outer-const.tact)
primitive Int;

const B: Int = 456;

fun testFunction(): Int {
    let a: Int = 123;
    do {
        let B: Int = a + 3;
    } until (false);
    return a;
}

## var-scope-do-until-shadows-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-do-until-shadows-outer-var.tact)
primitive Int;

fun testFunction(): Int {
    let a: Int = 123;
    let b: Int = 456;
    do {
        let b: Int = a + 3;
    } until (false);
    return a;
}

## var-scope-external-shadows-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-external-shadows-param.tact)
primitive Int;
trait BaseTrait {}

message Message {}

contract Test {
    external (foo: Message) {
        let foo: Int = 0;
    }
}


## var-scope-foreach-internal-var-does-not-escape.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-internal-var-does-not-escape.tact)
primitive Int;

fun test(): Int {
    let m: map<Int, Int> = emptyMap();
    foreach (k, v in m) {
        let x: Int = 123;
    }
    return x;
}


## var-scope-foreach-key-does-not-escape.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-key-does-not-escape.tact)
primitive Int;

fun test(): Int {
    let m: map<Int, Int> = emptyMap();
    foreach (k, v in m) {
        // something
    }
    return k;
}


## var-scope-foreach-key-shadows-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-key-shadows-map.tact)
primitive Int;

fun test() {
    let m: map<Int, Int> = emptyMap();
    foreach (m, v in m) {
        // something
    }
}


## var-scope-foreach-key-shadows-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-key-shadows-outer-var.tact)
primitive Int;

fun test() {
    let m: map<Int, Int> = emptyMap();
    let a: Int = 4;
    foreach (a, v in m) {
        // something
    }
}


## var-scope-foreach-shadows-outer-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-shadows-outer-const.tact)
primitive Int;

const m: map<Int, Int> = emptyMap();

fun test() {
    let a: Int = 4;
    foreach (k, v in m) {
        let m: map<Int, Int> = emptyMap();
    }
}


## var-scope-foreach-shadows-outer-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-shadows-outer-map.tact)
primitive Int;

fun test() {
    let m: map<Int, Int> = emptyMap();
    let a: Int = 4;
    foreach (k, v in m) {
        let m: map<Int, Int> = emptyMap();
    }
}


## var-scope-foreach-shadows-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-shadows-outer-var.tact)
primitive Int;

fun test() {
    let m: map<Int, Int> = emptyMap();
    let a: Int = 4;
    foreach (k, v in m) {
        let a: Int = 5;
    }
}


## var-scope-foreach-val-does-not-escape.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-val-does-not-escape.tact)
primitive Int;

fun test(): Int {
    let m: map<Int, Int> = emptyMap();
    foreach (k, v in m) {
        // something
    }
    return v;
}


## var-scope-foreach-val-shadows-const-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-val-shadows-const-map.tact)
primitive Int;

const m: map<Int, Int> = emptyMap();

fun test() {
    foreach (k, m in m) {
        // something
    }
}


## var-scope-foreach-val-shadows-key.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-val-shadows-key.tact)
primitive Int;

fun test() {
    let m: map<Int, Int> = emptyMap();
    foreach (k, k in m) {
        // something
    }
}


## var-scope-foreach-val-shadows-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-val-shadows-map.tact)
primitive Int;

fun test() {
    let m: map<Int, Int> = emptyMap();
    foreach (k, m in m) {
        // something
    }
}


## var-scope-foreach-val-shadows-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-foreach-val-shadows-outer-var.tact)
primitive Int;

fun test() {
    let m: map<Int, Int> = emptyMap();
    let a: Int = 4;
    foreach (k, a in m) {
        // something
    }
}


## var-scope-function-shadows-local-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-function-shadows-local-var.tact)
primitive Int;

fun testFunction(a: Int, b: Int): Int {
    let c: Int = 456;
    let c: Int = 10;
}

## var-scope-function-shadows-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-function-shadows-param.tact)
primitive Int;

fun testFunction(a: Int, b: Int): Int {
    let b: Int = 456;
    return b;
}

## var-scope-if-else-shadows-outer-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-if-else-shadows-outer-const.tact)
primitive Int;

const A: Int = 123;

fun testFunction(): Int {
    let b: Int = 456;
    if (true) {
        // do nothing
    } else {
        let A: Int = 2;
    }
    return b;
}

## var-scope-if-else-shadows-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-if-else-shadows-outer-var.tact)
primitive Int;

fun testFunction(): Int {
    let a: Int = 123;
    let b: Int = 456;
    if (true) {
        // do nothing
    } else {
        let a: Int = 2;
    }
    return b;
}

## var-scope-if-then-shadows-outer-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-if-then-shadows-outer-const.tact)
primitive Int;

const A: Int = 123;

fun testFunction(): Int {
    let b: Int = 456;
    if (true) {
        let A: Int = 2;
    } else {
        // do nothing
    }
    return b;
}


## var-scope-if-then-shadows-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-if-then-shadows-outer-var.tact)
primitive Int;

fun testFunction(): Int {
    let a: Int = 123;
    let b: Int = 456;
    if (true) {
        let a: Int = 2;
    } else {
        // do nothing
    }
    return b;
}

## var-scope-local-catch-param-does-not-escape.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-local-catch-param-does-not-escape.tact)
primitive Int;

fun test() {
    try {

    } catch (e) {

    }
    return e;
}

## var-scope-local-loop-var-does-not-escape.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-local-loop-var-does-not-escape.tact)
primitive Int;

fun testFunction(): Int {
    let a: Int = 123;
    let b: Int = 456;
    repeat (a) {
        let c: Int = a + b;
    }
    return c;
}

## var-scope-missing-storage-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-missing-storage-var.tact)
trait BaseTrait { }

contract Test {
    init() {
        self.nonExistentField = 42;
    }
}


## var-scope-no-toString-global-fun1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-no-toString-global-fun1.tact)
import "@stdlib/deploy";

trait BaseTrait { }

contract SampleTactContract {
    init() {
        toString(); // non-existent function
    }
}

## var-scope-no-toString-global-fun2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-no-toString-global-fun2.tact)
primitive Int;

struct WrappedInt { x: Int }

extends fun toString(self: WrappedInt): Int {
    return toString(self.x);
}



## var-scope-no-valueOf-global-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-no-valueOf-global-fun.tact)
primitive Int;

fun foo(x: Int) {
    valueOf(x);
}


## var-scope-rec-fun-shadowing-catch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-rec-fun-shadowing-catch.tact)
primitive Int;

fun rec(): Int {
    try {
        42/0;
    } catch (rec) {  // <-- shadowing
        return rec;
    }
    return rec();
}



## var-scope-rec-fun-shadowing-foreach.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-rec-fun-shadowing-foreach.tact)
primitive Int;

fun rec(): Int {
    let m: map<Int, Int> = null;
    foreach (rec, _ in m) {   // shadowing error
        42/0;
    }
    return rec();
}


## var-scope-rec-fun-shadowing-fun-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-rec-fun-shadowing-fun-param.tact)
primitive Int;

fun rec(rec: Int): Int { // <-- shadowing
    return rec;
}



## var-scope-rec-fun-shadowing-let.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-rec-fun-shadowing-let.tact)
primitive Int;

fun rec(): Int {
    let rec: Int = 42;  // shadowing error
    return rec;
}


## var-scope-receiver-shadows-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-receiver-shadows-param.tact)
primitive Int;
trait BaseTrait {}

message Message {}

contract Test {
    receive (foo: Message) {
        let foo: Int = 0;
    }
}


## var-scope-repeat-shadows-outer-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-repeat-shadows-outer-const.tact)
primitive Int;

const B: Int = 456;

fun testFunction(): Int {
    let a: Int = 123;
    repeat (a) {
        let B: Int = a + 3;
    }
    return a;
}

## var-scope-repeat-shadows-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-repeat-shadows-outer-var.tact)
primitive Int;

fun testFunction(): Int {
    let a: Int = 123;
    let b: Int = 456;
    repeat (a) {
        let b: Int = a + 3;
    }
    return a;
}

## var-scope-try-does-not-shadow-outer-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-try-does-not-shadow-outer-const.tact)
primitive Int;
primitive String;

const e: String = "qwe";

fun test(): String {
    try {
        let e: String = "rty";
        return e;
    } catch (err) {
        return "err";
    }
}

## var-scope-try-does-not-shadow-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-try-does-not-shadow-outer-var.tact)
primitive Int;
primitive String;

fun test(): String {
    let e: String = "qwe";
    try {
        let e: String = "rty";
        return e;
    } catch (err) {
        return "err";
    }
    return "test";
}

## var-scope-while-shadows-outer-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-while-shadows-outer-const.tact)
primitive Int;

const B: Int = 456;

fun testFunction(): Int {
    let a: Int = 123;
    while (true) {
        let B: Int = a + 3;
    }
    return a;
}

## var-scope-while-shadows-outer-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-scope-while-shadows-outer-var.tact)
primitive Int;

fun testFunction(): Int {
    let a: Int = 123;
    let b: Int = 456;
    while (true) {
        let b: Int = a + 3;
    }
    return a;
}

## var-underscore-name-access.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-underscore-name-access.tact)
primitive Int;

fun test(): Int {
    let m: map<Int, Int> = emptyMap();
    foreach (_, _ in m) {
        return _;
    }
    return 0;
}


## var-underscore-name-access2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-underscore-name-access2.tact)
primitive Int;

fun test(): Int {
    let m: map<Int, Int> = emptyMap();
    let x: Int = 0;
    foreach (_, v in m) {
        x += _;
    }
    return x;
}


## var-underscore-name-access3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/var-underscore-name-access3.tact)
primitive Int;

fun someImpureFunction(): Int {
    return 123;
}

fun test(): Int {
    let _: Int = someImpureFunction();
    return _;
}


## wf-type-let.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts-failed/wf-type-let.tact)
primitive String;
primitive Int;

fun foo() {
    let m: map<String, Int> = null;
}


## assign-self-mutating-method.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/assign-self-mutating-method.tact)
primitive Int;

struct IntWrapper { x: Int }

extends mutates fun foo(self: IntWrapper) {
    self.x = 42
}

extends mutates fun bar(self: Int) {
    self = 42
}


## contract-getter-with-method-id-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/contract-getter-with-method-id-1.tact)
primitive Int;
trait BaseTrait { }

contract Test {
    get((crc32("crc32") + 42) & 0x3FFFF | 0x4000) fun test(): Int {
        return 0
    }
}


## contract-getter-with-method-id-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/contract-getter-with-method-id-2.tact)
primitive Int;
trait BaseTrait { }

const MethodId: Int = 16384;

contract Test {
    get(MethodId) fun test(): Int {
        return MethodId
    }
}


## contract-getter-with-method-id-3.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/contract-getter-with-method-id-3.tact)
primitive Int;
trait BaseTrait { }

contract ManualMethodId {
    const methodId: Int = 16384 + 41;
    get(self.methodId + 1) fun methodId(): Int {
        return self.methodId;
    }
}


## contract-receiver-bounced.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/contract-receiver-bounced.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

message A {
  a: Int as uint32;
  b: Bool;
  c: Int as uint256;
}

contract Test {
  init() {}
  receive(src: A) {
    
  }
  
  bounced(src: bounced<A>) {
    let x: Int = src.a;
    let y: Bool = src.b;
  }
}

## expr-arith-bool-cmp.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-arith-bool-cmp.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int, y: Int, z: Bool): Bool {
    return (123 + 10) / 10 == x && y > 0 || z;
}

## expr-conditional-with-subtyping.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-conditional-with-subtyping.tact)
primitive Int;
primitive Bool;
primitive Cell;

fun foo1(x: Int?): Int? {
    let cond: Bool = true;
    return cond ? 42 : x;
}

fun foo2(x: Int?): Int? {
    let cond: Bool = true;
    return cond ? x : 42;
}

fun foo3(): Int? {
    let cond: Bool = true;
    return cond ? null : 42;
}

fun foo4(): Int? {
    let cond: Bool = true;
    return cond ? 42 : null;
}

fun foo5(): Int {
    let cond: Bool = true;
    let baz = cond ? 42 : null;
    return baz!!;
}

fun bar1(m: map<Int, Int>): map<Int, Int> {
    let cond: Bool = true;
    return cond ? null : m;
}

fun bar2(m: map<Int, Int>): map<Int, Int> {
    let cond: Bool = true;
    return cond ? m : null;
}

struct Bar {
    a: Cell?;
}

struct Baz { b: Int; }

fun baz(x: Cell?): Bar {
    let cond: Bool = true;
    return Bar {
        a: cond ? Baz { b: 42 }.toCell() : x
    };
}


## expr-eq-arith.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-eq-arith.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int): Bool {
    return 123 + 10 == x;
}

## expr-eq-int-optional-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-eq-int-optional-int.tact)
primitive Int;
primitive Bool;

fun foo(x: Int?, y: Int): Bool {
    return x == y || y == x || x == x;
}


## expr-eq-literal.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-eq-literal.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int): Bool {
    return x == 0;
}

## expr-eq-map-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-eq-map-map.tact)
primitive Int;
primitive Address;
primitive Bool;

fun foo(m1: map<Int, Address>, m2: map<Int, Address>): Bool {
    return m1 == m2;
}


## expr-eq-map-null.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-eq-map-null.tact)
primitive Int;
primitive Address;
primitive Bool;

fun foo(m: map<Int, Address>): Bool {
    return m == null;
}


## expr-eq-null-null.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-eq-null-null.tact)
fun foo() {
    if (null == null) { return }
}


## expr-eq-optional-int-null.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-eq-optional-int-null.tact)
primitive Int;
primitive Bool;

fun foo(x: Int?): Bool {
    return x == null || null == x;
}


## expr-eq-optional-struct-null.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-eq-optional-struct-null.tact)
primitive Int;
primitive Bool;
struct S { f: Int }

fun foo(s: S?): Bool {
    if (s != null) {
        return s!!.f == 42
    }
    return false;
}



## expr-field-access-method-call.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-field-access-method-call.tact)
primitive Int;
primitive Bool;
primitive Cell;

trait BaseTrait {
    
}

struct Point {
    x: Int;
    y: Int;
}

fun isZero(p: Point): Bool {
    return p.x == 0 && p.y == 0;
}

fun packPoint(p: Point): Cell {
    return p.toCell();
}

## expr-maps-del-method.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-maps-del-method.tact)
primitive Int;
primitive Bool;

fun testFunction1(): Bool {
    let m: map<Int, Int> = emptyMap();
    m.set(1, 2);
    return m.del(3);
}

fun testFunction2(): Bool {
    let m: map<Int, Int as uint8> = emptyMap();
    m.set(1, 2);
    return m.del(1);
}

## expr-maps-exists-method.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-maps-exists-method.tact)
primitive Int;
primitive Bool;

fun testFunction1(): Bool {
    let m: map<Int, Int> = emptyMap();
    m.set(1, 2);
    return m.exists(1);
}

fun testFunction2(): Bool {
    let m: map<Int, Int as uint8> = emptyMap();
    m.set(1, 2);
    return m.exists(2);
}

## expr-struct-construction.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/expr-struct-construction.tact)
primitive Int;
primitive Bool;
primitive Cell;

trait BaseTrait {
    
}

struct SomeStruct {
    a: Int;
    b: Int;
}

fun main() {
    let a: SomeStruct = SomeStruct{
        a: 1,
        b: 2
    };
}


## fun-extends-optional.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/fun-extends-optional.tact)
primitive Int;

fun test(x: Int, y: Int?): Int {
    if (y == null) {
        return x;
    }
    return x + y!!;
}

extends fun test_extends(self: Int, y: Int?): Int {
    if (y == null) {
        return self;
    }
    return self + y!!;
}

extends fun test_extends_self(self: Int?, y: Int): Int {
    if (self == null) {
        return y;
    }
    return self!! + y;
}

extends mutates fun test_mutates(self: Int, y: Int?): Int {
    if (y == null) {
        return self;
    }
    self += y!!;
    return self;
}

extends mutates fun test_mutates_self(self: Int?, y: Int): Int {
    if (self == null) {
        return y;
    }
    self = self!! + y;
    return self!!;
}

extends mutates fun test_mutates_self_opt(self: Int?, y: Int): Int? {
    if (self == null) {
        return null;
    }
    self = self!! + y;
    return self;
}

## init-vars-analysis-with-if.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/init-vars-analysis-with-if.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Contract {
    value: Int;
    init(arg: Bool) {
        if (arg) {
            self.value = 1;
        } else if (!arg) {
            self.value = 2;
        } else {
            self.value = 3;
        }
    }
}

struct S {
    a: Int;
    b: Int;
}

contract Contract2 {
    value: Int;
    value2: S;
    init(arg: Bool) {
        self.value = 1;
        self.value2 = S{ a: 1, b: self.value };
    }
}

contract Contract3 {
    value: Int;
    init(arg: Bool) {
        self.value = 1;
        self.update();
    }

    fun update() {
        self.value = self.value + 1;
    }
}

## return-analysis-if-elseif.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/return-analysis-if-elseif.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

contract Foo {
    get fun returnInAllBranches(b: Bool, c: Bool, d: Bool): Int {
        if b {
            return 42;
        } else if c {
            return 43;
        } else if d {
            return 44;
        } else {
            return 45;
        }
    }
}


## return-analysis-if-try-catch-do-loop.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/return-analysis-if-try-catch-do-loop.tact)
primitive Int;
primitive Bool;

fun notAlwaysReachableReturn(b: Bool): Int {
    if b {
        try {
            let x: Int = 1 / (b ? 0 : 1);
            return 42;
        } catch(e) {
            return 43;
        }
    } else {
        do {
            return 44;
        } until (!b);
    }
}


## return-analysis-no-return-in-void1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/return-analysis-no-return-in-void1.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

contract Foo {
    get fun noReturn() {
        // it's since the function does not return anything
    }
}


## return-analysis-no-return-in-void2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/return-analysis-no-return-in-void2.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

contract Foo {
    get fun noReturn() {
        let x: Int = 42;
        x += 1;
        // it's since the function does not return anything
    }
}


## return-analysis-throw1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/return-analysis-throw1.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

@name(throw)
native throw(code: Int);

contract Foo {
    get fun test(c: Bool): Int {
        if (c) {
            throw(200);
        } else {
            return 42;
        }
    }
}


## return-analysis-throw2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/return-analysis-throw2.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

@name(throw)
native nativeThrow(code: Int);

contract Foo {
    get fun test(c: Bool): Int {
        if (c) {
            nativeThrow(200);
        } else {
            return 42;
        }
    }
}


## return-analysis-try-catch.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/return-analysis-try-catch.tact)
primitive Int;
primitive Bool;

fun alwaysReachableReturn(b: Bool): Int {
    let x: Int = 0;
    try {
        let y: Int = 1;
        return 42;
    } catch (e) {
        let z: Int = 1;
        return 43;
    }
}


## stmt-augmented-assgn-bool.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/stmt-augmented-assgn-bool.tact)
primitive Bool;

fun test(): Bool {
    let a: Bool = false;
    a &&= true;
    a ||= false;
    return a;
}

## stmt-augmented-assgn-numerical-type.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/stmt-augmented-assgn-numerical-type.tact)
primitive Int;

fun test(): Int {
    let a: Int = 3;
    a %= 2;
    return a;
}

## stmt-destructuring.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/stmt-destructuring.tact)
primitive Int;

trait BaseTrait {
    
}

struct S {
    a: Int;
    b: Int;
    c: Int;
}

message M {
    a: Int;
    b: Int;
}

fun testFunc(): Int {
    let s = S{ a: 1, b: 2, c: 3 };
    let S { a, b, c } = s;
    let S { a: a1, .. } = s;
    let S { b: b1, .. } = s;
    let S { c: c1, .. } = s;
    let S { a: a2, b: b2, .. } = s;
    let S { a: a3, c: c3, .. } = s;
    let S { b: b4, c: c4, .. } = s;

    let m = M{ a: 1, b: 2 };
    let M { a: a_m, b: b_m } = m;

    return a + b + c + a1 + b1 + c1 + a2 + b2 + a3 + c3 + b4 + c4 + a_m + b_m;
}

## stmt-let-assgn-unbox.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/stmt-let-assgn-unbox.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int, y: Int, z: Bool, w: Int?): Bool {
    let b: Int = x + y;
    b = b + 1;
    return b > 0 || z || (w!! > 0);
}

## stmt-let-assgn.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/stmt-let-assgn.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun isZero(x: Int, y: Int, z: Bool): Bool {
    let b: Int = x + y;
    b = b + 1;
    return b > 0 || z;
}

## stmt-let-if-elseif.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/stmt-let-if-elseif.tact)
primitive Int;
primitive Bool;
primitive Cell;

trait BaseTrait {
    
}

fun main() {
    let a: Int = 10;
    if (a > 0) {
        a = 10;
    } else if (a < -10) {
        a = -1;
    } else {
        a = 1;
    }
}


## stmt-let-map-type-inference.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/stmt-let-map-type-inference.tact)
primitive Int;

trait BaseTrait {
    
}

fun test() {
    let a: map<Int, Int as uint32> = emptyMap();
    let b = a;
}

## stmt-let-nullable-type-inference.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/stmt-let-nullable-type-inference.tact)
primitive Int;

trait BaseTrait {
    
}

fun test() {
    let a: Int? = null;
    let b = a;
}

## var-scope-let-toString.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/var-scope-let-toString.tact)
primitive Int;

fun testFunction() {
    let toString: Int = 1;
    dump(toString);
}

## var-scope-repeat.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/var-scope-repeat.tact)
primitive Int;

fun testFunction(): Int {
    let a: Int = 123;
    let b: Int = 456;
    repeat (a) {
        let c: Int = a + b;
    }
    return a + b;
}

## var-scope-repeat2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/var-scope-repeat2.tact)
primitive Int;

fun testFunction(): Int {
    let a: Int = 123;
    let b: Int = 456;
    repeat (a) {
        b = a + b;
    }
    return b;
}

## var-scope-toString-non-method.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/var-scope-toString-non-method.tact)
import "@stdlib/deploy";
primitive Int;

trait BaseTrait { }

fun toString(): Int {
    return 123;
}

contract SampleTactContract {
    init() {
        toString();
    }
}

## var-scope-valueOf-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/var-scope-valueOf-fun.tact)
import "@stdlib/deploy";

primitive Int;

trait BaseTrait { }

fun valueOf(a: Int, b: Int): Int {
    return (a + b) / 2;
}

contract SampleTactContract {
    init() {
    }
    get fun result(): Int {
        return valueOf(1, 10);
    }
}

## var-underscore-name-in-foreach.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/var-underscore-name-in-foreach.tact)
primitive Int;

fun test() {
    let m: map<Int, Int> = emptyMap();
    foreach (_, _ in m) {
        // something
    }
}


## var-underscore-name-in-foreach2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/var-underscore-name-in-foreach2.tact)
primitive Int;

fun test(): Int {
    let m: map<Int, Int> = emptyMap();
    let x: Int = 0;
    foreach (_, v in m) {
        x += v;
    }
    return x;
}


## var-underscore-name-in-let.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/stmts/var-underscore-name-in-let.tact)
primitive Int;

fun someImpureFunction(): Int {
    return 123;
}

fun test(): Int {
    let _: Int = someImpureFunction();
    let _ = someImpureFunction();
    return 123;
}


## asm-fun-shuffle-arg-duplicate.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/asm-fun-shuffle-arg-duplicate.tact)
primitive Int;

asm(x x) fun foo(x: Int) {
    DROP
}


## asm-fun-shuffle-arg-missing-and-non-existent-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/asm-fun-shuffle-arg-missing-and-non-existent-param.tact)
primitive Int;

asm(x extra) fun foo(x: Int, y: Int) {
    DROP
    DROP
}


## asm-fun-shuffle-arg-missing-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/asm-fun-shuffle-arg-missing-param.tact)
primitive Int;

asm(x) fun foo(x: Int, y: Int) {
    DROP
    DROP
}


## asm-fun-shuffle-arg-non-existent-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/asm-fun-shuffle-arg-non-existent-param.tact)
primitive Int;

asm(x extra) fun foo(x: Int) {
    DROP
    DROP
}


## asm-fun-shuffle-ret-duplicate.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/asm-fun-shuffle-ret-duplicate.tact)
primitive Int;

asm(-> 0 0) fun foo(x: Int): Int {
    INC
}


## asm-fun-shuffle-ret-missing-position.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/asm-fun-shuffle-ret-missing-position.tact)
primitive Int;
struct Pair { fst: Int; snd: Int }

asm(-> 0) fun foo(x: Int, y: Int): Pair {
    SWAP
}


## asm-fun-shuffle-ret-non-existent-position.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/asm-fun-shuffle-ret-non-existent-position.tact)
primitive Int;
struct Pair { fst: Int; snd: Int }

asm(-> 2 1 0) fun foo(x: Int, y: Int): Pair {
    SWAP
}


## const-decl-default-field-wrong-initializer-type copy.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/const-decl-default-field-wrong-initializer-type copy.tact)
primitive Bool;
trait BaseTrait { }

const C: Bool = 42;


## const-eval-overflow.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/const-eval-overflow.tact)
primitive Int;
primitive Bool;

trait BaseTrait {

}

const a: Int = 1 + (1 >> -1073741824);


## contract-bounced-receiver-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-bounced-receiver-int.tact)
primitive Int;

trait BaseTrait {

}

message A {
  a: Int as uint32;
}

contract Test {
  init() {}
  receive(src: A) {
    
  }
  
  bounced(src: Int) {
    
  }
}

## contract-bounced-receiver-missing-type-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-bounced-receiver-missing-type-1.tact)
contract Test {
  bounced(a: A) {}
}


## contract-bounced-receiver-missing-type-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-bounced-receiver-missing-type-2.tact)
contract Test {
  bounced(a: bounced<A>) {}
}


## contract-bounced-storage-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-bounced-storage-var.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

message A {
  a: Int as uint32;
  b: Bool;
  c: Int as uint256;
}

contract Test {
  src: bounced<A>;
  init() {}
  receive(src: A) {
    
  }
  
  // bounced(src: bounced<A>) {
  //   let x: Int = src.a;
  //   let y: Bool = src.b;
  //   let z: Int = src.c;
  // }
}

## contract-const-decl-default-field-wrong-initializer-type.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-const-decl-default-field-wrong-initializer-type.tact)
primitive Bool;
trait BaseTrait { }

contract Test {
    const C: Bool = 42;
}


## contract-const-override-virtual-no-keyword.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-const-override-virtual-no-keyword.tact)
primitive Int;
trait BaseTrait { }

trait T {
  virtual const Foo: Int = 42;
}

contract TestContract with T {
  const Foo: Int = 42;
}


## contract-does-not-override-abstract-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-does-not-override-abstract-const.tact)
primitive Int;
trait BaseTrait { }

trait T {
  abstract const Foo: Int;
}

contract TestContract with T {
  // does not override an abstract const
}


## contract-does-not-override-abstract-getter.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-does-not-override-abstract-getter.tact)
primitive Int;
trait BaseTrait { }

trait T {
  abstract get fun getter(): Int;
}

contract TestContract with T {
  // does not override an abstract getter
}


## contract-duplicate-bounced-fallback.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicate-bounced-fallback.tact)
primitive Int;
primitive Bool;
primitive Slice;

trait BaseTrait {

}

message A {
  a: Int as uint32;
  b: Bool;
  c: Int as uint256;
}

contract Test {
  init() {}
  receive(src: A) {
    
  }
  
  bounced(src: Slice) {
  }
  
  bounced(msg: Slice) {
  }
}

## contract-duplicate-bounced1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicate-bounced1.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

message A {
  a: Int as uint32;
  b: Bool;
  c: Int as uint256;
}

contract Test {
  init() {}
  receive(src: A) {
    
  }
  
  bounced(src: bounced<A>) {
    let x: Int = src.c; // Resolve descriptors won't fail on this
  }
  
  bounced(msg: bounced<A>) {
  }
}

## contract-duplicate-bounced2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicate-bounced2.tact)
trait BaseTrait { }

message Msg {}

contract Example {
    bounced(msg: Msg) { }
    bounced(msg: Msg) { }
}



## contract-duplicate-external-fallback.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicate-external-fallback.tact)
primitive Int;

trait BaseTrait {
    
}

message A {
    a: Int as uint32;
}

contract Test {
    external(msg: A) {
        42;
    }

    external() {
        42;
    }

    external() {

    }
}

## contract-duplicate-external.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicate-external.tact)
trait BaseTrait { }

message Msg {}

contract Example {
    external(msg: Msg) { }
    external(msg: Msg) { }
}



## contract-duplicate-init.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicate-init.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Main {
    init(a: Bool, b: Int) {

    }

    init(a: Bool) {

    }
}

## contract-duplicate-receiver.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicate-receiver.tact)
trait BaseTrait { }

message Msg {}

contract Example {
    receive(msg: Msg) { }
    receive(msg: Msg) { }
}



## contract-duplicate-storage-var.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicate-storage-var.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Pair {
  a: Int;
  b: Int;
  b: Int;
}

## contract-duplicates-in-trait-list.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-duplicates-in-trait-list.tact)
trait BaseTrait {}

trait Foo {
    receive("comment") { }
}

contract Test with Foo, Foo { }



## contract-getter-override-virtual-no-keyword.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-getter-override-virtual-no-keyword.tact)
primitive Int;
trait BaseTrait { }

trait T {
   virtual get fun getter(): Int { return 42 }
}

contract TestContract with T {
  get fun getter(): Int { return 43 }
}


## contract-missing-type.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-missing-type.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Main {
    get fun hello(): Int {
        return 0;
    }
    get fun hello2(): Point {
        return 0;
    }
}

## contract-receiver-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-receiver-int.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

struct B {
  a: Int;
}

contract Pair {
  receive(src: Int) {
    
  }
}

## contract-receiver-optional-msg.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-receiver-optional-msg.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

message B {
  a: Int;
}

contract Pair {
  receive(src: B?) {
    
  }
}

## contract-receiver-struct.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/contract-receiver-struct.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

struct B {
  a: Int;
}

contract Pair {
  receive(src: B) {
    
  }
}

## expr-bitwise-not-bool-in-const1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/expr-bitwise-not-bool-in-const1.tact)
primitive Int;
primitive Bool;

const a: Int = ~ true;

## expr-bitwise-not-bool-in-const2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/expr-bitwise-not-bool-in-const2.tact)
primitive Int;
primitive Bool;

const a: Bool = ~ true;

## getter-outside-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/getter-outside-contract.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

get fun sample(a: Int): Int {
    return 0;
}

## message-negative-opcode-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/message-negative-opcode-1.tact)
message(-1) Foo { }


## message-negative-opcode-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/message-negative-opcode-2.tact)
message(42 - 43) Foo { }


## message-opcode-div-by-zero.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/message-opcode-div-by-zero.tact)
trait BaseTrait { }

message(42 / 0) DivByZeroOpcode { }

contract Test {
    receive(msg: DivByZeroOpcode) { }
}



## message-opcode-too-large-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/message-opcode-too-large-1.tact)
message(0x1_FFFFF_FFFF) Foo { }


## message-opcode-too-large-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/message-opcode-too-large-2.tact)
message(0xFFFF * 0x1FFFF) Foo { }


## message-opcode-zero-1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/message-opcode-zero-1.tact)
trait BaseTrait { }

// zero opcodes are reserved for string comments
message(0) ZeroOpcode { }

contract Test {
    receive(msg: ZeroOpcode) { }
}



## message-opcode-zero-2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/message-opcode-zero-2.tact)
trait BaseTrait { }

// zero opcodes are reserved for string comments
message(pow(2, 4) - 16) ZeroOpcode { }

contract Test {
    receive(msg: ZeroOpcode) { }
}



## method-first-param-not-self1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/method-first-param-not-self1.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

extends fun inc(a: Int): Int {
    return a + 1;
}

## method-first-param-not-self2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/method-first-param-not-self2.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun inc(a: Int, self: Int): Int {
    return a + 1 + self;
}

## native-fun-getter.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/native-fun-getter.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

@name(hello_world)
get native sample(a: Int): Int;

## scope-contract-shadows-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-contract-shadows-contract.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Main {
    
}

contract Main {
    
}

## scope-duplicate-method.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-duplicate-method.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

extends fun hello(self: Main): Int {
    return 0;
}

extends fun hello(self: Main): Bool {
    return true;
}

struct Main {
    v: Int = 0;
}

## scope-fun-shadows-builtin-dumpStack.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-fun-shadows-builtin-dumpStack.tact)
fun dumpStack() {

}

## scope-fun-shadows-builtin-ton.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-fun-shadows-builtin-ton.tact)
fun ton() {

}

## scope-fun-shadows-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-fun-shadows-fun.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun hello(a: Main): Int {

}

fun hello(b: Main): Int {

}

struct Main {
    
}

## scope-internal-fun-shadows-internal-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-internal-fun-shadows-internal-fun.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Main {
    fun hello(a: Main): Int {

    }

    fun hello(b: Main): Int {

    }
}

## scope-param-shadows-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-param-shadows-param.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Main {
    fun hello(a: Bool, a: Int): Int {

    }
}

## scope-storage-var-shadows-trait-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-storage-var-shadows-trait-const.tact)
primitive Int;

trait BaseTrait { virtual const storageReserve: Int = 0; }

contract Foo {
  // this should be a var-scope error because storageReserve
  // is a virtual constant defined in BaseTrait
  storageReserve: Int;

  init() {
    self.storageReserve = ton("0.05");
  }
}


## scope-struct-shadows-contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-struct-shadows-contract.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract Main {
    
}

struct Main {
    
}

## scope-struct-shadows-struct.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/scope-struct-shadows-struct.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

struct Main {
    
}

struct Main {
    
}

## struct-decl-clash-with-int.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-clash-with-int.tact)
primitive Int;

struct Int { s: Int = 42 }

trait BaseTrait { }


## struct-decl-default-field-wrong-initializer-type.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-default-field-wrong-initializer-type.tact)
primitive Bool;

struct S { s: Bool = 42 }

trait BaseTrait { }


## struct-decl-duplicate-decl.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-duplicate-decl.tact)
primitive Int;
primitive Bool;
trait BaseTrait { }

struct Pair {
  a: Int;
  b: Int;
}

struct Pair {
  a: Int;
  b: Bool;
}

## struct-decl-duplicate-field.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-duplicate-field.tact)
primitive Int;

trait BaseTrait { }

struct Pair {
  a: Int;
  b: Int;
  b: Int;
}

## struct-decl-empty-not-allowed.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-empty-not-allowed.tact)
trait BaseTrait { }

struct Main { }

## struct-decl-mutually-recursive.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-mutually-recursive.tact)
primitive Int;
trait BaseTrait {}

struct A1 {
  a: Int;
  b: A2;
}
    
struct A2 {
  a: Int;
  b: A1;
}


## struct-decl-remainder-in-the-middle.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-remainder-in-the-middle.tact)
trait BaseTrait { }

primitive Int;
primitive Cell;

struct Test {
    a: Int;
    s: Cell as remaining;
    b: Int;
}

## struct-decl-self-reference-map.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-self-reference-map.tact)
primitive Int;
trait BaseTrait {}

struct A {
  a: Int;
  b: map<Int, A>;
}



## struct-decl-self-reference.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/struct-decl-self-reference.tact)
primitive Int;
trait BaseTrait { }

struct A {
  a: Int;
  b: A;
}



## trait-duplicates-in-trait-list.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/trait-duplicates-in-trait-list.tact)
trait BaseTrait {}

trait Foo {
    receive("comment") { }
}

trait Test with Foo, Foo { }



## trait-field-initialized.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/trait-field-initialized.tact)
trait T {
    a: Int = 42; // error

    get fun getA(): Int {
        return self.a;
    }
}

contract Test with T {
    a: Int = 19;
}



## wf-type-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/wf-type-const.tact)
primitive Int;
primitive String;

const m: map<Int, String> = null;



## wf-type-contract-const-incorrect-annotation.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/wf-type-contract-const-incorrect-annotation.tact)
primitive Int;
primitive Address;
trait BaseTrait {}

contract Test {
    const m: map<Int, Address as uint32> = null;
}



## wf-type-contract-const.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/wf-type-contract-const.tact)
primitive Int;
primitive String;
trait BaseTrait {}

contract Test {
    const m: map<Int, String> = null;
}



## wf-type-contract-getter.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/wf-type-contract-getter.tact)
primitive Int;
primitive String;
trait BaseTrait {}

contract Test {
    get fun foo(): map<Int, String> {
        let m: map<Int, String> = null;
        return m;
    }
}



## wf-type-fun-param.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test-failed/wf-type-fun-param.tact)
primitive Bool;
primitive Int;

fun foo(m: map<Bool, Int>) { }



## asm-extends-fun.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/asm-extends-fun.tact)
primitive Slice;
primitive Cell;
asm(-> 1 0) extends mutates fun loadRef(self: Slice): Cell { LDREF }


## asm-fun-no-arg-shuffle.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/asm-fun-no-arg-shuffle.tact)
primitive Int;

asm(-> 0) fun foo(x: Int): Int {
    NOP
}


## asm-fun-no-ret-shuffle.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/asm-fun-no-ret-shuffle.tact)
primitive Int;

asm(y x) fun foo(x: Int, y: Int) {
    DROP
    DROP
}


## asm-fun-no-shuffle.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/asm-fun-no-shuffle.tact)
primitive Int;

asm fun foo(x: Int) {
    DROP
}


## asm-fun-shuffle-pair.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/asm-fun-shuffle-pair.tact)
primitive Int;
struct Pair { fst: Int; snd: Int }

asm(-> 1 0) fun foo(x: Int, y: Int): Pair {
    SWAP
}


## const-decl-struct-with-default-field.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/const-decl-struct-with-default-field.tact)
primitive Int;
trait BaseTrait { }

struct S { s: Int = 42 }
const x: Int = S {}.s;


## const-decl-struct-with-optional-field.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/const-decl-struct-with-optional-field.tact)
primitive Int;
trait BaseTrait { }

struct S { s: Int? }
const x: Int = S {}.s == null ? 42 : 0;


## contract-bounced-slice.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/contract-bounced-slice.tact)
primitive Int;
primitive Slice;

trait BaseTrait {
    
}

message A {
  a: Int as uint32;
}

contract Test {
  init() {}
  receive(src: A) {
    
  }
  
  bounced(src: Slice) {
    
  }
}

## contract-bounced-too-small-not-detected.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/contract-bounced-too-small-not-detected.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

message A {
  a: Int as uint32;
  b: Bool;
  c: Int as uint256;
}

contract Test {
  init() {}
  receive(src: A) {
    
  }
  
  bounced(src: bounced<A>) {
    let x: Int = src.c;
  }
}

## contract-const-override-abstract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/contract-const-override-abstract.tact)
primitive Int;
trait BaseTrait { }

trait T {
  abstract const Foo: Int;
}

contract TestContract with T {
  override const Foo: Int = 42;
}


## contract-const-override-virtual.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/contract-const-override-virtual.tact)
primitive Int;
trait BaseTrait { }

trait T {
   virtual const Foo: Int = 41;
}

contract TestContract with T {
  override const Foo: Int = 42;
}


## contract-external-fallback-receiver.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/contract-external-fallback-receiver.tact)
primitive Int;

trait BaseTrait {
    
}

message A {
    a: Int as uint32;
}

contract Test {
    external(msg: A) {
        42;
    }

    external() {
        42;
    }
}

## contract-getter-override-abstract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/contract-getter-override-abstract.tact)
primitive Int;
trait BaseTrait { }

trait T {
  abstract get fun getter(): Int;
}

contract TestContract with T {
  override get fun getter(): Int { return 0 }
}


## contract-getter-override-virtual.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/contract-getter-override-virtual.tact)
primitive Int;
trait BaseTrait { }

trait T {
   virtual get fun getter(): Int { return 42 }
}

contract TestContract with T {
  override get fun getter(): Int { return 43 }
}


## fun-extends-opt-self.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/fun-extends-opt-self.tact)
primitive Int;

fun test(x: Int, y: Int?): Int {
    return 123;
}

extends fun test_extends(self: Int, y: Int?): Int {
    return 123;
}

extends fun test_extends_self(self: Int?, y: Int): Int {
    return 123;
}

extends mutates fun test_mutates(self: Int, y: Int?): Int {
    return 123;
}

extends mutates fun test_mutates_self(self: Int?, y: Int): Int {
    return 123;
}

extends mutates fun test_mutates_self_opt(self: Int?, y: Int): Int? {
    return null;
}

## init-vars-analysis-uninit-storage-vars.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/init-vars-analysis-uninit-storage-vars.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

contract HelloWorld {
    a: Int;
    b: Bool;

    init() {
        
    }

    fun hello() {
        
    }

    fun hello2() {
        
    }
}


## item-funs-with-errors-in-bodies1.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/item-funs-with-errors-in-bodies1.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

fun testFunc(): Int {
    return 0;
}

fun testFunc2() {
    return 0;
}

fun testFunc3(a: Int, b: Bool) {
    return 0;
}

## item-funs-with-errors-in-bodies2.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/item-funs-with-errors-in-bodies2.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

struct Point {
    p: Int;
}

contract Main {
    a: Int;
    init(a: Int) {
        self.a = a;
    }

    get fun hello(): Int {
        return 0;
    }
    get fun hello2(): Point {
        return 0;
    }
}

## item-method.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/item-method.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

extends fun inc(self: Int): Int {
    return self + 1;
}

## item-native-decl.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/item-native-decl.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

@name(hello_world)
native sample(a: Int): Int;

## item-native-mutating-method.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/item-native-mutating-method.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

@name(inc)
mutates extends native inc(self: Int): Int;

## map-value-as-coins.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/map-value-as-coins.tact)
primitive Int;

trait BaseTrait {
    
}

contract Main {
    m: map<Int, Int as coins>;

    get fun test(): Int {
        let m: map<Int, Int as coins> = emptyMap();
        m.set(1, 2);
        self.m.set(1, 2);
        return m.get(1) + self.m.get(1);
    }
}

## message-opcode-expr.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/message-opcode-expr.tact)
primitive Int;
trait BaseTrait { }

message((crc32("Tact") + 42) & 0xFFFF_FFFF) MsgWithExprOpcode {
    field: Int as uint4;
}

contract Foo {
    receive(msg: MsgWithExprOpcode) { }
}


## scope-loops.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/scope-loops.tact)
fun scopeUntil() {
    do {
        let a: Int = 0;
    } until (true);
    let a: String = "abc";
}

fun scopeRepeat() {
    repeat (1) {
        let a: Int = 0;
    }
    let a: String = "abc";
}

fun scopeWhile() {
    while (true) {
        let a: Int = 0;
    }
    let a: String = "abc";
}

fun scopeIf() {
    if (true) {
        let a: Int = 0;
    }
    let a: String = "abc";
}

## struct-decl-default-field.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/struct-decl-default-field.tact)
primitive Int;
trait BaseTrait { }

struct S { a: Int = 42 }

## struct-decl-nested.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/struct-decl-nested.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

struct Struct1 {
    a: Int;
    b: Bool;
}

struct Struct2 {
    a: Struct1;
}

## struct-decl-non-rec-types.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/struct-decl-non-rec-types.tact)
primitive Int;
trait BaseTrait { }

message SetIntMap4 {
    key: Int;
    value: SomeStruct?;
}

struct SomeStruct { value: Int }


## struct-decl-remainder.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/struct-decl-remainder.tact)
trait BaseTrait { }

primitive Int;
primitive Cell;

struct Test {
    a: Int;
    b: Int;
    s: Cell as remaining;
}

## trait-base.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/trait-base.tact)
primitive Int;
primitive Bool;

trait BaseTrait {
    
}

## trait-foreach.tact (https://github.com/tact-lang/tact/blob/main/tact-main/src/types/test/trait-foreach.tact)
primitive Int;
trait BaseTrait { }

trait TraitWithForeach {
    m: map<Int, Int>;

    fun test() { foreach(_, _ in self.m) { } }
}


contract Test with TraitWithForeach {
    m: map<Int, Int>;
}


## Writer.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/Writer.ts)
import { trimIndent } from "./text";

export class Writer {
    private indent = 0;
    private lines: string[] = [];

    inIndent = (handler: () => void) => {
        this.indent++;
        handler();
        this.indent--;
    };

    append(src: string = "") {
        this.lines.push(" ".repeat(this.indent * 4) + src);
    }

    write(src: string) {
        const lines = trimIndent(src).split("\n");
        for (const l of lines) {
            this.append(l);
        }
    }

    end() {
        return this.lines.join("\n");
    }
}


## array.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/array.ts)
export const isUndefined = <T>(t: T | undefined): t is undefined =>
    typeof t === "undefined";

export const groupBy = <T, U>(
    items: readonly T[],
    f: (t: T) => U,
): readonly (readonly T[])[] => {
    const result: T[][] = [];
    const [head, ...tail] = items;
    if (isUndefined(head)) {
        return result;
    }
    let group: T[] = [head];
    result.push(group);
    let tag: U = f(head);
    for (const item of tail) {
        const nextTag = f(item);
        if (tag === nextTag) {
            group.push(item);
        } else {
            group = [item];
            result.push(group);
            tag = nextTag;
        }
    }
    return result;
};

export const intercalate = <T>(
    items: readonly (readonly T[])[],
    value: T,
): readonly T[] => {
    const [head, ...tail] = items;
    if (isUndefined(head)) {
        return [];
    }
    const result: T[] = [...head];
    for (const item of tail) {
        result.push(value, ...item);
    }
    return result;
};


## calculateIPFSlink.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/calculateIPFSlink.ts)
import { importer } from "ipfs-unixfs-importer";
import { MemoryBlockstore } from "blockstore-core/memory";

export async function calculateIPFSlink(data: Buffer) {
    const blockstore = new MemoryBlockstore();
    const cid = await new Promise<string>((resolve, reject) => {
        void (async () => {
            try {
                for await (const entry of importer(
                    { content: data },
                    blockstore,
                )) {
                    resolve(entry.cid.toString());
                }
            } catch (e) {
                reject(e);
            }
        })();
    });
    return "ipfs://" + cid;
}


## crc16.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/crc16.ts)
const TABLE = new Int16Array([
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108,
    0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 0x1231, 0x0210,
    0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0xb37b,
    0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de, 0x2462, 0x3443, 0x0420, 0x1401,
    0x64e6, 0x74c7, 0x44a4, 0x5485, 0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee,
    0xf5cf, 0xc5ac, 0xd58d, 0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6,
    0x5695, 0x46b4, 0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d,
    0xc7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 0x5af5,
    0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0xdbfd, 0xcbdc,
    0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a, 0x6ca6, 0x7c87, 0x4ce4,
    0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0xedae, 0xfd8f, 0xcdec, 0xddcd,
    0xad2a, 0xbd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13,
    0x2e32, 0x1e51, 0x0e70, 0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a,
    0x9f59, 0x8f78, 0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e,
    0xe16f, 0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 0x02b1,
    0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 0xb5ea, 0xa5cb,
    0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d, 0x34e2, 0x24c3, 0x14a0,
    0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 0xa7db, 0xb7fa, 0x8799, 0x97b8,
    0xe75f, 0xf77e, 0xc71d, 0xd73c, 0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657,
    0x7676, 0x4615, 0x5634, 0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9,
    0xb98a, 0xa9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882,
    0x28a3, 0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0xfd2e,
    0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07,
    0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0xef1f, 0xff3e, 0xcf5d,
    0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74,
    0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
]);

export function crc16(data: string | Buffer) {
    if (!(data instanceof Buffer)) {
        data = Buffer.from(data);
    }

    let crc = 0;

    data.forEach(
        (byte) =>
            (crc = (TABLE[((crc >> 8) ^ byte) & 0xff]! ^ (crc << 8)) & 0xffff),
    );

    return crc;
}


## filePath.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/filePath.ts)
import pathModule from "node:path";

export function posixNormalize(path: string): string {
    if (
        typeof global === "object" &&
        typeof global.process === "object" &&
        typeof global.process.versions === "object" &&
        global.process.versions.node
    ) {
        return path.split(pathModule.sep).join(pathModule.posix.sep);
    }
    return path;
}


## idToHex.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/idToHex.ts)
import { beginCell } from "@ton/core";

export function idToHex(id: number) {
    return beginCell()
        .storeUint(id, 32)
        .endCell()
        .beginParse()
        .loadBuffer(4)
        .toString("hex");
}


## isSubsetOf.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/isSubsetOf.spec.ts)
import { ReadonlySetLike, isSubsetOf } from "./isSubsetOf";

// Tests are adapted from:
// https://github.com/zloirock/core-js/blob/227a758ef96fa585a66cc1e89741e7d0bb696f48/tests/unit-global/es.set.is-subset-of.js

describe("isSubsetOf", () => {
    /* eslint-disable @typescript-eslint/no-explicit-any */
    let s1: Set<any>;
    let s2: ReadonlySetLike<unknown>;

    it("should implement isSubsetOf correctly", () => {
        s1 = new Set([1]);
        s2 = new Set([1, 2, 3]);
        expect(isSubsetOf(s1, s2)).toBe(true);

        s1 = new Set([1]);
        s2 = new Set([2, 3, 4]);
        expect(isSubsetOf(s1, s2)).toBe(false);

        s1 = new Set([1, 2, 3]);
        s2 = new Set([5, 4, 3, 2, 1]);
        expect(isSubsetOf(s1, s2)).toBe(true);

        s1 = new Set([1, 2, 3]);
        s2 = new Set([5, 4, 3, 2]);
        expect(isSubsetOf(s1, s2)).toBe(false);

        s1 = new Set([1]);
        s2 = createSetLike([1, 2, 3]);
        expect(isSubsetOf(s1, s2)).toBe(true);

        s1 = new Set([1]);
        s2 = createSetLike([2, 3, 4]);
        expect(isSubsetOf(s1, s2)).toBe(false);

        s1 = new Set([1, 2, 3]);
        s2 = createSetLike([5, 4, 3, 2, 1]);
        expect(isSubsetOf(s1, s2)).toBe(true);

        s1 = new Set([1, 2, 3]);
        s2 = createSetLike([5, 4, 3, 2]);
        expect(isSubsetOf(s1, s2)).toBe(false);

        s1 = new Set([1, 2, 3]);
        s2 = new Set([1]);
        expect(isSubsetOf(s1, s2)).toBe(false);

        s1 = new Set([1, 2, 3]);
        s2 = new Set();
        expect(isSubsetOf(s1, s2)).toBe(false);

        s1 = new Set();
        s2 = new Set([1, 2, 3]);
        expect(isSubsetOf(s1, s2)).toBe(true);
    });
});

// Helper functions are adapted from:
// https://github.com/zloirock/core-js/blob/227a758ef96fa585a66cc1e89741e7d0bb696f48/tests/helpers/helpers.js

function createSetLike<T>(elements: T[]): ReadonlySetLike<T> {
    return {
        size: elements.length,
        has(value: T): boolean {
            return includes(elements, value);
        },
        keys(): Iterator<T> {
            return createIterator(elements);
        },
    };
}

function includes<T>(target: T[], wanted: T) {
    return target.some((element) => element === wanted);
}

function createIterator<T>(elements: T[]): Iterator<T> {
    let index = 0;
    const iterator = {
        called: false,
        /* eslint-disable @typescript-eslint/no-explicit-any */
        next(): IteratorResult<any> {
            iterator.called = true;
            return {
                value: elements[index++],
                done: index > elements.length,
            };
        },
    };
    return iterator;
}


## isSubsetOf.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/isSubsetOf.ts)
/** Taken from TypeScript collection lib to perfectly match the .isSubsetOf signature */
export interface ReadonlySetLike<T> {
    /**
     * Despite its name, returns an iterator of the values in the set-like.
     */
    keys(): Iterator<T>;
    /**
     * @returns a boolean indicating whether an element with the specified value exists in the set-like or not.
     */
    has(value: T): boolean;
    /**
     * @returns the number of (unique) elements in the set-like.
     */
    readonly size: number;
}

/**
 * @returns a boolean indicating whether all the elements in Set `one` are also in the `other`.
 */
export function isSubsetOf<T>(
    one: Set<T>,
    other: ReadonlySetLike<unknown>,
): boolean {
    // If the builtin method exists, just call it
    if ("isSubsetOf" in Set.prototype) {
        return one.isSubsetOf(other);
    }
    // If not, provide the implementation
    if (one.size > other.size) {
        return false;
    }
    for (const element of one) {
        if (!other.has(element)) {
            return false;
        }
    }
    return true;
}


## loadCases.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/loadCases.ts)
import fs from "fs";

export function loadCases(src: string) {
    const recs = fs.readdirSync(src);
    const res: { name: string; code: string }[] = [];
    for (const r of recs) {
        if (r.endsWith(".tact")) {
            res.push({
                name: r.slice(0, r.length - ".tact".length),
                code: fs.readFileSync(src + r, "utf8"),
            });
        }
    }
    res.sort((a, b) => a.name.localeCompare(b.name));
    return res;
}


## testKey.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/testKey.ts)
import Prando from "prando";
import { keyPairFromSeed } from "@ton/crypto";

export function testKey(seed: string) {
    const random = new Prando(seed);
    const res = Buffer.alloc(32);
    for (let i = 0; i < res.length; i++) {
        res[i] = random.nextInt(0, 256);
    }
    return keyPairFromSeed(res);
}


## text.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/text.spec.ts)
import { isBlank, trimIndent } from "./text";
describe("text", () => {
    it("should detect blank lines", () => {
        expect(isBlank("")).toBe(true);
        expect(isBlank(" ")).toBe(true);
        expect(isBlank("\t")).toBe(true);
        expect(isBlank("a")).toBe(false);
    });
    it("should trim indent", () => {
        const res = trimIndent(`
            hello world
            123123 123123
               12312312
            12312312
        `);
        expect(res).toBe(`hello world\n123123 123123\n   12312312\n12312312`);
    });
});


## text.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/text.ts)
export function isBlank(src: string): boolean {
    return src.trim().length === 0;
}

function indentWidth(src: string): number {
    return src.length - src.trimStart().length;
}

export function trimIndent(src: string): string {
    // Parse lines
    let lines = src.split("\n");
    if (lines.length === 0) {
        return "";
    }
    if (lines.length === 1) {
        return lines[0]!.trim();
    }

    // Remove first and last empty line
    if (isBlank(lines[0]!)) {
        lines = lines.slice(1);
    }
    if (isBlank(lines[lines.length - 1]!)) {
        lines = lines.slice(0, lines.length - 1);
    }
    if (lines.length === 0) {
        return "";
    }

    // Find minimal indent
    const indents = lines.filter((v) => !isBlank(v)).map((v) => indentWidth(v));
    const minimal = indents.length > 0 ? Math.min(...indents) : 0;

    // Trim indent
    return lines.map((v) => (isBlank(v) ? "" : v.slice(minimal))).join("\n");
}

/**
 * Escapes unicode control codes in the [src] string
 * See: https://en.m.wikipedia.org/wiki/List_of_Unicode_characters#Control_codes
 */
export function escapeUnicodeControlCodes(src: string): string {
    // eslint-disable-next-line no-control-regex
    return src.replace(/[\x00-\x1F\x7F-\x9F]/g, (char) => {
        return `\\x${char.charCodeAt(0).toString(16).padStart(2, "0")}`;
    });
}


## tricks.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/tricks.ts)
/* eslint-disable @typescript-eslint/no-explicit-any */
type Extend<T extends any[], H> = H extends infer A ? [...T, A] : never;
type Flat<TS extends any[], R extends any[] = []> = TS extends [
    infer H,
    ...infer T,
]
    ? Flat<T, Extend<R, H>>
    : R;

declare const NoSuchCase: unique symbol;
interface NoSuchCaseBug<L> extends Array<never> {
    [NoSuchCase]: L;
}
type On<I extends any[], O> = {
    on: <const DI extends any[]>(
        ...key: I extends Flat<DI> ? DI : NoSuchCaseBug<DI>
    ) => <const DO>(
        handler: (...args: Extract<I, Flat<DI>>) => DO,
    ) => MV<Exclude<I, Flat<DI>>, O | DO>;
};

declare const CasesAreNotExhaustive: unique symbol;
interface NonExhaustiveBug<L> {
    [CasesAreNotExhaustive]: L;
}
type End<I extends any[], O> = [I] extends [never]
    ? EndInternal<I, O>
    : {
          otherwise: <const DO>(handle: (...input: I) => DO) => O | DO;
          end: NonExhaustiveBug<I>;
      };
type MV<I extends any[], O> = End<I, O> & On<I, O>;

type OnInternal<I extends any[], O> = {
    on: <const DI extends any[]>(
        ...key: DI
    ) => <const DO>(
        handler: (...args: Extract<I, Flat<DI>>) => DO,
    ) => MVInternal<Exclude<I, Flat<DI>>, O | DO>;
};
type EndInternal<I extends any[], O> = {
    otherwise: <const DO>(handle: (...input: I) => DO) => O | DO;
    end: () => O;
};
type MVInternal<I extends any[], O> = EndInternal<I, O> & OnInternal<I, O>;

const deepMatch = (a: unknown, b: unknown): boolean => {
    if (
        a === b &&
        ["number", "string", "boolean", "bigint"].includes(typeof a) &&
        typeof a === typeof b
    ) {
        return true;
    }
    if (a === null || b === null) {
        return a === b;
    }
    if (typeof a === "object" && typeof b === "object") {
        if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {
            return a.every((a, i) => deepMatch(a, b[i]));
        } else {
            return Object.entries(b).every(([k, b]) =>
                deepMatch(k in a ? (a as any)[k] : undefined, b),
            );
        }
    }
    return false;
};

export const match = <const I extends any[]>(
    ...args: I
): MV<Flat<I>, never> => {
    const rec = <I extends any[], O>(end: () => O): MVInternal<I, O> => ({
        end,
        otherwise: (handler) => handler(...(args as unknown as I)),
        on:
            <const DI extends any[]>(...match: DI) =>
            <const DO>(handler: (...args: Extract<I, Flat<DI>>) => DO) =>
                rec<Exclude<I, Flat<DI>>, O | DO>(() =>
                    deepMatch(args, match)
                        ? handler(
                              ...(args as unknown as Extract<I, Flat<DI, []>>),
                          )
                        : end(),
                ),
    });
    return rec<Flat<I>, never>(() => {
        throw new Error("Not exhaustive");
    }) as MV<Flat<I>, never>;
};

import { throwInternalCompilerError } from "../errors";

/**
 * Convert union to intersection. See https://stackoverflow.com/q/50374908
 */
type Intersect<T> = (T extends unknown ? (x: T) => 0 : never) extends (
    x: infer R,
) => 0
    ? R
    : never;

/**
 * Makes types more readable
 * Example: Unwrap<{ a: 1 } & { b: 2 }> = { a: 1, b: 2 }
 */
type Unwrap<T> = T extends infer R ? { [K in keyof R]: R[K] } : never;

type Inputs<I> = I extends { kind: infer K }
    ? K extends string
        ? Record<K, (input: I) => unknown>
        : never
    : never;
type Outputs<O> = { [K in keyof O]: (input: never) => O[K] };
type Handlers<I, O> = Unwrap<Intersect<Inputs<I>>> & Outputs<O>;

/**
 * Make visitor for disjoint union (tagged union, discriminated union)
 */
export const makeVisitor =
    <I>() =>
    <O>(handlers: Handlers<I, O>) =>
    (input: Extract<I, { kind: string }>): O[keyof O] => {
        const handler = (handlers as Record<string, (input: I) => O[keyof O]>)[
            input.kind
        ];

        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        if (handler) {
            return handler(input);
        } else {
            throwInternalCompilerError(
                `Reached impossible case: ${input.kind}`,
            );
        }
    };


## utils.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/utils/utils.ts)
import { throwInternalCompilerError } from "../errors";

export function topologicalSort<T>(src: T[], references: (src: T) => T[]) {
    const result: T[] = [];
    const visited: Set<T> = new Set();
    const visiting: Set<T> = new Set();
    const visit = (src: T) => {
        if (visiting.has(src)) {
            throwInternalCompilerError("Cycle detected");
        }
        if (!visited.has(src)) {
            visiting.add(src);
            for (const r of references(src)) {
                visit(r);
            }
            visiting.delete(src);
            visited.add(src);
            result.push(src);
        }
    };
    for (const s of src) {
        visit(s);
    }
    return result;
}


## VirtualFileSystem.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/vfs/VirtualFileSystem.ts)
export type VirtualFileSystem = {
    root: string;
    resolve(...path: string[]): string;
    exists(path: string): boolean;
    readFile(path: string): Buffer;
    writeFile(path: string, content: Buffer | string): void;
};


## createNodeFileSystem.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/vfs/createNodeFileSystem.spec.ts)
import path from "path";
import fs from "fs";
import rimraf from "rimraf";
import { createNodeFileSystem } from "./createNodeFileSystem";

describe("createNodeFileSystem", () => {
    it("should open file system", () => {
        const vfs = createNodeFileSystem(
            path.resolve(__dirname, "./__testdata/"),
        );
        expect(vfs.root).toBe(path.normalize(__dirname + "/__testdata/"));
    });

    it("should write and read files", () => {
        const vfs = createNodeFileSystem(
            path.resolve(__dirname, "./__testdata"),
            false,
        );

        // Create a single file
        const filename = "tmp-" + Math.random() + ".txt";
        const realPath = vfs.resolve(filename);
        try {
            expect(vfs.exists(realPath)).toBe(false);
            vfs.writeFile(realPath, "Hello world");
            expect(vfs.exists(realPath)).toBe(true);
            expect(vfs.readFile(realPath).toString("utf8")).toBe("Hello world");
            expect(fs.readFileSync(realPath, "utf8")).toBe("Hello world");
        } finally {
            fs.unlinkSync(realPath);
        }

        // Automatically create directories
        const dir = "dir-" + Math.random();
        const fileName2 = dir + "/" + Math.random() + ".txt";
        const realPath2 = vfs.resolve(fileName2);
        const realPathDir2 = vfs.resolve(dir);
        try {
            expect(vfs.exists(realPath2)).toBe(false);
            vfs.writeFile(realPath2, "Hello world");
            expect(vfs.exists(realPath2)).toBe(true);
            expect(vfs.readFile(realPath2).toString("utf8")).toBe(
                "Hello world",
            );
            expect(fs.readFileSync(realPath2, "utf8")).toBe("Hello world");
        } finally {
            rimraf.sync(realPathDir2);
        }
    });
});


## createNodeFileSystem.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/vfs/createNodeFileSystem.ts)
import { VirtualFileSystem } from "./VirtualFileSystem";
import fs from "fs";
import path from "path";
import mkdirp from "mkdirp";

export function createNodeFileSystem(
    root: string,
    readonly: boolean = true,
): VirtualFileSystem {
    let normalizedRoot = path.normalize(root);
    if (!normalizedRoot.endsWith(path.sep)) {
        normalizedRoot += path.sep;
    }
    return {
        root: normalizedRoot,
        exists(filePath: string): boolean {
            if (!filePath.startsWith(normalizedRoot)) {
                throw new Error(
                    `Path '${filePath}' is outside of the root directory '${normalizedRoot}'`,
                );
            }
            return fs.existsSync(filePath);
        },
        resolve(...filePath) {
            return path.normalize(path.resolve(normalizedRoot, ...filePath));
        },
        readFile(filePath) {
            if (!filePath.startsWith(normalizedRoot)) {
                throw new Error(
                    `Path '${filePath}' is outside of the root directory '${normalizedRoot}'`,
                );
            }
            return fs.readFileSync(filePath);
        },
        writeFile(filePath, content) {
            if (readonly) {
                throw new Error("File system is readonly");
            }
            if (!filePath.startsWith(normalizedRoot)) {
                throw new Error(
                    `Path '${filePath}' is outside of the root directory '${normalizedRoot}'`,
                );
            }

            mkdirp.sync(path.dirname(filePath));
            fs.writeFileSync(filePath, content);
        },
    };
}


## createVirtualFileSystem.spec.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/vfs/createVirtualFileSystem.spec.ts)
import { createVirtualFileSystem } from "./createVirtualFileSystem";

describe("createVirtualFileSystem", () => {
    it("should create a virtual file system", () => {
        let vfs = createVirtualFileSystem("/", {});
        expect(vfs.root).toBe("/");
        vfs = createVirtualFileSystem("//", {});
        expect(vfs.root).toBe("/");
        vfs = createVirtualFileSystem("//./", {});
        expect(vfs.root).toBe("/");
        vfs = createVirtualFileSystem("@stdlib", {});
        expect(vfs.root).toBe("@stdlib/");
    });

    it("should read from virtual file system", () => {
        const fs: Record<string, string> = {
            ["file.txt"]: Buffer.from("Hello World").toString("base64"),
            ["empty.txt"]: Buffer.from([]).toString("base64"),
        };
        const vfs = createVirtualFileSystem("@stdlib", fs);
        let realPath = vfs.resolve("./", "./", "file.txt");
        expect(realPath).toBe("@stdlib/file.txt");
        expect(vfs.exists(realPath)).toBe(true);
        expect(vfs.readFile(realPath).toString()).toBe("Hello World");
        realPath = vfs.resolve("./", "./", "empty.txt");
        expect(realPath).toBe("@stdlib/empty.txt");
        expect(vfs.exists(realPath)).toBe(true);
        expect(vfs.readFile(realPath).toString()).toBe("");
    });
});


## createVirtualFileSystem.ts (https://github.com/tact-lang/tact/blob/main/tact-main/src/vfs/createVirtualFileSystem.ts)
import normalize from "path-normalize";
import { VirtualFileSystem } from "./VirtualFileSystem";

export function createVirtualFileSystem(
    root: string,
    fs: Record<string, string>,
    readonly: boolean = true,
): VirtualFileSystem {
    let normalizedRoot = normalize(root);
    if (!normalizedRoot.endsWith("/")) {
        normalizedRoot += "/";
    }
    return {
        root: normalizedRoot,
        exists(filePath: string): boolean {
            if (!filePath.startsWith(normalizedRoot)) {
                throw new Error(
                    `Path '${filePath}' is outside of the root directory '${normalizedRoot}'`,
                );
            }
            const name = filePath.slice(normalizedRoot.length);
            return typeof fs[name] === "string";
        },
        resolve(...filePath): string {
            return normalize([normalizedRoot, ...filePath].join("/"));
        },
        readFile(filePath): Buffer {
            if (!filePath.startsWith(normalizedRoot)) {
                throw new Error(
                    `Path '${filePath}' is outside of the root directory '${normalizedRoot}'`,
                );
            }
            const name = filePath.slice(normalizedRoot.length);
            const content = fs[name];
            if (typeof content !== "string") {
                throw Error(`File ${name} not found at ${filePath}`);
            } else {
                return Buffer.from(content, "base64");
            }
        },
        writeFile(filePath, content): void {
            if (readonly) {
                throw new Error("File system is readonly");
            }
            if (!filePath.startsWith(normalizedRoot)) {
                throw new Error(
                    `Path '${filePath}' is outside of the root directory '${normalizedRoot}'`,
                );
            }
            const name = filePath.slice(normalizedRoot.length);
            fs[name] =
                typeof content === "string"
                    ? Buffer.from(content).toString("base64")
                    : content.toString("base64");
        },
    };
}


## stdlib.fc (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/stdlib.fc)
;; Standard library for funC
;;

{-
    This file is part of TON FunC Standard Library.

    FunC Standard Library is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    FunC Standard Library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

-}

{-
  # Tuple manipulation primitives
  The names and the types are mostly self-explaining.
  See [polymorhism with forall](https://ton.org/docs/#/func/functions?id=polymorphism-with-forall)
  for more info on the polymorphic functions.

  Note that currently values of atomic type `tuple` can't be cast to composite tuple type (e.g. `[int, cell]`)
  and vise versa.
-}

{-
  # Lisp-style lists

  Lists can be represented as nested 2-elements tuples.
  Empty list is conventionally represented as TVM `null` value (it can be obtained by calling [null()]).
  For example, tuple `(1, (2, (3, null)))` represents list `[1, 2, 3]`. Elements of a list can be of different types.
-}

;;; Adds an element to the beginning of lisp-style list.
forall X -> tuple cons(X head, tuple tail) asm "CONS";

;;; Extracts the head and the tail of lisp-style list.
forall X -> (X, tuple) uncons(tuple list) asm "UNCONS";

;;; Extracts the tail and the head of lisp-style list.
forall X -> (tuple, X) list_next(tuple list) asm(-> 1 0) "UNCONS";

;;; Returns the head of lisp-style list.
forall X -> X car(tuple list) asm "CAR";

;;; Returns the tail of lisp-style list.
tuple cdr(tuple list) asm "CDR";

;;; Creates tuple with zero elements.
tuple empty_tuple() asm "NIL";

;;; Appends a value `x` to a `Tuple t = (x1, ..., xn)`, but only if the resulting `Tuple t' = (x1, ..., xn, x)`
;;; is of length at most 255. Otherwise throws a type check exception.
forall X -> tuple tpush(tuple t, X value) asm "TPUSH";
forall X -> (tuple, ()) ~tpush(tuple t, X value) asm "TPUSH";

;;; Creates a tuple of length one with given argument as element.
forall X -> [X] single(X x) asm "SINGLE";

;;; Unpacks a tuple of length one
forall X -> X unsingle([X] t) asm "UNSINGLE";

;;; Creates a tuple of length two with given arguments as elements.
forall X, Y -> [X, Y] pair(X x, Y y) asm "PAIR";

;;; Unpacks a tuple of length two
forall X, Y -> (X, Y) unpair([X, Y] t) asm "UNPAIR";

;;; Creates a tuple of length three with given arguments as elements.
forall X, Y, Z -> [X, Y, Z] triple(X x, Y y, Z z) asm "TRIPLE";

;;; Unpacks a tuple of length three
forall X, Y, Z -> (X, Y, Z) untriple([X, Y, Z] t) asm "UNTRIPLE";

;;; Creates a tuple of length four with given arguments as elements.
forall X, Y, Z, W -> [X, Y, Z, W] tuple4(X x, Y y, Z z, W w) asm "4 TUPLE";

;;; Unpacks a tuple of length four
forall X, Y, Z, W -> (X, Y, Z, W) untuple4([X, Y, Z, W] t) asm "4 UNTUPLE";

;;; Returns the first element of a tuple (with unknown element types).
forall X -> X first(tuple t) asm "FIRST";

;;; Returns the second element of a tuple (with unknown element types).
forall X -> X second(tuple t) asm "SECOND";

;;; Returns the third element of a tuple (with unknown element types).
forall X -> X third(tuple t) asm "THIRD";

;;; Returns the fourth element of a tuple (with unknown element types).
forall X -> X fourth(tuple t) asm "3 INDEX";

;;; Returns the first element of a pair tuple.
forall X, Y -> X pair_first([X, Y] p) asm "FIRST";

;;; Returns the second element of a pair tuple.
forall X, Y -> Y pair_second([X, Y] p) asm "SECOND";

;;; Returns the first element of a triple tuple.
forall X, Y, Z -> X triple_first([X, Y, Z] p) asm "FIRST";

;;; Returns the second element of a triple tuple.
forall X, Y, Z -> Y triple_second([X, Y, Z] p) asm "SECOND";

;;; Returns the third element of a triple tuple.
forall X, Y, Z -> Z triple_third([X, Y, Z] p) asm "THIRD";


;;; Push null element (casted to given type)
;;; By the TVM type `Null` FunC represents absence of a value of some atomic type.
;;; So `null` can actually have any atomic type.
forall X -> X null() asm "PUSHNULL";

;;; Moves a variable [x] to the top of the stack
forall X -> (X, ()) ~impure_touch(X x) impure asm "NOP";



;;; Returns the current Unix time as an Integer
int now() asm "NOW";

;;; Returns the internal address of the current smart contract as a Slice with a `MsgAddressInt`.
;;; If necessary, it can be parsed further using primitives such as [parse_std_addr].
slice my_address() asm "MYADDR";

;;; Returns the balance of the smart contract as a tuple consisting of an int
;;; (balance in nanotoncoins) and a `cell`
;;; (a dictionary with 32-bit keys representing the balance of "extra currencies")
;;; at the start of Computation Phase.
;;; Note that RAW primitives such as [send_raw_message] do not update this field.
[int, cell] get_balance() asm "BALANCE";

;;; Returns the logical time of the current transaction.
int cur_lt() asm "LTIME";

;;; Returns the starting logical time of the current block.
int block_lt() asm "BLOCKLT";

;;; Computes the representation hash of a `cell` [c] and returns it as a 256-bit unsigned integer `x`.
;;; Useful for signing and checking signatures of arbitrary entities represented by a tree of cells.
int cell_hash(cell c) asm "HASHCU";

;;; Computes the hash of a `slice s` and returns it as a 256-bit unsigned integer `x`.
;;; The result is the same as if an ordinary cell containing only data and references from `s` had been created
;;; and its hash computed by [cell_hash].
int slice_hash(slice s) asm "HASHSU";

;;; Computes sha256 of the data bits of `slice` [s]. If the bit length of `s` is not divisible by eight,
;;; throws a cell underflow exception. The hash value is returned as a 256-bit unsigned integer `x`.
int string_hash(slice s) asm "SHA256U";

{-
  # Signature checks
-}

;;; Checks the Ed25519-`signature` of a `hash` (a 256-bit unsigned integer, usually computed as the hash of some data)
;;; using [public_key] (also represented by a 256-bit unsigned integer).
;;; The signature must contain at least 512 data bits; only the first 512 bits are used.
;;; The result is `−1` if the signature is valid, `0` otherwise.
;;; Note that `CHKSIGNU` creates a 256-bit slice with the hash and calls `CHKSIGNS`.
;;; That is, if [hash] is computed as the hash of some data, these data are hashed twice,
;;; the second hashing occurring inside `CHKSIGNS`.
int check_signature(int hash, slice signature, int public_key) asm "CHKSIGNU";

;;; Checks whether [signature] is a valid Ed25519-signature of the data portion of `slice data` using `public_key`,
;;; similarly to [check_signature].
;;; If the bit length of [data] is not divisible by eight, throws a cell underflow exception.
;;; The verification of Ed25519 signatures is the standard one,
;;; with sha256 used to reduce [data] to the 256-bit number that is actually signed.
int check_data_signature(slice data, slice signature, int public_key) asm "CHKSIGNS";

{---
  # Computation of boc size
  The primitives below may be useful for computing storage fees of user-provided data.
-}

;;; Returns `(x, y, z, -1)` or `(null, null, null, 0)`.
;;; Recursively computes the count of distinct cells `x`, data bits `y`, and cell references `z`
;;; in the DAG rooted at `cell` [c], effectively returning the total storage used by this DAG taking into account
;;; the identification of equal cells.
;;; The values of `x`, `y`, and `z` are computed by a depth-first traversal of this DAG,
;;; with a hash table of visited cell hashes used to prevent visits of already-visited cells.
;;; The total count of visited cells `x` cannot exceed non-negative [max_cells];
;;; otherwise the computation is aborted before visiting the `(max_cells + 1)`-st cell and
;;; a zero flag is returned to indicate failure. If [c] is `null`, returns `x = y = z = 0`.
(int, int, int) compute_data_size(cell c, int max_cells) impure asm "CDATASIZE";

;;; Similar to [compute_data_size?], but accepting a `slice` [s] instead of a `cell`.
;;; The returned value of `x` does not take into account the cell that contains the `slice` [s] itself;
;;; however, the data bits and the cell references of [s] are accounted for in `y` and `z`.
(int, int, int) slice_compute_data_size(slice s, int max_cells) impure asm "SDATASIZE";

;;; A non-quiet version of [compute_data_size?] that throws a cell overflow exception (`8`) on failure.
(int, int, int, int) compute_data_size?(cell c, int max_cells) asm "CDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";

;;; A non-quiet version of [slice_compute_data_size?] that throws a cell overflow exception (8) on failure.
(int, int, int, int) slice_compute_data_size?(cell c, int max_cells) asm "SDATASIZEQ NULLSWAPIFNOT2 NULLSWAPIFNOT";

;;; Throws an exception with exit_code excno if cond is not 0 (commented since implemented in compilator)
;; () throw_if(int excno, int cond) impure asm "THROWARGIF";

{--
  # Debug primitives
  Only works for local TVM execution with debug level verbosity
-}
;;; Dumps the stack (at most the top 255 values) and shows the total stack depth.
() dump_stack() impure asm "DUMPSTK";

{-
  # Persistent storage save and load
-}

;;; Returns the persistent contract storage cell. It can be parsed or modified with slice and builder primitives later.
cell get_data() asm "c4 PUSH";

;;; Sets `cell` [c] as persistent contract data. You can update persistent contract storage with this primitive.
() set_data(cell c) impure asm "c4 POP";

{-
  # Continuation primitives
-}
;;; Usually `c3` has a continuation initialized by the whole code of the contract. It is used for function calls.
;;; The primitive returns the current value of `c3`.
cont get_c3() impure asm "c3 PUSH";

;;; Updates the current value of `c3`. Usually, it is used for updating smart contract code in run-time.
;;; Note that after execution of this primitive the current code
;;; (and the stack of recursive function calls) won't change,
;;; but any other function call will use a function from the new code.
() set_c3(cont c) impure asm "c3 POP";

;;; Transforms a `slice` [s] into a simple ordinary continuation `c`, with `c.code = s` and an empty stack and savelist.
cont bless(slice s) impure asm "BLESS";

{---
  # Gas related primitives
-}

;;; Sets current gas limit `gl` to its maximal allowed value `gm`, and resets the gas credit `gc` to zero,
;;; decreasing the value of `gr` by `gc` in the process.
;;; In other words, the current smart contract agrees to buy some gas to finish the current transaction.
;;; This action is required to process external messages, which bring no value (hence no gas) with themselves.
;;;
;;; For more details check [accept_message effects](https://ton.org/docs/#/smart-contracts/accept).
() accept_message() impure asm "ACCEPT";

;;; Sets current gas limit `gl` to the minimum of limit and `gm`, and resets the gas credit `gc` to zero.
;;; If the gas consumed so far (including the present instruction) exceeds the resulting value of `gl`,
;;; an (unhandled) out of gas exception is thrown before setting new gas limits.
;;; Notice that [set_gas_limit] with an argument `limit ≥ 2^63 − 1` is equivalent to [accept_message].
() set_gas_limit(int limit) impure asm "SETGASLIMIT";

;;; Commits the current state of registers `c4` (“persistent data”) and `c5` (“actions”)
;;; so that the current execution is considered “successful” with the saved values even if an exception
;;; in Computation Phase is thrown later.
() commit() impure asm "COMMIT";

;;; Not implemented
;;; Computes the amount of gas that can be bought for `amount` nanoTONs,
;;; and sets `gl` accordingly in the same way as [set_gas_limit].
;;() buy_gas(int amount) impure asm "BUYGAS";

;;; Computes the minimum of two integers [x] and [y].
int min(int x, int y) asm "MIN";

;;; Computes the maximum of two integers [x] and [y].
int max(int x, int y) asm "MAX";

;;; Sorts two integers.
(int, int) minmax(int x, int y) asm "MINMAX";

;;; Computes the absolute value of an integer [x].
int abs(int x) asm "ABS";

{-
  # Slice primitives

  It is said that a primitive _loads_ some data,
  if it returns the data and the remainder of the slice
  (so it can also be used as [modifying method](https://ton.org/docs/#/func/statements?id=modifying-methods)).

  It is said that a primitive _preloads_ some data, if it returns only the data
  (it can be used as [non-modifying method](https://ton.org/docs/#/func/statements?id=non-modifying-methods)).

  Unless otherwise stated, loading and preloading primitives read the data from a prefix of the slice.
-}


;;; Converts a `cell` [c] into a `slice`. Notice that [c] must be either an ordinary cell,
;;; or an exotic cell (see [TVM.pdf](https://ton-blockchain.github.io/docs/tvm.pdf), 3.1.2)
;;; which is automatically loaded to yield an ordinary cell `c'`, converted into a `slice` afterwards.
slice begin_parse(cell c) asm "CTOS";

;;; Checks if [s] is empty. If not, throws an exception.
() end_parse(slice s) impure asm "ENDS";

;;; Loads the first reference from the slice.
(slice, cell) load_ref(slice s) asm(-> 1 0) "LDREF";

;;; Preloads the first reference from the slice.
cell preload_ref(slice s) asm "PLDREF";

{- Functions below are commented because are implemented on compilator level for optimisation -}

;;; Loads a signed [len]-bit integer from a slice [s].
;; (slice, int) ~load_int(slice s, int len) asm(s len -> 1 0) "LDIX";

;;; Loads an unsigned [len]-bit integer from a slice [s].
;; (slice, int) ~load_uint(slice s, int len) asm( -> 1 0) "LDUX";

;;; Preloads a signed [len]-bit integer from a slice [s].
;; int preload_int(slice s, int len) asm "PLDIX";

;;; Preloads an unsigned [len]-bit integer from a slice [s].
;; int preload_uint(slice s, int len) asm "PLDUX";

;;; Loads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.
;; (slice, slice) load_bits(slice s, int len) asm(s len -> 1 0) "LDSLICEX";

;;; Preloads the first `0 ≤ len ≤ 1023` bits from slice [s] into a separate `slice s''`.
;; slice preload_bits(slice s, int len) asm "PLDSLICEX";

;;; Loads serialized amount of TonCoins (any unsigned integer up to `2^120 - 1`).
(slice, int) load_grams(slice s) asm(-> 1 0) "LDGRAMS";
(slice, int) load_coins(slice s) asm(-> 1 0) "LDVARUINT16";

;;; Returns all but the first `0 ≤ len ≤ 1023` bits of `slice` [s].
slice skip_bits(slice s, int len) asm "SDSKIPFIRST";
(slice, ()) ~skip_bits(slice s, int len) asm "SDSKIPFIRST";

;;; Returns the first `0 ≤ len ≤ 1023` bits of `slice` [s].
slice first_bits(slice s, int len) asm "SDCUTFIRST";

;;; Returns all but the last `0 ≤ len ≤ 1023` bits of `slice` [s].
slice skip_last_bits(slice s, int len) asm "SDSKIPLAST";
(slice, ()) ~skip_last_bits(slice s, int len) asm "SDSKIPLAST";

;;; Returns the last `0 ≤ len ≤ 1023` bits of `slice` [s].
slice slice_last(slice s, int len) asm "SDCUTLAST";

;;; Loads a dictionary `D` (HashMapE) from `slice` [s].
;;; (returns `null` if `nothing` constructor is used).
(slice, cell) load_dict(slice s) asm(-> 1 0) "LDDICT";

;;; Preloads a dictionary `D` from `slice` [s].
cell preload_dict(slice s) asm "PLDDICT";

;;; Loads a dictionary as [load_dict], but returns only the remainder of the slice.
slice skip_dict(slice s) asm "SKIPDICT";
(slice, ()) ~skip_dict(slice s) asm "SKIPDICT";

;;; Loads (Maybe ^Cell) from `slice` [s].
;;; In other words loads 1 bit and if it is true
;;; loads first ref and return it with slice remainder
;;; otherwise returns `null` and slice remainder
(slice, cell) load_maybe_ref(slice s) asm(-> 1 0) "LDOPTREF";

;;; Preloads (Maybe ^Cell) from `slice` [s].
cell preload_maybe_ref(slice s) asm "PLDOPTREF";


;;; Returns the depth of `cell` [c].
;;; If [c] has no references, then return `0`;
;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [c].
;;; If [c] is a `null` instead of a cell, returns zero.
int cell_depth(cell c) asm "CDEPTH";


{-
  # Slice size primitives
-}

;;; Returns the number of references in `slice` [s].
int slice_refs(slice s) asm "SREFS";

;;; Returns the number of data bits in `slice` [s].
int slice_bits(slice s) asm "SBITS";

;;; Returns both the number of data bits and the number of references in `slice` [s].
(int, int) slice_bits_refs(slice s) asm "SBITREFS";

;;; Checks whether a `slice` [s] is empty (i.e., contains no bits of data and no cell references).
int slice_empty?(slice s) asm "SEMPTY";

;;; Checks whether `slice` [s] has no bits of data.
int slice_data_empty?(slice s) asm "SDEMPTY";

;;; Checks whether `slice` [s] has no references.
int slice_refs_empty?(slice s) asm "SREMPTY";

;;; Returns the depth of `slice` [s].
;;; If [s] has no references, then returns `0`;
;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [s].
int slice_depth(slice s) asm "SDEPTH";

{-
  # Builder size primitives
-}

;;; Returns the number of cell references already stored in `builder` [b]
int builder_refs(builder b) asm "BREFS";

;;; Returns the number of data bits already stored in `builder` [b].
int builder_bits(builder b) asm "BBITS";

;;; Returns the depth of `builder` [b].
;;; If no cell references are stored in [b], then returns 0;
;;; otherwise the returned value is one plus the maximum of depths of cells referred to from [b].
int builder_depth(builder b) asm "BDEPTH";

{-
  # Builder primitives
  It is said that a primitive _stores_ a value `x` into a builder `b`
  if it returns a modified version of the builder `b'` with the value `x` stored at the end of it.
  It can be used as [non-modifying method](https://ton.org/docs/#/func/statements?id=non-modifying-methods).

  All the primitives below first check whether there is enough space in the `builder`,
  and only then check the range of the value being serialized.
-}

;;; Creates a new empty `builder`.
builder begin_cell() asm "NEWC";

;;; Converts a `builder` into an ordinary `cell`.
cell end_cell(builder b) asm "ENDC";

;;; Stores a reference to `cell` [c] into `builder` [b].
builder store_ref(builder b, cell c) asm(c b) "STREF";

;;; Stores an unsigned [len]-bit integer `x` into `b` for `0 ≤ len ≤ 256`.
;; builder store_uint(builder b, int x, int len) asm(x b len) "STUX";

;;; Stores a signed [len]-bit integer `x` into `b` for` 0 ≤ len ≤ 257`.
;; builder store_int(builder b, int x, int len) asm(x b len) "STIX";


;;; Stores `slice` [s] into `builder` [b]
builder store_slice(builder b, slice s) asm "STSLICER";

;;; Stores (serializes) an integer [x] in the range `0..2^120 − 1` into `builder` [b].
;;; The serialization of [x] consists of a 4-bit unsigned big-endian integer `l`,
;;; which is the smallest integer `l ≥ 0`, such that `x < 2^8l`,
;;; followed by an `8l`-bit unsigned big-endian representation of [x].
;;; If [x] does not belong to the supported range, a range check exception is thrown.
;;;
;;; Store amounts of TonCoins to the builder as VarUInteger 16
builder store_grams(builder b, int x) asm "STGRAMS";
builder store_coins(builder b, int x) asm "STVARUINT16";

;;; Stores dictionary `D` represented by `cell` [c] or `null` into `builder` [b].
;;; In other words, stores a `1`-bit and a reference to [c] if [c] is not `null` and `0`-bit otherwise.
builder store_dict(builder b, cell c) asm(c b) "STDICT";

;;; Stores (Maybe ^Cell) to builder:
;;; if cell is null store 1 zero bit
;;; otherwise store 1 true bit and ref to cell
builder store_maybe_ref(builder b, cell c) asm(c b) "STOPTREF";


{-
  # Address manipulation primitives
  The address manipulation primitives listed below serialize and deserialize values according to the following TL-B scheme:
  ```TL-B
  addr_none$00 = MsgAddressExt;
  addr_extern$01 len:(## 8) external_address:(bits len)
               = MsgAddressExt;
  anycast_info$_ depth:(#<= 30) { depth >= 1 }
    rewrite_pfx:(bits depth) = Anycast;
  addr_std$10 anycast:(Maybe Anycast)
    workchain_id:int8 address:bits256 = MsgAddressInt;
  addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)
    workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
  _ _:MsgAddressInt = MsgAddress;
  _ _:MsgAddressExt = MsgAddress;

  int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    src:MsgAddress dest:MsgAddressInt
    value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
  ext_out_msg_info$11 src:MsgAddress dest:MsgAddressExt
    created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
  ```
  A deserialized `MsgAddress` is represented by a tuple `t` as follows:

  - `addr_none` is represented by `t = (0)`,
    i.e., a tuple containing exactly one integer equal to zero.
  - `addr_extern` is represented by `t = (1, s)`,
    where slice `s` contains the field `external_address`. In other words, `
    t` is a pair (a tuple consisting of two entries), containing an integer equal to one and slice `s`.
  - `addr_std` is represented by `t = (2, u, x, s)`,
    where `u` is either a `null` (if `anycast` is absent) or a slice `s'` containing `rewrite_pfx` (if anycast is present).
    Next, integer `x` is the `workchain_id`, and slice `s` contains the address.
  - `addr_var` is represented by `t = (3, u, x, s)`,
    where `u`, `x`, and `s` have the same meaning as for `addr_std`.
-}

;;; Loads from slice [s] the only prefix that is a valid `MsgAddress`,
;;; and returns both this prefix `s'` and the remainder `s''` of [s] as slices.
(slice, slice) load_msg_addr(slice s) asm(-> 1 0) "LDMSGADDR";

;;; Decomposes slice [s] containing a valid `MsgAddress` into a `tuple t` with separate fields of this `MsgAddress`.
;;; If [s] is not a valid `MsgAddress`, a cell deserialization exception is thrown.
tuple parse_addr(slice s) asm "PARSEMSGADDR";

;;; Parses slice [s] containing a valid `MsgAddressInt` (usually a `msg_addr_std`),
;;; applies rewriting from the anycast (if present) to the same-length prefix of the address,
;;; and returns both the workchain and the 256-bit address as integers.
;;; If the address is not 256-bit, or if [s] is not a valid serialization of `MsgAddressInt`,
;;; throws a cell deserialization exception.
(int, int) parse_std_addr(slice s) asm "REWRITESTDADDR";

;;; A variant of [parse_std_addr] that returns the (rewritten) address as a slice [s],
;;; even if it is not exactly 256 bit long (represented by a `msg_addr_var`).
(int, slice) parse_var_addr(slice s) asm "REWRITEVARADDR";

{-
  # Dictionary primitives
-}


;;; Sets the value associated with [key_len]-bit key signed index in dictionary [dict] to [value] (cell),
;;; and returns the resulting dictionary.
cell idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";
(cell, ()) ~idict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETREF";

;;; Sets the value associated with [key_len]-bit key unsigned index in dictionary [dict] to [value] (cell),
;;; and returns the resulting dictionary.
cell udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";
(cell, ()) ~udict_set_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETREF";

cell idict_get_ref(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETOPTREF";
(cell, int) idict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGETREF" "NULLSWAPIFNOT";
(cell, int) udict_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGETREF" "NULLSWAPIFNOT";
(cell, cell) idict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTISETGETOPTREF";
(cell, cell) udict_set_get_ref(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUSETGETOPTREF";
(cell, int) idict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDEL";
(cell, int) udict_delete?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDEL";
(slice, int) idict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIGET" "NULLSWAPIFNOT";
(slice, int) udict_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUGET" "NULLSWAPIFNOT";
(cell, slice, int) idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, slice, int) udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGET" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_delete_get?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGET" "NULLSWAPIFNOT";
(cell, cell, int) idict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGETREF" "NULLSWAPIFNOT";
(cell, cell, int) udict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~idict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTIDELGETREF" "NULLSWAPIFNOT";
(cell, (cell, int)) ~udict_delete_get_ref?(cell dict, int key_len, int index) asm(index dict key_len) "DICTUDELGETREF" "NULLSWAPIFNOT";
cell udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
(cell, ()) ~udict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUSET";
cell idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
(cell, ()) ~idict_set(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTISET";
cell dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
(cell, ()) ~dict_set(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTSET";
(cell, int) udict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUADD";
(cell, int) udict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACE";
(cell, int) udict_replace_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUREPLACEREF";
(cell, slice, int) udict_replaceget?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACEGET" "NULLSWAPIFNOT";
(cell, cell, int) udict_replaceget_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUREPLACEGETREF" "NULLSWAPIFNOT";
(cell, (slice, int)) ~udict_replaceget?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTUREPLACEGET" "NULLSWAPIFNOT";
(cell, (cell, int)) ~udict_replaceget_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTUREPLACEGETREF" "NULLSWAPIFNOT";
(cell, int) idict_add?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIADD";
(cell, int) idict_replace?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACE";
(cell, int) idict_replace_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIREPLACEREF";
(cell, slice, int) idict_replaceget?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACEGET" "NULLSWAPIFNOT";
(cell, cell, int) idict_replaceget_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIREPLACEGETREF" "NULLSWAPIFNOT";
(cell, (slice, int)) ~idict_replaceget?(cell dict, int key_len, int index, slice value) asm(value index dict key_len) "DICTIREPLACEGET" "NULLSWAPIFNOT";
(cell, (cell, int)) ~idict_replaceget_ref?(cell dict, int key_len, int index, cell value) asm(value index dict key_len) "DICTIREPLACEGETREF" "NULLSWAPIFNOT";
cell udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
(cell, ()) ~udict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUSETB";
cell idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
(cell, ()) ~idict_set_builder(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTISETB";
cell dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
(cell, ()) ~dict_set_builder(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTSETB";
(cell, int) dict_replace_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTREPLACEB";
(cell, builder, int) dict_replaceget_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTREPLACEGETB" "NULLSWAPIFNOT";
(cell, slice, int) dict_replaceget?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTREPLACEGET" "NULLSWAPIFNOT";
(cell, (builder, int)) ~dict_replaceget_builder?(cell dict, int key_len, slice index, builder value) asm(value index dict key_len) "DICTREPLACEGETB" "NULLSWAPIFNOT";
(cell, (slice, int)) ~dict_replaceget?(cell dict, int key_len, slice index, slice value) asm(value index dict key_len) "DICTREPLACEGET" "NULLSWAPIFNOT";
(cell, int) udict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUADDB";
(cell, int) udict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEB";
(cell, builder, int) udict_replaceget_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEGETB" "NULLSWAPIFNOT";
(cell, (builder, int)) ~udict_replaceget_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTUREPLACEGETB" "NULLSWAPIFNOT";
(cell, int) idict_add_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIADDB";
(cell, int) idict_replace_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEB";
(cell, builder, int) idict_replaceget_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEGETB" "NULLSWAPIFNOT";
(cell, (builder, int)) ~idict_replaceget_builder?(cell dict, int key_len, int index, builder value) asm(value index dict key_len) "DICTIREPLACEGETB" "NULLSWAPIFNOT";
(cell, int, slice, int) udict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMIN" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMIN" "NULLSWAPIFNOT2";
(cell, slice, slice, int) dict_delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict::delete_get_min(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMIN" "NULLSWAPIFNOT2";
(cell, int, slice, int) udict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~udict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTUREMMAX" "NULLSWAPIFNOT2";
(cell, int, slice, int) idict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, (int, slice, int)) ~idict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTIREMMAX" "NULLSWAPIFNOT2";
(cell, slice, slice, int) dict_delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
(cell, (slice, slice, int)) ~dict::delete_get_max(cell dict, int key_len) asm(-> 0 2 1 3) "DICTREMMAX" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMIN" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAX" "NULLSWAPIFNOT2";
(int, cell, int) udict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMINREF" "NULLSWAPIFNOT2";
(int, cell, int) udict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTUMAXREF" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_min?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMIN" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_max?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAX" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_min_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMINREF" "NULLSWAPIFNOT2";
(int, cell, int) idict_get_max_ref?(cell dict, int key_len) asm (-> 1 0 2) "DICTIMAXREF" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXT" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETNEXTEQ" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREV" "NULLSWAPIFNOT2";
(int, slice, int) udict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTUGETPREVEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_next?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXT" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_nexteq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETNEXTEQ" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_prev?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREV" "NULLSWAPIFNOT2";
(int, slice, int) idict_get_preveq?(cell dict, int key_len, int pivot) asm(pivot dict key_len -> 1 0 2) "DICTIGETPREVEQ" "NULLSWAPIFNOT2";

;;; Creates an empty dictionary, which is actually a null value. Equivalent to PUSHNULL
cell new_dict() asm "NEWDICT";
;;; Checks whether a dictionary is empty. Equivalent to cell_null?.
int dict_empty?(cell c) asm "DICTEMPTY";


{- Prefix dictionary primitives -}
(slice, slice, slice, int) pfxdict_get?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTGETQ" "NULLSWAPIFNOT2";
(cell, int) pfxdict_set?(cell dict, int key_len, slice key, slice value) asm(value key dict key_len) "PFXDICTSET";
(cell, int) pfxdict_delete?(cell dict, int key_len, slice key) asm(key dict key_len) "PFXDICTDEL";

;;; Returns the value of the global configuration parameter with integer index `i` as a `cell` or `null` value.
cell config_param(int x) asm "CONFIGOPTPARAM";
;;; Checks whether c is a null. Note, that FunC also has polymorphic null? built-in.
int cell_null?(cell c) asm "ISNULL";

;;; Creates an output action which would reserve exactly amount nanotoncoins (if mode = 0), at most amount nanotoncoins (if mode = 2), or all but amount nanotoncoins (if mode = 1 or mode = 3), from the remaining balance of the account. It is roughly equivalent to creating an outbound message carrying amount nanotoncoins (or b − amount nanotoncoins, where b is the remaining balance) to oneself, so that the subsequent output actions would not be able to spend more money than the remainder. Bit +2 in mode means that the external action does not fail if the specified amount cannot be reserved; instead, all remaining balance is reserved. Bit +8 in mode means `amount <- -amount` before performing any further actions. Bit +4 in mode means that amount is increased by the original balance of the current account (before the compute phase), including all extra currencies, before performing any other checks and actions. Currently, amount must be a non-negative integer, and mode must be in the range 0..15.
() raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
;;; Similar to raw_reserve, but also accepts a dictionary extra_amount (represented by a cell or null) with extra currencies. In this way currencies other than TonCoin can be reserved.
() raw_reserve_extra(int amount, cell extra_amount, int mode) impure asm "RAWRESERVEX";
;;; Sends a raw message contained in msg, which should contain a correctly serialized object Message X, with the only exception that the source address is allowed to have dummy value addr_none (to be automatically replaced with the current smart contract address), and ihr_fee, fwd_fee, created_lt and created_at fields can have arbitrary values (to be rewritten with correct values during the action phase of the current transaction). Integer parameter mode contains the flags. Currently mode = 0 is used for ordinary messages; mode = 128 is used for messages that are to carry all the remaining balance of the current smart contract (instead of the value originally indicated in the message); mode = 64 is used for messages that carry all the remaining value of the inbound message in addition to the value initially indicated in the new message (if bit 0 is not set, the gas fees are deducted from this amount); mode' = mode + 1 means that the sender wants to pay transfer fees separately; mode' = mode + 2 means that any errors arising while processing this message during the action phase should be ignored. Finally, mode' = mode + 32 means that the current account must be destroyed if its resulting balance is zero. This flag is usually employed together with +128.
() send_raw_message(cell msg, int mode) impure asm "SENDRAWMSG";
;;; Creates an output action that would change this smart contract code to that given by cell new_code. Notice that this change will take effect only after the successful termination of the current run of the smart contract
() set_code(cell new_code) impure asm "SETCODE";

;;; Generates a new pseudo-random unsigned 256-bit integer x. The algorithm is as follows: if r is the old value of the random seed, considered as a 32-byte array (by constructing the big-endian representation of an unsigned 256-bit integer), then its sha512(r) is computed; the first 32 bytes of this hash are stored as the new value r' of the random seed, and the remaining 32 bytes are returned as the next random value x.
int random() impure asm "RANDU256";
;;; Generates a new pseudo-random integer z in the range 0..range−1 (or range..−1, if range < 0). More precisely, an unsigned random value x is generated as in random; then z := x * range / 2^256 is computed.
int rand(int range) impure asm "RAND";
;;; Returns the current random seed as an unsigned 256-bit Integer.
int get_seed() impure asm "RANDSEED";
;;; Sets the random seed to unsigned 256-bit seed.
() set_seed(int x) impure asm "SETRAND";
;;; Mixes unsigned 256-bit integer x into the random seed r by setting the random seed to sha256 of the concatenation of two 32-byte strings: the first with the big-endian representation of the old seed r, and the second with the big-endian representation of x.
() randomize(int x) impure asm "ADDRAND";
;;; Equivalent to randomize(cur_lt());.
() randomize_lt() impure asm "LTIME" "ADDRAND";

;;; Checks whether the data parts of two slices coinside
int equal_slices_bits(slice a, slice b) asm "SDEQ";
;;; Checks whether b is a null. Note, that FunC also has polymorphic null? built-in.
int builder_null?(builder b) asm "ISNULL";
;;; Concatenates two builders
builder store_builder(builder to, builder from) asm "STBR";

;; CUSTOM:

;; TVM UPGRADE 2023-07 https://docs.ton.org/learn/tvm-instructions/tvm-upgrade-2023-07
;; In mainnet since 20 Dec 2023 https://t.me/tonblockchain/226

;;; Retrieves code of smart-contract from c7
cell my_code() asm "MYCODE";


## stdlib.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/stdlib.tact)
import "./std/primitives";
import "./std/cells";
import "./std/crypto";
import "./std/text";
import "./std/math";
import "./std/contract";
import "./std/debug";
import "./std/context";
import "./std/reserve";
import "./std/send";
import "./std/config";
import "./std/base";

## stdlib_ex.fc (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/stdlib_ex.fc)
forall X -> tuple __tact_set(tuple x, X v, int i) asm "SETINDEXVARQ";
() __tact_nop() asm "NOP";
slice __tact_str_to_slice(slice s) asm "NOP";
slice __tact_slice_to_str(slice s) asm "NOP";
slice __tact_address_to_slice(slice s) asm "NOP";

## config.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/libs/config.tact)
fun getConfigAddress(): Address {
    let cell: Cell = getConfigParam(0)!!;
    let sc: Slice = cell.beginParse();
    return newAddress(-1, sc.loadUint(256));
}

fun getElectorAddress(): Address {
    let cell: Cell = getConfigParam(1)!!;
    let sc: Slice = cell.beginParse();
    return newAddress(-1, sc.loadUint(256));
}

## content.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/libs/content.tact)
fun createOffchainContent(link: String): Cell {
    let builder: StringBuilder = beginStringFromBuilder(beginCell().storeUint(0x01, 8));
    builder.append(link);
    return builder.toCell();
}

## deploy.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/libs/deploy.tact)

message Deploy {
    queryId: Int as uint64;
}

message DeployOk {
    queryId: Int as uint64;
}

trait Deployable {
    receive(deploy: Deploy) {
        self.notify(DeployOk{queryId: deploy.queryId}.toCell());
    }
}

message FactoryDeploy {
    queryId: Int as uint64;
    cashback: Address;
}

trait FactoryDeployable  {
    receive(deploy: FactoryDeploy) {
        self.forward(deploy.cashback, DeployOk{queryId: deploy.queryId}.toCell(), false, null);
    }
}

## dns.fc (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/libs/dns.fc)
slice dns_string_to_internal(slice domain) inline_ref {

    ;; Special case for root domain
    if ((domain.slice_bits() == 8) & (domain.slice_refs() == 0)) {
        if (domain.preload_uint(8) == 46) {
            return begin_cell().store_uint(0, 8).end_cell().begin_parse();
        }
    }
    
    ;; Split domain into segments
    tuple segments = null();
    builder current = begin_cell();
    int isCurrentEmpty = true;
    int isFirst = true;
    int isHyphen = false;
    slice cs = domain;
    int continue = true;
    do {

        ;; Prepare for loading next character
        if (cs.slice_bits() == 0) {
            int refs = cs.slice_refs();
            if (refs == 1) {
                cs = cs~load_ref().begin_parse();
            } elseif (refs > 1) {
                return null();
            } else {
                continue = false;
            }
            continue = false;
        }

        ;; Continue loading next character
        if (continue) {
            int char = cs~load_uint(8);
            ;; we can do it because additional UTF-8 character's octets >= 128 -- https://www.ietf.org/rfc/rfc3629.txt
            int is_hyphen = (char == 45);
            int is_dot  = (char == 46);
            int valid_char = is_hyphen | is_dot | ((char >= 48) & (char <= 57)) | ((char >= 97) & (char <= 122)); ;; '-' or 0-9 or a-z
            if (~ valid_char | (isFirst & is_hyphen)) {
                return null();
            }
            isHyphen = is_hyphen;
            if (is_dot) {
                if (isFirst | isHyphen) { ;; Empty or ends with hyphen
                    return null();
                }
                segments = cons(current, segments);
                current = begin_cell();
                isHyphen = false;
                isFirst = true;
                isCurrentEmpty = true;
            } else {
                isFirst = false;
                isCurrentEmpty = false;
                current~store_uint(char, 8);
            }
        }

    } until (~ continue);
    if (isHyphen) { ;; ends with hyphen
        return null();
    }
    if (~ isCurrentEmpty) {
        segments = cons(current, segments);
    }

    ;; Concatenate segments
    builder res = begin_cell();
    (builder b, tuple tail) = uncons(segments);
    res = res.store_builder(b);
    while(~ null?(tail)) {
        (b, tail) = uncons(tail);
        res = res.store_uint(0, 8); ;; Add \0 separator
        res = res.store_builder(b);
    }
    res = res.store_uint(0, 8); ;; Add \0 separator
    return res.end_cell().begin_parse();
}

int dns_internal_verify(slice sc) inline_ref {
    if (sc.slice_refs() != 0) {
        return false;
    }
    int bits = sc.slice_bits();
    if (bits % 8 != 0) {
        return false;
    }
    if (bits == 0) { ;; Case for root domain
        return true;
    }
    int len = bits / 8;
    int counter = 0;
    int isFirst = true;
    int isHyphen = false;
    repeat(len) {
        int char = sc~load_uint(8);
        if (char == 0) {
            if (counter == 0) {
                return false;
            }
            if (isHyphen) {
                return false;
            }
            counter = 0;
            isHyphen = false;
            isFirst = true;
        } else {
            int charIsHyphen = (char == 45);
            int isValid = charIsHyphen | ((char >= 48) & (char <= 57)) | ((char >= 97) & (char <= 122));
            if (~ isValid) {
                return false;
            }
            if (charIsHyphen & isFirst)  {
                return false;
            }
            isHyphen = charIsHyphen;
            isFirst = false;
            counter = counter + 1;
        }
    }
    return counter == 0 & ~ isHyphen;
}

slice dns_internal_normalize(slice src) impure inline_ref {
    throw_unless(134, src.slice_refs() == 0); ;; Invalid argument error
    builder target = begin_cell();
    repeat(src.slice_bits() / 8) {
        int char = src~load_uint(8);

        ;; b => 6
        if (char == 98) {
            char = 54;
        }

        ;; g, q => 9
        if ((char == 103) | (char == 113)) {
            char = 57;    
        }

        ;; l => 1
        if (char == 108) {
            char = 49;
        }

        ;; o => 0
        if (char == 111) {
            char = 48;
        }

        ;; s => 5
        if (char == 115) {
            char = 53;
        }

        ;; u => v
        if (char == 117) {
            char = 118;
        }

        ;; z => 2
        if (char == 122) {
            char = 50;
        }

        target = target.store_uint(char, 8);
    }
    return target.end_cell().begin_parse();
}


## dns.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/libs/dns.tact)
import "./dns.fc";

struct DNSResolveResult {
    prefix: Int; 
    record: Cell?; 
}

@name(dns_string_to_internal)
native dnsStringToInternal(str: String): Slice?;

@name(dns_internal_normalize)
native dnsInternalNormalize(src: Slice): Slice;

@name(dns_internal_verify)
native dnsInternalVerify(subdomain: Slice): Bool;

fun dnsExtractTopDomainLength(subdomain: Slice): Int {
    let i: Int = 0;
    let needBreak: Bool = false;
    do {
        let char: Int = subdomain.loadUint(8); // we do not check domain.length because it MUST contains \0 character
        needBreak = char == 0;
        if (!needBreak) {
            i = i + 8;
        }
    } until (needBreak);
    require(i != 0, "Invalid DNS name");
    return i;
}

fun dnsExtractTopDomain(subdomain: Slice): Slice {
    let len: Int = dnsExtractTopDomainLength(subdomain);
    return subdomain.loadBits(len);
}

fun dnsResolveNext(address: Address): Cell {
    return beginCell()
        .storeUint(0xba93, 16)
        .storeAddress(address)
        .endCell();
}

fun dnsResolveWallet(address: Address): Cell {
    return beginCell()
        .storeUint(0x9fd3, 16)
        .storeAddress(address)
        .storeUint(0, 8)
        .endCell();
}

trait DNSResolver {

    get fun dnsresolve(subdomain: Slice, category: Int): DNSResolveResult {

        // Normalize
        let delta: Int = 0;
        if (subdomain.preloadUint(8) == 0) {
            subdomain.loadUint(8); // Skip first byte
            delta = delta + 8;
        }

        // Checks correctness
        require(dnsInternalVerify(subdomain), "Invalid DNS name");

        // Resolve
        let res: DNSResolveResult = self.doResolveDNS(subdomain, category);
        return DNSResolveResult{prefix: res.prefix + delta, record: res.record};
    }

    virtual fun doResolveDNS(subdomain: Slice, category: Int): DNSResolveResult {
        return DNSResolveResult{prefix: subdomain.bits(), record: null};
    }
}

## ownable.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/libs/ownable.tact)
message ChangeOwner {
    queryId: Int as uint64;
    newOwner: Address;
}

message ChangeOwnerOk {
    queryId: Int as uint64;
    newOwner: Address;
}

@interface("org.ton.ownable")
trait Ownable {
    owner: Address;

    fun requireOwner() {
        nativeThrowUnless(132, sender() == self.owner);
    }

    get fun owner(): Address {
        return self.owner;
    }
}

@interface("org.ton.ownable.transferable.v2")
trait OwnableTransferable with Ownable {

    owner: Address;

    receive(msg: ChangeOwner) {
        
        // Check if the sender is the owner
        self.requireOwner();

        // Update owner
        self.owner = msg.newOwner;

        // Reply result
        self.reply(ChangeOwnerOk{ queryId: msg.queryId, newOwner:msg.newOwner }.toCell());
    }
}

## stoppable.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/libs/stoppable.tact)
import "./ownable";

@interface("org.ton.stoppable")
trait Stoppable with Ownable {
    
    stopped: Bool;
    owner: Address;

    fun requireNotStopped() {
        require(!self.stopped, "Contract stopped");
    }

    fun requireStopped() {
        require(self.stopped, "Contract not stopped");
    }

    receive("Stop") {
        self.requireOwner();
        self.requireNotStopped();
        self.stopped = true;
        self.reply("Stopped".asComment());
    }

    get fun stopped(): Bool {
        return self.stopped;
    }
}

@interface("org.ton.resumable")
trait Resumable with Stoppable {
    stopped: Bool;
    owner: Address;

    receive("Resume") {
        self.requireOwner();
        self.requireStopped();
        self.stopped = false;
        self.reply("Resumed".asComment());
    }
}

## base.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/base.tact)
trait BaseTrait {
    virtual const storageReserve: Int = 0;
    
    virtual inline fun reply(body: Cell?) {
        self.forward(sender(), body, true, null);
    }

    virtual inline fun notify(body: Cell?) {
        self.forward(sender(), body, false, null);
    }

    virtual fun forward(to: Address, body: Cell?, bounce: Bool, init: StateInit?) {

        let code: Cell? = null;
        let data: Cell? = null;
        if (init != null) {
            let init2: StateInit = init!!;
            code = init2.code;
            data = init2.data;
        }

        // Lock storage if needed
        if (self.storageReserve > 0) { // Optimized in compile-time
            let ctx: Context = context();
            let balance: Int = myBalance();
            let balanceBeforeMessage: Int = balance - ctx.value;
            if (balanceBeforeMessage < self.storageReserve) {
                nativeReserve(self.storageReserve, ReserveExact);
                send(SendParameters{bounce: bounce, to: to, value: 0, mode: SendRemainingBalance | SendIgnoreErrors, body: body, code: code, data: data });
                return;
            }
        }

        // Just send with remaining balance
        send(SendParameters{bounce: bounce, to: to, value: 0, mode: SendRemainingValue | SendIgnoreErrors, body: body, code: code, data: data });
    }
}

## cells.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/cells.tact)
//
// Builder
//

asm fun beginCell(): Builder { NEWC }

// special treatment in Func compiler, so not replaced with asm "STIX"
@name(store_int)
extends native storeInt(self: Builder, value: Int, bits: Int): Builder;

// special treatment in Func compiler, so not replaced with asm "STUX"
@name(store_uint)
extends native storeUint(self: Builder, value: Int, bits: Int): Builder;

@name(__tact_store_bool)
extends native storeBool(self: Builder, value: Bool): Builder;

/// Extension function for the `Builder`. Alias to `Builder.storeBool()`. Available since Tact 1.5.0.
///
/// ```tact
/// fun example() {
///     let b: Builder = beginCell();
///     let fizz: Builder = b.storeBit(true);  // writes 1
///     let buzz: Builder = b.storeBit(false); // writes 0
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-cells#builderstorebit
///
@name(__tact_store_bool)
extends native storeBit(self: Builder, value: Bool): Builder;

asm extends fun storeCoins(self: Builder, value: Int): Builder { STVARUINT16 }

asm(cell self) extends fun storeRef(self: Builder, cell: Cell): Builder { STREF }

asm extends fun storeSlice(self: Builder, cell: Slice): Builder { STSLICER }

/// Extension function for the `Builder`. Available since Tact 1.5.0.
///
/// Appends all data from a `Builder` `cell` to the copy of the `Builder`. Returns that copy.
///
/// ```tact
/// fun example() {
///     let b: Builder = beginCell().storeCoins(42);
///     let fizz: Builder = beginCell().storeBuilder(b);
///     b.endCell() == fizz.endCell(); // true
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-cells#builderstorebuilder
///
asm extends fun storeBuilder(self: Builder, cell: Builder): Builder { STBR }

@name(__tact_store_address)
extends native storeAddress(self: Builder, address: Address): Builder;

/// Extension function for the `Builder`. Available since Tact 1.5.0.
///
/// If the `cell` is not `null`, stores 1 as a single bit and then reference `cell` into the copy of the `Builder`. Returns that copy.
///
/// If the `cell` is `null`, only stores 0 as a single bit into the copy of the `Builder`. Returns that copy.
///
/// As a single `Cell` can store up to 4 references, attempts to store more throw an exception with exit code 8: `Cell overflow`.
///
/// ```tact
/// fun example() {
///     let b: Builder = beginCell();
///     let fizz: Builder = b
///         .storeMaybeRef(emptyCell()) // 1, then empty cell
///         .storeMaybeRef(null);       // 0
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-cells#builderstoremayberef
///
asm(cell self) extends fun storeMaybeRef(self: Builder, cell: Cell?): Builder { STOPTREF }

asm extends fun endCell(self: Builder): Cell { ENDC }

asm extends fun refs(self: Builder): Int { BREFS }

asm extends fun bits(self: Builder): Int { BBITS }

//
// Slice
//

asm extends fun beginParse(self: Cell): Slice { CTOS }

asm(-> 1 0) extends mutates fun loadRef(self: Slice): Cell { LDREF }

/// Extension function for the `Slice`. Available since Tact 1.5.0.
///
/// Preloads the next reference from the `Slice` as a `Cell`. Doesn't modify the original `Slice`.
///
/// Attempts to preload such reference `Cell` when `Slice` doesn't contain it throw an exception with exit code 8: `Cell overflow`.
///
/// Attempts to preload more data than `Slice` contains throw an exception with exit code 9: `Cell underflow`.
///
/// ```tact
/// fun examples() {
///     let s1: Slice = beginCell().storeRef(emptyCell()).asSlice();
///     let fizz: Cell = s1.preloadRef(); // didn't modify s1
///
///     let s2: Slice = beginCell()
///         .storeRef(emptyCell())
///         .storeRef(s1.asCell())
///         .asSlice();
///     let ref1: Cell = s2.preloadRef();
///     let ref2: Cell = s2.preloadRef();
///     ref1 == ref2; // true
/// }
/// ```
///
/// See:
/// * https://docs.tact-lang.org/ref/core-cells#slicepreloadref
/// * https://docs.tact-lang.org/book/exit-codes
///
asm extends fun preloadRef(self: Slice): Cell { PLDREF }

// special treatment in Func compiler, so not replaced with asm "LDSLICEX"
@name(load_bits)
extends mutates native loadBits(self: Slice, l: Int): Slice;

// special treatment in Func compiler, so not replaced with asm "PLDSLICEX"
@name(preload_bits)
extends native preloadBits(self: Slice, l: Int): Slice;

// special treatment in Func compiler, so not replaced with asm "LDIX"
@name(load_int)
extends mutates native loadInt(self: Slice, l: Int): Int;

// special treatment in Func compiler, so not replaced with asm "PLDIX"
@name(preload_int)
extends native preloadInt(self: Slice, l: Int): Int;

// special treatment in Func compiler, so not replaced with asm "LDUX"
@name(load_uint)
extends mutates native loadUint(self: Slice, l: Int): Int;

// special treatment in Func compiler, so not replaced with asm "PLDUX"
@name(preload_uint)
extends native preloadUint(self: Slice, l: Int): Int;

asm(-> 1 0) extends mutates fun loadBool(self: Slice): Bool { 1 LDI }

/// Extension mutation function for the `Slice`. Alias to `Slice.loadBool()`. Available since Tact 1.5.0.
///
/// ```tact
/// fun example() {
///     let s: Slice = beginCell().storeBool(true).asSlice();
///     let fizz: Bool = s.loadBit(); // true
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-cells#sliceloadbit
///
asm(-> 1 0) extends mutates fun loadBit(self: Slice): Bool { 1 LDI }

asm( -> 1 0) extends mutates fun loadCoins(self: Slice): Int { LDVARUINT16 }

@name(__tact_load_address)
extends mutates native loadAddress(self: Slice): Address;

asm extends mutates fun skipBits(self: Slice, l: Int) { SDSKIPFIRST }

asm extends fun endParse(self: Slice) { ENDS }

//
// Slice size
//

asm extends fun refs(self: Slice): Int { SREFS }

asm extends fun bits(self: Slice): Int { SBITS }

asm extends fun empty(self: Slice): Bool { SEMPTY }

asm extends fun dataEmpty(self: Slice): Bool { SDEMPTY }

asm extends fun refsEmpty(self: Slice): Bool { SREMPTY }

//
// Conversions
//

inline extends fun asSlice(self: Builder): Slice {
    return self.endCell().beginParse();
}

inline extends fun asSlice(self: Cell): Slice {
    return self.beginParse();
}

inline extends fun asCell(self: Slice): Cell {
    return beginCell()
        .storeSlice(self)
        .endCell();
}

inline extends fun asCell(self: Builder): Cell {
    return self.endCell();
}

inline fun emptyCell(): Cell {
    return beginCell().endCell();
}

inline fun emptySlice(): Slice {
    return emptyCell().asSlice();
}


## config.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/config.tact)
asm fun getConfigParam(id: Int): Cell? { CONFIGOPTPARAM }


## context.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/context.tact)
struct Context {
    bounced: Bool;
    sender: Address;
    value: Int;
    raw: Slice;
}

@name(__tact_context_get)
native context(): Context;

@name(__tact_context_get_sender)
native sender(): Address;

extends fun readForwardFee(self: Context): Int {
    let sc: Slice = self.raw;
    sc.loadAddress(); // Skip destination
    sc.loadCoins(); // Skip value
    sc.skipBits(1); // Skip extra currency collection
    sc.loadCoins(); // Skip ihr_fee
    return (sc.loadCoins() * 3) / 2;
}

## contract.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/contract.tact)
struct StateInit {
    code: Cell;
    data: Cell;
}

@name(__tact_compute_contract_address)
native contractAddressExt(chain: Int, code: Cell, data: Cell): Address;

inline fun contractAddress(s: StateInit): Address {
    return contractAddressExt(0, s.code, s.data);
}

@name(__tact_address_to_slice)
extends native asSlice(self: Address): Slice;

@name(__tact_create_address)
native newAddress(chain: Int, hash: Int): Address;

asm fun myAddress(): Address { MYADDR }

asm fun myBalance(): Int { BALANCE FIRST }

/// Global function. Available since Tact 1.5.0.
///
/// Returns the nanoToncoin `Int` amount of gas consumed by TVM in the current transaction so far. The resulting value includes the cost of calling this function.
///
/// ```tact
/// fun example() {
///     let gas: Int = gasConsumed();
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-advanced#gasconsumed
///
asm fun gasConsumed(): Int { GASCONSUMED }

/// Global function. Available since Tact 1.5.0.
///
/// Returns the nanoToncoin `Int` amount of the accumulated storage fee debt. Storage fees are deducted from the incoming message value before the new contract balance is calculated.
///
/// ```tact
/// fun example() {
///     let debt: Int = myStorageDue();
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-advanced#mystoragedue
///
asm fun myStorageDue(): Int { DUEPAYMENT }

/// Global function. Available since Tact 1.5.0.
///
/// Calculates and returns the storage fee in nanoToncoins `Int` for storing a contract with a given number of `cells` and `bits` for a number of `seconds`. Uses the prices of the masterchain if `isMasterchain` is `true`, otherwise the prices of the basechain. The current prices are obtained from the config param 18 of TON Blockchain.
///
/// Note, that the values of `cells` and `bits` are taken modulo their maximum values plus 1. That is, specifying values higher than those listed in account state limits (`max_acc_state_cells` and `max_acc_state_bits`) will have the same result as with specifying the exact limits. In addition, make sure you take into account the deduplication of cells with the same hash.
///
/// Attempts to specify negative number of `cells`, `bits` or `seconds` throw an exception with exit code 5: `Integer out of expected range`.
///
/// ```tact
/// fun example() {
///     let fee: Int = getStorageFee(1_000, 1_000, 1_000, false);
/// }
/// ```
///
/// See:
/// * https://docs.tact-lang.org/ref/core-advanced#getstoragefee
/// * https://docs.tact-lang.org/ref/core-advanced#getsimplestoragefee
///
asm fun getStorageFee(cells: Int, bits: Int, seconds: Int, isMasterchain: Bool): Int { GETSTORAGEFEE }

/// Global function. Available since Tact 1.5.0.
///
/// Calculates and returns the compute fee in nanoToncoins `Int` for a transaction that consumed `gasUsed` amount of gas. Uses the prices of the masterchain if `isMasterchain` is `true`, otherwise the prices of the basechain. The current prices are obtained from the config param 20 for the masterchain and config param 21 for the basechain of TON Blockchain.
///
/// When the `gasUsed` is less than a certain threshold called `flat_gas_limit`, there's a minimum price to pay based on the value of `flat_gas_price`. The less gas is used below this threshold, the higher the minimum price will be. See the example for `getSimpleComputeFee()` to derive that threshold.
///
/// Attempts to specify negative value of `gasUsed` throw an exception with exit code 5: `Integer out of expected range`.
///
/// ```tact
/// fun example() {
///     let fee: Int = getComputeFee(1_000, false);
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-advanced#getcomputefee
///
asm fun getComputeFee(gasUsed: Int, isMasterchain: Bool): Int { GETGASFEE }

/// Global function. Available since Tact 1.5.0.
///
/// Similar to `getComputeFee()`, but without the `flat_gas_price`, i.e. without a minimum price to pay if the `gasUsed` is less than a certain threshold called `flat_gas_limit`. Calculates and returns only the `gasUsed` times the current gas price.
///
/// Attempts to specify negative number of `cells`, `bits` or `seconds` throw an exception with exit code 5: `Integer out of expected range`.
///
/// ```tact
/// fun example() {
///     let fee = getComputeFee(0, false);
///     let feeNoFlat = getSimpleComputeFee(0, false);
///     let maxFlatPrice = fee - feeNoFlat;
/// }
/// ```
///
/// See:
/// * https://docs.tact-lang.org/ref/core-advanced#getsimplestoragefee
/// * https://docs.tact-lang.org/ref/core-advanced#getstoragefee
///
asm fun getSimpleComputeFee(gasUsed: Int, isMasterchain: Bool): Int { GETGASFEESIMPLE }

/// Global function. Available since Tact 1.5.0.
///
/// Calculates and returns the forward fee in nanoToncoins `Int` for an outgoing message consisting of a given number of `cells` and `bits`. Uses the prices of the masterchain if `isMasterchain` is `true{:tact}`, otherwise the prices of the basechain. The current prices are obtained from the config param 24 for the masterchain and config param 25 for the basechain of TON Blockchain.
///
/// If both the source and the destination addresses are in the basechain, then specify `isMasterchain` as `false`. Otherwise, specify `true`.
///
/// Note, that the values of `cells` and `bits` are taken modulo their maximum values plus 1. That is, specifying values higher than those listed in account state limits (`max_msg_cells` and `max_msg_bits`) will have the same result as with specifying the exact limits.
///
/// However, regardless of the values of `cells` and `bits`, this function always adds the minimum price based on the value of `lump_price`. See the example for [`getSimpleForwardFee(){:tact}`](#getsimpleforwardfee) to derive it. In addition, make sure you take into account the deduplication of cells with the same hash, since for example the root cell and its data bits don't count towards the forward fee and are covered by the `lump_price`.
///
/// Attempts to specify negative number of `cells` or `bits` throw an exception with exit code 5: `Integer out of expected range`.
///
/// ```tact
/// fun example() {
///     let fee: Int = getForwardFee(1_000, 1_000, false);
/// }
/// ```
///
/// See:
/// * https://docs.tact-lang.org/ref/core-advanced#getforwardfee
/// * https://docs.tact-lang.org/ref/core-advanced#getsimpleforwardfee
/// * https://docs.tact-lang.org/ref/core-advanced#getoriginalfwdfee
///
asm fun getForwardFee(cells: Int, bits: Int, isMasterchain: Bool): Int { GETFORWARDFEE }

/// Global function. Available since Tact 1.5.0.
///
/// Similar to `getForwardFee()`, but without the `lump_price`, i.e. without the minimum price to pay regardless of the amount of `cells` or `bits`. Calculates and returns only the `cells` times the current cell price plus `bits` times the current bit price.
///
/// Attempts to specify negative number of `cells` or `bits` throw an exception with exit code 5: `Integer out of expected range`.
///
/// ```tact
/// fun example() {
///     let fee = getForwardFee(1_000, 1_000, false);
///     let feeNoLump = getSimpleForwardFee(1_000, 1_000, false);
///     let lumpPrice = fee - feeNoLump;
/// }
/// ```
///
/// See:
/// * https://docs.tact-lang.org/ref/core-advanced#getsimpleforwardfee
/// * https://docs.tact-lang.org/ref/core-advanced#getforwardfee
///
asm fun getSimpleForwardFee(cells: Int, bits: Int, isMasterchain: Bool): Int { GETFORWARDFEESIMPLE }

/// Global function. Available since Tact 1.5.0.
///
/// Calculates and returns the so-called _original_ forward fee in nanoToncoins `Int` for an outgoing message based on the `fwdFee` obtained from the incoming message. If both the source and the destination addresses are in the basechain, then specify `isMasterchain` as `false`. Otherwise, specify `true`.
///
/// This function is useful when the outgoing message depends heavily on the structure of the incoming message, so much so that you cannot fully predict the fee using `getForwardFee()` alone. Even if you could, calculating the exact fee with nanoToncoin-level precision can be very expensive, so the approximate value given by this function is often good enough.
///
/// Attempts to specify a negative value of `fwdFee` throw an exception with exit code 5: `Integer out of expected range`.
///
/// ```tact
/// fun example() {
///     let fwdFee: Int = context().readForwardFee();
///     let origFee: Int = getOriginalFwdFee(fee, false);
/// }
/// ```
///
/// See:
/// * https://docs.tact-lang.org/ref/core-advanced#getoriginalfwdfee
/// * https://docs.tact-lang.org/ref/core-advanced#getforwardfee
/// * https://docs.tact-lang.org/ref/core-advanced#contextreadforwardfee
///
asm fun getOriginalFwdFee(fwdFee: Int, isMasterchain: Bool): Int { GETORIGINALFWDFEE }

/// Struct representing the standard address on TON Blockchain with signed 8-bit `workchain` ID and an unsigned 256-bit `address` in the specified `workchain`. Available since Tact 1.5.0.
///
/// At the moment, only `workchain` IDs used on TON are 0 of the basechain and -1 of the masterchain.
///
/// See:
/// * https://docs.tact-lang.org/ref/core-advanced#parsestdaddress
/// * https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L105-L106
///
struct StdAddress {
    workchain: Int as int8;
    address: Int as uint256;
}

/// Struct representing the address of variable length with signed 32-bit `workchain` ID and a `Slice` containing unsigned `address` in the specified `workchain`. Available since Tact 1.5.0.
///
/// Variable-length addresses are intended for future extensions, and while validators must be ready to accept them in inbound messages, the standard (non-variable) addresses are used whenever possible.
///
/// See:
/// * https://docs.tact-lang.org/ref/core-advanced#parsevaraddress
/// * https://github.com/ton-blockchain/ton/blob/master/crypto/block/block.tlb#L107-L108
///
struct VarAddress {
    workchain: Int as int32;
    address: Slice;
}

/// Assembly function. Available since Tact 1.5.0.
///
/// Converts a `Slice` containing an address into the `StdAddress` Struct and returns it.
///
/// ```tact
/// fun example() {
///     let addr = address("EQDtFpEwcFAEcRe5mLVh2N6C0x-_hJEM7W61_JLnSF74p4q2");
///     let parsedAddr = parseStdAddress(addr.asSlice());
///
///     parsedAddr.workchain; // 0
///     parsedAddr.address;   // 107...287
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-advanced#parsestdaddress
///
asm fun parseStdAddress(slice: Slice): StdAddress { REWRITESTDADDR }

/// Assembly function. Available since Tact 1.5.0.
///
/// Converts a `Slice` containing an address of variable length into the `VarAddress` Struct and returns it.
///
/// ```tact
/// fun example() {
///     let varAddrSlice = beginCell()
///         .storeUint(6, 3)     // to recognize the following as a VarAddress
///         .storeUint(123, 9)   // make address occupy 123 bits
///         .storeUint(234, 32)  // specify workchain ID of 234
///         .storeUint(345, 123) // specify address of 345
///         .asSlice();
///     let parsedVarAddr = parseVarAddress(varAddrSlice);
///
///     parsedVarAddr.workchain;             // 234
///     parsedVarAddr.address;               // CS{Cell{002...2b3} bits: 44..167; refs: 0..0}
///     parsedVarAddr.address.loadUint(123); // 345
/// }
/// ```
///
/// See: https://docs.tact-lang.org/ref/core-advanced#parsevaraddress
///
asm fun parseVarAddress(slice: Slice): VarAddress { REWRITEVARADDR }


## crypto.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/crypto.tact)
asm extends fun hash(self: Cell): Int { HASHCU }

asm extends fun hash(self: Slice): Int { HASHSU }

asm fun checkSignature(hash: Int, signature: Slice, public_key: Int): Bool { CHKSIGNU }

asm fun checkDataSignature(data: Slice, signature: Slice, public_key: Int): Bool { CHKSIGNS }


## debug.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/debug.tact)
// these are builtin functions, these get special treatment from FunC
// hence, no asm here

@name(throw)
native nativeThrow(code: Int);

@name(throw_if)
native nativeThrowIf(code: Int, condition: Bool);

@name(throw)
native throw(code: Int);

@name(throw_unless)
native nativeThrowUnless(code: Int, condition: Bool);

## math.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/math.tact)
// Prepare random

// Mixes unsigned 256-bit integer x into the random seed r by setting the random seed
// to sha256 of the concatenation of two 32-byte strings:
// the first with the big-endian representation of the old seed r, and
// the second with the big-endian representation of x.
asm fun nativeRandomize(x: Int) { ADDRAND }

/// Equivalent to `nativeRandomize(cur_lt())`,
/// where `cur_lt()` is the logical time of the current transaction
asm fun nativeRandomizeLt() { LTIME ADDRAND }

@name(__tact_prepare_random)
native nativePrepareRandom();

// Random

// Generates a new pseudo-random unsigned 256-bit integer x.
// The algorithm is as follows: if r is the old value of the random seed,
// considered as a 32-byte array (by constructing the big-endian representation
// of an unsigned 256-bit integer), then its sha512(r) is computed;
// the first 32 bytes of this hash are stored as the new value r' of the random seed,
// and the remaining 32 bytes are returned as the next random value x.
asm fun nativeRandom(): Int { RANDU256 }

// Generates a new pseudo-random integer z in the range 0..range−1
// (or range..−1, if range < 0).
// More precisely, an unsigned random value x is generated as in `nativeRandom`;
// then z := x * range / 2^256 is computed.
asm fun nativeRandomInterval(max: Int): Int { RAND }

inline fun randomInt(): Int {
    nativePrepareRandom();
    return nativeRandom();
}

inline fun random(min: Int, max: Int): Int {
    nativePrepareRandom();
    return min + nativeRandomInterval(max - min);
}

// Math

asm fun min(x: Int, y: Int): Int { MIN }

asm fun max(x: Int, y: Int): Int { MAX }

asm fun abs(x: Int): Int { ABS }

asm fun now(): Int { NOW }

asm fun log2(num: Int): Int {
    DUP 5 THROWIFNOT UBITSIZE DEC
}

@name(__tact_log)
native log(num: Int, base: Int): Int;

@name(__tact_pow)
native pow(base: Int, exp: Int): Int;

asm fun pow2(exp: Int): Int { POW2 }

## primitives.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/primitives.tact)
primitive Int;
primitive Bool;
primitive Builder;
primitive Slice;
primitive Cell;
primitive Address;
primitive String;
primitive StringBuilder;

## reserve.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/reserve.tact)
asm fun nativeReserve(amount: Int, mode: Int) { RAWRESERVE }

const ReserveExact: Int = 0;
const ReserveAllExcept: Int = 1;
const ReserveAtMost: Int = 2;
const ReserveAddOriginalBalance: Int = 4;
const ReserveInvertSign: Int = 8;
const ReserveBounceIfActionFail: Int = 16;

## send.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/send.tact)
asm fun nativeSendMessage(cell: Cell, mode: Int) { SENDRAWMSG }

asm fun nativeSendMessageReturnForwardFee(msg: Cell, mode: Int): Int { SENDMSG }

const SendRemainingBalance: Int = 128;
const SendRemainingValue: Int = 64;
const SendDefaultMode: Int = 0;
const SendIgnoreErrors: Int = 2;
const SendPayGasSeparately: Int = 1;
const SendDestroyIfZero: Int = 32;
const SendBounceIfActionFail: Int = 16;
const SendOnlyEstimateFee: Int = 1024;

struct SendParameters {
    bounce: Bool = true;
    to: Address;
    value: Int;
    mode: Int = 0;
    body: Cell? = null;
    code: Cell? = null;
    data: Cell? = null;
}

fun send(params: SendParameters): Int { // returns forward fee
    let b: Builder = beginCell();
    b = b.storeInt(1, 2); // internal_message + ihd_disabled
    b = b.storeBool(params.bounce); // bounce
    b = b.storeInt(0, 3); // bounced + from
    b = b.storeAddress(params.to); // To
    b = b.storeCoins(params.value); // Value
    b = b.storeInt(0, 1 + 4 + 4 + 64 + 32); // currency_collection + IHR fees + Fwd fees + CreatedLT + CreatedAt

    // Stateinit
    if (params.code != null || params.data != null) {
        b = b.storeBool(true); // State init

        // Assemble state init cell
        let bc: Builder = beginCell();
        bc = bc.storeBool(false); // SplitDepth
        bc = bc.storeBool(false); // TickTock
        if (params.code != null) {
            bc = bc.storeBool(true); // Code presence
            bc = bc.storeRef(params.code!!);
        } else {
            bc = bc.storeBool(false); // Code presence
        }
        if (params.data != null) {
            bc = bc.storeBool(true); // Data presence
            bc = bc.storeRef(params.data!!);
        } else {
            bc = bc.storeBool(false); // Data presence
        }
        bc = bc.storeBool(false); // Library

        b = b.storeBool(true); // Store as ref
        b = b.storeRef(bc.endCell());
    } else {
        b = b.storeBool(false); // No state init
    }

    // Body
    let body: Cell? = params.body;
    if (body != null) {
        b = b.storeBool(true);
        b = b.storeRef(body!!);
    } else {
        b = b.storeBool(false); // No body
    }

    // Send
    let c: Cell = b.endCell();
    return nativeSendMessageReturnForwardFee(c, params.mode);
}

inline fun emit(body: Cell) {
    // ext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt created_lt:uint64 created_at:uint32
    //                     maybe: stateInit (false) bodyRef: bool (true)
    let c: Cell = beginCell()
        .storeUint(15211807202738752817960438464513, 104)
        .storeRef(body)
        .endCell();
    nativeSendMessage(c, 0);
}

asm fun acceptMessage() { ACCEPT }

asm fun commit() { COMMIT }


## text.tact (https://github.com/tact-lang/tact/blob/main/tact-main/stdlib/std/text.tact)
//
// String builder
//

@name(__tact_string_builder_start_string)
native beginString(): StringBuilder;

@name(__tact_string_builder_start_comment)
native beginComment(): StringBuilder;

@name(__tact_string_builder_start_tail_string)
native beginTailString(): StringBuilder;

@name(__tact_string_builder_start)
native beginStringFromBuilder(b: Builder): StringBuilder;

@name(__tact_string_builder_append)
extends mutates native append(self: StringBuilder, s: String);

@name(__tact_string_builder_append_not_mut)
extends native concat(self: StringBuilder, s: String): StringBuilder;

@name(__tact_string_builder_end)
extends native toCell(self: StringBuilder): Cell;

@name(__tact_string_builder_end_slice)
extends native toString(self: StringBuilder): String;

@name(__tact_string_builder_end_slice)
extends native toSlice(self: StringBuilder): Slice;

//
// String conversion
//

@name(__tact_int_to_string)
extends native toString(self: Int): String;

@name(__tact_float_to_string)
extends native toFloatString(self: Int, digits: Int): String;

inline extends fun toCoinsString(self: Int): String {
    return self.toFloatString(9);
}

extends fun asComment(self: String): Cell {
    let b: StringBuilder = beginComment();
    b.append(self);
    return b.toCell();
}

@name(__tact_str_to_slice)
extends native asSlice(self: String): Slice;

@name(__tact_slice_to_str)
extends native asString(self: Slice): String;

inline extends fun fromBase64(self: String): Slice {
    return self.asSlice().fromBase64();
}

extends fun fromBase64(self: Slice): Slice {
    let size: Int = self.bits() / 8;
    let result: Builder = beginCell();

    repeat (size) {
        let code: Int = self.loadUint(8);
        if (code >= 65 && code <= 90) { // A-Z
            result = result.storeUint(code - 65, 6);
        } else if (code >= 97 && code <= 122) { // a-z
            result = result.storeUint(code - (97 - 26), 6);
        } else if (code >= 48 && code <= 57) { // 0-9
            result = result.storeUint(code + (52 - 48), 6);
        } else if (code == 45 || code == 43) { // - or +
            result = result.storeUint(62, 6);
        } else if (code == 95 || code == 47) { // _ or /
            result = result.storeUint(63, 6);
        } else if (code == 61) { // =
            // Skip
        } else {
            throw(134);
        }
    }

    // Padding
    let total: Int = result.bits();
    let padding: Int = total % 8;
    if (padding != 0) {
        let s: Slice = result.asSlice();
        return s.loadBits(total - padding);
    } else {
        return result.asSlice();
    }
}

//
// Address conversion
//

@name(__tact_address_to_user_friendly)
extends native toString(self: Address): String;